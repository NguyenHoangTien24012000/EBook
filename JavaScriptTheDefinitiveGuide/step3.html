<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Types, Values, and Variables"><div class="chapter" id="datatypes">
        <h1><span class="label">Chapter 3. </span>Types, Values, and Variables</h1>
        
        
        <p>Computer<a data-type="indexterm" data-primary="types" data-secondary="overview of" id="Tbasic03"></a><a data-type="indexterm" data-primary="values" data-secondary="overview of" id="Vbasic03"></a><a data-type="indexterm" data-primary="variables" data-secondary="overview of" id="Valbasic03"></a> programs work by manipulating values, such as the number 3.14
        or the text “Hello World.” The kinds of values that can be represented
        and manipulated in a programming language are known as types, and one
        of the most fundamental characteristics of a programming language is
        the set of types it supports. When a program needs to retain a value
        for future use, it assigns the value to (or “stores” the value in) a
        variable. Variables have names, and they allow use of those names in our
        programs to refer to values. The way that variables work is another
        fundamental characteristic of any programming language. This chapter
        explains types, values, and variables in JavaScript. It begins with an
        overview and some definitions.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.1 Overview and Definitions"><div class="sect1" id="idm46198571982088">
        <h1>3.1 Overview and Definitions</h1>
        
        <p>JavaScript types can be divided into<a data-type="indexterm" data-primary="objects" data-secondary="overview of" id="Oover03"></a><a data-type="indexterm" data-primary="primitive types" data-secondary="overview and definitions" id="idm46198571978952"></a><a data-type="indexterm" data-primary="types" data-secondary="primitive" id="idm46198571978040"></a> two categories: <em>primitive types</em>
        and <em>object types</em>. JavaScript’s primitive types include numbers,
        strings of text (known as strings), and Boolean truth values (known as
        booleans). A significant portion of this chapter is dedicated to a
        detailed explanation of the numeric (<a data-type="xref" href="#numbers">§3.2</a>) and string
        (<a data-type="xref" href="#text">§3.3</a>) types in JavaScript. Booleans are covered in <a data-type="xref" href="#booleans">§3.4</a>.</p>
        
        <p>The special JavaScript values <code>null</code> and <code>undefined</code> are primitive values, but
        they are not numbers, strings, or booleans. Each value is typically considered
        to be the sole member of its own special type. <a data-type="xref" href="#nullundefined">§3.5</a> has more about
        <code>null</code> and <code>undefined</code>. ES6<a data-type="indexterm" data-primary="ES6" data-secondary="Symbol type" id="idm46198571970152"></a><a data-type="indexterm" data-primary="Symbols" data-secondary="definition of language extensions" id="idm46198571969144"></a> adds a new special-purpose type,
        known as Symbol, that enables the definition of language extensions
        without harming backward compatibility. Symbols are covered briefly in
        <a data-type="xref" href="#symbols">§3.6</a>.</p>
        
        <p>Any JavaScript value that is not a number, a string, a boolean, a
        symbol, <code>null</code>, or <code>undefined</code> is an object. An object (that is, a
        member of the type <em>object</em>) is a collection of<a data-type="indexterm" data-primary="properties" data-secondary="definition of term" id="idm46198571965272"></a> <em>properties</em> where
        each property has a name and a value (either a primitive value or
        another object). One very special object, the  <em>global object</em>, is
        covered in <a data-type="xref" href="#global">§3.7</a>, but more general and more detailed coverage of
        objects is in <a data-type="xref" href="ch06.html#objects">Chapter&nbsp;6</a>.</p>
        
        <p>An<a data-type="indexterm" data-primary="arrays" data-secondary="definition of term" id="idm46198571961208"></a> ordinary JavaScript object is an unordered collection of named values. The
        language also defines a special kind of object, known as an array, that
        represents an ordered collection of numbered values. The JavaScript language
        includes special syntax for working with arrays, and arrays have some special
        behavior that distinguishes them from ordinary objects. Arrays are the subject
        of <a data-type="xref" href="ch07.html#arrays">Chapter&nbsp;7</a>.</p>
        
        <p>In addition to basic objects and arrays, JavaScript defines a number of
        other useful object types. A<a data-type="indexterm" data-primary="Set objects" id="idm46198571958120"></a> Set object represents a set of values. A<a data-type="indexterm" data-primary="Map objects" id="idm46198571957288"></a>
        Map object
        represents a mapping from keys to values. Various “typed array” types
        facilitate operations on arrays of bytes and other binary data. The<a data-type="indexterm" data-primary="RegExp type" id="idm46198571956312"></a>
        RegExp type represents textual patterns and enables sophisticated
        matching, searching, and replacing operations on strings. The<a data-type="indexterm" data-primary="Date type" id="idm46198571955368"></a> Date type
        represents dates and times and supports rudimentary date
        arithmetic. Error and its subtypes represent errors that can arise when
        executing JavaScript code. All of these types are covered in
        <a data-type="xref" href="ch11.html#builtintypes">Chapter&nbsp;11</a>.</p>
        
        <p>JavaScript<a data-type="indexterm" data-primary="functions" data-secondary="overview of" id="idm46198571953256"></a><a data-type="indexterm" data-primary="classes" data-secondary="overview of" id="idm46198571952248"></a> differs from more static languages in that functions and
        classes are not just part of the language syntax: they are themselves
        values that can be manipulated by JavaScript programs. Like any
        JavaScript value that is not a primitive value, functions and classes
        are a specialized kind of object. They are covered in detail in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#functions">8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#classes">9</a>.</p>
        
        <p>The JavaScript interpreter performs automatic<a data-type="indexterm" data-primary="memory management" id="idm46198571947912"></a><a data-type="indexterm" data-primary="garbage collection" id="idm46198571947208"></a> garbage collection for
        memory management. This means that a JavaScript programmer generally
        does not need to worry about destruction or deallocation of objects or
        other values. When a value is no longer reachable—when a program no
        longer has any way to refer to it—the interpreter knows it can never
        be used again and automatically reclaims the memory it was
        occupying. (JavaScript programmers do sometimes need to take care to
        ensure that values do not inadvertently remain reachable—and therefore
        nonreclaimable—longer than necessary.)</p>
        
        <p>JavaScript<a data-type="indexterm" data-primary="object-oriented programming" data-secondary="definition of term" id="idm46198571945240"></a> supports an object-oriented programming style. Loosely,
        this means that rather than having globally defined functions to
        operate on values of various types, the types themselves define
        methods for working with values. To sort the elements of an array <code>a</code>,
        for example, we don’t pass <code>a</code> to a <code>sort()</code> function.  Instead, we
        invoke the <code>sort()</code> method of <code>a</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">a</code><code class="p">.</code><code class="nx">sort</code><code class="p">();</code>       <code class="c1">// The object-oriented version of sort(a).</code></pre>
        
        <p>Method definition is covered in <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>. Technically, it is only
        JavaScript objects that have methods. But numbers, strings, boolean, and
        symbol values behave as if they have methods. In JavaScript, <code>null</code> and
        <code>undefined</code> are the only values that methods cannot be invoked on.</p>
        
        <p>JavaScript’s<a data-type="indexterm" data-primary="mutability" id="idm46198571934616"></a> object types are <em>mutable</em> and its primitive types are
        <em>immutable</em>. A value of a mutable type can change: a JavaScript program
        can change the values of object properties and array elements. Numbers,
        booleans, symbols, <code>null</code>, and <code>undefined</code> are immutable—it doesn’t even make
        sense to talk about changing the value of a number, for example. Strings
        can be thought of as arrays of characters, and you might expect them to
        be mutable. In JavaScript, however, strings are immutable: you can
        access the text at any index of a string, but JavaScript provides no way
        to alter the text of an existing string. The differences between mutable
        and immutable values are explored further in <a data-type="xref" href="#mutableandimmutable">§3.8</a>.</p>
        
        <p>JavaScript liberally converts values from one type to another. If a
        program expects a string, for example, and you give it a number, it will
        automatically convert the number to a string for you. And if you use a
        non-boolean value where a boolean is expected, JavaScript will convert
        accordingly. The rules for value conversion are explained in
        <a data-type="xref" href="#conversions">§3.9</a>. JavaScript’s liberal value conversion rules affect its
        definition of equality, and<a data-type="indexterm" data-primary="== (equality operator)" data-secondary="type conversions" id="idm46198571925912"></a><a data-type="indexterm" data-primary="equality operator (==)" data-secondary="type conversions" id="idm46198571924968"></a> the <code>==</code> equality operator performs type
        conversions as described in <a data-type="xref" href="#conversionsandequality">§3.9.1</a>. (In practice,
        however, the <code>==</code> equality operator is deprecated in favor of<a data-type="indexterm" data-primary="strict equality operator (===)" data-secondary="type conversions" id="idm46198571922200"></a><a data-type="indexterm" data-primary="=== (strict equality operator)" data-secondary="type conversions" id="idm46198571921256"></a> the
        strict equality operator <code>===</code>, which does no type conversions. See
        <a data-type="xref" href="ch04.html#equalityops">§4.9.1</a> for more about both operators.)</p>
        
        <p>Constants<a data-type="indexterm" data-primary="constants" data-secondary="declaring" id="idm46198571918472"></a> and variables allow you to use names to refer to values in
        your programs. Constants are declared with <code>const</code> and variables are
        declared with <code>let</code> (or with <code>var</code> in older JavaScript code). JavaScript
        constants and variables are <em>untyped</em>: declarations do not specify what
        kind of values will be assigned. Variable declaration and assignment are
        covered in <a data-type="xref" href="#variabledeclaration">§3.10</a>.</p>
        
        <p>As you can see from this long introduction, this is a wide-ranging
        chapter that explains many fundamental details about how data is
        represented and manipulated in JavaScript. We’ll begin by diving right
        in to the details of JavaScript numbers and text.<a data-type="indexterm" data-primary="" data-startref="Vbasic03" id="idm46198571914040"></a><a data-type="indexterm" data-primary="" data-startref="Valbasic03" id="idm46198571913064"></a><a data-type="indexterm" data-primary="" data-startref="Tbasic03" id="idm46198571912120"></a><a data-type="indexterm" data-primary="" data-startref="Oover03" id="idm46198571911176"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.2 Numbers"><div class="sect1" id="numbers">
        <h1>3.2 Numbers</h1>
        
        <p>JavaScript’s<a data-type="indexterm" data-primary="primitive types" data-secondary="Number type" id="PTnumber03"></a><a data-type="indexterm" data-primary="types" data-secondary="Number type" id="Tnumber03"></a><a data-type="indexterm" data-primary="Number type" data-secondary="64-bit floating-point format" id="idm46198571888168"></a> primary numeric type, Number, is used to represent
        integers and to approximate real numbers. JavaScript represents
        numbers using the 64-bit floating-point format defined by the IEEE 754
        standard,<sup><a data-type="noteref" id="idm46198571886872-marker" href="ch03.html#idm46198571886872">1</a></sup>  which means it can
        represent numbers as large as ±1.7976931348623157 × 10<sup>308</sup> and as
        small as ±5 × 10<sup>−324</sup>.</p>
        
        <p>The JavaScript number format allows you to exactly represent all integers
        between −9,007,199,254,740,992 (−2<sup>53</sup>) and 9,007,199,254,740,992 (2<sup>53</sup>), inclusive. If
        you use integer values larger than this, you may lose precision in the trailing
        digits. Note, however, that certain operations in JavaScript (such as array
        indexing and the bitwise operators described in <a data-type="xref" href="ch04.html#expressions">Chapter&nbsp;4</a>) are performed
        with 32-bit integers. If you need to exactly represent larger
        integers, see <a data-type="xref" href="#bigint">§3.2.5</a>.</p>
        
        <p>When<a data-type="indexterm" data-primary="numeric literals" id="idm46198571881272"></a><a data-type="indexterm" data-primary="literals" data-secondary="numeric" data-tertiary="negative numbers" id="idm46198571880536"></a> a number appears directly in a JavaScript program, it’s called a <em>numeric literal</em>. JavaScript supports numeric literals in several formats, as described
        in the following sections. Note that any numeric literal can be preceded by a
        minus sign (-) to make the number negative.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.2.1 Integer Literals"><div class="sect2" id="idm46198571878472">
        <h2>3.2.1 Integer Literals</h2>
        
        <p>In<a data-type="indexterm" data-primary="Number type" data-secondary="integer literals" id="idm46198571876904"></a><a data-type="indexterm" data-primary="integer literals" id="idm46198571875896"></a><a data-type="indexterm" data-primary="literals" data-secondary="numeric" data-tertiary="integer literals" id="idm46198571875224"></a> a JavaScript program, a base-10 integer is written as a sequence of
        digits. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mi">0</code>
        <code class="mi">3</code>
        <code class="mi">10000000</code></pre>
        
        <p>In addition to base-10 integer literals, JavaScript recognizes
        hexadecimal (base-16) values. A<a data-type="indexterm" data-primary="hexadecimal literals" id="idm46198571846472"></a> hexadecimal literal begins with <code>0x</code>
        or <code>0X</code>, followed by a string of hexadecimal digits. A hexadecimal
        digit is one of the digits 0 through 9 or the letters a (or A) through
        f (or F), which represent values 10 through 15. Here are examples of
        hexadecimal integer literals:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mh">0xff</code>       <code class="c1">// =&gt; 255: (15*16 + 15)</code>
        <code class="mh">0xBADCAFE</code>  <code class="c1">// =&gt; 195939070</code></pre>
        
        <p>In<a data-type="indexterm" data-primary="ES6" data-secondary="binary and octal integers" id="idm46198571852984"></a><a data-type="indexterm" data-primary="binary integer literals" id="idm46198571852136"></a> ES6 and later, you can also express integers in binary
        (base 2) or octal (base 8) using the prefixes <code>0b</code> and <code>0o</code> (or <code>0B</code>
        and <code>0O</code>) instead of <code>0x</code>:</p>
        
        <pre data-type="programlisting">0b10101  // =&gt; 21:  (1*16 + 0*8 + 1*4 + 0*2 + 1*1)
        0o377    // =&gt; 255: (3*64 + 7*8 + 7*1)</pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.2.2 Floating-Point Literals"><div class="sect2" id="idm46198571859240">
        <h2>3.2.2 Floating-Point Literals</h2>
        
        <p>Floating-point literals<a data-type="indexterm" data-primary="literals" data-secondary="numeric" data-tertiary="floating-point literals" id="idm46198571857704"></a><a data-type="indexterm" data-primary="Number type" data-secondary="floating-point literals" id="idm46198571863576"></a><a data-type="indexterm" data-primary="floating-point literals" id="idm46198571862632"></a> can have a decimal point; they use the traditional
        syntax for real numbers. A real value is represented as the integral part of
        the number, followed by a decimal point and the fractional part of the number.</p>
        
        <p>Floating-point<a data-type="indexterm" data-primary="exponential notation" id="idm46198571861224"></a> literals may also be represented using exponential notation: a
        real number followed by the letter e (or E), followed by an optional plus or
        minus sign, followed by an integer exponent. This notation represents the real
        number multiplied by 10 to the power of the exponent.</p>
        
        <p>More succinctly, the syntax is:</p>
        <pre id="I_programlisting2_d1e2046" data-type="programlisting" data-code-language="js">[<em><code>digits</code></em>][.<em><code>digits</code></em>][(E|e)[(+|-)]<em><code>digits</code></em>]</pre>
        
        <p class="less_space pagebreak-before">For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mf">3.14</code>
        <code class="mf">2345.6789</code>
        <code class="p">.</code><code class="mi">333333333333333333</code>
        <code class="mf">6.02e23</code>        <code class="c1">// 6.02 × 10²³</code>
        <code class="mf">1.4738223</code><code class="nx">E</code><code class="o">-</code><code class="mi">32</code>  <code class="c1">// 1.4738223 × 10⁻³²</code></pre>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198571793048">
        <h5>Separators in Numeric Literals</h5>
        <p>You<a data-type="indexterm" data-primary="Number type" data-secondary="separators in numeric literals" id="idm46198571799464"></a><a data-type="indexterm" data-primary="literals" data-secondary="numeric" data-tertiary="separators in" id="idm46198571798520"></a><a data-type="indexterm" data-primary="_ (underscores, as numeric separators)" id="idm46198571797304"></a><a data-type="indexterm" data-primary="underscores, as numeric separators (_)" id="idm46198571796664"></a> can use underscores within numeric literals to break long literals
        up into chunks that are easier to read:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">billion</code> <code class="o">=</code> <code class="mi">1</code><code class="nx">_000_000_000</code><code class="p">;</code>   <code class="c1">// Underscore as a thousands separator.</code>
        <code class="kd">let</code> <code class="nx">bytes</code> <code class="o">=</code> <code class="mh">0x89</code><code class="nx">_AB_CD_EF</code><code class="p">;</code>     <code class="c1">// As a bytes separator.</code>
        <code class="kd">let</code> <code class="nx">bits</code> <code class="o">=</code> <code class="mb">0b0001</code><code class="nx">_1101_0111</code><code class="p">;</code>   <code class="c1">// As a nibble separator.</code>
        <code class="kd">let</code> <code class="nx">fraction</code> <code class="o">=</code> <code class="mf">0.123</code><code class="nx">_456_789</code><code class="p">;</code>  <code class="c1">// Works in the fractional part, too.</code></pre>
        
        <p>At the time of this writing in early 2020, underscores in numeric
        literals are not yet formally standardized as part of JavaScript. But
        they are in the advanced stages of the standardization process and are
        implemented by all major browsers and by Node.</p>
        </div></aside>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.2.3 Arithmetic in JavaScript"><div class="sect2" id="idm46198571728472">
        <h2>3.2.3 Arithmetic in JavaScript</h2>
        
        <p>JavaScript<a data-type="indexterm" data-primary="operators" data-secondary="arithmetic operators" id="Oarith03"></a><a data-type="indexterm" data-primary="arithmetic operators" id="arith03"></a><a data-type="indexterm" data-primary="Number type" data-secondary="arithmetic and complex math" id="NTarith03"></a> programs work with numbers using the arithmetic operators
        . that the language provides. These<a data-type="indexterm" data-primary="+ (plus sign)" data-secondary="addition operator" id="idm46198571722856"></a><a data-type="indexterm" data-primary="addition operator (+)" id="idm46198571721912"></a><a data-type="indexterm" data-primary="plus sign (+)" data-secondary="addition operator" id="idm46198571721240"></a><a data-type="indexterm" data-primary="- (minus sign)" data-secondary="subtraction operator" id="idm46198571720296"></a><a data-type="indexterm" data-primary="minus sign (-)" data-secondary="subtraction operator" id="idm46198571719352"></a><a data-type="indexterm" data-primary="subtraction operator (-)" id="idm46198571718408"></a><a data-type="indexterm" data-primary="* (multiplication operator)" id="idm46198571717720"></a><a data-type="indexterm" data-primary="multiplication operator (*)" id="idm46198571717032"></a><a data-type="indexterm" data-primary="/ (division operator)" id="idm46198571716344"></a><a data-type="indexterm" data-primary="division operator (/)" id="idm46198571715672"></a><a data-type="indexterm" data-primary="% (modulo operator)" id="idm46198571715000"></a><a data-type="indexterm" data-primary="modulo operator (%)" id="idm46198571714328"></a> include <code>+</code> for addition,
        <code>-</code> for subtraction, <code>*</code> for multiplication, <code>/</code> for
        division, and <code>%</code> for modulo (remainder after division).
        ES2016<a data-type="indexterm" data-primary="ES2016" data-secondary="exponentiation operator (**)" id="idm46198571711320"></a><a data-type="indexterm" data-primary="exponentiation operator (**)" id="idm46198571710328"></a><a data-type="indexterm" data-primary="** (exponentiation operator)" id="idm46198571709640"></a> adds <code>**</code> for exponentiation.
        Full details on these and other operators can be found in <a data-type="xref" href="ch04.html#expressions">Chapter&nbsp;4</a>.</p>
        
        <p>In<a data-type="indexterm" data-primary="mathematical operations" id="math04"></a> addition to these basic arithmetic operators, JavaScript supports more
        complex mathematical operations through a set of functions and constants
        defined as properties of the <code>Math</code> object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">53</code><code class="p">)</code>           <code class="c1">// =&gt; 9007199254740992: 2 to the power 53</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">round</code><code class="p">(.</code><code class="mi">6</code><code class="p">)</code>           <code class="c1">// =&gt; 1.0: round to the nearest integer</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(.</code><code class="mi">6</code><code class="p">)</code>            <code class="c1">// =&gt; 1.0: round up to an integer</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(.</code><code class="mi">6</code><code class="p">)</code>           <code class="c1">// =&gt; 0.0: round down to an integer</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">abs</code><code class="p">(</code><code class="o">-</code><code class="mi">5</code><code class="p">)</code>             <code class="c1">// =&gt; 5: absolute value</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">,</code><code class="nx">z</code><code class="p">)</code>          <code class="c1">// Return the largest argument</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">min</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">,</code><code class="nx">z</code><code class="p">)</code>          <code class="c1">// Return the smallest argument</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code>            <code class="c1">// Pseudo-random number x where 0 &lt;= x &lt; 1.0</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code>                  <code class="c1">// π: circumference of a circle / diameter</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">E</code>                   <code class="c1">// e: The base of the natural logarithm</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>             <code class="c1">// =&gt; 3**0.5: the square root of 3</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">1</code><code class="o">/</code><code class="mi">3</code><code class="p">)</code>         <code class="c1">// =&gt; 3**(1/3): the cube root of 3</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">sin</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>              <code class="c1">// Trigonometry: also Math.cos, Math.atan, etc.</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>             <code class="c1">// Natural logarithm of 10</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code><code class="o">/</code><code class="nb">Math</code><code class="p">.</code><code class="nx">LN10</code>  <code class="c1">// Base 10 logarithm of 100</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="mi">512</code><code class="p">)</code><code class="o">/</code><code class="nb">Math</code><code class="p">.</code><code class="nx">LN2</code>   <code class="c1">// Base 2 logarithm of 512</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">exp</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>              <code class="c1">// Math.E cubed</code></pre>
        
        <p>ES6<a data-type="indexterm" data-primary="ES6" data-secondary="Math object" id="idm46198571704872"></a> defines more functions on the <code>Math</code> object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Math</code><code class="p">.</code><code class="nx">cbrt</code><code class="p">(</code><code class="mi">27</code><code class="p">)</code>    <code class="c1">// =&gt; 3: cube root</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">hypot</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">)</code> <code class="c1">// =&gt; 5: square root of sum of squares of all arguments</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">log10</code><code class="p">(</code><code class="mi">100</code><code class="p">)</code>  <code class="c1">// =&gt; 2: Base-10 logarithm</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">log2</code><code class="p">(</code><code class="mi">1024</code><code class="p">)</code>  <code class="c1">// =&gt; 10: Base-2 logarithm</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">log1p</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>    <code class="c1">// Natural log of (1+x); accurate for very small x</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">expm1</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>    <code class="c1">// Math.exp(x)-1; the inverse of Math.log1p()</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">sign</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>     <code class="c1">// -1, 0, or 1 for arguments &lt;, ==, or &gt; 0</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">imul</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code>   <code class="c1">// =&gt; 6: optimized multiplication of 32-bit integers</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">clz32</code><code class="p">(</code><code class="mh">0xf</code><code class="p">)</code>  <code class="c1">// =&gt; 28: number of leading zero bits in a 32-bit integer</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">trunc</code><code class="p">(</code><code class="mf">3.9</code><code class="p">)</code>  <code class="c1">// =&gt; 3: convert to an integer by truncating fractional part</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">fround</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>   <code class="c1">// Round to nearest 32-bit float number</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">sinh</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>     <code class="c1">// Hyperbolic sine. Also Math.cosh(), Math.tanh()</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">asinh</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>    <code class="c1">// Hyperbolic arcsine. Also Math.acosh(), Math.atanh()</code></pre>
        
        <p>Arithmetic<a data-type="indexterm" data-primary="overflow" id="idm46198571556360"></a> in JavaScript does not raise errors in cases of overflow, underflow,
        or division by zero. When the result of a numeric operation is larger than the
        largest representable number (overflow), the result is a special<a data-type="indexterm" data-primary="infinity value" id="idm46198571310232"></a> infinity
        value, <code>Infinity</code>. Similarly, when the absolute
        value of a negative value becomes larger than the absolute value of the largest
        representable negative number, the result is<a data-type="indexterm" data-primary="negative infinity value" id="idm46198571308872"></a> negative infinity,
        <code>-Infinity</code>. The infinite values behave as you would expect: adding,
        subtracting, multiplying, or dividing them by anything results in an infinite
        value (possibly with the sign reversed).</p>
        
        <p>Underflow<a data-type="indexterm" data-primary="underflow" id="idm46198571307144"></a> occurs when the result of a numeric operation is closer to zero than
        the smallest representable number. In this case, JavaScript returns 0. If
        underflow occurs from a negative number, JavaScript returns a special value
        known as<a data-type="indexterm" data-primary="negative zero" id="idm46198571306040"></a><a data-type="indexterm" data-primary="zero" data-secondary="negative zero" id="idm46198571511064"></a> “negative zero.” This value is almost completely indistinguishable
        from regular zero and JavaScript programmers rarely need to detect it.</p>
        
        <p>Division<a data-type="indexterm" data-primary="not-a-number value (NaN)" id="idm46198571509448"></a><a data-type="indexterm" data-primary="NaN (not-a-number value)" id="idm46198571508744"></a> by zero is not an error in JavaScript: it simply returns infinity or
        negative infinity. There is one exception, however: zero divided by zero does
        not have a well-defined value, and the result of this operation is the special
        not-a-number value, <code>NaN</code>. <code>NaN</code> also arises if you attempt to
        divide infinity by infinity, take the square root of a negative number, or
        use arithmetic operators with non-numeric operands that cannot be converted to
        numbers.</p>
        
        <p>JavaScript predefines global constants <code>Infinity</code> and <code>NaN</code> to hold the
        positive infinity and not-a-number value, and these values are also
        available as properties of the <span class="keep-together"><code>Number</code></span> object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kc">Infinity</code>                    <code class="c1">// A positive number too big to represent</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">POSITIVE_INFINITY</code>    <code class="c1">// Same value</code>
        <code class="mi">1</code><code class="o">/</code><code class="mi">0</code>                         <code class="c1">// =&gt; Infinity</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_VALUE</code> <code class="o">*</code> <code class="mi">2</code>        <code class="c1">// =&gt; Infinity; overflow</code>
        
        <code class="o">-</code><code class="kc">Infinity</code>                   <code class="c1">// A negative number too big to represent</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">NEGATIVE_INFINITY</code>    <code class="c1">// The same value</code>
        <code class="o">-</code><code class="mi">1</code><code class="o">/</code><code class="mi">0</code>                        <code class="c1">// =&gt; -Infinity</code>
        <code class="o">-</code><code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_VALUE</code> <code class="o">*</code> <code class="mi">2</code>       <code class="c1">// =&gt; -Infinity</code>
        
        <code class="kc">NaN</code>                         <code class="c1">// The not-a-number value</code>
        <code class="nb">Number</code><code class="p">.</code><code class="kc">NaN</code>                  <code class="c1">// The same value, written another way</code>
        <code class="mi">0</code><code class="o">/</code><code class="mi">0</code>                         <code class="c1">// =&gt; NaN</code>
        <code class="kc">Infinity</code><code class="o">/</code><code class="kc">Infinity</code>           <code class="c1">// =&gt; NaN</code>
        
        <code class="nb">Number</code><code class="p">.</code><code class="nx">MIN_VALUE</code><code class="o">/</code><code class="mi">2</code>          <code class="c1">// =&gt; 0: underflow</code>
        <code class="o">-</code><code class="nb">Number</code><code class="p">.</code><code class="nx">MIN_VALUE</code><code class="o">/</code><code class="mi">2</code>         <code class="c1">// =&gt; -0: negative zero</code>
        <code class="o">-</code><code class="mi">1</code><code class="o">/</code><code class="kc">Infinity</code>                 <code class="c1">// -&gt; -0: also negative 0</code>
        <code class="o">-</code><code class="mi">0</code>
        
        <code class="c1">// The following Number properties are defined in ES6</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nb">parseInt</code><code class="p">()</code>       <code class="c1">// Same as the global parseInt() function</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nb">parseFloat</code><code class="p">()</code>     <code class="c1">// Same as the global parseFloat() function</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nb">isNaN</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>         <code class="c1">// Is x the NaN value?</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nb">isFinite</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>      <code class="c1">// Is x a number and finite?</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code>     <code class="c1">// Is x an integer?</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nb">isSafeInteger</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="c1">// Is x an integer -(2**53) &lt; x &lt; 2**53?</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">MIN_SAFE_INTEGER</code> <code class="c1">// =&gt; -(2**53 - 1)</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_SAFE_INTEGER</code> <code class="c1">// =&gt; 2**53 - 1</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">EPSILON</code>          <code class="c1">// =&gt; 2**-52: smallest difference between numbers</code></pre>
        
        <p>The not-a-number value has one unusual feature in JavaScript: it does
        not compare equal to any other value, including itself. This means
        that you can’t write <code>x === NaN</code> to determine whether the value of a
        variable <code>x</code> is <code>NaN</code>. Instead, you must write <code>x != x</code> or
        <code>Number.isNaN(x)</code>. Those expressions will be true if, and only if, <code>x</code>
        has the same value as the global constant <code>NaN</code>.</p>
        
        <p>The<a data-type="indexterm" data-primary="isNaN() function" id="idm46198571203624"></a> global function <code>isNaN()</code> is similar to <code>Number.isNaN()</code>. It
        returns <code>true</code> if its argument is <code>NaN</code>, or if that argument is a
        non-numeric value that cannot be converted to a number. The<a data-type="indexterm" data-primary="Number.isFinite() function" id="idm46198571200664"></a> related
        function <code>Number.isFinite()</code> returns <code>true</code> if its argument is a
        number other than <code>NaN</code>, <code>Infinity</code>, or <code>-Infinity</code>. The<a data-type="indexterm" data-primary="isFinite() function" id="idm46198571197592"></a> global
        <code>isFinite()</code> function returns <code>true</code> if its argument is, or can be
        converted to, a finite number.</p>
        
        <p>The negative zero value is also somewhat unusual. It compares equal (even using
        JavaScript’s strict equality test) to<a data-type="indexterm" data-primary="zero" data-secondary="positive zero" id="idm46198571195608"></a><a data-type="indexterm" data-primary="positive zero" id="idm46198571194632"></a> positive zero, which means that the two
        values are almost indistinguishable, except when used as<a data-type="indexterm" data-primary="" data-startref="NTarith03" id="idm46198571193720"></a><a data-type="indexterm" data-primary="" data-startref="arith03" id="idm46198571192776"></a><a data-type="indexterm" data-primary="" data-startref="Oarith03" id="idm46198571191832"></a><a data-type="indexterm" data-primary="" data-startref="math04" id="idm46198571190888"></a> a divisor:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">zero</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>         <code class="c1">// Regular zero</code>
        <code class="kd">let</code> <code class="nx">negz</code> <code class="o">=</code> <code class="o">-</code><code class="mi">0</code><code class="p">;</code>        <code class="c1">// Negative zero</code>
        <code class="nx">zero</code> <code class="o">===</code> <code class="nx">negz</code>         <code class="c1">// =&gt; true: zero and negative zero are equal</code>
        <code class="mi">1</code><code class="o">/</code><code class="nx">zero</code> <code class="o">===</code> <code class="mi">1</code><code class="o">/</code><code class="nx">negz</code>     <code class="c1">// =&gt; false: Infinity and -Infinity are not equal</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.2.4 Binary Floating-Point and Rounding Errors"><div class="sect2" id="idm46198571727880">
        <h2>3.2.4 Binary Floating-Point and Rounding Errors</h2>
        
        <p>There<a data-type="indexterm" data-primary="rounding errors" id="idm46198571168440"></a><a data-type="indexterm" data-primary="floating-point literals" id="idm46198571167768"></a><a data-type="indexterm" data-primary="literals" data-secondary="numeric" data-tertiary="floating-point literals" id="idm46198571167096"></a><a data-type="indexterm" data-primary="Number type" data-secondary="binary floating-point and rounding errors" id="idm46198571165880"></a> are infinitely many real numbers, but only a finite number of them
        (18,437,736,874,454,810,627, to be exact) can be represented exactly by the
        JavaScript floating-point format. This means that when you’re working with real
        numbers in JavaScript, the representation of the number will often be an
        approximation of the actual number.</p>
        
        <p>The IEEE-754 floating-point representation used by JavaScript (and just about
        every other modern programming language) is a binary representation, which can
        exactly represent fractions like <code>1/2</code>, <code>1/8</code>, and <code>1/1024</code>.
        Unfortunately, the fractions we use most commonly (especially when performing
        financial calculations) are decimal fractions: <code>1/10</code>, <code>1/100</code>, and
        so on. Binary floating-point representations cannot exactly represent numbers
        as simple as <code>0.1</code>.</p>
        
        <p>JavaScript numbers have plenty of precision and can approximate <code>0.1</code> very
        closely. But the fact that this number cannot be represented exactly can lead
        to problems. Consider this code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="p">.</code><code class="mi">3</code> <code class="o">-</code> <code class="p">.</code><code class="mi">2</code><code class="p">;</code>    <code class="c1">// thirty cents minus 20 cents</code>
        <code class="kd">let</code> <code class="nx">y</code> <code class="o">=</code> <code class="p">.</code><code class="mi">2</code> <code class="o">-</code> <code class="p">.</code><code class="mi">1</code><code class="p">;</code>    <code class="c1">// twenty cents minus 10 cents</code>
        <code class="nx">x</code> <code class="o">===</code> <code class="nx">y</code>             <code class="c1">// =&gt; false: the two values are not the same!</code>
        <code class="nx">x</code> <code class="o">===</code> <code class="p">.</code><code class="mi">1</code>            <code class="c1">// =&gt; false: .3-.2 is not equal to .1</code>
        <code class="nx">y</code> <code class="o">===</code> <code class="p">.</code><code class="mi">1</code>            <code class="c1">// =&gt; true: .2-.1 is equal to .1</code></pre>
        
        <p>Because of rounding error, the difference between the approximations of .3 and
        .2 is not exactly the same as the difference between the approximations of .2
        and .1. It is important to understand that this problem is not specific to
        JavaScript: it affects any programming language that uses binary floating-point
        numbers. Also, note that the values <code>x</code> and <code>y</code> in the code shown here are <em>very</em>
        close to each other and to the correct value. The computed values are adequate
        for almost any purpose; the problem only  arises when we attempt to
        compare values for equality.</p>
        
        <p>If these floating-point approximations are problematic for your
        programs, consider using scaled integers. For example, you might
        manipulate monetary values as integer cents rather than fractional
        dollars.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.2.5 Arbitrary Precision Integers with BigInt"><div class="sect2" id="bigint">
        <h2>3.2.5 Arbitrary Precision Integers with BigInt</h2>
        
        <p>One<a data-type="indexterm" data-primary="Number type" data-secondary="arbitrary precision integers with BigInt" id="idm46198571091960"></a><a data-type="indexterm" data-primary="BigInt type" id="idm46198571035352"></a><a data-type="indexterm" data-primary="ES2020" data-secondary="BigInt type" id="idm46198571034680"></a><a data-type="indexterm" data-primary="Node" data-secondary="BigInt type" id="idm46198571033736"></a> of the newest features of JavaScript, defined in ES2020, is a new
        numeric type known as BigInt. As of early 2020, it has been implemented
        in Chrome, Firefox, Edge, and Node, and there is an implementation in
        progress in Safari. As the name implies, BigInt is a numeric type
        whose values are integers. The type was added to JavaScript mainly to
        allow the representation of 64-bit integers, which are required for
        compatibility with many other programming languages and APIs. But
        BigInt values can have thousands or even millions of digits, should
        you have need to work with numbers that large. (Note, however, that
        BigInt implementations are not suitable for<a data-type="indexterm" data-primary="cryptography" id="idm46198571031992"></a> cryptography because they
        do not attempt to prevent timing attacks.)</p>
        
        <p>BigInt literals are written as a string of digits followed by a
        lowercase letter <code>n</code>. By default, the are in base 10, but you can use
        the <code>0b</code>, <code>0o</code>, and <code>0x</code> prefixes for binary, octal, and hexadecimal
        BigInts:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mi">1234</code><code class="nx">n</code>                <code class="c1">// A not-so-big BigInt literal</code>
        <code class="mb">0b111111</code><code class="nx">n</code>            <code class="c1">// A binary BigInt</code>
        <code class="mo">0o7777</code><code class="nx">n</code>              <code class="c1">// An octal BigInt</code>
        <code class="mh">0x8000000000000000</code><code class="nx">n</code>  <code class="c1">// =&gt; 2n**63n: A 64-bit integer</code></pre>
        
        <p>You can use <code>BigInt()</code> as a function for converting regular JavaScript
        numbers or strings to BigInt values:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">BigInt</code><code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nx">MAX_SAFE_INTEGER</code><code class="p">)</code>     <code class="c1">// =&gt; 9007199254740991n</code>
        <code class="kd">let</code> <code class="nx">string</code> <code class="o">=</code> <code class="s2">"1"</code> <code class="o">+</code> <code class="s2">"0"</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="mi">100</code><code class="p">);</code> <code class="c1">// 1 followed by 100 zeros.</code>
        <code class="nx">BigInt</code><code class="p">(</code><code class="nx">string</code><code class="p">)</code>                      <code class="c1">// =&gt; 10n**100n: one googol</code></pre>
        
        <p>Arithmetic with BigInt values works like arithmetic with regular
        JavaScript numbers, except that division drops any remainder and
        rounds down (toward zero):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mi">1000</code><code class="nx">n</code> <code class="o">+</code> <code class="mi">2000</code><code class="nx">n</code>  <code class="c1">// =&gt; 3000n</code>
        <code class="mi">3000</code><code class="nx">n</code> <code class="o">-</code> <code class="mi">2000</code><code class="nx">n</code>  <code class="c1">// =&gt; 1000n</code>
        <code class="mi">2000</code><code class="nx">n</code> <code class="o">*</code> <code class="mi">3000</code><code class="nx">n</code>  <code class="c1">// =&gt; 6000000n</code>
        <code class="mi">3000</code><code class="nx">n</code> <code class="o">/</code> <code class="mi">997</code><code class="nx">n</code>   <code class="c1">// =&gt; 3n: the quotient is 3</code>
        <code class="mi">3000</code><code class="nx">n</code> <code class="o">%</code> <code class="mi">997</code><code class="nx">n</code>   <code class="c1">// =&gt; 9n: and the remainder is 9</code>
        <code class="p">(</code><code class="mi">2</code><code class="nx">n</code> <code class="o">**</code> <code class="mi">131071</code><code class="nx">n</code><code class="p">)</code> <code class="o">-</code> <code class="mi">1</code><code class="nx">n</code>  <code class="c1">// A Mersenne prime with 39457 decimal digits</code></pre>
        
        <p>Although the standard <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, and <code>**</code> operators work
        with BigInt, it is important to understand that you may not mix
        operands of type BigInt with regular number operands. This may seem
        confusing at first, but there is a good reason for it. If one numeric
        type was more general than the other, it would be easy to define
        arithmetic on mixed operands to simply return a value of the more
        general type. But neither type is more general than the other: BigInt
        can represent extraordinarily large values, making it more general
        than regular numbers. But BigInt can only represent integers, making
        the regular JavaScript number type more general. There is no way
        around this problem, so JavaScript sidesteps it by simply not allowing
        mixed operands to the arithmetic operators.</p>
        
        <p>Comparison operators, by contrast, do work with mixed numeric types
        (but see <a data-type="xref" href="#conversionsandequality">§3.9.1</a> for more about the difference
        between <code>==</code> and <code>===</code>):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mi">1</code> <code class="o">&lt;</code> <code class="mi">2</code><code class="nx">n</code>     <code class="c1">// =&gt; true</code>
        <code class="mi">2</code> <code class="o">&gt;</code> <code class="mi">1</code><code class="nx">n</code>     <code class="c1">// =&gt; true</code>
        <code class="mi">0</code> <code class="o">==</code> <code class="mi">0</code><code class="nx">n</code>    <code class="c1">// =&gt; true</code>
        <code class="mi">0</code> <code class="o">===</code> <code class="mi">0</code><code class="nx">n</code>   <code class="c1">// =&gt; false: the === checks for type equality as well</code></pre>
        
        <p>The bitwise operators (described in <a data-type="xref" href="ch04.html#bitwiseoperators">§4.8.3</a>) generally
        work with BigInt operands. None of the functions of the <code>Math</code> object
        accept BigInt operands, however.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.2.6 Dates and Times"><div class="sect2" id="idm46198571093192">
        <h2>3.2.6 Dates and Times</h2>
        
        <p>JavaScript<a data-type="indexterm" data-primary="Number type" data-secondary="dates and times" id="idm46198570873240"></a><a data-type="indexterm" data-primary="dates and times" data-secondary="overview of" id="idm46198570872232"></a><a data-type="indexterm" data-primary="timestamps" id="idm46198570871288"></a> defines a simple Date class for representing and
        manipulating the numbers that represent dates and times. JavaScript
        Dates are objects, but they also have a numeric representation as a
        <em>timestamp</em> that specifies the number of elapsed milliseconds since
        January 1, 1970:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">timestamp</code> <code class="o">=</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>  <code class="c1">// The current time as a timestamp (a number).</code>
        <code class="kd">let</code> <code class="nx">now</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">();</code>        <code class="c1">// The current time as a Date object.</code>
        <code class="kd">let</code> <code class="nx">ms</code> <code class="o">=</code> <code class="nx">now</code><code class="p">.</code><code class="nx">getTime</code><code class="p">();</code>      <code class="c1">// Convert to a millisecond timestamp.</code>
        <code class="kd">let</code> <code class="nx">iso</code> <code class="o">=</code> <code class="nx">now</code><code class="p">.</code><code class="nx">toISOString</code><code class="p">();</code> <code class="c1">// Convert to a string in standard format.</code></pre>
        
        <p>The Date class and its methods are covered in detail in
        <a data-type="xref" href="ch11.html#datesandtimes">§11.4</a>. But we will see Date objects again in <a data-type="xref" href="#objtoprim">§3.9.3</a> when we examine the details of JavaScript type
        conversions.<a data-type="indexterm" data-primary="" data-startref="Tnumber03" id="idm46198570768824"></a><a data-type="indexterm" data-primary="" data-startref="PTnumber03" id="idm46198570767912"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.3 Text"><div class="sect1" id="text">
        <h1>3.3 Text</h1>
        
        <p>The<a data-type="indexterm" data-primary="primitive types" data-secondary="String type" id="PTstring03"></a><a data-type="indexterm" data-primary="types" data-secondary="strings" id="Tstring03"></a><a data-type="indexterm" data-primary="text" data-secondary="string type representing" id="idm46198570753528"></a><a data-type="indexterm" data-primary="strings" data-secondary="overview of" id="idm46198570752616"></a> JavaScript type for representing text is the <em>string</em>.  A string
        is an immutable ordered sequence of 16-bit values, each of which
        typically represents a Unicode character. The <em>length</em> of a string is
        the number of 16-bit values it contains. JavaScript’s strings (and its
        arrays) use zero-based indexing: the first 16-bit value is at position
        0, the second at position 1, and so on. The<a data-type="indexterm" data-primary="empty strings" id="idm46198570750376"></a> <em>empty string</em> is the
        string of length 0. JavaScript does not have a special type that
        represents a single element of a string. To represent a single 16-bit
        value, simply use a string that has a length of 1.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="I_sidebar2_d1e2438">
        <h5>Characters, Codepoints, and JavaScript Strings</h5>
        <p>JavaScript<a data-type="indexterm" data-primary="Unicode character set" data-secondary="JavaScript strings" id="idm46198570747112"></a><a data-type="indexterm" data-primary="strings" data-secondary="characters and codepoints" id="idm46198570746104"></a> uses the<a data-type="indexterm" data-primary="UTF-16 encoding" id="idm46198570745064"></a> UTF-16 encoding of the Unicode character set, and JavaScript strings are sequences of unsigned 16-bit values. The most commonly used Unicode characters (those from the “basic multilingual plane”) have codepoints that fit in 16 bits and can be represented by one element of a string. Unicode characters whose codepoints do not fit in 16 bits are encoded using the rules of UTF-16 as a sequence (known as a<a data-type="indexterm" data-primary="surrogate pairs" id="idm46198570743800"></a> “surrogate pair”) of two 16-bit values. This means that a JavaScript string of length 2 (two 16-bit values) might represent only a single Unicode character:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">euro</code> <code class="o">=</code> <code class="s2">"€"</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">love</code> <code class="o">=</code> <code class="s2">"❤"</code><code class="p">;</code>
        <code class="nx">euro</code><code class="p">.</code><code class="nx">length</code>   <code class="c1">// =&gt; 1: this character has one 16-bit element</code>
        <code class="nx">love</code><code class="p">.</code><code class="nx">length</code>   <code class="c1">// =&gt; 2: UTF-16 encoding of ❤ is "\ud83d\udc99"</code></pre>
        
        <p>Most string-manipulation methods defined by JavaScript operate on 16-bit
        values, not characters. They do not treat surrogate pairs specially, they perform
        no normalization of the string, and don’t even ensure that a string is
        well-formed UTF-16.</p>
        
        <p>In<a data-type="indexterm" data-primary="ES6" data-secondary="iterable strings in" id="idm46198570733304"></a><a data-type="indexterm" data-primary="for/of loops" id="idm46198570732424"></a> ES6, however, strings are <em>iterable</em>, and if you use the
        <code>for/of</code> loop or <code>...</code> operator with a string, it will iterate the
        actual characters of the string, not the 16-bit values.</p>
        </div></aside>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.3.1 String Literals"><div class="sect2" id="idm46198570730104">
        <h2>3.3.1 String Literals</h2>
        
        <p>To<a data-type="indexterm" data-primary="strings" data-secondary="string literals" id="idm46198570728312"></a><a data-type="indexterm" data-primary="text" data-secondary="string literals" id="idm46198570727304"></a><a data-type="indexterm" data-primary="literals" data-secondary="string" id="idm46198570726360"></a><a data-type="indexterm" data-primary="string literals" data-secondary="overview of" id="idm46198570725416"></a><a data-type="indexterm" data-primary="' (single quotes)" id="idm46198570724472"></a><a data-type="indexterm" data-primary="single quotes (')" id="idm46198570723800"></a><a data-type="indexterm" data-primary="&quot; (double quotes)" id="idm46198570723128"></a><a data-type="indexterm" data-primary="double quotes (&quot;)" id="idm46198570722456"></a><a data-type="indexterm" data-primary="` (backtick)" id="idm46198581301544"></a><a data-type="indexterm" data-primary="backtick (`)" id="idm46198581300872"></a><a data-type="indexterm" data-primary="quote marks" data-secondary="single quotes (')" id="idm46198581300200"></a><a data-type="indexterm" data-primary="quote marks" data-secondary="double quotes (&quot;)" id="idm46198581299256"></a> include a string in a JavaScript program, simply enclose the
        characters of the string within a matched pair of single or double
        quotes or backticks (<code>'</code> or <code>"</code> or <code>`</code>). Double-quote characters and
        backticks may be contained within strings delimited by single-quote
        characters, and similarly for strings delimited by double quotes and
        backticks. Here are examples of string literals:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="s2">""</code>  <code class="c1">// The empty string: it has zero characters</code>
        <code class="s1">'testing'</code>
        <code class="s2">"3.14"</code>
        <code class="s1">'name="myform"'</code>
        <code class="s2">"Wouldn't you prefer O'Reilly's book?"</code>
        <code class="s2">"τ is the ratio of a circle's circumference to its radius"</code>
        <code class="sb">`"She said 'hi'", he said.`</code></pre>
        
        <p>Strings<a data-type="indexterm" data-primary="ES6" data-secondary="strings delimited with backticks" id="idm46198581289176"></a><a data-type="indexterm" data-primary="expressions" data-secondary="embedding within string literals" id="idm46198581288328"></a> delimited with backticks are a feature of ES6, and
        allow JavaScript expressions to be embedded within<a data-type="indexterm" data-primary="interpolation" id="idm46198581287208"></a> (or <em>interpolated</em>
        into) the string literal. This expression interpolation syntax is
        covered in <a data-type="xref" href="#templateliterals">§3.3.4</a>.</p>
        
        <p>The original versions of JavaScript required string literals to be
        written on a single line, and it is common to see JavaScript code that
        creates long strings by concatenating single-line strings<a data-type="indexterm" data-primary="plus sign (+)" data-secondary="string concatenation" id="idm46198581254216"></a><a data-type="indexterm" data-primary="+ (plus sign)" data-secondary="string concatenation" id="idm46198581294440"></a> with the <code>+</code>
        operator. As<a data-type="indexterm" data-primary="backslash (\)" id="backs03"></a><a data-type="indexterm" data-primary="\ (backslash)" id="backslash03"></a><a data-type="indexterm" data-primary="ES5" data-secondary="breaking strings across multiple lines" id="idm46198581291000"></a> of ES5, however, you can break a string literal
        across multiple lines by ending each line but the last with a
        backslash (<code>\</code>). Neither the backslash nor the line terminator that
        follow it are part of the string literal. If<a data-type="indexterm" data-primary="\n (newline)" id="idm46198581249368"></a><a data-type="indexterm" data-primary="newline (\n)" id="idm46198581248664"></a> you need to include a
        newline character in a single-quoted or double-quoted string literal,
        use the character sequence <code>\n</code> (documented in the next section). The ES6 backtick
        syntax allows strings to be broken across multiple lines, and in this
        case, the line terminators are part of the string literal:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// A string representing 2 lines written on one line:</code>
        <code class="s1">'two\nlines'</code>
        
        <code class="c1">// A one-line string written on 3 lines:</code>
        <code class="s2">"one\</code>
        <code class="s2"> long\</code>
        <code class="s2"> line"</code>
        
        <code class="c1">// A two-line string written on two lines:</code>
        <code class="sb">`the newline character at the end of this line</code>
        <code class="sb">is included literally in this string`</code></pre>
        
        <p>Note<a data-type="indexterm" data-primary="English contractions" id="idm46198581244152"></a><a data-type="indexterm" data-primary="possessives" id="idm46198581243544"></a><a data-type="indexterm" data-primary="apostrophes" id="idm46198581241304"></a><a data-type="indexterm" data-primary="escape sequences" data-secondary="apostrophes" id="idm46198581240632"></a> that when you use single quotes to delimit your strings, you must be
        careful with English contractions and possessives, such as <em>can’t</em> and
        <em>O’Reilly’s</em>. Since the apostrophe is the same as the single-quote character,
        you must use the backslash character (<code>\</code>) to “escape” any apostrophes
        that appear in single-quoted strings (escapes are explained in the next
        section).</p>
        
        <p>In<a data-type="indexterm" data-primary="HTML code, single and double quotes in" id="idm46198581237624"></a> client-side JavaScript programming, JavaScript code may contain strings of
        HTML code, and HTML code may contain strings of JavaScript code. Like
        JavaScript, HTML uses either single or double quotes to delimit its strings.
        Thus, when combining JavaScript and HTML, it is a good idea to use one style of
        quotes for JavaScript and the other style for HTML. In the following example,
        the string “Thank you” is single-quoted within a JavaScript expression, which
        is then double-quoted within an HTML event-handler attribute:</p>
        
        <pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;button</code> <code class="na">onclick=</code><code class="s">"alert('Thank you')"</code><code class="nt">&gt;</code>Click Me<code class="nt">&lt;/button&gt;</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.3.2 Escape Sequences in String Literals"><div class="sect2" id="idm46198581207160">
        <h2>3.3.2 Escape Sequences in String Literals</h2>
        
        <p>The<a data-type="indexterm" data-primary="string literals" data-secondary="escape sequences in" id="idm46198581205560"></a><a data-type="indexterm" data-primary="text" data-secondary="escape sequences in string literals" id="idm46198581203768"></a><a data-type="indexterm" data-primary="escape sequences" data-secondary="in string literals" data-secondary-sortas="string literals" id="idm46198581202856"></a> backslash character (<code>\</code>) has a special purpose in JavaScript
        strings. Combined with the character that follows it, it represents a character
        that is not otherwise representable within the string. For<a data-type="indexterm" data-primary="newline (\n)" id="idm46198581200904"></a><a data-type="indexterm" data-primary="\n (newline)" id="idm46198581200200"></a> example, <code>\n</code>
        is an <em>escape sequence</em> that represents a newline character.</p>
        
        <p>Another<a data-type="indexterm" data-primary="\` (backtick or apostrophe) escape" id="idm46198581198248"></a> example, mentioned earlier, is the <code>\'</code> escape, which
        represents the single quote (or apostrophe) character. This escape sequence is
        useful when you need to include an apostrophe in a string literal that is
        contained within single quotes. You can see why these are called escape
        sequences: the backslash allows you to escape from the usual interpretation of
        the single-quote character. Instead of using it to mark the end of the string,
        you use it as an apostrophe:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="s1">'You\'re right, it can\'t be a quote'</code></pre>
        
        <p><a data-type="xref" href="#escapesequences">Table&nbsp;3-1</a> lists<a data-type="indexterm" data-primary="hexadecimal literals" id="idm46198581166072"></a> the JavaScript escape sequences and the
        characters they represent. Three<a data-type="indexterm" data-primary="Unicode character set" data-secondary="escape sequences" id="idm46198581165304"></a> escape sequences are generic and can
        be used to represent any character by specifying its Unicode character
        code as a hexadecimal number. For<a data-type="indexterm" data-primary="\xA9 (copyright symbol)" id="idm46198581162376"></a><a data-type="indexterm" data-primary="copyright symbol (\xA9)" id="idm46198581161816"></a> example, the sequence <code>\xA9</code>
        represents the copyright symbol, which has the Unicode encoding given
        by the hexadecimal number A9. Similarly, the<a data-type="indexterm" data-primary="\u (Unicode character escape)" id="idm46198581160472"></a> <code>\u</code> escape represents an
        arbitrary Unicode character specified by four hexadecimal digits or
        one to five digits when the digits are enclosed in curly braces:
        <code>\u03c0</code> represents the character π, for example, and <code>\u{1f600}</code>
        represents<a data-type="indexterm" data-primary="emojis" id="idm46198581158248"></a> the “grinning face” emoji.</p>
        <table id="escapesequences">
        <caption><span class="label">Table 3-1. </span>JavaScript escape sequences</caption>
        <thead>
        <tr>
        <th>Sequence</th>
        <th>Character represented</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p><code>\0</code></p></td>
        <td><p>The NUL character (<code>\u0000</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\b</code></p></td>
        <td><p>Backspace (<code>\u0008</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\t</code></p></td>
        <td><p>Horizontal tab (<code>\u0009</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\n</code></p></td>
        <td><p>Newline (<code>\u000A</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\v</code></p></td>
        <td><p>Vertical tab (<code>\u000B</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\f</code></p></td>
        <td><p>Form feed (<code>\u000C</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\r</code></p></td>
        <td><p>Carriage return (<code>\u000D</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\"</code></p></td>
        <td><p>Double quote (<code>\u0022</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\'</code></p></td>
        <td><p>Apostrophe or single quote (<code>\u0027</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\\</code></p></td>
        <td><p>Backslash (<code>\u005C</code>)</p></td>
        </tr>
        <tr>
        <td><p><code>\x</code><em>nn</em></p></td>
        <td><p>The Unicode character specified by the two hexadecimal digits <em>nn</em></p></td>
        </tr>
        <tr>
        <td><p><code>\u</code><em>nnnn</em></p></td>
        <td><p>The Unicode character specified by the four hexadecimal digits <em>nnnn</em></p></td>
        </tr>
        <tr>
        <td><p><code>\u{</code><em>n</em><code>}</code></p></td>
        <td><p>The Unicode character specified by the codepoint <em>n</em>, where <em>n</em> is one to six hexadecimal digits between 0 and 10FFFF (ES6)</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>If the <code>\</code> character precedes any character other than those shown in
        <a data-type="xref" href="#escapesequences">Table&nbsp;3-1</a>, the backslash is simply ignored (although future versions
        of the language may, of course, define new escape sequences). For example,
        <code>\#</code> is the same as <code>#</code>. Finally, as noted earlier, ES5<a data-type="indexterm" data-primary="ES5" data-secondary="breaking strings across multiple lines" id="idm46198581087848"></a> allows a
        backslash before a line break to break a string literal across multiple lines.<a data-type="indexterm" data-primary="" data-startref="backslash03" id="idm46198581086568"></a><a data-type="indexterm" data-primary="" data-startref="backs03" id="idm46198581085624"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.3.3 Working with Strings"><div class="sect2" id="idm46198581084680">
        <h2>3.3.3 Working with Strings</h2>
        
        <p>One<a data-type="indexterm" data-primary="text" data-secondary="working with strings" id="idm46198581082760"></a><a data-type="indexterm" data-primary="strings" data-secondary="working with" data-tertiary="concatenation" id="idm46198581081752"></a> of the built-in features of JavaScript is the ability to <em>concatenate</em>
        strings. If<a data-type="indexterm" data-primary="+ (plus sign)" data-secondary="string concatenation" id="idm46198581080024"></a><a data-type="indexterm" data-primary="plus sign (+)" data-secondary="string concatenation" id="idm46198581079016"></a> you use the <code>+</code> operator with numbers, it adds them. But if
        you use this operator on strings, it joins them by appending the second to the
        first. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">msg</code> <code class="o">=</code> <code class="s2">"Hello, "</code> <code class="o">+</code> <code class="s2">"world"</code><code class="p">;</code>   <code class="c1">// Produces the string "Hello, world"</code>
        <code class="kd">let</code> <code class="nx">greeting</code> <code class="o">=</code> <code class="s2">"Welcome to my blog,"</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="nx">name</code><code class="p">;</code></pre>
        
        <p>Strings<a data-type="indexterm" data-primary="strings" data-secondary="working with" data-tertiary="comparing" id="idm46198581067832"></a><a data-type="indexterm" data-primary="strict equality operator (===)" data-secondary="string comparison" id="idm46198581066280"></a><a data-type="indexterm" data-primary="=== (strict equality operator)" data-secondary="string comparison" id="idm46198581053976"></a><a data-type="indexterm" data-primary="!== (inequality operator)" data-secondary="string comparison" id="idm46198581053064"></a><a data-type="indexterm" data-primary="inequality operator (!==)" data-secondary="string comparison" id="idm46198581052152"></a> can be compared with the standard <code>===</code> equality and <code>!==</code>
        inequality operators: two strings are equal if and only if they
        consist of exactly the same sequence of 16-bit values. Strings<a data-type="indexterm" data-primary="< (less than operator)" data-secondary="string comparison" id="idm46198581050088"></a><a data-type="indexterm" data-primary="less than operator (<)" data-secondary="string comparison" id="idm46198581049112"></a><a data-type="indexterm" data-primary="<= (less than or equal to operator)" data-secondary="string comparison" id="idm46198581048168"></a><a data-type="indexterm" data-primary="less than or equal to operator (<=)" data-secondary="string comparison" id="idm46198581047160"></a><a data-type="indexterm" data-primary="> (greater than operator)" data-secondary="string comparison" id="idm46198581046200"></a><a data-type="indexterm" data-primary="greater than operator (>)" data-secondary="string comparison" id="idm46198581045240"></a><a data-type="indexterm" data-primary=">= (greater than or equal to operator)" data-secondary="string comparison" id="idm46198581044280"></a><a data-type="indexterm" data-primary="greater than or equal to operator (>=)" data-secondary="string comparison" id="idm46198581043320"></a> can
        also be compared with the <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> operators. String
        comparison is done simply by comparing the 16-bit values. (For more
        robust locale-aware string comparison and sorting, see <a data-type="xref" href="ch11.html#collator">§11.7.3</a>.)</p>
        
        <p>To<a data-type="indexterm" data-primary="strings" data-secondary="working with" data-tertiary="determining length" id="idm46198581039512"></a> determine the length of a string—the number of 16-bit values it contains—use
        the <code>length</code> property of the string:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">s</code><code class="p">.</code><code class="nx">length</code></pre>
        
        <p>In<a data-type="indexterm" data-primary="strings" data-secondary="working with" data-tertiary="API for" id="idm46198580989016"></a> addition to this <code>length</code> property, JavaScript provides a rich API
        for working with strings:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="s2">"Hello, world"</code><code class="p">;</code> <code class="c1">// Start with some text.</code>
        
        <code class="c1">// Obtaining portions of a string</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">substring</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">4</code><code class="p">)</code>        <code class="c1">// =&gt; "ell": the 2nd, 3rd, and 4th characters.</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">4</code><code class="p">)</code>            <code class="c1">// =&gt; "ell": same thing</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="o">-</code><code class="mi">3</code><code class="p">)</code>             <code class="c1">// =&gt; "rld": last 3 characters</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">", "</code><code class="p">)</code>           <code class="c1">// =&gt; ["Hello", "world"]: split at delimiter string</code>
        
        <code class="c1">// Searching a string</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="s2">"l"</code><code class="p">)</code>          <code class="c1">// =&gt; 2: position of first letter l</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="s2">"l"</code><code class="p">,</code> <code class="mi">3</code><code class="p">)</code>       <code class="c1">// =&gt; 3: position of first "l" at or after 3</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="s2">"zz"</code><code class="p">)</code>         <code class="c1">// =&gt; -1: s does not include the substring "zz"</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">lastIndexOf</code><code class="p">(</code><code class="s2">"l"</code><code class="p">)</code>      <code class="c1">// =&gt; 10: position of last letter l</code>
        
        <code class="c1">// Boolean searching functions in ES6 and later</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code><code class="s2">"Hell"</code><code class="p">)</code>    <code class="c1">// =&gt; true: the string starts with these</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code><code class="s2">"!"</code><code class="p">)</code>         <code class="c1">// =&gt; false: s does not end with that</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="s2">"or"</code><code class="p">)</code>        <code class="c1">// =&gt; true: s includes substring "or"</code>
        
        <code class="c1">// Creating modified versions of a string</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"llo"</code><code class="p">,</code> <code class="s2">"ya"</code><code class="p">)</code>  <code class="c1">// =&gt; "Heya, world"</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">()</code>         <code class="c1">// =&gt; "hello, world"</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">()</code>         <code class="c1">// =&gt; "HELLO, WORLD"</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">normalize</code><code class="p">()</code>           <code class="c1">// Unicode NFC normalization: ES6</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">normalize</code><code class="p">(</code><code class="s2">"NFD"</code><code class="p">)</code>      <code class="c1">// NFD normalization. Also "NFKC", "NFKD"</code>
        
        <code class="c1">// Inspecting individual (16-bit) characters of a string</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>             <code class="c1">// =&gt; "H": the first character</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><code class="nx">s</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">)</code>    <code class="c1">// =&gt; "d": the last character</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">charCodeAt</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>         <code class="c1">// =&gt; 72: 16-bit number at the specified position</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">codePointAt</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>        <code class="c1">// =&gt; 72: ES6, works for codepoints &gt; 16 bits</code>
        
        <code class="c1">// String padding functions in ES2017</code>
        <code class="s2">"x"</code><code class="p">.</code><code class="nx">padStart</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>         <code class="c1">// =&gt; "  x": add spaces on the left to a length of 3</code>
        <code class="s2">"x"</code><code class="p">.</code><code class="nx">padEnd</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>           <code class="c1">// =&gt; "x  ": add spaces on the right to a length of 3</code>
        <code class="s2">"x"</code><code class="p">.</code><code class="nx">padStart</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="s2">"*"</code><code class="p">)</code>    <code class="c1">// =&gt; "**x": add stars on the left to a length of 3</code>
        <code class="s2">"x"</code><code class="p">.</code><code class="nx">padEnd</code><code class="p">(</code><code class="mi">3</code><code class="p">,</code> <code class="s2">"-"</code><code class="p">)</code>      <code class="c1">// =&gt; "x--": add dashes on the right to a length of 3</code>
        
        <code class="c1">// Space trimming functions. trim() is ES5; others ES2019</code>
        <code class="s2">" test "</code><code class="p">.</code><code class="nx">trim</code><code class="p">()</code>         <code class="c1">// =&gt; "test": remove spaces at start and end</code>
        <code class="s2">" test "</code><code class="p">.</code><code class="nx">trimStart</code><code class="p">()</code>    <code class="c1">// =&gt; "test ": remove spaces on left. Also trimLeft</code>
        <code class="s2">" test "</code><code class="p">.</code><code class="nx">trimEnd</code><code class="p">()</code>      <code class="c1">// =&gt; " test": remove spaces at right. Also trimRight</code>
        
        <code class="c1">// Miscellaneous string methods</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="s2">"!"</code><code class="p">)</code>           <code class="c1">// =&gt; "Hello, world!": just use + operator instead</code>
        <code class="s2">"&lt;&gt;"</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>          <code class="c1">// =&gt; "&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;&lt;&gt;": concatenate n copies. ES6</code></pre>
        
        <p>Remember<a data-type="indexterm" data-primary="strings" data-secondary="working with" data-tertiary="immutability" id="idm46198581008536"></a><a data-type="indexterm" data-primary="immutability" id="idm46198581007416"></a> that strings are immutable in JavaScript. Methods<a data-type="indexterm" data-primary="replace() method" id="idm46198580772952"></a><a data-type="indexterm" data-primary="toUpperCase() method" id="idm46198580772392"></a> like <code>replace()</code> and
        <code>toUpperCase()</code> return new strings: they do not modify the string on which
        they are invoked.</p>
        
        <p>Strings<a data-type="indexterm" data-primary="strings" data-secondary="working with" data-tertiary="accessing individual characters" id="idm46198580770440"></a><a data-type="indexterm" data-primary="[] (square brackets)" id="idm46198580769096"></a><a data-type="indexterm" data-primary="square brackets ([])" id="idm46198580768424"></a> can also be treated like read-only arrays,
        and you can access individual characters (16-bit values) from a string
        using square brackets instead of the <code>charAt()</code> method:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="s2">"hello, world"</code><code class="p">;</code>
        <code class="nx">s</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>                  <code class="c1">// =&gt; "h"</code>
        <code class="nx">s</code><code class="p">[</code><code class="nx">s</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code>         <code class="c1">// =&gt; "d"</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.3.4 Template Literals"><div class="sect2" id="templateliterals">
        <h2>3.3.4 Template Literals</h2>
        
        <p>In<a data-type="indexterm" data-primary="literals" data-secondary="template literals" id="idm46198580744584"></a><a data-type="indexterm" data-primary="ES6" data-secondary="strings delimited with backticks" id="idm46198580743576"></a><a data-type="indexterm" data-primary="text" data-secondary="template literals" id="idm46198580742664"></a><a data-type="indexterm" data-primary="template literals" id="idm46198580741720"></a><a data-type="indexterm" data-primary="` (backtick)" id="idm46198580741048"></a><a data-type="indexterm" data-primary="backtick (`)" id="idm46198580740376"></a> ES6 and later, string literals can be delimited with
        backticks:</p>
        
        <pre data-type="programlisting">let s = `hello world`;</pre>
        
        <p>This is more than just another string literal syntax, however, because
        these <em>template literals</em> can include arbitrary JavaScript
        expressions. The final value of a string literal in backticks is
        computed by evaluating any included expressions, converting the values
        of those expressions to strings and combining those computed strings
        with the literal characters within the backticks:</p>
        
        <pre data-type="programlisting">let name = "Bill";
        let greeting = `Hello ${ name }.`;  // greeting == "Hello Bill."</pre>
        
        <p>Everything between the <code>${</code> and the matching <code>}</code> is
        interpreted as a JavaScript expression. Everything outside the curly
        braces is normal string literal text. The expression inside the braces
        is evaluated and then converted to a string and inserted into the
        template, replacing the dollar sign, the curly braces, and everything
        in between them.</p>
        
        <p>A template literal may include any number of expressions. It can use
        any of the escape characters that normal strings can, and it can span
        any number of lines, with no special escaping required. The following
        template literal includes four JavaScript expressions, a Unicode escape
        sequence, and at least four newlines (the expression values may include
        newlines as well):</p>
        
        <pre data-type="programlisting">let errorMessage = `\
        \u2718 Test failure at ${filename}:${linenumber}:
        ${exception.message}
        Stack trace:
        ${exception.stack}
        `;</pre>
        
        <p>The backslash at the end of the first line here escapes the initial
        newline so that the resulting string begins with the Unicode ✘
        character (<code>\u2718</code>) rather than a newline.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Tagged template literals"><div class="sect3" id="taggedtemplates">
        <h3>Tagged template literals</h3>
        
        <p>A<a data-type="indexterm" data-primary="tagged template literals" id="idm46198580730872"></a> powerful but less commonly used feature of template literals is
        that, if a function name (or “tag”) comes right before the opening
        backtick, then the text and the values of the expressions within the
        template literal are passed to the function. The value of this
        “tagged template literal” is the return value of the function. This
        could be used, for example, to apply HTML or SQL escaping to the
        values before substituting them into the text.</p>
        
        <p>ES6<a data-type="indexterm" data-primary="ES6" data-secondary="built-in tag function" id="idm46198580729144"></a><a data-type="indexterm" data-primary="String.raw() function" id="idm46198580728136"></a> has one built-in tag function: <code>String.raw()</code>. It
        returns the text within backticks without any processing of
        backslash escapes:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="sb">`</code><code class="err">\</code><code class="sb">n`</code><code class="p">.</code><code class="nx">length</code>            <code class="c1">// =&gt; 1: the string has a single newline character</code>
        <code class="nb">String</code><code class="p">.</code><code class="nx">raw</code><code class="sb">`</code><code class="err">\</code><code class="sb">n`</code><code class="p">.</code><code class="nx">length</code>  <code class="c1">// =&gt; 2: a backslash character and the letter n</code></pre>
        
        <p>Note that even though the tag portion of a tagged template literal is a
        function, there are no parentheses used in its invocation. In this
        very specific case, the backtick characters replace the open and close
        parentheses.</p>
        
        <p>The ability to define your own template tag functions is a powerful
        feature of JavaScript. These functions do not need to return
        strings, and they can be used like constructors, as if defining a new
        literal syntax for the language. We’ll see an example in <a data-type="xref" href="ch14.html#templatetags">§14.5</a>.<a data-type="indexterm" data-primary="" data-startref="Tstring03" id="idm46198580696776"></a><a data-type="indexterm" data-primary="" data-startref="PTstring03" id="idm46198580695832"></a></p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.3.5 Pattern Matching"><div class="sect2" id="regexpintro">
        <h2>3.3.5 Pattern Matching</h2>
        
        <p>JavaScript<a data-type="indexterm" data-primary="types" data-secondary="RegExp" id="Tregexp03"></a><a data-type="indexterm" data-primary="text" data-secondary="pattern matching" id="idm46198580691800"></a><a data-type="indexterm" data-primary="pattern matching" data-secondary="syntax for" id="idm46198580690856"></a><a data-type="indexterm" data-primary="RegExp type" id="idm46198580682584"></a> defines a datatype known as a <em>regular expression</em> (or
        RegExp) for describing and matching patterns in strings of
        text. RegExps are not one of the fundamental datatypes in JavaScript,
        but they have a literal syntax like numbers and strings do, so they
        sometimes seem like they are fundamental. The grammar of regular
        expression literals is complex and the API they define is
        nontrivial. They are documented in detail in <a data-type="xref" href="ch11.html#regexps">§11.3</a>. Because
        RegExps are powerful and commonly used for text processing, however,
        this section provides a brief overview.</p>
        
        <p>Text<a data-type="indexterm" data-primary="literals" data-secondary="regular expressions" id="idm46198580679672"></a> between a pair of slashes constitutes a regular expression
        literal. The second slash in the pair can also be followed by one or more
        letters, which modify the meaning of the pattern. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="sr">/^HTML/</code><code class="p">;</code>             <code class="c1">// Match the letters H T M L at the start of a string</code>
        <code class="sr">/[1-9][0-9]*/</code><code class="p">;</code>       <code class="c1">// Match a nonzero digit, followed by any # of digits</code>
        <code class="sr">/\bjavascript\b/i</code><code class="p">;</code>   <code class="c1">// Match "javascript" as a word, case-insensitive</code></pre>
        
        <p>RegExp objects define a number of useful methods, and strings also have methods
        that accept RegExp arguments.<a data-type="indexterm" data-primary="" data-startref="Tregexp03" id="idm46198580671192"></a> For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">text</code> <code class="o">=</code> <code class="s2">"testing: 1, 2, 3"</code><code class="p">;</code>   <code class="c1">// Sample text</code>
        <code class="kd">let</code> <code class="nx">pattern</code> <code class="o">=</code> <code class="sr">/\d+/g</code><code class="p">;</code>            <code class="c1">// Matches all instances of one or more digits</code>
        <code class="nx">pattern</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">text</code><code class="p">)</code>               <code class="c1">// =&gt; true: a match exists</code>
        <code class="nx">text</code><code class="p">.</code><code class="nx">search</code><code class="p">(</code><code class="nx">pattern</code><code class="p">)</code>             <code class="c1">// =&gt; 9: position of first match</code>
        <code class="nx">text</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="nx">pattern</code><code class="p">)</code>              <code class="c1">// =&gt; ["1", "2", "3"]: array of all matches</code>
        <code class="nx">text</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="nx">pattern</code><code class="p">,</code> <code class="s2">"#"</code><code class="p">)</code>       <code class="c1">// =&gt; "testing: #, #, #"</code>
        <code class="nx">text</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="sr">/\D+/</code><code class="p">)</code>                <code class="c1">// =&gt; ["","1","2","3"]: split on nondigits</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.4 Boolean Values"><div class="sect1" id="booleans">
        <h1>3.4 Boolean Values</h1>
        
        <p>A<a data-type="indexterm" data-primary="primitive types" data-secondary="Boolean truth values" id="PTboolean03"></a><a data-type="indexterm" data-primary="values" data-secondary="boolean values" id="Vboolean03"></a><a data-type="indexterm" data-primary="boolean values" id="booleanval03"></a> boolean value represents truth or falsehood, on or off, yes or no. There are
        only two possible values of this type. The reserved words <code>true</code> and <code>false</code>
        evaluate to these two values.</p>
        
        <p>Boolean<a data-type="indexterm" data-primary="strict equality operator (===)" data-secondary="boolean values" id="idm46198580473720"></a><a data-type="indexterm" data-primary="=== (strict equality operator)" data-secondary="boolean values" id="idm46198580472744"></a> values are generally the result of comparisons you make in your
        JavaScript programs. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">a</code> <code class="o">===</code> <code class="mi">4</code></pre>
        
        <p>This code tests to see whether the value of the variable <code>a</code> is equal to the
        number <code>4</code>. If it is, the result of this comparison is the boolean value
        <code>true</code>. If <code>a</code> is not equal to <code>4</code>, the result of the comparison is <code>false</code>.</p>
        
        <p>Boolean values are commonly used in JavaScript control structures. For<a data-type="indexterm" data-primary="if/else statement" id="idm46198580468712"></a><a data-type="indexterm" data-primary="statements" data-secondary="if/else statement" id="idm46198580468008"></a> example,
        the <code>if/else</code> statement in JavaScript performs one action if a boolean
        value is <code>true</code> and another action if the value is <code>false</code>. You usually combine
        a comparison that creates a boolean value directly with a statement that uses
        it. The result looks like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">===</code> <code class="mi">4</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">b</code> <code class="o">=</code> <code class="nx">b</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="nx">a</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>This code checks whether <code>a</code> equals <code>4</code>. If so, it adds <code>1</code> to <code>b</code>; otherwise,
        it adds <code>1</code> to <code>a</code>.</p>
        
        <p>As we’ll discuss in <a data-type="xref" href="#conversions">§3.9</a>, any JavaScript value can be converted to a
        boolean value. The following values convert to, and therefore work like,
        <code>false</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kc">undefined</code>
        <code class="kc">null</code>
        <code class="mi">0</code>
        <code class="o">-</code><code class="mi">0</code>
        <code class="kc">NaN</code>
        <code class="s2">""</code>  <code class="c1">// the empty string</code></pre>
        
        <p>All<a data-type="indexterm" data-primary="values" data-secondary="falsy and truthy" id="idm46198580374040"></a><a data-type="indexterm" data-primary="falsy values" id="idm46198580373192"></a><a data-type="indexterm" data-primary="truthy values" id="idm46198580372520"></a> other values, including all objects (and arrays) convert to, and work like,
        <code>true</code>. <code>false</code>, and the six values that convert to it, are sometimes called
        <em>falsy</em> values, and all other values are called <em>truthy</em>. Any time JavaScript
        expects a boolean value, a falsy value works like <code>false</code> and a truthy value
        works like <code>true</code>.</p>
        
        <p>As an example, suppose that the variable <code>o</code> either holds an object or the
        value <code>null</code>. You can test explicitly to see if <code>o</code> is non-null with an <code>if</code>
        statement like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">o</code> <code class="o">!==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">...</code></pre>
        
        <p>The<a data-type="indexterm" data-primary="!== (inequality operator)" data-secondary="boolean values" id="idm46198580289800"></a><a data-type="indexterm" data-primary="inequality operator (!==)" data-secondary="boolean values" id="idm46198580288952"></a> not-equal operator <code>!==</code> compares <code>o</code> to <code>null</code> and evaluates to either
        <code>true</code> or <code>false</code>. But you can omit the comparison and instead rely on the fact
        that <code>null</code> is falsy and objects are truthy:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">...</code></pre>
        
        <p>In the first case, the body of the <code>if</code> will be executed only if <code>o</code> is not
        <code>null</code>. The second case is less strict: it will execute the body of the <code>if</code>
        only if <code>o</code> is not <code>false</code> or any falsy value (such as <code>null</code> or <code>undefined</code>).
        Which <code>if</code> statement is appropriate for your program really depends on what
        values you expect to be assigned to <code>o</code>. If you need to distinguish <code>null</code> from
        <code>0</code> and <code>""</code>, then you should use an explicit comparison.</p>
        
        <p>Boolean<a data-type="indexterm" data-primary="toString() method" id="idm46198580300184"></a> values have a <code>toString()</code> method that you can use to convert them to
        the strings “true” or “false”, but they do not have any other useful
        methods. Despite the trivial API, there are three important boolean operators.</p>
        
        <p>The <code>&amp;&amp;</code> operator<a data-type="indexterm" data-primary="&amp;&amp; (Boolean AND operator)" id="idm46198580297608"></a><a data-type="indexterm" data-primary="Boolean AND operator (&amp;&amp;)" id="idm46198580296856"></a> performs the Boolean AND operation. It evaluates to a
        truthy value if and only if both of its operands are truthy; it evaluates to a
        falsy value otherwise. The <code>||</code> operator<a data-type="indexterm" data-primary="|| (Boolean OR operator)" id="idm46198580295480"></a><a data-type="indexterm" data-primary="Boolean OR operator (||)" id="idm46198580271272"></a><a data-type="indexterm" data-primary="unary operators" data-secondary="Boolean NOT operator (!)" id="idm46198580270584"></a> is the Boolean OR operation: it
        evaluates to a truthy value if either one (or both) of its operands is truthy
        and evaluates to a falsy value if both operands are falsy. Finally, the unary
        <code>!</code> operator performs the Boolean NOT operation: it evaluates to <code>true</code> if its
        operand is falsy and evaluates to <code>false</code> if its operand is truthy. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">((</code><code class="nx">x</code> <code class="o">===</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="nx">y</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="o">||</code> <code class="o">!</code><code class="p">(</code><code class="nx">z</code> <code class="o">===</code> <code class="mi">0</code><code class="p">))</code> <code class="p">{</code>
            <code class="c1">// x and y are both zero or z is non-zero</code>
        <code class="p">}</code></pre>
        
        <p>Full<a data-type="indexterm" data-primary="" data-startref="booleanval03" id="idm46198580231992"></a><a data-type="indexterm" data-primary="" data-startref="Vboolean03" id="idm46198580231144"></a><a data-type="indexterm" data-primary="" data-startref="PTboolean03" id="idm46198580230200"></a> details on these operators are in <a data-type="xref" href="ch04.html#logicalexprs">§4.10</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.5 null and undefined"><div class="sect1" id="nullundefined">
        <h1>3.5 null and undefined</h1>
        
        <p><code>null</code> is<a data-type="indexterm" data-primary="values" data-secondary="null and undefined" id="idm46198580224008"></a><a data-type="indexterm" data-primary="null values" id="idm46198580223000"></a><a data-type="indexterm" data-primary="undefined values" id="idm46198580222328"></a> a language keyword that evaluates to a special value that is usually
        used to indicate the absence of a value. Using the <code>typeof</code> operator on <code>null</code>
        returns the string “object”, indicating that <code>null</code> can be thought of as a
        special object value that indicates “no object”. In practice, however, <code>null</code>
        is typically regarded as the sole member of its own type, and it can be used to
        indicate “no value” for numbers and strings as well as objects. Most
        programming languages have an equivalent to JavaScript’s <code>null</code>: you may be
        familiar with it as <code>NULL</code>, <code>nil</code>, or <code>None</code>.</p>
        
        <p>JavaScript also has a second value that indicates absence of value. The
        <code>undefined</code> value represents a deeper kind of absence. It is the value of
        variables that have not been initialized and the value you get when you
        query the value of an object property or array element that does not
        exist. The <code>undefined</code> value is also the return value of functions that do
        not explicitly return a value and the value of function parameters for
        which no argument is passed. <code>undefined</code> is a predefined global constant
        (not a language keyword like <code>null</code>, though this is not an important
        distinction in practice) that is initialized to the <code>undefined</code> value. If
        you apply the <code>typeof</code> operator to the <code>undefined</code> value, it returns
        “undefined”, indicating that this value is the sole member of a
        special type.</p>
        
        <p>Despite these differences, <code>null</code> and <code>undefined</code> both indicate an absence of
        value and can often be used interchangeably. The equality operator <code>==</code>
        considers them to be equal. (Use the strict equality operator <code>===</code> to
        distinguish them.) Both are falsy values: they behave like <code>false</code> when a
        boolean value is required. Neither <code>null</code> nor <span class="keep-together"><code>undefined</code></span> have any properties
        or methods. In fact, using <code>.</code> or <code>[]</code> to access a property or method of these
        values causes a TypeError.</p>
        
        <p>I consider <code>undefined</code> to represent a system-level, unexpected, or
        error-like absence of value and <code>null</code> to represent a program-level,
        normal, or expected absence of value. I avoid using <code>null</code> and
        <code>undefined</code> when I can, but if I need to assign one of these values to
        a variable or property or pass or return one of these values to or
        from a function, I usually use <code>null</code>. Some programmers strive to avoid
        <code>null</code> entirely and use <code>undefined</code> in its place wherever they can.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.6 Symbols"><div class="sect1" id="symbols">
        <h1>3.6 Symbols</h1>
        
        <p>Symbols<a data-type="indexterm" data-primary="types" data-secondary="Symbols" id="Tsymbol03"></a><a data-type="indexterm" data-primary="Symbols" data-secondary="property names" id="idm46198580173128"></a><a data-type="indexterm" data-primary="properties" data-secondary="naming" id="idm46198580172184"></a> were introduced in ES6 to serve as
        non-string property names. To understand Symbols, you need to know that
        JavaScript’s fundamental Object type is an unordered collection of
        properties, where each property has a name and a value. Property names
        are typically (and until ES6, were exclusively) strings. But in
        ES6 and later, Symbols can also serve this purpose:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">strname</code> <code class="o">=</code> <code class="s2">"string name"</code><code class="p">;</code>      <code class="c1">// A string to use as a property name</code>
        <code class="kd">let</code> <code class="nx">symname</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"propname"</code><code class="p">);</code> <code class="c1">// A Symbol to use as a property name</code>
        <code class="k">typeof</code> <code class="nx">strname</code>                    <code class="c1">// =&gt; "string": strname is a string</code>
        <code class="k">typeof</code> <code class="nx">symname</code>                    <code class="c1">// =&gt; "symbol": symname is a symbol</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{};</code>                       <code class="c1">// Create a new object</code>
        <code class="nx">o</code><code class="p">[</code><code class="nx">strname</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>                   <code class="c1">// Define a property with a string name</code>
        <code class="nx">o</code><code class="p">[</code><code class="nx">symname</code><code class="p">]</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>                   <code class="c1">// Define a property with a Symbol name</code>
        <code class="nx">o</code><code class="p">[</code><code class="nx">strname</code><code class="p">]</code>                        <code class="c1">// =&gt; 1: access the string-named property</code>
        <code class="nx">o</code><code class="p">[</code><code class="nx">symname</code><code class="p">]</code>                        <code class="c1">// =&gt; 2: access the symbol-named property</code></pre>
        
        <p>The Symbol type does not have a literal syntax. To obtain a Symbol
        value, you call the <code>Symbol()</code> function. This function never returns
        the same value twice, even when called with the same argument. This
        means that if you call <code>Symbol()</code> to obtain a Symbol value, you can
        safely use that value as a property name to add a new property to an
        object and do not need to worry that you might be overwriting an
        existing property with the same name. Similarly, if you use symbolic
        property names and do not share those symbols, you can be confident
        that other modules of code in your program will not accidentally
        overwrite your properties.</p>
        
        <p>In practice, Symbols serve as a language extension mechanism. When ES6
        introduced the <code>for/of</code> loop (<a data-type="xref" href="ch05.html#forofloop">§5.4.4</a>) and iterable objects
        (<a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>), it needed to define standard method that classes could
        implement to make themselves iterable. But standardizing any
        particular string name for this iterator method would have broken
        existing code, so a symbolic name was used instead. As we’ll see in
        <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>, <code>Symbol.iterator</code> is a Symbol value that can be used as
        a method name to make an object iterable.</p>
        
        <p>The <code>Symbol()</code> function takes an optional string argument and returns a
        unique Symbol value. If you supply a string argument, that string will
        be included in the output of the Symbol’s <code>toString()</code> method. Note,
        however, that calling <code>Symbol()</code> twice with the same string produces two
        completely different Symbol values.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"sym_x"</code><code class="p">);</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>             <code class="c1">// =&gt; "Symbol(sym_x)"</code></pre>
        
        <p><code>toString()</code> is the only interesting method of Symbol instances. There
        are two other Symbol-related functions you should know about,
        however. Sometimes when using Symbols, you want to keep them private to
        your own code so you have a guarantee that your properties will never
        conflict with properties used by other code. Other times, however, you
        might want to define a Symbol value and share it widely with other
        code. This would be the case, for example, if you were defining some
        kind of extension that you wanted other code to be able to participate
        in, as with the <span class="keep-together"><code>Symbol.iterator</code></span> mechanism described earlier.</p>
        
        <p>To serve this latter use case, JavaScript defines a global Symbol
        registry. The <span class="keep-together"><code>Symbol.for()</code></span> function takes a string argument and
        returns a Symbol value that is associated with the string you pass. If
        no Symbol is already associated with that string, then a new one is
        created and returned; otherwise, the already existing Symbol is
        returned. That is, the <code>Symbol.for()</code> function is completely different
        than the <code>Symbol()</code> function: <code>Symbol()</code> never returns the same value
        twice, but <code>Symbol.for()</code> always returns the same value when called with
        the same string. The string passed to <code>Symbol.for()</code> appears in the
        output of <code>toString()</code> for the returned Symbol, and it can also be
        retrieved by calling <code>Symbol.keyFor()</code> on the returned Symbol.<a data-type="indexterm" data-primary="" data-startref="Tsymbol03" id="idm46198580084728"></a></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s2">"shared"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">t</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">.</code><code class="k">for</code><code class="p">(</code><code class="s2">"shared"</code><code class="p">);</code>
        <code class="nx">s</code> <code class="o">===</code> <code class="nx">t</code>          <code class="c1">// =&gt; true</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>     <code class="c1">// =&gt; "Symbol(shared)"</code>
        <code class="nx">Symbol</code><code class="p">.</code><code class="nx">keyFor</code><code class="p">(</code><code class="nx">t</code><code class="p">)</code> <code class="c1">// =&gt; "shared"</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.7 The Global Object"><div class="sect1" id="global">
        <h1>3.7 The Global Object</h1>
        
        <p>The<a data-type="indexterm" data-primary="global object" id="idm46198579985160"></a><a data-type="indexterm" data-primary="types" data-secondary="global object" id="Tglobal03"></a> preceding sections have explained JavaScript’s primitive types and
        values.  Object types—objects, arrays, and functions—are covered in
        chapters of their own later in this book. But there is one very
        important object value that we must cover now. The <em>global object</em>
        is a regular JavaScript object that serves a very important purpose:
        the properties of this object are the globally defined identifiers
        that are available to a JavaScript program. When the JavaScript
        interpreter starts (or whenever a web browser loads a new page), it
        creates a new global object and gives it an initial set of properties
        that define:</p>
        
        <ul>
        <li>
        <p>Global constants like <code>undefined</code>, <code>Infinity</code>, and <code>NaN</code></p>
        </li>
        <li>
        <p>Global functions like <code>isNaN()</code>, <code>parseInt()</code>
        (<a data-type="xref" href="#explicitconversions">§3.9.2</a>), and <code>eval()</code> (<a data-type="xref" href="ch04.html#evalexprs">§4.12</a>)</p>
        </li>
        <li>
        <p>Constructor functions like <code>Date()</code>, <code>RegExp()</code>, <code>String()</code>,
        <code>Object()</code>, and <code>Array()</code> (<a data-type="xref" href="#explicitconversions">§3.9.2</a>)</p>
        </li>
        <li>
        <p>Global objects like Math and JSON (<a data-type="xref" href="ch06.html#serializingobjects">§6.8</a>)</p>
        </li>
        </ul>
        
        <p>The initial properties of the global object are not reserved words, but
        they deserve to be treated as if they are. This chapter has already
        described some of these global properties. Most of the others will be
        covered elsewhere in this book.</p>
        
        <p>In Node, the global object has a property named <code>global</code> whose value is
        the global object itself, so you can always refer to the global object
        by the name <code>global</code> in Node programs.</p>
        
        <p>In web browsers, the Window object serves as the global object for all
        JavaScript code contained in the browser window it represents. This
        global Window object has a self-referential <code>window</code> property that can
        be used to refer to the global object. The Window object defines the
        core global properties, but it also defines quite a few other globals
        that are specific to web browsers and client-side JavaScript. Web
        worker threads (<a data-type="xref" href="ch15.html#webworkers">§15.13</a>) have a different global object than
        the Window with which they are associated. Code in a worker can refer
        to its global object as <code>self</code>.</p>
        
        <p>ES2020<a data-type="indexterm" data-primary="ES2020" data-secondary="globalThis" id="idm46198579964648"></a> finally defines <code>globalThis</code> as the standard way to refer to
        the global object in any context. As of early 2020, this feature has been
        implemented by all modern browsers and by Node.<a data-type="indexterm" data-primary="" data-startref="Tglobal03" id="idm46198579962920"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.8 Immutable Primitive Values and Mutable Object References"><div class="sect1" id="mutableandimmutable">
        <h1>3.8 Immutable Primitive Values and Mutable Object References</h1>
        
        <p>There<a data-type="indexterm" data-primary="objects" data-secondary="mutable object references" id="idm46198579959992"></a><a data-type="indexterm" data-primary="immutability" id="idm46198579959016"></a><a data-type="indexterm" data-primary="values" data-secondary="immutable primitive values" id="idm46198579958344"></a><a data-type="indexterm" data-primary="primitive types" data-secondary="immutable primitive values" id="idm46198579957432"></a> is a fundamental difference in JavaScript between primitive values
        (<code>undefined</code>, <code>null</code>, booleans, numbers, and strings) and objects (including
        arrays and functions). Primitives are immutable: there is no way to change (or
        “mutate”) a primitive value. This is obvious for numbers and booleans—it
        doesn’t even make sense to change the value of a number. It is not so obvious
        for strings, however. Since strings are like arrays of characters, you might
        expect to be able to alter the character at any specified index. In fact,
        JavaScript does not allow this, and all string methods that appear to return a
        modified string are, in fact, returning a new string value. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="s2">"hello"</code><code class="p">;</code>   <code class="c1">// Start with some lowercase text</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>   <code class="c1">// Returns "HELLO", but doesn't alter s</code>
        <code class="nx">s</code>                  <code class="c1">// =&gt; "hello": the original string has not changed</code></pre>
        
        <p>Primitives are also compared <em>by value</em>: two values are the same only if they
        have the same value. This sounds circular for numbers, booleans, <code>null</code>, and
        <code>undefined</code>: there is no other way that they could be compared. Again, however,
        it is not so obvious for strings. If two distinct string values are compared,
        JavaScript treats them as equal if, and only if, they have the same length and
        if the character at each index is the same.</p>
        
        <p>Objects are different than primitives. First, they are <em>mutable</em>—their values
        can change:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code> <code class="p">};</code>  <code class="c1">// Start with an object</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>           <code class="c1">// Mutate it by changing the value of a property</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>           <code class="c1">// Mutate it again by adding a new property</code>
        
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>   <code class="c1">// Arrays are also mutable</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>          <code class="c1">// Change the value of an array element</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">3</code><code class="p">]</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>          <code class="c1">// Add a new array element</code></pre>
        
        <p>Objects are not compared by value: two distinct objects are not equal
        even if they have the same properties and values. And two distinct
        arrays are not equal even if they have the same elements in the same
        order:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">},</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">};</code>  <code class="c1">// Two objects with the same properties</code>
        <code class="nx">o</code> <code class="o">===</code> <code class="nx">p</code>                      <code class="c1">// =&gt; false: distinct objects are never equal</code>
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[],</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[];</code>          <code class="c1">// Two distinct, empty arrays</code>
        <code class="nx">a</code> <code class="o">===</code> <code class="nx">b</code>                      <code class="c1">// =&gt; false: distinct arrays are never equal</code></pre>
        
        <p>Objects<a data-type="indexterm" data-primary="reference types" id="idm46198579830104"></a> are sometimes called <em>reference types</em> to distinguish them from
        JavaScript’s primitive types. Using this terminology, object values are
        <em>references</em>, and we say that objects are compared <em>by reference</em>: two object
        values are the same if and only if they <em>refer</em> to the same underlying object.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[];</code>   <code class="c1">// The variable a refers to an empty array.</code>
        <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">a</code><code class="p">;</code>    <code class="c1">// Now b refers to the same array.</code>
        <code class="nx">b</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>     <code class="c1">// Mutate the array referred to by variable b.</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>          <code class="c1">// =&gt; 1: the change is also visible through variable a.</code>
        <code class="nx">a</code> <code class="o">===</code> <code class="nx">b</code>       <code class="c1">// =&gt; true: a and b refer to the same object, so they are equal.</code></pre>
        
        <p>As you can see from this code, assigning an object (or array) to a
        variable simply assigns the reference: it does not create a new copy of the
        object. If you want to make a new copy of an object or array, you must
        explicitly copy the properties of the object or the elements of the array. This
        example demonstrates using a <code>for</code> loop (<a data-type="xref" href="ch05.html#forloop">§5.4.3</a>):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"a"</code><code class="p">,</code><code class="s2">"b"</code><code class="p">,</code><code class="s2">"c"</code><code class="p">];</code>              <code class="c1">// An array we want to copy</code>
        <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[];</code>                         <code class="c1">// A distinct array we'll copy into</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// For each index of a[]</code>
            <code class="nx">b</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>                    <code class="c1">// Copy an element of a into b</code>
        <code class="p">}</code>
        <code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">b</code><code class="p">);</code>              <code class="c1">// In ES6, copy arrays with Array.from()</code></pre>
        
        <p>Similarly, if we want to compare two distinct objects or arrays, we must
        compare their properties or elements. This code defines a function to compare
        two arrays:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">equalArrays</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">===</code> <code class="nx">b</code><code class="p">)</code> <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>                <code class="c1">// Identical arrays are equal</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">length</code> <code class="o">!==</code> <code class="nx">b</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code> <code class="c1">// Different-size arrays not equal</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>      <code class="c1">// Loop through all elements</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">!==</code> <code class="nx">b</code><code class="p">[</code><code class="nx">i</code><code class="p">])</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>     <code class="c1">// If any differ, arrays not equal</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>                             <code class="c1">// Otherwise they are equal</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.9 Type Conversions"><div class="sect1" id="conversions">
        <h1>3.9 Type Conversions</h1>
        
        <p>JavaScript<a data-type="indexterm" data-primary="types" data-secondary="type conversions" id="Tconver03"></a><a data-type="indexterm" data-primary="type conversions" data-secondary="overview of" id="idm46198579544984"></a> is very flexible about the types of values it requires. We’ve seen
        this for booleans: when JavaScript expects a boolean value, you may supply a
        value of any type, and JavaScript will convert it as needed. Some values
        (“truthy” values) convert to <code>true</code> and others (“falsy” values) convert to
        <code>false</code>. The same is true for other types: if JavaScript wants a string, it
        will convert whatever value you give it to a string. If JavaScript wants a
        number, it will try to convert the value you give it to a number (or to <code>NaN</code>
        if it cannot perform a meaningful conversion).</p>
        
        <p>Some examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mi">10</code> <code class="o">+</code> <code class="s2">" objects"</code>     <code class="c1">// =&gt; "10 objects":  Number 10 converts to a string</code>
        <code class="s2">"7"</code> <code class="o">*</code> <code class="s2">"4"</code>           <code class="c1">// =&gt; 28: both strings convert to numbers</code>
        <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">-</code> <code class="s2">"x"</code><code class="p">;</code>    <code class="c1">// n == NaN; string "x" can't convert to a number</code>
        <code class="nx">n</code> <code class="o">+</code> <code class="s2">" objects"</code>      <code class="c1">// =&gt; "NaN objects": NaN converts to string "NaN"</code></pre>
        
        <p><a data-type="xref" href="#conversionstable">Table&nbsp;3-2</a> summarizes how values convert from one type to another in
        JavaScript. Bold entries in the table highlight conversions that you may find
        surprising. Empty cells indicate that no conversion is necessary and none is
        performed.</p>
        <table id="conversionstable">
        <caption><span class="label">Table 3-2. </span>JavaScript type conversions</caption>
        <thead>
        <tr>
        <th>Value</th>
        <th>to String</th>
        <th>to Number</th>
        <th>to Boolean</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p><code>undefined</code></p></td>
        <td><p><code>"undefined"</code></p></td>
        <td><p><code>NaN</code></p></td>
        <td><p><code>false</code></p></td>
        </tr>
        <tr>
        <td><p><code>null</code></p></td>
        <td><p><code>"null"</code></p></td>
        <td><p><strong><code>0</code></strong></p></td>
        <td><p><code>false</code></p></td>
        </tr>
        <tr>
        <td><p><code>true</code></p></td>
        <td><p><code>"true"</code></p></td>
        <td><p><strong><code>1</code></strong></p></td>
        <td></td>
        </tr>
        <tr>
        <td><p><code>false</code></p></td>
        <td><p><code>"false"</code></p></td>
        <td><p><strong><code>0</code></strong></p></td>
        <td></td>
        </tr>
        <tr>
        <td><p><code>""</code> (empty string)</p></td>
        <td></td>
        <td><p><strong><code>0</code></strong></p></td>
        <td><p><strong><code>false</code></strong></p></td>
        </tr>
        <tr>
        <td><p><code>"1.2"</code> (nonempty, numeric)</p></td>
        <td></td>
        <td><p><code>1.2</code></p></td>
        <td><p><code>true</code></p></td>
        </tr>
        <tr>
        <td><p><code>"one"</code> (nonempty, non-numeric)</p></td>
        <td></td>
        <td><p><code>NaN</code></p></td>
        <td><p><code>true</code></p></td>
        </tr>
        <tr>
        <td><p><code>0</code></p></td>
        <td><p><code>"0"</code></p></td>
        <td></td>
        <td><p><strong><code>false</code></strong></p></td>
        </tr>
        <tr>
        <td><p><code>-0</code></p></td>
        <td><p><code>"0"</code></p></td>
        <td></td>
        <td><p><strong><code>false</code></strong></p></td>
        </tr>
        <tr>
        <td><p><code>1</code> (finite, non-zero)</p></td>
        <td><p><code>"1"</code></p></td>
        <td></td>
        <td><p><code>true</code></p></td>
        </tr>
        <tr>
        <td><p><code>Infinity</code></p></td>
        <td><p><code>"Infinity"</code></p></td>
        <td></td>
        <td><p><code>true</code></p></td>
        </tr>
        <tr>
        <td><p><code>-Infinity</code></p></td>
        <td><p><code>"-Infinity"</code></p></td>
        <td></td>
        <td><p><code>true</code></p></td>
        </tr>
        <tr>
        <td><p><code>NaN</code></p></td>
        <td><p><code>"NaN"</code></p></td>
        <td></td>
        <td><p><strong><code>false</code></strong></p></td>
        </tr>
        <tr>
        <td><p><code>{}</code> (any object)</p></td>
        <td><p><em>see <a data-type="xref" href="#objtoprim">§3.9.3</a></em></p></td>
        <td><p><em>see <a data-type="xref" href="#objtoprim">§3.9.3</a></em></p></td>
        <td><p><code>true</code></p></td>
        </tr>
        <tr>
        <td><p><code>[]</code> (empty array)</p></td>
        <td><p><code>""</code></p></td>
        <td><p><strong><code>0</code></strong></p></td>
        <td><p><code>true</code></p></td>
        </tr>
        <tr>
        <td><p><code>[9]</code> (one numeric element)</p></td>
        <td><p><code>"9"</code></p></td>
        <td><p><strong><code>9</code></strong></p></td>
        <td><p><code>true</code></p></td>
        </tr>
        <tr>
        <td><p><code>['a']</code> (any other array)</p></td>
        <td><p><em>use join() method</em></p></td>
        <td><p><code>NaN</code></p></td>
        <td><p><code>true</code></p></td>
        </tr>
        <tr>
        <td><p><code>function(){}</code> (any function)</p></td>
        <td><p><em>see <a data-type="xref" href="#objtoprim">§3.9.3</a></em></p></td>
        <td><p><code>NaN</code></p></td>
        <td><p><code>true</code></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>The primitive-to-primitive conversions shown in the table are relatively
        straightforward. Conversion to boolean was already discussed in <a data-type="xref" href="#booleans">§3.4</a>.
        Conversion to strings is well defined for all primitive values. Conversion to
        numbers is just a little trickier. Strings that can be parsed as numbers
        convert to those numbers. Leading and trailing spaces are allowed, but any
        leading or trailing nonspace characters that are not part of a numeric literal
        cause the string-to-number conversion to produce <code>NaN</code>. Some numeric
        conversions may seem surprising: <code>true</code> converts to 1, and <code>false</code> and the
        empty string convert to 0.</p>
        
        <p>Object-to-primitive conversion is somewhat more complicated, and it is the
        subject of <a data-type="xref" href="#objtoprim">§3.9.3</a>.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.9.1 Conversions and Equality"><div class="sect2" id="conversionsandequality">
        <h2>3.9.1 Conversions and Equality</h2>
        
        <p>JavaScript<a data-type="indexterm" data-primary="type conversions" data-secondary="equality and" id="idm46198579358440"></a><a data-type="indexterm" data-primary="== (equality operator)" data-secondary="type conversions" id="idm46198579357432"></a><a data-type="indexterm" data-primary="equality operator (==)" data-secondary="type conversions" id="idm46198579356488"></a><a data-type="indexterm" data-primary="strict equality operator (===)" data-secondary="type conversions" id="idm46198579355544"></a><a data-type="indexterm" data-primary="=== (strict equality operator)" data-secondary="type conversions" id="idm46198579354632"></a> has two operators that test whether two values are
        equal. The “strict equality operator,” <code>===</code>, does not consider its
        operands to be equal if they are not of the same type, and this is
        almost always the right operator to use when coding. But because
        JavaScript is so flexible with type conversions, it also defines the
        <code>==</code> operator with a flexible definition of equality. All of the
        following comparisons are true, for example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kc">null</code> <code class="o">==</code> <code class="kc">undefined</code> <code class="c1">// =&gt; true: These two values are treated as equal.</code>
        <code class="s2">"0"</code> <code class="o">==</code> <code class="mi">0</code>          <code class="c1">// =&gt; true: String converts to a number before comparing.</code>
        <code class="mi">0</code> <code class="o">==</code> <code class="kc">false</code>        <code class="c1">// =&gt; true: Boolean converts to number before comparing.</code>
        <code class="s2">"0"</code> <code class="o">==</code> <code class="kc">false</code>      <code class="c1">// =&gt; true: Both operands convert to 0 before comparing!</code></pre>
        
        <p><a data-type="xref" href="ch04.html#equalityops">§4.9.1</a> explains exactly what conversions are performed by the <code>==</code>
        operator in order to determine whether two values should be considered equal.</p>
        
        <p>Keep in mind that convertibility of one value to another does not imply
        equality of those two values. If <code>undefined</code> is used where a boolean value is
        expected, for example, it will convert to <code>false</code>. But this does not mean that
        <code>undefined == false</code>. JavaScript operators and statements expect values of
        various types and perform conversions to those types. The <code>if</code> statement
        converts <code>undefined</code> to <code>false</code>, but the <code>==</code> operator never attempts to
        convert its operands to booleans.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.9.2 Explicit Conversions"><div class="sect2" id="explicitconversions">
        <h2>3.9.2 Explicit Conversions</h2>
        
        <p>Although<a data-type="indexterm" data-primary="type conversions" data-secondary="explicit conversions" id="idm46198579331240"></a> JavaScript performs many type conversions automatically, you may
        sometimes need to perform an explicit conversion, or you may prefer to make the
        conversions explicit to keep your code clearer.</p>
        
        <p>The<a data-type="indexterm" data-primary="Boolean() function" id="idm46198579329288"></a><a data-type="indexterm" data-primary="Number() function" id="idm46198579328552"></a><a data-type="indexterm" data-primary="String() function" id="idm46198579327880"></a> simplest way to perform an explicit type conversion is to use the
        <code>Boolean()</code>, <code>Number()</code>, and <code>String()</code> functions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Number</code><code class="p">(</code><code class="s2">"3"</code><code class="p">)</code>    <code class="c1">// =&gt; 3</code>
        <code class="nb">String</code><code class="p">(</code><code class="kc">false</code><code class="p">)</code>  <code class="c1">// =&gt; "false":  Or use false.toString()</code>
        <code class="nb">Boolean</code><code class="p">([])</code>    <code class="c1">// =&gt; true</code></pre>
        
        <p>Any value other than <code>null</code> or <code>undefined</code> has a <code>toString()</code> method, and
        the result of this method is usually the same as that returned by the
        <code>String()</code> function.</p>
        
        <p>As an aside, note that the <code>Boolean()</code>, <code>Number()</code>, and <code>String()</code>
        functions can also be invoked—with <code>new</code>—as constructor. If you use
        them this way, you’ll get a “wrapper” object that behaves just like a
        primitive boolean, number, or string value. These wrapper objects are a
        historical leftover from the earliest days of JavaScript, and there is
        never really any good reason to use them.</p>
        
        <p>Certain<a data-type="indexterm" data-primary="type conversions" data-secondary="implicit conversions" id="idm46198579314760"></a> JavaScript operators perform implicit type conversions and
        are sometimes used explicitly for the purpose of type conversion. If
        one operand of the <code>+</code> operator is a string, it converts the other one
        to a string. The unary <code>+</code> operator converts its operand to a
        number. And the unary <code>!</code> operator converts its operand to a boolean
        and negates it. These facts lead to the following type conversion
        idioms that you may see in some code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">x</code> <code class="o">+</code> <code class="s2">""</code>   <code class="c1">// =&gt; String(x)</code>
        <code class="o">+</code><code class="nx">x</code>       <code class="c1">// =&gt; Number(x)</code>
        <code class="nx">x</code><code class="o">-</code><code class="mi">0</code>      <code class="c1">// =&gt; Number(x)</code>
        <code class="o">!!</code><code class="nx">x</code>      <code class="c1">// =&gt; Boolean(x): Note double !</code></pre>
        
        <p>Formatting and parsing numbers are common tasks in computer programs, and
        JavaScript has specialized functions and methods that provide more precise
        control over number-to-string and string-to-number conversions.</p>
        
        <p>The<a data-type="indexterm" data-primary="toString() method" id="idm46198579259464"></a> <code>toString()</code> method defined by the Number class accepts an optional
        argument that specifies a radix, or base, for the conversion. If you do not
        specify the argument, the conversion is done in base 10. However, you can also
        convert numbers in other bases (between 2 and 36). For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">17</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">binary</code> <code class="o">=</code> <code class="s2">"0b"</code> <code class="o">+</code> <code class="nx">n</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="mi">2</code><code class="p">);</code>  <code class="c1">// binary == "0b10001"</code>
        <code class="kd">let</code> <code class="nx">octal</code> <code class="o">=</code> <code class="s2">"0o"</code> <code class="o">+</code> <code class="nx">n</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code>   <code class="c1">// octal == "0o21"</code>
        <code class="kd">let</code> <code class="nx">hex</code> <code class="o">=</code> <code class="s2">"0x"</code> <code class="o">+</code> <code class="nx">n</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="mi">16</code><code class="p">);</code>    <code class="c1">// hex == "0x11"</code></pre>
        
        <p>When<a data-type="indexterm" data-primary="type conversions" data-secondary="financial and scientific data" id="idm46198579182312"></a> working with financial or scientific data, you may want to convert numbers
        to strings in ways that give you control over the number of decimal places or
        the number of significant digits in the output, or you may want to control
        whether exponential notation is used. The<a data-type="indexterm" data-primary="toFixed() method" id="idm46198579152200"></a> Number class defines three methods
        for these kinds of number-to-string conversions. <code>toFixed()</code> converts a number
        to a string with a specified number of digits after the decimal point. It never
        uses<a data-type="indexterm" data-primary="toExponential() method" id="idm46198579150936"></a> exponential notation. <span class="keep-together"><code>toExponential()</code></span> converts a number to a string
        using exponential notation, with one digit before the decimal point and a
        specified number of digits after the decimal point (which means that the number
        of significant digits is one larger than the value you specify).
        <code>toPrecision()</code> converts<a data-type="indexterm" data-primary="toPrecision() method" id="idm46198579148600"></a> a number to a string with the number of significant
        digits you specify. It uses exponential notation if the number of significant
        digits is not large enough to display the entire integer portion of the number.
        Note that all three methods round the trailing digits or pad with zeros as
        appropriate. Consider the following examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mf">123456.789</code><code class="p">;</code>
        <code class="nx">n</code><code class="p">.</code><code class="nx">toFixed</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>         <code class="c1">// =&gt; "123457"</code>
        <code class="nx">n</code><code class="p">.</code><code class="nx">toFixed</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>         <code class="c1">// =&gt; "123456.79"</code>
        <code class="nx">n</code><code class="p">.</code><code class="nx">toFixed</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>         <code class="c1">// =&gt; "123456.78900"</code>
        <code class="nx">n</code><code class="p">.</code><code class="nx">toExponential</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>   <code class="c1">// =&gt; "1.2e+5"</code>
        <code class="nx">n</code><code class="p">.</code><code class="nx">toExponential</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>   <code class="c1">// =&gt; "1.235e+5"</code>
        <code class="nx">n</code><code class="p">.</code><code class="nx">toPrecision</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>     <code class="c1">// =&gt; "1.235e+5"</code>
        <code class="nx">n</code><code class="p">.</code><code class="nx">toPrecision</code><code class="p">(</code><code class="mi">7</code><code class="p">)</code>     <code class="c1">// =&gt; "123456.8"</code>
        <code class="nx">n</code><code class="p">.</code><code class="nx">toPrecision</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>    <code class="c1">// =&gt; "123456.7890"</code></pre>
        
        <p>In addition to the number-formatting methods shown here, the
        Intl.NumberFormat class defines a more general, internationalized
        number-formatting method. See <a data-type="xref" href="ch11.html#numberformat">§11.7.1</a> for details.</p>
        
        <p>If<a data-type="indexterm" data-primary="Number() function" id="idm46198579235912"></a> you pass a string to the <code>Number()</code> conversion function, it attempts to
        parse that string as an integer or floating-point literal. That function only
        works for base-10 integers and does not allow trailing characters that are not
        part of the literal. The<a data-type="indexterm" data-primary="parseInt() function" id="idm46198579066776"></a><a data-type="indexterm" data-primary="parseFloat() function" id="idm46198579066072"></a> <code>parseInt()</code> and <code>parseFloat()</code> functions (these are
        global functions, not methods of any class) are more flexible. <code>parseInt()</code>
        parses only integers, while <code>parseFloat()</code> parses both integers and
        floating-point numbers. If a string begins with “0x” or “0X”, <code>parseInt()</code>
        interprets it as a hexadecimal number. Both
        <code>parseInt()</code> and <code>parseFloat()</code> skip leading whitespace, parse as many numeric
        characters as they can, and ignore anything that follows. If the first nonspace
        character is not part of a valid numeric literal, they return <code>NaN</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">parseInt</code><code class="p">(</code><code class="s2">"3 blind mice"</code><code class="p">)</code>     <code class="c1">// =&gt; 3</code>
        <code class="nb">parseFloat</code><code class="p">(</code><code class="s2">" 3.14 meters"</code><code class="p">)</code>   <code class="c1">// =&gt; 3.14</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">"-12.34"</code><code class="p">)</code>           <code class="c1">// =&gt; -12</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">"0xFF"</code><code class="p">)</code>             <code class="c1">// =&gt; 255</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">"0xff"</code><code class="p">)</code>             <code class="c1">// =&gt; 255</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">"-0XFF"</code><code class="p">)</code>            <code class="c1">// =&gt; -255</code>
        <code class="nb">parseFloat</code><code class="p">(</code><code class="s2">".1"</code><code class="p">)</code>             <code class="c1">// =&gt; 0.1</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">"0.1"</code><code class="p">)</code>              <code class="c1">// =&gt; 0</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">".1"</code><code class="p">)</code>               <code class="c1">// =&gt; NaN: integers can't start with "."</code>
        <code class="nb">parseFloat</code><code class="p">(</code><code class="s2">"$72.47"</code><code class="p">)</code>         <code class="c1">// =&gt; NaN: numbers can't start with "$"</code></pre>
        
        <p><code>parseInt()</code> accepts an optional second argument specifying the radix (base) of
        the number to be parsed. Legal values are between 2 and 36. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js" class="less_space pagebreak-before"><code class="nb">parseInt</code><code class="p">(</code><code class="s2">"11"</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>     <code class="c1">// =&gt; 3: (1*2 + 1)</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">"ff"</code><code class="p">,</code> <code class="mi">16</code><code class="p">)</code>    <code class="c1">// =&gt; 255: (15*16 + 15)</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">"zz"</code><code class="p">,</code> <code class="mi">36</code><code class="p">)</code>    <code class="c1">// =&gt; 1295: (35*36 + 35)</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">"077"</code><code class="p">,</code> <code class="mi">8</code><code class="p">)</code>    <code class="c1">// =&gt; 63: (7*8 + 7)</code>
        <code class="nb">parseInt</code><code class="p">(</code><code class="s2">"077"</code><code class="p">,</code> <code class="mi">10</code><code class="p">)</code>   <code class="c1">// =&gt; 77: (7*10 + 7)</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.9.3 Object to Primitive Conversions"><div class="sect2" id="objtoprim">
        <h2>3.9.3 Object to Primitive Conversions</h2>
        
        <p>The<a data-type="indexterm" data-primary="type conversions" data-secondary="object to primitive conversions" data-tertiary="algorithms for" id="idm46198578934824"></a> previous sections have explained how you can explicitly convert
        values of one type to another type and have explained JavaScript’s
        implicit conversions of values from one primitive type to another
        primitive type. This section covers the complicated rules that
        JavaScript uses to convert objects to primitive values. It is long and
        obscure, and if this is your first reading of this chapter, you should
        feel free to skip ahead to <a data-type="xref" href="#variabledeclaration">§3.10</a>.</p>
        
        <p>One reason for the complexity of JavaScript’s object-to-primitive
        conversions is that some types of objects have more than one primitive
        representation. Date objects, for example, can be represented as
        strings or as numeric timestamps. The JavaScript specification defines
        three fundamental algorithms for converting objects to primitive
        values:</p>
        <dl>
        <dt>prefer-string</dt>
        <dd>
        <p>This algorithm returns a primitive value,
          preferring a string value, if a conversion to string is possible.</p>
        </dd>
        <dt>prefer-number</dt>
        <dd>
        <p>This algorithm returns a primitive value,
          preferring a number, if such a conversion is possible.</p>
        </dd>
        <dt>no-preference</dt>
        <dd>
        <p>This algorithm expresses no preference about what
          type of primitive value is desired, and classes can define their own
          conversions. Of the built-in JavaScript types, all except Date
          implement this algorithm as <em>prefer-number</em>. The Date class
          implements this algorithm as <em>prefer-string</em>.</p>
        </dd>
        </dl>
        
        <p>The implementation of these object-to-primitive conversion algorithms is explained at the end of this section. First, however, we explain
        how the algorithms are used in JavaScript.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Object-to-boolean conversions"><div class="sect3" id="idm46198578888968">
        <h3>Object-to-boolean conversions</h3>
        
        <p>Object-to-boolean<a data-type="indexterm" data-primary="type conversions" data-secondary="object to primitive conversions" data-tertiary="object-to-boolean" id="idm46198578887672"></a> conversions are trivial: all objects convert to
        <code>true</code>.  Notice that this conversion does not require the use of the
        object-to-primitive algorithms described, and that it literally
        applies to <em>all</em> objects, including empty arrays and even the wrapper
        object <code>new Boolean(false)</code>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Object-to-string conversions"><div class="sect3" id="idm46198578884568">
        <h3>Object-to-string conversions</h3>
        
        <p>When<a data-type="indexterm" data-primary="type conversions" data-secondary="object to primitive conversions" data-tertiary="object-to-string" id="idm46198578883240"></a> an object needs to be converted to a string, JavaScript first
        converts it to a primitive using the <em>prefer-string</em> algorithm, then converts the resulting primitive value to a string, if necessary,
        following the rules in <a data-type="xref" href="#conversionstable">Table&nbsp;3-2</a>.</p>
        
        <p>This kind of conversion happens, for example, if you pass an object to
        a built-in function that expects a string argument, if you call
        <code>String()</code> as a conversion function, and when you interpolate objects
        into template literals (<a data-type="xref" href="#templateliterals">§3.3.4</a>).</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Object-to-number conversions"><div class="sect3" id="idm46198578878248">
        <h3>Object-to-number conversions</h3>
        
        <p>When<a data-type="indexterm" data-primary="type conversions" data-secondary="object to primitive conversions" data-tertiary="object-to-number" id="idm46198578876952"></a> an object needs to be converted to a number, JavaScript first
        converts it to a primitive value using the <em>prefer-number</em> algorithm, then converts the resulting primitive value to a number, if
        necessary, following the rules in <a data-type="xref" href="#conversionstable">Table&nbsp;3-2</a>.</p>
        
        <p>Built-in JavaScript functions and methods that expect numeric
        arguments convert object arguments to numbers in this way, and most
        (see the exceptions that follow) JavaScript operators that expect
        numeric operands convert objects to numbers in this way as well.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Special case operator conversions"><div class="sect3" id="idm46198578873064">
        <h3>Special case operator conversions</h3>
        
        <p>Operators<a data-type="indexterm" data-primary="type conversions" data-secondary="object to primitive conversions" data-tertiary="special case operator conversions" id="idm46198578871528"></a> are covered in detail in <a data-type="xref" href="ch04.html#expressions">Chapter&nbsp;4</a>. Here, we explain
        the special case operators that do not use the basic object-to-string
        and object-to-number conversions described earlier.</p>
        
        <p>The <code>+</code> operator<a data-type="indexterm" data-primary="+ (plus sign)" data-secondary="type conversions" id="idm46198578868248"></a><a data-type="indexterm" data-primary="plus sign (+)" data-secondary="type conversions" id="idm46198578867240"></a> in JavaScript performs numeric addition and string
        concatenation. If either of its operands is an object, JavaScript
        converts them to primitive values using the <em>no-preference</em> algorithm.
        Once it has two primitive values, it checks their types. If either
        argument is a string, it converts the other to a string and
        concatenates the strings. Otherwise, it converts both arguments to
        numbers and adds them.</p>
        
        <p>The<a data-type="indexterm" data-primary="== (equality operator)" data-secondary="type conversions" id="idm46198578864728"></a><a data-type="indexterm" data-primary="equality operator (==)" data-secondary="type conversions" id="idm46198578863720"></a><a data-type="indexterm" data-primary="!= (non-strict inequality operator)" data-secondary="type conversions" id="idm46198578862776"></a><a data-type="indexterm" data-primary="non-strict inequality operator (!=)" data-secondary="type conversions" id="idm46198578861816"></a> <code>==</code> and <code>!=</code> operators perform equality and inequality testing in
        a loose way that allows type conversions. If one operand is an object and
        the other is a primitive value, these operators convert the object to
        primitive using the <em>no-preference</em> algorithm and then compare the two
        primitive values.</p>
        
        <p>Finally, the<a data-type="indexterm" data-primary="< (less than operator)" data-secondary="type conversions" id="idm46198578858920"></a><a data-type="indexterm" data-primary="less than operator (<)" data-secondary="type conversions" id="idm46198578839272"></a><a data-type="indexterm" data-primary="<= (less than or equal to operator)" data-secondary="type conversions" id="idm46198578838328"></a><a data-type="indexterm" data-primary="less than or equal to operator (<=)" data-secondary="type conversions" id="idm46198578837416"></a><a data-type="indexterm" data-primary="> (greater than operator)" data-secondary="type conversions" id="idm46198578836504"></a><a data-type="indexterm" data-primary="greater than operator (>)" data-secondary="type conversions" id="idm46198578835544"></a><a data-type="indexterm" data-primary=">= (greater than or equal to operator)" data-secondary="type conversions" id="idm46198578834584"></a><a data-type="indexterm" data-primary="greater than or equal to operator (>=)" data-secondary="type conversions" id="idm46198578833624"></a> relational operators <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, and <code>&gt;=</code> compare the
        order of their operands and can be used to compare both numbers and
        strings. If either operand is an object, it is converted to a
        primitive value using the <em>prefer-number</em> algorithm. Note, however,
        that unlike the object-to-number conversion, the primitive values
        returned by the <em>prefer-number</em> conversion are not then converted to
        numbers.</p>
        
        <p>Note that the numeric representation of Date objects is meaningfully
        comparable with <code>&lt;</code> and <code>&gt;</code>, but the string representation is not. For
        Date objects, the <em>no-preference</em> algorithm converts to a string, so
        the fact that JavaScript uses the <em>prefer-number</em> <span class="keep-together">algorithm</span> for these
        operators means that we can use them to compare the order of two Date
        objects.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="The toString() and valueOf() methods"><div class="sect3" id="idm46198578826680">
        <h3>The toString() and valueOf() methods</h3>
        
        <p>All<a data-type="indexterm" data-primary="type conversions" data-secondary="object to primitive conversions" data-tertiary="toString() and valueOf() methods" id="idm46198578824920"></a><a data-type="indexterm" data-primary="toString() method" id="idm46198578823704"></a><a data-type="indexterm" data-primary="valueOf() method" id="idm46198578823032"></a> objects inherit two conversion methods that are used by
        object-to-primitive conversions, and before we can explain the
        <em>prefer-string</em>, <em>prefer-number</em>, and <em>no-preference</em> conversion
        algorithms, we have to explain these two methods.</p>
        
        <p>The first method is <code>toString()</code>, and its job is to return a string
        representation of the object. The default <code>toString()</code> method does not
        return a very interesting value (though we’ll find it useful in
        <a data-type="xref" href="ch14.html#tostringtag">§14.4.3</a>):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">}).</code><code class="nx">toString</code><code class="p">()</code>    <code class="c1">// =&gt; "[object Object]"</code></pre>
        
        <p>Many classes define more specific versions of the <code>toString()</code>
        method. The <code>toString()</code> method of the Array class, for example,
        converts each array element to a string and joins the resulting
        strings together with commas in between. The <code>toString()</code> method of
        the Function class converts user-defined functions to strings
        of JavaScript source code. The Date class defines a <code>toString()</code>
        method that returns a human-readable (and JavaScript-parsable) date
        and time string. The RegExp class defines a <code>toString()</code> method that
        converts RegExp objects to a string that looks like a RegExp literal:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">].</code><code class="nx">toString</code><code class="p">()</code>                  <code class="c1">// =&gt; "1,2,3"</code>
        <code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code> <code class="p">}).</code><code class="nx">toString</code><code class="p">()</code>  <code class="c1">// =&gt; "function(x) { f(x); }"</code>
        <code class="sr">/\d+/g</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>                   <code class="c1">// =&gt; "/\\d+/g"</code>
        <code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="mi">2020</code><code class="p">,</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">);</code>
        <code class="nx">d</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>  <code class="c1">// =&gt; "Wed Jan 01 2020 00:00:00 GMT-0800 (Pacific Standard Time)"</code></pre>
        
        <p>The other object conversion function is called <code>valueOf()</code>. The job of
        this method is less well defined: it is supposed to convert an object
        to a primitive value that represents the object, if any such primitive
        value exists. Objects are compound values, and most objects cannot
        really be represented by a single primitive value, so the default
        <code>valueOf()</code> method simply returns the object itself rather than
        returning a primitive. Wrapper classes such as String, Number, and
        Boolean define <code>valueOf()</code> methods that simply return the wrapped
        primitive value. Arrays, functions, and regular expressions simply
        inherit the default method. Calling <code>valueOf()</code> for instances of these
        types simply returns the object itself. The Date class defines a
        <code>valueOf()</code> method that returns the date in its internal
        representation: the number of milliseconds since January 1, 1970:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">(</code><code class="mi">2010</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>   <code class="c1">// January 1, 2010, (Pacific time)</code>
        <code class="nx">d</code><code class="p">.</code><code class="nx">valueOf</code><code class="p">()</code>                     <code class="c1">// =&gt; 1262332800000</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Object-to-primitive conversion algorithms"><div class="sect3" id="toprimitivealgorithms">
        <h3>Object-to-primitive conversion algorithms</h3>
        
        <p>With<a data-type="indexterm" data-primary="type conversions" data-secondary="object to primitive conversions" data-tertiary="algorithms for" id="idm46198578702008"></a> the <code>toString()</code> and <code>valueOf()</code> methods explained, we can now
        explain approximately how the three object-to-primitive algorithms
        work (the complete details are deferred until <a data-type="xref" href="ch14.html#toprimitive">§14.4.7</a>):</p>
        
        <ul>
        <li>
        <p>The <em>prefer-string</em> algorithm first tries the <code>toString()</code>
        method. If the method is defined and returns a primitive value, then
        JavaScript uses that primitive value (even if it is not a
        string!). If <code>toString()</code> does not exist or if it returns an object,
        then JavaScript tries the <code>valueOf()</code> method. If that method exists
        and returns a primitive value, then JavaScript uses that
        value. Otherwise, the conversion fails with a TypeError.</p>
        </li>
        <li>
        <p>The <em>prefer-number</em> algorithm works like the <em>prefer-string</em>
        algorithm, except that it tries <code>valueOf()</code> first and <code>toString()</code>
        second.</p>
        </li>
        <li>
        <p>The <em>no-preference</em> algorithm depends on the class of the object
        being converted. If the object is a Date object, then JavaScript
        uses the <em>prefer-string</em> algorithm. For any other object, JavaScript
        uses the <em>prefer-number</em> algorithm.</p>
        </li>
        </ul>
        
        <p>The rules described here are true for all built-in JavaScript types
        and are the default rules for any classes you define
        yourself. <a data-type="xref" href="ch14.html#toprimitive">§14.4.7</a> explains how you can define your own
        object-to-primitive conversion algorithms for the classes you define.</p>
        
        <p>Before we leave this topic, it is worth noting that the details of the
        <em>prefer-number</em> conversion explain why empty arrays convert to the
        number 0 and single-element arrays can also convert to numbers:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Number</code><code class="p">([])</code>    <code class="c1">// =&gt; 0: this is unexpected!</code>
        <code class="nb">Number</code><code class="p">([</code><code class="mi">99</code><code class="p">])</code>  <code class="c1">// =&gt; 99: really?</code></pre>
        
        <p>The object-to-number conversion first converts the object to a
        primitive using the <em>prefer-number</em> algorithm, then converts the
        resulting primitive value to a number. The <em>prefer-number</em> algorithm
        tries <code>valueOf()</code> first and then falls back on <code>toString()</code>. But the
        Array class inherits the default <code>valueOf()</code> method, which does not
        return a primitive value. So when we try to convert an array to a
        number, we end up invoking the <code>toString()</code> method of the array. Empty
        arrays convert to the empty string. And the empty string converts to
        the number 0. An array with a single element converts to the same
        string that that one element does. If an array contains a single
        number, that number is converted to a string, and then back to a
        number.<a data-type="indexterm" data-primary="" data-startref="Tconver03" id="idm46198578678360"></a></p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="3.10 Variable Declaration and Assignment"><div class="sect1" id="variabledeclaration">
        <h1>3.10 Variable Declaration and Assignment</h1>
        
        <p>One<a data-type="indexterm" data-primary="identifiers" data-secondary="purpose of" id="idm46198578626776"></a> of the most fundamental techniques of computer programming is the
        use of names—or <em>identifiers</em>—to represent values. Binding a name to a
        value gives us a way to refer to that value and use it in the programs
        we write. When we do this, we typically say that we are assigning a
        value to a <em>variable</em>. The<a data-type="indexterm" data-primary="variables" data-secondary="definition of term" id="idm46198578624632"></a> term “variable” implies that new values can
        be assigned: that the value associated with the variable may vary as our
        program runs. If<a data-type="indexterm" data-primary="constants" data-secondary="definition of term" id="idm46198578623336"></a> we permanently assign a value to a name, then we call
        that name a <em>constant</em> instead of a variable.</p>
        
        <p>Before you can use a variable or constant in a JavaScript program,
        you must <em>declare</em> it. In<a data-type="indexterm" data-primary="ES6" data-secondary="variable declaration in" id="idm46198578620920"></a> ES6 and later, this is done with the
        <code>let</code> and <code>const</code> keywords, which we explain next. Prior to
        ES6, variables were declared with <code>var</code>, which is more idiosyncratic and
        is explained later on in this section.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.10.1 Declarations with let and const"><div class="sect2" id="idm46198578618536">
        <h2>3.10.1 Declarations with let and const</h2>
        
        <p>In<a data-type="indexterm" data-primary="let keyword" id="idm46198578616520"></a><a data-type="indexterm" data-primary="keywords" data-secondary="let keyword" id="idm46198578615784"></a><a data-type="indexterm" data-primary="variables" data-secondary="declaration and assignment" data-tertiary="declarations with let and const" id="Vdalet03"></a> modern JavaScript (ES6 and later), variables are declared with the
        <code>let</code> keyword, like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">i</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">sum</code><code class="p">;</code></pre>
        
        <p>You can also declare multiple variables in a single <code>let</code> statement:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">sum</code><code class="p">;</code></pre>
        
        <p>It is a good programming practice to assign an initial value to your
        variables when you declare them, when this is possible:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">message</code> <code class="o">=</code> <code class="s2">"hello"</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">j</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">k</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;</code> <code class="c1">// Initializers can use previously declared variables</code></pre>
        
        <p>If you don’t specify an initial value for a variable with the <code>let</code>
        statement, the variable is declared, but its value is <code>undefined</code>
        until your code assigns a value to it.</p>
        
        <p>To<a data-type="indexterm" data-primary="const keyword" id="idm46198578510568"></a><a data-type="indexterm" data-primary="keywords" data-secondary="const keyword" id="idm46198578509832"></a><a data-type="indexterm" data-primary="constants" data-secondary="declaring" id="idm46198578508888"></a> declare a constant instead of a variable, use <code>const</code> instead of
        <code>let</code>. <code>const</code> works just like <code>let</code> except that you must initialize the
        constant when you declare it:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">H0</code> <code class="o">=</code> <code class="mi">74</code><code class="p">;</code>         <code class="c1">// Hubble constant (km/s/Mpc)</code>
        <code class="kr">const</code> <code class="nx">C</code> <code class="o">=</code> <code class="mf">299792.458</code><code class="p">;</code>  <code class="c1">// Speed of light in a vacuum (km/s)</code>
        <code class="kr">const</code> <code class="nx">AU</code> <code class="o">=</code> <code class="mf">1.496E8</code><code class="p">;</code>    <code class="c1">// Astronomical Unit: distance to the sun (km)</code></pre>
        
        <p>As the name implies, constants cannot have their values changed, and
        any attempt to do so causes a TypeError to be thrown.</p>
        
        <p>It is a common (but not universal) convention to declare constants
        using names with all capital letters such as <code>H0</code> or <code>HTTP_NOT_FOUND</code>
        as a way to distinguish them from variables.</p>
        <div data-type="note" epub:type="note"><h1>When to Use const</h1>
        <p>There are two schools of thought about the use of the <code>const</code>
        keyword. One approach is to use <code>const</code> only for values that are
        fundamentally unchanging, like the physical constants shown, or
        program version numbers, or byte sequences used to identify file types,
        for example.  Another approach recognizes that many of the so-called
        variables in our program don’t actually ever change as our program
        runs. In this approach, we declare everything with <code>const</code>, and then if
        we find that we do actually want to allow the value to vary, we switch
        the declaration to <code>let</code>. This may help prevent bugs by ruling out
        accidental changes to variables that we did not intend.</p>
        
        <p>In one approach, we use <code>const</code> only for values that <em>must</em> <em>not</em>
        change. In the other, we use <code>const</code> for any value that does not happen
        to change. I prefer the former approach in my own code.</p>
        </div>
        
        <p>In <a data-type="xref" href="ch05.html#statements">Chapter&nbsp;5</a>, we’ll learn about the <code>for</code>, <code>for/in</code>, and <code>for/of</code>
        loop statements in JavaScript. Each of these loops includes a loop
        variable that gets a new value assigned to it on each iteration of the
        loop. JavaScript allows us to declare the loop variable as part of the
        loop syntax itself, and this is another common way to use <code>let</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">len</code> <code class="o">=</code> <code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">len</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">data</code><code class="p">[</code><code class="nx">i</code><code class="p">]);</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">datum</code> <code class="k">of</code> <code class="nx">data</code><code class="p">)</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">datum</code><code class="p">);</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">in</code> <code class="nx">object</code><code class="p">)</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">property</code><code class="p">);</code></pre>
        
        <p>It may seem surprising, but you can also use <code>const</code> to declare the loop
        “variables” for <code>for/in</code> and <code>for/of</code> loops, as long as the body of the
        loop does not reassign a new value. In this case, the <code>const</code>
        declaration is just saying that the value is constant for the duration
        of one loop iteration:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kr">const</code> <code class="nx">datum</code> <code class="k">of</code> <code class="nx">data</code><code class="p">)</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">datum</code><code class="p">);</code>
        <code class="k">for</code><code class="p">(</code><code class="kr">const</code> <code class="nx">property</code> <code class="k">in</code> <code class="nx">object</code><code class="p">)</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">property</code><code class="p">);</code></pre>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Variable and constant scope"><div class="sect3" id="idm46198572204904">
        <h3>Variable and constant scope</h3>
        
        <p>The <em>scope</em> of<a data-type="indexterm" data-primary="variables" data-secondary="scope of" id="idm46198578335240"></a><a data-type="indexterm" data-primary="block scoping" id="idm46198578334232"></a> a variable is the region of your program source code in
        which it is defined. Variables and constants declared with <code>let</code> and
        <code>const</code> are <em>block scoped</em>. This means that they are only defined
        within the block of code in which the <code>let</code> or <code>const</code> statement
        appears. JavaScript class and function definitions are blocks, and so
        are the bodies of <code>if/else</code> statements, <code>while</code> loops, <code>for</code> loops, and
        so on. Roughly speaking, if a variable or constant is declared within a
        set of curly braces, then those curly braces delimit the region of code in
        which the variable or constant is defined (though of course it is not
        legal to reference a variable or constant from lines of code that
        execute before the <code>let</code> or <code>const</code> statement that declares the
        variable). Variables and constants declared as part of a <code>for</code>, <code>for/in</code>,
        or <code>for/of</code> loop have the loop body as their scope, even though they
        technically appear outside of the curly braces.</p>
        
        <p>When<a data-type="indexterm" data-primary="global variables" id="idm46198578326744"></a> a declaration appears at the top level, outside of any code blocks,
        we say it is a <em>global</em> variable or constant and has global scope. In
        Node and in client-side JavaScript modules (see <a data-type="xref" href="ch10.html#modules">Chapter&nbsp;10</a>), the scope
        of a global variable is the file that it is defined in. In traditional
        client-side JavaScript, however, the scope of a global variable is the
        HTML document in which it is defined. That is: if one <code>&lt;script&gt;</code>
        declares a global variable or constant, that variable or constant is
        defined in all of the <code>&lt;script&gt;</code> elements in that document (or at least
        all of the scripts that execute after the <code>let</code> or <code>const</code> statement
        executes).</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Repeated declarations"><div class="sect3" id="idm46198578322424">
        <h3>Repeated declarations</h3>
        
        <p>It is a syntax error to use the same name with more than one <code>let</code> or
        <code>const</code> declaration in the same scope. It is legal (though a practice
        best avoided) to declare a new variable with the same name in a nested
        scope:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>        <code class="c1">// Declare x as a global constant</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>      <code class="c1">// Inside a block x can refer to a different value</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code> <code class="c1">// Prints 2</code>
        <code class="p">}</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>     <code class="c1">// Prints 1: we're back in the global scope now</code>
        <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>          <code class="c1">// ERROR! Syntax error trying to re-declare x</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Declarations and types"><div class="sect3" id="idm46198578170232">
        <h3>Declarations and types</h3>
        
        <p>If you’re used to statically typed languages such as C or Java, you
        may think that the primary purpose of variable declarations is to
        specify the type of values that may be assigned to a variable. But, as
        you have seen, there is no type associated with <span class="keep-together">JavaScript’s</span> variable
        declarations.<sup><a data-type="noteref" id="idm46198578212696-marker" href="ch03.html#idm46198578212696">2</a></sup> A
        JavaScript variable can hold a value of any type. For example, it is
        perfectly legal (but generally poor programming style) in JavaScript
        to assign a number to a variable and then later assign a string to
        that<a data-type="indexterm" data-primary="" data-startref="Vdalet03" id="idm46198578210536"></a> variable:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>
        <code class="nx">i</code> <code class="o">=</code> <code class="s2">"ten"</code><code class="p">;</code></pre>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.10.2 Variable Declarations with var"><div class="sect2" id="idm46198578617592">
        <h2>3.10.2 Variable Declarations with var</h2>
        
        <p>In<a data-type="indexterm" data-primary="variables" data-secondary="declaration and assignment" data-tertiary="declarations with var" id="idm46198578200664"></a><a data-type="indexterm" data-primary="var keyword" id="idm46198578199448"></a><a data-type="indexterm" data-primary="keywords" data-secondary="var keyword" id="idm46198578198776"></a> versions of JavaScript before ES6, the only way to declare a variable
        is with the <code>var</code> keyword, and there is no way to declare constants. The
        syntax of <code>var</code> is just like the syntax of <code>let</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">var</code> <code class="nx">x</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[],</code> <code class="nx">count</code> <code class="o">=</code> <code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">count</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">data</code><code class="p">[</code><code class="nx">i</code><code class="p">]);</code></pre>
        
        <p>Although <code>var</code> and <code>let</code> have the same syntax, there are important
        differences in the way they work:</p>
        
        <ul>
        <li>
        <p>Variables declared with <code>var</code> do not have block scope. Instead, they
        are scoped to the body of the containing function no matter how deeply
        nested they are inside that function.</p>
        </li>
        <li>
        <p>If you use <code>var</code> outside of a function body, it declares a global
        variable. But global variables declared with <code>var</code> differ from
        globals declared with <code>let</code> in an important way. Globals declared
        with <code>var</code> are implemented as properties of the global object
        (<a data-type="xref" href="#global">§3.7</a>). The global object can be referenced as
        <code>globalThis</code>. So if you write <code>var x = 2;</code> outside of a function, it
        is like you wrote <code>globalThis.x = 2;</code>. Note however, that the analogy is not perfect: the properties created with global <code>var</code> declarations
        cannot be deleted with the <code>delete</code> operator
        (<a data-type="xref" href="ch04.html#deleteoperator">§4.13.4</a>). Global variables and constants declared with
        <code>let</code> and <code>const</code> are not properties of the global object.</p>
        </li>
        <li>
        <p>Unlike variables declared with <code>let</code>, it is legal to declare the same
        variable multiple times with <code>var</code>. And because <code>var</code> variables have
        function scope instead of block scope, it is actually common to do
        this kind of redeclaration.  The variable <code>i</code> is frequently used for
        integer values, and especially as the index variable of <code>for</code>
        loops. In a function with multiple <code>for</code> loops, it is typical for each
        one to begin <code>for(var i = 0; ...</code>. Because <code>var</code> does not scope these
        variables to the loop body, each of these loops is (harmlessly)
        re-declaring and re-initializing the same variable.</p>
        </li>
        <li>
        <p>One<a data-type="indexterm" data-primary="hoisting" id="idm46198578081720"></a><a data-type="indexterm" data-primary="variables" data-secondary="hoisted" id="idm46198578080632"></a> of the most unusual features of <code>var</code> declarations is known as
        <em>hoisting</em>. When a variable is declared with <code>var</code>, the declaration is
        lifted up (or “hoisted”) to the top of the enclosing function. The
        initialization of the variable remains where you wrote it, but the
        definition of the variable moves to the top of the function. So
        variables declared with <code>var</code> can be used, without error, anywhere in
        the enclosing function. If the initialization code has not run yet,
        then the value of the variable may be <code>undefined</code>, but you won’t get an
        error if you use the variable before it is initialized. (This can be a
        source of bugs and is one of the important misfeatures that <code>let</code>
        corrects: if you declare a variable with <code>let</code> but attempt to use it
        before the <code>let</code> statement runs, you will get an actual error instead
        of just seeing an <code>undefined</code> value.)</p>
        </li>
        </ul>
        <div data-type="note" epub:type="note"><h1>Using Undeclared Variables</h1>
        <p>In<a data-type="indexterm" data-primary="undeclared variables" id="idm46198578073624"></a><a data-type="indexterm" data-primary="variables" data-secondary="declaration and assignment" data-tertiary="undeclared variables" id="idm46198578072888"></a><a data-type="indexterm" data-primary="strict mode" data-secondary="undeclared variables and" id="idm46198578071656"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="undeclared variables and" id="idm46198578070696"></a><a data-type="indexterm" data-primary="use strict mode" data-secondary="and global variables" id="idm46198578069736"></a> strict mode (<a data-type="xref" href="ch05.html#strictmode">§5.6.3</a>), if you attempt to use an undeclared
        variable, you’ll get a reference error when you run your code. Outside
        of strict mode, however, if you assign a value to a name that has not
        been declared with <code>let</code>, <code>const</code>, or <code>var</code>, you’ll end up creating a new
        global variable. It will be a global no matter now deeply nested within
        functions and blocks your code is, which is almost certainly not what
        you want, is bug-prone, and is one of the best reasons for using strict
        mode!</p>
        
        <p>Global variables created in this accidental way are like global
        variables declared with <code>var</code>: they define properties of the global
        object. But unlike the properties defined by proper <code>var</code>
        declarations, these properties <em>can</em> be deleted with the <code>delete</code>
        operator (<a data-type="xref" href="ch04.html#deleteoperator">§4.13.4</a>).</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="3.10.3 Destructuring Assignment"><div class="sect2" id="destructuring-assignment">
        <h2>3.10.3 Destructuring Assignment</h2>
        
        <p>ES6<a data-type="indexterm" data-primary="destructuring assignment" id="deassign03"></a><a data-type="indexterm" data-primary="variables" data-secondary="declaration and assignment" data-tertiary="destructuring assignment" id="Vdadestrut03"></a> implements a kind of compound declaration and assignment
        syntax known as <em>destructuring assignment</em>. In a destructuring
        assignment, the value on the righthand side of the equals sign is an
        array or object (a “structured” value), and the lefthand side
        specifies one or more variable names using a syntax that mimics array
        and object literal syntax. When a destructuring assignment occurs, one
        or more values are extracted (“destructured”) from the value on the
        right and stored into the variables named on the left. Destructuring
        assignment is perhaps most commonly used to initialize variables as part
        of a <code>const</code>, <code>let</code>, or <code>var</code> declaration statement, but it can also be
        done in regular assignment expressions (with variables that have already
        been declared). And, as we’ll see in <a data-type="xref" href="ch08.html#destructuring-for-functions">§8.3.5</a>,
        destructuring can also be used when defining the parameters to a
        function.</p>
        
        <p>Here are simple destructuring assignments using arrays of values:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">];</code>  <code class="c1">// Same as let x=1, y=2</code>
        <code class="p">[</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">x</code><code class="o">+</code><code class="mi">1</code><code class="p">,</code><code class="nx">y</code><code class="o">+</code><code class="mi">1</code><code class="p">];</code>  <code class="c1">// Same as x = x + 1, y = y + 1</code>
        <code class="p">[</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">y</code><code class="p">,</code><code class="nx">x</code><code class="p">];</code>      <code class="c1">// Swap the value of the two variables</code>
        <code class="p">[</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">]</code>               <code class="c1">// =&gt; [3,2]: the incremented and swapped values</code></pre>
        
        <p>Notice how destructuring assignment makes it easy to work with functions that
        return arrays of values:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Convert [x,y] coordinates to [r,theta] polar coordinates</code>
        <code class="kd">function</code> <code class="nx">toPolar</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">[</code><code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="o">+</code><code class="nx">y</code><code class="o">*</code><code class="nx">y</code><code class="p">),</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">atan2</code><code class="p">(</code><code class="nx">y</code><code class="p">,</code><code class="nx">x</code><code class="p">)];</code>
        <code class="p">}</code>
        
        <code class="c1">// Convert polar to Cartesian coordinates</code>
        <code class="kd">function</code> <code class="nx">toCartesian</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code> <code class="nx">theta</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">[</code><code class="nx">r</code><code class="o">*</code><code class="nb">Math</code><code class="p">.</code><code class="nx">cos</code><code class="p">(</code><code class="nx">theta</code><code class="p">),</code> <code class="nx">r</code><code class="o">*</code><code class="nb">Math</code><code class="p">.</code><code class="nx">sin</code><code class="p">(</code><code class="nx">theta</code><code class="p">)];</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="p">[</code><code class="nx">r</code><code class="p">,</code><code class="nx">theta</code><code class="p">]</code> <code class="o">=</code> <code class="nx">toPolar</code><code class="p">(</code><code class="mf">1.0</code><code class="p">,</code> <code class="mf">1.0</code><code class="p">);</code>  <code class="c1">// r == Math.sqrt(2); theta == Math.PI/4</code>
        <code class="kd">let</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="nx">toCartesian</code><code class="p">(</code><code class="nx">r</code><code class="p">,</code><code class="nx">theta</code><code class="p">);</code>   <code class="c1">// [x, y] == [1.0, 1,0]</code></pre>
        
        <p>We saw that variables and constants can be declared as part of
        JavaScript’s various <code>for</code> loops. It is possible to use variable
        destructuring in this context as well. Here is a code that loops over
        the name/value pairs of all properties of an object and uses
        destructuring assignment to convert those pairs from two-element arrays
        into individual variables:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code> <code class="p">};</code> <code class="c1">// The object we'll loop over</code>
        <code class="k">for</code><code class="p">(</code><code class="kr">const</code> <code class="p">[</code><code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">]</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">entries</code><code class="p">(</code><code class="nx">o</code><code class="p">))</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code> <code class="c1">// Prints "x 1" and "y 2"</code>
        <code class="p">}</code></pre>
        
        <p>The number of variables on the left of a destructuring assignment does
        not have to match the number of array elements on the right. Extra
        variables on the left are set to <code>undefined</code>, and extra values on the
        right are ignored. The list of variables on the left can include extra
        commas to skip certain values on the right:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">];</code>     <code class="c1">// x == 1; y == undefined</code>
        <code class="p">[</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>     <code class="c1">// x == 1; y == 2</code>
        <code class="p">[,</code><code class="nx">x</code><code class="p">,,</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">];</code> <code class="c1">// x == 2; y == 4</code></pre>
        
        <p>If you want to collect all unused or remaining values into a single
        variable when destructuring an array, use three dots (<code>...</code>) before the
        last variable name on the left-hand side:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code> <code class="p">...</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">];</code>  <code class="c1">// y == [2,3,4]</code></pre>
        
        <p>We’ll see three dots used this way again in <a data-type="xref" href="ch08.html#restparameters">§8.3.2</a>, where
        they are used to indicate that all remaining function arguments should
        be collected into a single array.</p>
        
        <p>Destructuring assignment can be used with nested arrays. In this case,
        the lefthand side of the assignment should look like a nested array
        literal:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="p">[</code><code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">]]</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code><code class="mf">2.5</code><code class="p">],</code> <code class="mi">3</code><code class="p">];</code> <code class="c1">// a == 1; b == 2; c == 2.5</code></pre>
        
        <p>A powerful feature of array destructuring is that it does not actually
        require an array! You can use any <em>iterable</em> object (<a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>) on
        the righthand side of the assignment; any object that can be used with
        a <code>for/of</code> loop (<a data-type="xref" href="ch05.html#forofloop">§5.4.4</a>) can also be destructured:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="p">[</code><code class="nx">first</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"Hello"</code><code class="p">;</code> <code class="c1">// first == "H"; rest == ["e","l","l","o"]</code></pre>
        
        <p>Destructuring assignment can also be performed when the righthand side is an
        object value. In this case, the lefthand side of the assignment looks
        something like an object literal: a comma-separated list of variable
        names within curly braces:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">transparent</code> <code class="o">=</code> <code class="p">{</code><code class="nx">r</code><code class="o">:</code> <code class="mf">0.0</code><code class="p">,</code> <code class="nx">g</code><code class="o">:</code> <code class="mf">0.0</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="mf">0.0</code><code class="p">,</code> <code class="nx">a</code><code class="o">:</code> <code class="mf">1.0</code><code class="p">};</code> <code class="c1">// A RGBA color</code>
        <code class="kd">let</code> <code class="p">{</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">}</code> <code class="o">=</code> <code class="nx">transparent</code><code class="p">;</code>  <code class="c1">// r == 0.0; g == 0.0; b == 0.0</code></pre>
        
        <p>The next example copies global functions of the <code>Math</code> object into variables,
        which might simplify code that does a lot of trigonometry:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Same as const sin=Math.sin, cos=Math.cos, tan=Math.tan</code>
        <code class="kr">const</code> <code class="p">{</code><code class="nx">sin</code><code class="p">,</code> <code class="nx">cos</code><code class="p">,</code> <code class="nx">tan</code><code class="p">}</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">;</code></pre>
        
        <p>Notice in the code here that the <code>Math</code> object has many properties
        other than the three that are destructured into individual
        variables. Those that are not named are simply ignored. If the lefthand
        side of this assignment had included a variable whose name was not
        a property of <code>Math</code>, that variable would simply be assigned <span class="keep-together"><code>undefined</code>.</span></p>
        
        <p>In each of these object destructuring examples, we have chosen
        variable names that match the property names of the object we’re
        destructuring. This keeps the syntax simple and easy to understand, but
        it is not required. Each of the identifiers on the lefthand side of an
        object destructuring assignment can also be a colon-separated pair of
        identifiers, where the first is the name of the property whose value is
        to be assigned and the second is the name of the variable to assign it
        to:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Same as const cosine = Math.cos, tangent = Math.tan;</code>
        <code class="kr">const</code> <code class="p">{</code> <code class="nx">cos</code><code class="o">:</code> <code class="nx">cosine</code><code class="p">,</code> <code class="nx">tan</code><code class="o">:</code> <code class="nx">tangent</code> <code class="p">}</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">;</code></pre>
        
        <p>I find that object destructuring syntax becomes too complicated to be
        useful when the variable names and property names are not the same, and
        I tend to avoid the shorthand in this case. If you choose to use it,
        remember that property names are always on the left of the colon, in
        both object literals and on the left of an object destructuring
        assignment.</p>
        
        <p>Destructuring assignment becomes even more complicated when it is used
        with nested objects, or arrays of objects, or objects of arrays, but it
        is legal:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">points</code> <code class="o">=</code> <code class="p">[{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">4</code><code class="p">}];</code>     <code class="c1">// An array of two point objects</code>
        <code class="kd">let</code> <code class="p">[{</code><code class="nx">x</code><code class="o">:</code> <code class="nx">x1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y1</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="nx">x2</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y2</code><code class="p">}]</code> <code class="o">=</code> <code class="nx">points</code><code class="p">;</code> <code class="c1">// destructured into 4 variables.</code>
        <code class="p">(</code><code class="nx">x1</code> <code class="o">===</code> <code class="mi">1</code> <code class="o">&amp;&amp;</code> <code class="nx">y1</code> <code class="o">===</code> <code class="mi">2</code> <code class="o">&amp;&amp;</code> <code class="nx">x2</code> <code class="o">===</code> <code class="mi">3</code> <code class="o">&amp;&amp;</code> <code class="nx">y2</code> <code class="o">===</code> <code class="mi">4</code><code class="p">)</code> <code class="c1">// =&gt; true</code></pre>
        
        <p>Or, instead of destructuring an array of objects, we could destructure an
        object of arrays:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">points</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">p1</code><code class="o">:</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">],</code> <code class="nx">p2</code><code class="o">:</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">]</code> <code class="p">};</code>         <code class="c1">// An object with 2 array props</code>
        <code class="kd">let</code> <code class="p">{</code> <code class="nx">p1</code><code class="o">:</code> <code class="p">[</code><code class="nx">x1</code><code class="p">,</code> <code class="nx">y1</code><code class="p">],</code> <code class="nx">p2</code><code class="o">:</code> <code class="p">[</code><code class="nx">x2</code><code class="p">,</code> <code class="nx">y2</code><code class="p">]</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">points</code><code class="p">;</code>   <code class="c1">// destructured into 4 vars</code>
        <code class="p">(</code><code class="nx">x1</code> <code class="o">===</code> <code class="mi">1</code> <code class="o">&amp;&amp;</code> <code class="nx">y1</code> <code class="o">===</code> <code class="mi">2</code> <code class="o">&amp;&amp;</code> <code class="nx">x2</code> <code class="o">===</code> <code class="mi">3</code> <code class="o">&amp;&amp;</code> <code class="nx">y2</code> <code class="o">===</code> <code class="mi">4</code><code class="p">)</code> <code class="c1">// =&gt; true</code></pre>
        
        <p>Complex destructuring syntax like this can be hard to write and hard to
        read, and you may be better off just writing out your assignments
        explicitly with traditional code like <code>let x1 = points.p1[0];</code>.</p>
        <aside data-type="sidebar" epub:type="sidebar" class="less_space pagebreak-before"><div class="sidebar" id="idm46198577291208">
        <h5>Understanding Complex Destructuring</h5>
        <p>If you find yourself working with code that uses complex destructuring
        assignments, there is a useful regularity that can help you make
        sense of the complex cases. Think first about a regular (single-value)
        assignment. After the assignment is done, you can take the variable
        name from the lefthand side of the assignment and use it as an
        expression in your code, where it will evaluate to whatever value you
        assigned it. The same thing is true for destructuring assignment. The
        lefthand side of a destructuring assignment looks like an array
        literal or an object literal (<a data-type="xref" href="ch06.html#objectliterals">§6.2.1</a> and
        <a data-type="xref" href="ch06.html#extended-object-literal-syntax">§6.10</a>). After the assignment has been
        done, the lefthand side will actually work as a valid array literal
        or object literal elsewhere in your code. You can check that you’ve
        written a destructuring assignment correctly by trying to use the
        lefthand side on the righthand side of another<a data-type="indexterm" data-primary="" data-startref="Vdadestrut03" id="idm46198577247736"></a><a data-type="indexterm" data-primary="" data-startref="deassign03" id="idm46198577246792"></a> assignment
        expression:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Start with a data structure and a complex destructuring</code>
        <code class="kd">let</code> <code class="nx">points</code> <code class="o">=</code> <code class="p">[{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">4</code><code class="p">}];</code>
        <code class="kd">let</code> <code class="p">[{</code><code class="nx">x</code><code class="o">:</code> <code class="nx">x1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y1</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="nx">x2</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y2</code><code class="p">}]</code> <code class="o">=</code> <code class="nx">points</code><code class="p">;</code>
        
        <code class="c1">// Check your destructuring syntax by flipping the assignment around</code>
        <code class="kd">let</code> <code class="nx">points2</code> <code class="o">=</code> <code class="p">[{</code><code class="nx">x</code><code class="o">:</code> <code class="nx">x1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y1</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="nx">x2</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y2</code><code class="p">}];</code> <code class="c1">// points2 == points</code></pre>
        </div></aside>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="3.11 Summary"><div class="sect1" id="idm46198578061688">
        <h1>3.11 Summary</h1>
        
        <p>Some key points to remember about this chapter:</p>
        
        <ul>
        <li>
        <p>How to write and manipulate numbers and strings of text in JavaScript.</p>
        </li>
        <li>
        <p>How to work with JavaScript’s other primitive types: booleans,
        Symbols, <code>null</code>, and <code>undefined</code>.</p>
        </li>
        <li>
        <p>The differences between immutable primitive types and mutable
        reference types.</p>
        </li>
        <li>
        <p>How JavaScript converts values implicitly from one type to another and
        how you can do so explicitly in your programs.</p>
        </li>
        <li>
        <p>How to declare and initialize constants and variables (including with
        destructuring assignment) and the lexical scope of the variables and
        constants you declare.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        <div data-type="footnotes"><p data-type="footnote" id="idm46198571886872"><sup><a href="ch03.html#idm46198571886872-marker">1</a></sup> This is the format for numbers of type <code>double</code> in Java, C++, and most modern programming languages.</p><p data-type="footnote" id="idm46198578212696"><sup><a href="ch03.html#idm46198578212696-marker">2</a></sup> There are JavaScript extensions, such as TypeScript and Flow (<a data-type="xref" href="ch17.html#flow">§17.8</a>), that allow types to be specified as part of variable declarations with syntax like <code>let x: number = 0;</code>.</p></div></div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->