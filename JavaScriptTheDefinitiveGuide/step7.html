<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Arrays"><div class="chapter" id="arrays">
        <h1><span class="label">Chapter 7. </span>Arrays</h1>
        
        
        <p>This<a data-type="indexterm" data-primary="arrays" data-secondary="overview of" id="idm46198548182584"></a> chapter documents arrays, a fundamental datatype in JavaScript
        and in most other programming languages.
        An <em>array</em> is<a data-type="indexterm" data-primary="elements" data-secondary="array elements" data-tertiary="definition of term" id="idm46198548180552"></a><a data-type="indexterm" data-primary="index position" id="idm46198548179272"></a> an ordered collection of values. Each value is called an
        <em>element</em>, and each element has a numeric position in the array, known as its
        <em>index</em>. JavaScript arrays are <em>untyped</em>: an array element may be of any type,
        and different elements of the same array may be of different types. Array
        elements may even be objects or other arrays, which allows you to create
        complex data structures, such as arrays of objects and arrays of arrays.
        JavaScript<a data-type="indexterm" data-primary="zero-based arrays" id="idm46198548176968"></a> arrays are <em>zero-based</em> and use 32-bit indexes: the index of the
        first element is 0, and the highest possible index is 4294967294 (2<sup>32</sup>−2), for
        a maximum array size of 4,294,967,295 elements. JavaScript<a data-type="indexterm" data-primary="dynamic arrays" id="idm46198548175176"></a> arrays are
        <em>dynamic</em>: they grow or shrink as needed, and there is no need to declare a
        fixed size for the array when you create it or to reallocate it when the size
        changes. JavaScript<a data-type="indexterm" data-primary="sparse arrays" id="idm46198548173752"></a> arrays may be <em>sparse</em>: the elements need not have
        contiguous indexes, and there may be gaps. Every JavaScript array has a <code>length</code>
        property. For nonsparse arrays, this property specifies the number of elements
        in the array. For sparse arrays, <code>length</code> is larger than the highest
        index of any element.</p>
        
        <p>JavaScript arrays are a specialized form of JavaScript object, and array
        indexes are really little more than property names that happen to be integers.
        We’ll talk more about the specializations of arrays elsewhere in this chapter.
        Implementations typically optimize arrays so that access to numerically indexed
        array elements is generally significantly faster than access to regular object
        properties.</p>
        
        <p>Arrays<a data-type="indexterm" data-primary="Array.prototype" id="idm46198548107576"></a><a data-type="indexterm" data-primary="methods" data-secondary="array methods" data-tertiary="generic application of" id="idm46198548106840"></a><a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="generic application of" id="idm46198548105624"></a> inherit properties from <code>Array.prototype</code>, which defines a rich
        set of array manipulation methods, covered in <a data-type="xref" href="#arraymethods">§7.8</a>. Most
        of these methods are <em>generic</em>, which means that they work correctly
        not only for true arrays, but for any “array-like object.”  We’ll
        discuss array-like objects in <a data-type="xref" href="#arraylike">§7.9</a>. Finally, JavaScript
        strings behave like arrays of characters, and we’ll discuss this in
        <a data-type="xref" href="#stringarrays">§7.10</a>.</p>
        
        <p>ES6<a data-type="indexterm" data-primary="ES6" data-secondary="typed arrays" id="idm46198548100488"></a><a data-type="indexterm" data-primary="typed arrays" data-secondary="versus regular arrays" data-secondary-sortas="regular arrays" id="idm46198548099480"></a> introduces a set of new array classes known collectively
        as “typed arrays.” Unlike regular JavaScript arrays, typed arrays have
        a fixed length and a fixed numeric element type. They offer high
        performance and byte-level access to binary data and are covered in
        <a data-type="xref" href="ch11.html#typedarrays">§11.2</a>.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.1 Creating Arrays"><div class="sect1" id="idm46198548096920">
        <h1>7.1 Creating Arrays</h1>
        
        <p>There<a data-type="indexterm" data-primary="arrays" data-secondary="creating" id="Acreat07"></a> are several ways to create arrays. The subsections that follow
        explain how to create arrays with:</p>
        
        <ul>
        <li>
        <p>Array literals</p>
        </li>
        <li>
        <p>The <code>...</code> spread operator on an iterable object</p>
        </li>
        <li>
        <p>The <code>Array()</code> constructor</p>
        </li>
        <li>
        <p>The <code>Array.of()</code> and <code>Array.from()</code> factory methods</p>
        </li>
        </ul>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.1.1 Array Literals"><div class="sect2" id="arrayliterals">
        <h2>7.1.1 Array Literals</h2>
        
        <p>By<a data-type="indexterm" data-primary="array literals" id="idm46198548085944"></a> far the simplest way to create an array is with an array literal,
        which is simply a comma-separated list of array elements within square
        brackets. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">empty</code> <code class="o">=</code> <code class="p">[];</code>                 <code class="c1">// An array with no elements</code>
        <code class="kd">let</code> <code class="nx">primes</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">11</code><code class="p">];</code>  <code class="c1">// An array with 5 numeric elements</code>
        <code class="kd">let</code> <code class="nx">misc</code> <code class="o">=</code> <code class="p">[</code> <code class="mf">1.1</code><code class="p">,</code> <code class="kc">true</code><code class="p">,</code> <code class="s2">"a"</code><code class="p">,</code> <code class="p">];</code> <code class="c1">// 3 elements of various types + trailing comma</code></pre>
        
        <p>The values in an array literal need not be constants; they may be
        arbitrary <span class="keep-together">expressions:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">base</code> <code class="o">=</code> <code class="mi">1024</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">table</code> <code class="o">=</code> <code class="p">[</code><code class="nx">base</code><code class="p">,</code> <code class="nx">base</code><code class="o">+</code><code class="mi">1</code><code class="p">,</code> <code class="nx">base</code><code class="o">+</code><code class="mi">2</code><code class="p">,</code> <code class="nx">base</code><code class="o">+</code><code class="mi">3</code><code class="p">];</code></pre>
        
        <p>Array literals can contain object literals or other array literals:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[[</code><code class="mi">1</code><code class="p">,</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">}],</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">4</code><code class="p">}]];</code></pre>
        
        <p>If an array literal contains multiple commas in a row, with no value
        between, the array is sparse (see <a data-type="xref" href="#sparsearrays">§7.3</a>). Array elements for which
        values are omitted do not exist but appear to be <code>undefined</code> if you
        query them:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,,</code><code class="mi">3</code><code class="p">];</code> <code class="c1">// Elements at indexes 0 and 2. No element at index 1</code>
        <code class="kd">let</code> <code class="nx">undefs</code> <code class="o">=</code> <code class="p">[,,];</code>  <code class="c1">// An array with no elements but a length of 2</code></pre>
        
        <p>Array literal syntax allows an optional trailing comma, so <code>[,,]</code>
        has a length of 2, <span class="keep-together">not 3.</span></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.1.2 The Spread Operator"><div class="sect2" id="spread-operator-in-array-literals">
        <h2>7.1.2 The Spread Operator</h2>
        
        <p>In<a data-type="indexterm" data-primary="spread operator (…)" id="idm46198547889128"></a><a data-type="indexterm" data-primary="… (spread operator)" id="idm46198547888392"></a><a data-type="indexterm" data-primary="ES6" data-secondary="spread operator (…)" id="idm46198547887720"></a> ES6 and later, you can use the “spread operator,” <code>...</code>, to
        include the elements of one array within an array literal:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
        <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code> <code class="p">...</code><code class="nx">a</code><code class="p">,</code> <code class="mi">4</code><code class="p">];</code>  <code class="c1">// b == [0, 1, 2, 3, 4]</code></pre>
        
        <p>The three dots “spread” the array <code>a</code> so that its elements become
        elements within the array literal that is being created. It is as if
        the <code>...a</code> was replaced by the elements of the array <code>a</code>, listed
        literally as part of the enclosing array literal. (Note that, although
        we call these three dots a spread operator, this is not a true
        operator because it can only be used in array literals and, as we’ll
        see later in the book, function invocations.)</p>
        
        <p>The spread operator is a convenient way to create a (shallow) copy of an
        array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">original</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        <code class="kd">let</code> <code class="nx">copy</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">original</code><code class="p">];</code>
        <code class="nx">copy</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>  <code class="c1">// Modifying the copy does not change the original</code>
        <code class="nx">original</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>   <code class="c1">// =&gt; 1</code></pre>
        
        <p>The spread operator
        works on any iterable object. (<em>Iterable</em> objects are what
        the <code>for/of</code> loop iterates over; we first saw them in <a data-type="xref" href="ch05.html#forofloop">§5.4.4</a>, and
        we’ll see much more about them in <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>.) Strings are iterable,
        so you can use a spread operator to turn any string into an array of
        single-character strings:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">digits</code> <code class="o">=</code> <code class="p">[...</code><code class="s2">"0123456789ABCDEF"</code><code class="p">];</code>
        <code class="nx">digits</code> <code class="c1">// =&gt; ["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F"]</code></pre>
        
        <p>Set objects (<a data-type="xref" href="ch11.html#setclass">§11.1.1</a>) are iterable, so an easy way to remove
        duplicate elements
        from an array is to convert the array to a set and then immediately
        convert the set back to an array using the spread operator:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">letters</code> <code class="o">=</code> <code class="p">[...</code><code class="s2">"hello world"</code><code class="p">];</code>
        <code class="p">[...</code><code class="k">new</code> <code class="nx">Set</code><code class="p">(</code><code class="nx">letters</code><code class="p">)]</code>  <code class="c1">// =&gt; ["h","e","l","o"," ","w","r","d"]</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.1.3 The Array() Constructor"><div class="sect2" id="arrayconstructor">
        <h2>7.1.3 The Array() Constructor</h2>
        
        <p>Another<a data-type="indexterm" data-primary="constructors" data-secondary="Array() constructor" id="idm46198547741832"></a><a data-type="indexterm" data-primary="Array() constructor" id="idm46198547740824"></a> way to create an array is with the <code>Array()</code>
        constructor. You can invoke this constructor in three distinct ways:</p>
        
        <ul>
        <li>
        <p>Call it with no arguments:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Array</code><code class="p">();</code></pre>
        
        <p>This method creates an empty array with no elements and is equivalent
        to the array literal <code>[]</code>.</p>
        </li>
        <li>
        <p>Call it with a single numeric argument, which specifies a length:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Array</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code></pre>
        
        <p>This technique creates an array with the specified length. This form
        of the <code>Array()</code> constructor can be used to preallocate an array
        when you know in advance how many elements will be required. Note that
        no values are stored in the array, and the array index properties
        “0”, “1”, and so on are not even defined for
        the array.</p>
        </li>
        <li>
        <p>Explicitly specify two or more array elements or a single
        non-numeric element for the array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Array</code><code class="p">(</code><code class="mi">5</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="s2">"testing, testing"</code><code class="p">);</code></pre>
        
        <p>In this form, the constructor arguments become the elements of the new
        array. Using an array literal is almost always simpler than this usage
        of the <code>Array()</code> constructor.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.1.4 Array.of()"><div class="sect2" id="arrayof">
        <h2>7.1.4 Array.of()</h2>
        
        <p>When<a data-type="indexterm" data-primary="Array.of() function" id="idm46198547564760"></a> the <code>Array()</code> constructor function is invoked with one numeric
        argument, it uses that argument as an array length. But when invoked
        with more than one numeric argument, it treats those arguments as
        elements for the array to be created. This means that the <code>Array()</code>
        constructor cannot be used to create an array with a single numeric
        element.</p>
        
        <p>In<a data-type="indexterm" data-primary="ES6" data-secondary="Array.of() function" id="idm46198547562392"></a> ES6, the <code>Array.of()</code> function addresses this problem: it is a
        factory method that creates and returns a new array, using its
        argument values (regardless of how many of them there are) as the
        array elements:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Array</code><code class="p">.</code><code class="k">of</code><code class="p">()</code>        <code class="c1">// =&gt; []; returns empty array with no arguments</code>
        <code class="nb">Array</code><code class="p">.</code><code class="k">of</code><code class="p">(</code><code class="mi">10</code><code class="p">)</code>      <code class="c1">// =&gt; [10]; can create arrays with a single numeric argument</code>
        <code class="nb">Array</code><code class="p">.</code><code class="k">of</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code>   <code class="c1">// =&gt; [1, 2, 3]</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.1.5 Array.from()"><div class="sect2" id="arrayfrom">
        <h2>7.1.5 Array.from()</h2>
        
        <p><code>Array.from</code> is<a data-type="indexterm" data-primary="Array.from() function" id="idm46198547549208"></a> another array factory method introduced in ES6. It
        expects an iterable or array-like object as its first argument and
        returns a new array that contains the elements of that object. With an
        iterable argument, <code>Array.from(iterable)</code> works like the spread
        operator <code>[...iterable]</code> does. It is also a simple way to make a copy
        of an array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">copy</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">original</code><code class="p">);</code></pre>
        
        <p><code>Array.from()</code> is also important because it defines a way to make a
        true-array copy of an array-like object. Array-like objects are
        non-array objects that have a numeric length property and have values
        stored with properties whose names happen to be integers. When working
        with client-side JavaScript, the return values of some web browser
        methods are array-like, and it can be easier to work with them if you
        first convert them to true arrays:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">truearray</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">arraylike</code><code class="p">);</code></pre>
        
        <p><code>Array.from()</code> also accepts an optional second argument. If you pass a
        function as the second argument, then as the new array is being built,
        each element from the source object will be passed to the function you
        specify, and the return value of the function will be stored in the
        array instead of the original value. (This is very much like the array
        <code>map()</code> method that will be introduced later in the chapter, but it is
        more efficient to perform the mapping while the array is being built
        than it is to build the array and then map it to another new array.)<a data-type="indexterm" data-primary="" data-startref="Acreat07" id="idm46198547454552"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.2 Reading and Writing Array Elements"><div class="sect1" id="idm46198547461912">
        <h1>7.2 Reading and Writing Array Elements</h1>
        
        <p>You<a data-type="indexterm" data-primary="[] (square brackets)" id="idm46198547460248"></a><a data-type="indexterm" data-primary="square brackets ([])" id="idm46198547496600"></a><a data-type="indexterm" data-primary="arrays" data-secondary="reading and writing array elements" id="idm46198547495928"></a><a data-type="indexterm" data-primary="elements" data-secondary="array elements" data-tertiary="reading and writing" id="idm46198547495016"></a> access an element of an array using the <code>[]</code> operator. A reference to the
        array should appear to the left of the brackets. An arbitrary expression that
        has a non-negative integer value should be inside the brackets. You can use
        this syntax to both read and write the value of an element of an array. Thus,
        the following are all legal JavaScript statements:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"world"</code><code class="p">];</code>     <code class="c1">// Start with a one-element array</code>
        <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>      <code class="c1">// Read element 0</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="mf">3.14</code><code class="p">;</code>           <code class="c1">// Write element 1</code>
        <code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
        <code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>              <code class="c1">// Write element 2</code>
        <code class="nx">a</code><code class="p">[</code><code class="nx">i</code> <code class="o">+</code> <code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"hello"</code><code class="p">;</code>    <code class="c1">// Write element 3</code>
        <code class="nx">a</code><code class="p">[</code><code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">]]</code> <code class="o">=</code> <code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>        <code class="c1">// Read elements 0 and 2, write element 3</code></pre>
        
        <p>What is special about arrays is that when you use property names that are
        non-negative integers less than 2<sup>32</sup>–1, the array automatically maintains the
        value of the <code>length</code> property for you. In the preceding, for example, we created an array
        <code>a</code> with a single element. We then assigned values at indexes 1, 2, and 3. The
        <code>length</code> property of the array changed as we did, so:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">a</code><code class="p">.</code><code class="nx">length</code>       <code class="c1">// =&gt; 4</code></pre>
        
        <p>Remember that arrays are a specialized kind of object. The square brackets used
        to access array elements work just like the square brackets used to access
        object properties. JavaScript converts the numeric array index you specify to a
        string—the index <code>1</code> becomes the string <code>"1"</code>—then uses that string as a
        property name. There is nothing special about the conversion of the index from
        a number to a string: you can do that with regular objects, too:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{};</code>    <code class="c1">// Create a plain object</code>
        <code class="nx">o</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"one"</code><code class="p">;</code>  <code class="c1">// Index it with an integer</code>
        <code class="nx">o</code><code class="p">[</code><code class="s2">"1"</code><code class="p">]</code>         <code class="c1">// =&gt; "one"; numeric and string property names are the same</code></pre>
        
        <p>It<a data-type="indexterm" data-primary="index position" id="idm46198547335928"></a><a data-type="indexterm" data-primary="array index" id="idm46198547335320"></a><a data-type="indexterm" data-primary="object property names" id="idm46198547334680"></a> is helpful to clearly distinguish an <em>array index</em> from an <em>object
        property name</em>. All indexes are property names, but only property names that
        are integers between 0 and 2<sup>32</sup>–2 are indexes. All arrays are objects, and you
        can create properties of any name on them. If you use properties that are array
        indexes, however, arrays have the special behavior of updating their <code>length</code>
        property as needed.</p>
        
        <p>Note that you can index an array using numbers that are negative or that are
        not integers. When you do this, the number is converted to a string, and that
        string is used as the property name. Since the name is not a non-negative
        integer, it is treated as a regular object property, not an array index. Also,
        if you index an array with a string that happens to be a non-negative integer,
        it behaves as an array index, not an object property. The same is true if you
        use a floating-point number that is the same as an <span class="keep-together">integer:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">a</code><code class="p">[</code><code class="o">-</code><code class="mf">1.23</code><code class="p">]</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>  <code class="c1">// This creates a property named "-1.23"</code>
        <code class="nx">a</code><code class="p">[</code><code class="s2">"1000"</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>    <code class="c1">// This the 1001st element of the array</code>
        <code class="nx">a</code><code class="p">[</code><code class="mf">1.000</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>     <code class="c1">// Array index 1. Same as a[1] = 1;</code></pre>
        
        <p>The fact that array indexes are simply a special type of object property name
        means that JavaScript arrays have no notion of an “out of bounds” error. When
        you try to query a nonexistent property of any object, you don’t get an error;
        you simply get <code>undefined</code>. This is just as true for arrays as it is for
        objects:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="kc">true</code><code class="p">,</code> <code class="kc">false</code><code class="p">];</code> <code class="c1">// This array has elements at indexes 0 and 1</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code>                   <code class="c1">// =&gt; undefined; no element at this index.</code>
        <code class="nx">a</code><code class="p">[</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code>                  <code class="c1">// =&gt; undefined; no property with this name.</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.3 Sparse Arrays"><div class="sect1" id="sparsearrays">
        <h1>7.3 Sparse Arrays</h1>
        
        <p>A<a data-type="indexterm" data-primary="arrays" data-secondary="sparse arrays" id="idm46198547212424"></a><a data-type="indexterm" data-primary="sparse arrays" id="idm46198547211416"></a> <em>sparse</em> array is one in which the elements do not have contiguous indexes
        starting at 0. Normally, the <code>length</code> property of an array specifies the number
        of elements in the array. If the array is sparse, the value of the <code>length</code>
        property is greater than the number of elements. Sparse arrays can be created
        with the <code>Array()</code> constructor or simply by assigning to an array index larger
        than the current array <code>length</code>.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Array</code><code class="p">(</code><code class="mi">5</code><code class="p">);</code> <code class="c1">// No elements, but a.length is 5.</code>
        <code class="nx">a</code> <code class="o">=</code> <code class="p">[];</code>               <code class="c1">// Create an array with no elements and length = 0.</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">1000</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>          <code class="c1">// Assignment adds one element but sets length to 1001.</code></pre>
        
        <p>We’ll see later that you can also make an array sparse with the <code>delete</code>
        operator.</p>
        
        <p>Arrays that are sufficiently sparse are typically implemented in a slower, more
        memory-efficient way than dense arrays are, and looking up elements in such an
        array will take about as much time as regular object property lookup.</p>
        
        <p>Note that when you omit a value in an array literal (using repeated commas as
        in <code>[1,,3]</code>), the resulting array is sparse, and the omitted elements simply do
        not exist:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a1</code> <code class="o">=</code> <code class="p">[,];</code>           <code class="c1">// This array has no elements and length 1</code>
        <code class="kd">let</code> <code class="nx">a2</code> <code class="o">=</code> <code class="p">[</code><code class="kc">undefined</code><code class="p">];</code>   <code class="c1">// This array has one undefined element</code>
        <code class="mi">0</code> <code class="k">in</code> <code class="nx">a1</code>                 <code class="c1">// =&gt; false: a1 has no element with index 0</code>
        <code class="mi">0</code> <code class="k">in</code> <code class="nx">a2</code>                 <code class="c1">// =&gt; true: a2 has the undefined value at index 0</code></pre>
        
        <p>Understanding sparse arrays is an important part of understanding the true
        nature of JavaScript arrays. In practice, however, most JavaScript arrays you
        will work with will not be sparse. And, if you do have to work with a sparse
        array, your code will probably treat it just as it would treat a nonsparse
        array with <code>undefined</code> elements.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.4 Array Length"><div class="sect1" id="arraylength">
        <h1>7.4 Array Length</h1>
        
        <p>Every<a data-type="indexterm" data-primary="arrays" data-secondary="array length" id="idm46198547069432"></a> array has a <code>length</code> property, and it is this property that makes arrays
        different from regular JavaScript objects. For arrays that are dense (i.e., not
        sparse), the <code>length</code> property specifies the number of elements in the array.
        Its value is one more than the highest index in the array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">[].</code><code class="nx">length</code>             <code class="c1">// =&gt; 0: the array has no elements</code>
        <code class="p">[</code><code class="s2">"a"</code><code class="p">,</code><code class="s2">"b"</code><code class="p">,</code><code class="s2">"c"</code><code class="p">].</code><code class="nx">length</code>  <code class="c1">// =&gt; 3: highest index is 2, length is 3</code></pre>
        
        <p>When an array is sparse, the <code>length</code> property is greater than the number of
        elements, and all we can say about it is that <code>length</code> is guaranteed to be
        larger than the index of every element in the array. Or, put another way, an
        array (sparse or not) will never have an element whose index is greater than or
        equal to its <code>length</code>. In order to maintain this invariant, arrays have two
        special behaviors. The first we described above: if you assign a value to an
        array element whose index <code>i</code> is greater than or equal to the array’s current
        <code>length</code>, the value of the <code>length</code> property is set to <code>i+1</code>.</p>
        
        <p>The second special behavior that arrays implement in order to maintain the
        length invariant is that, if you set the <code>length</code> property to a non-negative
        integer <code>n</code> smaller than its current value, any array elements whose index is
        greater than or equal to <code>n</code> are deleted from the array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>     <code class="c1">// Start with a 5-element array.</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>        <code class="c1">// a is now [1,2,3].</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>        <code class="c1">// Delete all elements.  a is [].</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">5</code><code class="p">;</code>        <code class="c1">// Length is 5, but no elements, like new Array(5)</code></pre>
        
        <p>You can also set the <code>length</code> property of an array to a value larger than its
        current value. Doing this does not actually add any new elements to the array;
        it simply creates a sparse area at the end of the array.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.5 Adding and Deleting Array Elements"><div class="sect1" id="idm46198546955944">
        <h1>7.5 Adding and Deleting Array Elements</h1>
        
        <p>We’ve<a data-type="indexterm" data-primary="arrays" data-secondary="adding and deleting" id="idm46198546954312"></a> already seen the simplest way to add elements to an array: just assign
        values to new indexes:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[];</code>      <code class="c1">// Start with an empty array.</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"zero"</code><code class="p">;</code>   <code class="c1">// And add elements to it.</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"one"</code><code class="p">;</code></pre>
        
        <p>You can also use the <code>push()</code> method to add one or more values to the end of an
        array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[];</code>           <code class="c1">// Start with an empty array</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s2">"zero"</code><code class="p">);</code>       <code class="c1">// Add a value at the end.  a = ["zero"]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="s2">"one"</code><code class="p">,</code> <code class="s2">"two"</code><code class="p">);</code> <code class="c1">// Add two more values.  a = ["zero", "one", "two"]</code></pre>
        
        <p>Pushing a value onto an array <code>a</code> is the same as assigning the value
        to <code>a[a.length]</code>. You can use the <code>unshift()</code> method (described in
        <a data-type="xref" href="#arraymethods">§7.8</a>) to insert a value at the beginning of an array,
        shifting the existing array elements to higher indexes. The <code>pop()</code>
        method is the opposite of <code>push()</code>: it removes the last element of the
        array and returns it, reducing the length of an array by 1. Similarly,
        the <code>shift()</code> method removes and returns the first element of the
        array, reducing the length by 1 and shifting all elements down to an
        index one lower than their current index. See <a data-type="xref" href="#arraymethods">§7.8</a> for
        more on these methods.</p>
        
        <p>You can delete array elements with the <code>delete</code> operator, just as you can
        delete object properties:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        <code class="k">delete</code> <code class="nx">a</code><code class="p">[</code><code class="mi">2</code><code class="p">];</code>   <code class="c1">// a now has no element at index 2</code>
        <code class="mi">2</code> <code class="k">in</code> <code class="nx">a</code>         <code class="c1">// =&gt; false: no array index 2 is defined</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">length</code>       <code class="c1">// =&gt; 3: delete does not affect array length</code></pre>
        
        <p>Deleting an array element is similar to (but subtly different than) assigning
        <code>undefined</code> to that element. Note that using <code>delete</code> on an array element does
        not alter the <code>length</code> property and does not shift elements with higher indexes
        down to fill in <span class="keep-together">the gap</span> that is left by the deleted property. If you delete an
        element from an array, the array becomes sparse.</p>
        
        <p>As we saw above, you can also remove elements from the end of an array
        simply by setting the <code>length</code> property to the new desired length.</p>
        
        <p>Finally, <code>splice()</code> is the general-purpose method for inserting,
        deleting, or replacing array elements. It alters the <code>length</code> property
        and shifts array elements to higher or lower indexes as needed. See
        <a data-type="xref" href="#arraymethods">§7.8</a> for details.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.6 Iterating Arrays"><div class="sect1" id="iteratingarrays">
        <h1>7.6 Iterating Arrays</h1>
        
        <p>As<a data-type="indexterm" data-primary="arrays" data-secondary="iterating arrays" id="idm46198546810536"></a><a data-type="indexterm" data-primary="ES6" data-secondary="iterating arrays" id="idm46198546809528"></a><a data-type="indexterm" data-primary="for/of loops" id="idm46198546808584"></a><a data-type="indexterm" data-primary="looping statements" data-secondary="for/of loops" id="idm46198546807912"></a> of ES6, the easiest way to loop through each of the
        elements of an array (or any iterable object) is with the <code>for/of</code>
        loop, which was covered in detail in <a data-type="xref" href="ch05.html#forofloop">§5.4.4</a>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">letters</code> <code class="o">=</code> <code class="p">[...</code><code class="s2">"Hello world"</code><code class="p">];</code>  <code class="c1">// An array of letters</code>
        <code class="kd">let</code> <code class="nx">string</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">letter</code> <code class="k">of</code> <code class="nx">letters</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">string</code> <code class="o">+=</code> <code class="nx">letter</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="nx">string</code>  <code class="c1">// =&gt; "Hello world"; we reassembled the original text</code></pre>
        
        <p>The built-in array iterator that the <code>for/of</code> loop uses returns the
        elements of an array in ascending order. It has no special behavior
        for sparse arrays and simply returns <code>undefined</code> for any array
        elements that do not exist.</p>
        
        <p>If you want to use a <code>for/of</code> loop for an array and need to know the index
        of each array element, use the <code>entries()</code> method of the array, along
        with destructuring assignment, like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">everyother</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="p">[</code><code class="nx">index</code><code class="p">,</code> <code class="nx">letter</code><code class="p">]</code> <code class="k">of</code> <code class="nx">letters</code><code class="p">.</code><code class="nx">entries</code><code class="p">())</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">index</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="nx">everyother</code> <code class="o">+=</code> <code class="nx">letter</code><code class="p">;</code>  <code class="c1">// letters at even indexes</code>
        <code class="p">}</code>
        <code class="nx">everyother</code>  <code class="c1">// =&gt; "Hlowrd"</code></pre>
        
        <p>Another<a data-type="indexterm" data-primary="forEach() method" id="idm46198546634888"></a> good way to iterate arrays is with <code>forEach()</code>. This is not a
        new form of the <code>for</code> loop, but an array method that offers a
        functional approach to array iteration. You pass a function to the
        <code>forEach()</code> method of an array, and <code>forEach()</code> invokes your function
        once on each element of the array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">uppercase</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
        <code class="nx">letters</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">letter</code> <code class="o">=&gt;</code> <code class="p">{</code>  <code class="c1">// Note arrow function syntax here</code>
            <code class="nx">uppercase</code> <code class="o">+=</code> <code class="nx">letter</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
        <code class="p">});</code>
        <code class="nx">uppercase</code>  <code class="c1">// =&gt; "HELLO WORLD"</code></pre>
        
        <p>As you would expect, <code>forEach()</code> iterates the array in order, and it
        actually passes the array index to your function as a second argument,
        which is occasionally useful. Unlike the <code>for/of</code> loop, the
        <code>forEach()</code> is aware of sparse arrays and does not invoke your
        function for elements that are not there.</p>
        
        <p><a data-type="xref" href="#arrayiteratormethods">§7.8.1</a> documents the <code>forEach()</code> method in more
        detail. That section also covers related methods such as <code>map()</code> and
        <code>filter()</code> that perform specialized kinds of array iteration.</p>
        
        <p>You<a data-type="indexterm" data-primary="looping statements" data-secondary="for loops" id="idm46198546649144"></a><a data-type="indexterm" data-primary="for loops" id="idm46198546648136"></a> can also loop through the elements of an array with a good
        old-fashioned <code>for</code> loop (<a data-type="xref" href="ch05.html#forloop">§5.4.3</a>):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">vowels</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">letters</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// For each index in the array</code>
            <code class="kd">let</code> <code class="nx">letter</code> <code class="o">=</code> <code class="nx">letters</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>              <code class="c1">// Get the element at that index</code>
            <code class="k">if</code> <code class="p">(</code><code class="sr">/[aeiou]/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">letter</code><code class="p">))</code> <code class="p">{</code>         <code class="c1">// Use a regular expression test</code>
                <code class="nx">vowels</code> <code class="o">+=</code> <code class="nx">letter</code><code class="p">;</code>                 <code class="c1">// If it is a vowel, remember it</code>
            <code class="p">}</code>
        <code class="p">}</code>
        <code class="nx">vowels</code>  <code class="c1">// =&gt; "eoo"</code></pre>
        
        <p>In nested loops, or other contexts where performance is critical, you
        may sometimes see this basic array iteration loop written so that the
        array length is only looked up once rather than on each
        iteration. Both of the following <code>for</code> loop forms are idiomatic,
        though not particularly common, and with modern JavaScript
        interpreters, it is not at all clear that they have any performance
        impact:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Save the array length into a local variable</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">len</code> <code class="o">=</code> <code class="nx">letters</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">len</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// loop body remains the same</code>
        <code class="p">}</code>
        
        <code class="c1">// Iterate backwards from the end of the array to the start</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">letters</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code><code class="o">--</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// loop body remains the same</code>
        <code class="p">}</code></pre>
        
        <p>These examples assume that the array is dense and that all elements
        contain valid data. If this is not the case, you should test the array
        elements before using them. If you want to skip undefined and
        nonexistent elements, you might write:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">===</code> <code class="kc">undefined</code><code class="p">)</code> <code class="k">continue</code><code class="p">;</code> <code class="c1">// Skip undefined + nonexistent elements</code>
            <code class="c1">// loop body here</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.7 Multidimensional Arrays"><div class="sect1" id="idm46198546811912">
        <h1>7.7 Multidimensional Arrays</h1>
        
        <p>JavaScript<a data-type="indexterm" data-primary="arrays" data-secondary="multidimensional arrays" id="idm46198546441160"></a> does not support true multidimensional arrays, but you can
        approximate them with arrays of arrays. To access a value in an array of
        arrays, simply use the <code>[]</code> operator twice. For example, suppose the variable
        <code>matrix</code> is an array of arrays of numbers. Every element in <code>matrix[x]</code> is an
        array of numbers. To access a particular number within this array, you would
        write <code>matrix[x][y]</code>. Here is a concrete example that uses a two-dimensional
        array as a multiplication table:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Create a multidimensional array</code>
        <code class="kd">let</code> <code class="nx">table</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Array</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code>               <code class="c1">// 10 rows of the table</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">table</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">table</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Array</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code>            <code class="c1">// Each row has 10 columns</code>
        <code class="p">}</code>
        
        <code class="c1">// Initialize the array</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">row</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">row</code> <code class="o">&lt;</code> <code class="nx">table</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">row</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">col</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">col</code> <code class="o">&lt;</code> <code class="nx">table</code><code class="p">[</code><code class="nx">row</code><code class="p">].</code><code class="nx">length</code><code class="p">;</code> <code class="nx">col</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">table</code><code class="p">[</code><code class="nx">row</code><code class="p">][</code><code class="nx">col</code><code class="p">]</code> <code class="o">=</code> <code class="nx">row</code><code class="o">*</code><code class="nx">col</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// Use the multidimensional array to compute 5*7</code>
        <code class="nx">table</code><code class="p">[</code><code class="mi">5</code><code class="p">][</code><code class="mi">7</code><code class="p">]</code>  <code class="c1">// =&gt; 35</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.8 Array Methods"><div class="sect1" id="arraymethods">
        <h1>7.8 Array Methods</h1>
        
        <p>The<a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="overview of" id="idm46198546233160"></a><a data-type="indexterm" data-primary="methods" data-secondary="array methods" data-tertiary="overview of" id="idm46198546231992"></a> preceding sections have focused on basic JavaScript syntax for working
        with arrays. In general, though, it is the methods defined by the
        Array class that are the most powerful. The next sections document
        these methods. While reading about these methods, keep in mind that
        some of them modify the array they are called on and some of them
        leave the array unchanged. A number of the methods return an array:
        sometimes, this is a new array, and the original is unchanged. Other
        times, a method will modify the array in place and will also return a
        reference to the modified array.</p>
        
        <p>Each of the subsections that follows covers a group of related array
        methods:</p>
        
        <ul>
        <li>
        <p>Iterator methods loop over the elements of an array, typically
        invoking a function that you specify on each of those elements.</p>
        </li>
        <li>
        <p>Stack and queue methods add and remove array elements to and from
        the beginning and the end of an array.</p>
        </li>
        <li>
        <p>Subarray methods are for extracting, deleting, inserting, filling,
        and copying contiguous regions of a larger array.</p>
        </li>
        <li>
        <p>Searching and sorting methods are for locating elements within an
        array and for sorting the elements of an array.</p>
        </li>
        </ul>
        
        <p>The following subsections also cover the static methods of the Array class
        and a few miscellaneous methods for concatenating arrays and converting
        arrays to strings.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.8.1 Array Iterator Methods"><div class="sect2" id="arrayiteratormethods">
        <h2>7.8.1 Array Iterator Methods</h2>
        
        <p>The<a data-type="indexterm" data-primary="array iterator methods" data-secondary="overview of" id="idm46198546222520"></a><a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="iterator methods" id="Aamethiter07"></a> methods described in this section iterate over arrays by passing
        array elements, in order, to a function you supply, and they provide
        convenient ways to iterate, map, filter, test, and reduce arrays.</p>
        
        <p>Before we explain the methods in detail, however, it is worth making
        some generalizations about them.  First, all of these methods accept a
        function as their first argument and invoke that function once for
        each element (or some elements) of the array. If the array is sparse,
        the function you pass is not invoked for nonexistent elements. In most
        cases, the function you supply is invoked with three arguments: the
        value of the array element, the index of the array element, and the
        array itself. Often, you only need the first of these argument values
        and can ignore the second and third values.</p>
        
        <p>Most of the iterator methods described in the following subsections accept an optional second argument. If specified, the function is
        invoked as if it is a method of this second argument. That is, the
        second argument you pass becomes the value of the <code>this</code> keyword
        inside of the function you pass as the first argument. The return
        value of the function you pass is usually important, but different
        methods handle the return value in different ways. None of the methods
        described here modify the array on which they are invoked (though the
        function you pass can modify the array, of course).</p>
        
        <p>Each of these functions is invoked with a function as its first
        argument, and it is very common to define that function inline as part
        of the method invocation expression instead of using an existing
        function that is defined elsewhere. Arrow function syntax (see
        <a data-type="xref" href="ch08.html#arrowfunctions">§8.1.3</a>) works particularly well with these methods, and we
        will use it in the examples that follow.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="forEach()"><div class="sect3" id="foreach">
        <h3>forEach()</h3>
        
        <p>The <code>forEach()</code> method<a data-type="indexterm" data-primary="array iterator methods" data-secondary="forEach()" id="idm46198546213272"></a><a data-type="indexterm" data-primary="forEach() method" id="idm46198546212264"></a> iterates through an array, invoking a function you
        specify for each element. As we’ve described, you pass the function as the
        first argument to <span class="keep-together"><code>forEach()</code></span>. <code>forEach()</code> then invokes your function with
        three arguments: the value of the array element, the index of the array
        element, and the array itself. If you only care about the value of the array
        element, you can write a function with only one parameter—the additional
        arguments will be ignored:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">],</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="c1">// Compute the sum of the elements of the array</code>
        <code class="nx">data</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">value</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">value</code><code class="p">;</code> <code class="p">});</code>          <code class="c1">// sum == 15</code>
        
        <code class="c1">// Now increment each array element</code>
        <code class="nx">data</code><code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">v</code><code class="p">,</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">a</code><code class="p">)</code> <code class="p">{</code> <code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">v</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code> <code class="p">});</code> <code class="c1">// data == [2,3,4,5,6]</code></pre>
        
        <p>Note that <code>forEach()</code> does not provide a way to terminate iteration before all
        elements have been passed to the function. That is, there is no equivalent of
        the <code>break</code> statement you can use with a regular <code>for</code> loop.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="map()"><div class="sect3" id="arraymap">
        <h3>map()</h3>
        
        <p>The<a data-type="indexterm" data-primary="array iterator methods" data-secondary="map()" id="idm46198546118824"></a><a data-type="indexterm" data-primary="map() method" id="idm46198546117816"></a> <code>map()</code> method passes each element of the array on which it is invoked to
        the function you specify and returns an array containing the values returned
        by your function. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">)</code>   <code class="c1">// =&gt; [1, 4, 9]: the function takes input x and returns x*x</code></pre>
        
        <p>The function you pass to <code>map()</code> is invoked in the same way as a
        function passed to <code>forEach()</code>. For the <code>map()</code> method, however, the
        function you pass should return a value. Note that <code>map()</code> returns a
        new array: it does not modify the array it is invoked on. If that
        array is sparse, your function will not be called for the missing
        elements, but the returned array will be sparse in the same way as the
        original array: it will have the same length and the same missing
        elements.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="filter()"><div class="sect3" id="arrayfilter">
        <h3>filter()</h3>
        
        <p>The<a data-type="indexterm" data-primary="array iterator methods" data-secondary="filter()" id="idm46198546039848"></a><a data-type="indexterm" data-primary="filter() method" id="idm46198546038840"></a> <code>filter()</code> method returns an array containing a subset of the elements of
        the array on which it is invoked. The function you pass to it should be
        predicate: a function that returns <code>true</code> or <code>false</code>. The predicate is invoked
        just as for <code>forEach()</code> and <code>map()</code>. If the return value is <code>true</code>, or a value
        that converts to <code>true</code>, then the element passed to the predicate is a member
        of the subset and is added to the array that will become the return value.
        Examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">1</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">)</code>         <code class="c1">// =&gt; [2, 1]; values less than 3</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">filter</code><code class="p">((</code><code class="nx">x</code><code class="p">,</code><code class="nx">i</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">i</code><code class="o">%</code><code class="mi">2</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="c1">// =&gt; [5, 3, 1]; every other value</code></pre>
        
        <p>Note that <code>filter()</code> skips missing elements in sparse arrays and that its
        return value is always dense. To close the gaps in a sparse array, you can do
        this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">dense</code> <code class="o">=</code> <code class="nx">sparse</code><code class="p">.</code><code class="nx">filter</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="kc">true</code><code class="p">);</code></pre>
        
        <p>And to close gaps and remove undefined and null elements, you can use <code>filter</code>,
        like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">a</code> <code class="o">=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">!==</code> <code class="kc">undefined</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">!==</code> <code class="kc">null</code><code class="p">);</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="find() and findIndex()"><div class="sect3" id="arrayfind">
        <h3>find() and findIndex()</h3>
        
        <p>The<a data-type="indexterm" data-primary="array iterator methods" data-secondary="find() and findIndex()" id="idm46198545956888"></a><a data-type="indexterm" data-primary="find() method" id="idm46198545955496"></a><a data-type="indexterm" data-primary="findIndex() method" id="idm46198545954824"></a> <code>find()</code> and <code>findIndex()</code> methods are like <code>filter()</code> in that
        they iterate through your array looking for elements for which your
        predicate function returns a truthy value. Unlike <code>filter()</code>, however,
        these two methods stop iterating the first time the predicate finds an
        element. When that happens, <code>find()</code> returns the
        matching element, and <code>findIndex()</code> returns the index of the matching
        element. If no matching element is found, <code>find()</code> returns <code>undefined</code>
        and <code>findIndex()</code> returns <code>-1</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">findIndex</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">===</code> <code class="mi">3</code><code class="p">)</code>  <code class="c1">// =&gt; 2; the value 3 appears at index 2</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">findIndex</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code>    <code class="c1">// =&gt; -1; no negative numbers in the array</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">5</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code>   <code class="c1">// =&gt; 5: this is a multiple of 5</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">7</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code>   <code class="c1">// =&gt; undefined: no multiples of 7 in the array</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="every() and some()"><div class="sect3" id="arrayevery">
        <h3>every() and some()</h3>
        
        <p>The<a data-type="indexterm" data-primary="array iterator methods" data-secondary="every() and some()" id="idm46198545814920"></a><a data-type="indexterm" data-primary="every() method" id="idm46198545813912"></a><a data-type="indexterm" data-primary="some() method" id="idm46198545813240"></a> <code>every()</code> and <code>some()</code> methods are array predicates: they apply a predicate
        function you specify to the elements of the array, then return <code>true</code> or
        <code>false</code>.</p>
        
        <p>The <code>every()</code> method is like the mathematical “for all” quantifier ∀: it
        returns <code>true</code> if and only if your predicate function returns <code>true</code> for all
        elements in the array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">every</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">)</code>      <code class="c1">// =&gt; true: all values are &lt; 10.</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">every</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="c1">// =&gt; false: not all values are even.</code></pre>
        
        <p>The <code>some()</code> method is like the mathematical “there exists” quantifier ∃: it
        returns <code>true</code> if there exists at least one element in the array for which the
        predicate returns <code>true</code> and returns <code>false</code> if and only if the predicate
        returns <code>false</code> for all elements of the array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">some</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">%</code><code class="mi">2</code><code class="o">===</code><code class="mi">0</code><code class="p">)</code>  <code class="c1">// =&gt; true; a has some even numbers.</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">some</code><code class="p">(</code><code class="nb">isNaN</code><code class="p">)</code>         <code class="c1">// =&gt; false; a has no non-numbers.</code></pre>
        
        <p>Note that both <code>every()</code> and <code>some()</code> stop iterating array elements as soon as
        they know what value to return. <code>some()</code> returns <code>true</code> the first time your
        predicate returns &lt;code&gt;true&lt;/code&gt; and only iterates through the entire array if your
        predicate always returns <code>false</code>. <code>every()</code> is the opposite: it returns <code>false</code>
        the first time your predicate returns <code>false</code> and only iterates all elements
        if your predicate always returns <code>true</code>. Note also that, by mathematical
        convention, <code>every()</code> returns <code>true</code> and <code>some</code> returns <code>false</code> when invoked on
        an empty array.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="reduce() and reduceRight()"><div class="sect3" id="arrayreduce">
        <h3>reduce() and reduceRight()</h3>
        
        <p>The<a data-type="indexterm" data-primary="array iterator methods" data-secondary="reduce() and reduceRight()" id="idm46198545654280"></a><a data-type="indexterm" data-primary="reduce() method" id="idm46198545653256"></a><a data-type="indexterm" data-primary="reduceRight() method" id="idm46198545652584"></a> <code>reduce()</code> and <code>reduceRight()</code> methods combine the elements of an array,
        using the function you specify, to produce a single value. This is a common
        operation in functional programming and also goes by the names “inject” and
        “fold.” Examples help illustrate how it works:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">+</code><code class="nx">y</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>          <code class="c1">// =&gt; 15; the sum of the values</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">y</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>          <code class="c1">// =&gt; 120; the product of the values</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">reduce</code><code class="p">((</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">y</code><code class="p">)</code> <code class="o">?</code> <code class="nx">x</code> <code class="o">:</code> <code class="nx">y</code><code class="p">)</code> <code class="c1">// =&gt; 5; the largest of the values</code></pre>
        
        <p><code>reduce()</code> takes two arguments. The first is the function that performs the
        reduction operation. The task of this reduction function is to somehow combine
        or reduce two values into a single value and to return that reduced value. In
        the examples we’ve shown here, the functions combine two values by adding them,
        multiplying them, and choosing the largest. The second (optional) argument is
        an initial value to pass to the function.</p>
        
        <p>Functions used with <code>reduce()</code> are different than the functions used with
        <code>forEach()</code> and <code>map()</code>. The familiar value, index, and array values are passed
        as the second, third, and fourth arguments. The first argument is the
        accumulated result of the reduction so far. On the first call to the function,
        this first argument is the initial value you passed as the second argument to
        <code>reduce()</code>. On subsequent calls, it is the value returned by the previous
        invocation of the function. In the first example, the reduction function
        is first called with arguments 0 and 1. It adds these and returns 1. It is then
        called again with arguments 1 and 2 and returns 3. Next, it computes 3+3=6,
        then 6+4=10, and finally 10+5=15. This final value, 15, becomes the return
        value of <code>reduce()</code>.</p>
        
        <p>You may have noticed that the third call to <code>reduce()</code> in this example has only a single
        argument: there is no initial value specified. When you invoke <code>reduce()</code> like
        this with no initial value, it uses the first element of the array as the
        initial value. This means that the first call to the reduction function will
        have the first and second array elements as its first and second arguments. In
        the sum and product examples, we could have omitted the initial value
        argument.</p>
        
        <p>Calling <code>reduce()</code> on an empty array with no initial value argument causes a
        <span class="keep-together">TypeError</span>. If you call it with only one value—either an array with one element
        and no initial value or an empty array and an initial value—it simply returns
        that one value without ever calling the reduction function.</p>
        
        <p><code>reduceRight()</code> works just like <code>reduce()</code>, except that it processes the array
        from highest index to lowest (right-to-left), rather than from lowest to
        highest. You might want to do this if the reduction operation has right-to-left
        associativity, for example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Compute 2^(3^4).  Exponentiation has right-to-left precedence</code>
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">reduceRight</code><code class="p">((</code><code class="nx">acc</code><code class="p">,</code><code class="nx">val</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code><code class="nx">val</code><code class="p">,</code><code class="nx">acc</code><code class="p">))</code> <code class="c1">// =&gt; 2.4178516392292583e+24</code></pre>
        
        <p>Note that neither <code>reduce()</code> nor <code>reduceRight()</code> accepts an optional
        argument that specifies the <code>this</code> value on which the reduction
        function is to be invoked. The optional initial value argument takes
        its place. See the <code>Function.bind()</code> method (<a data-type="xref" href="ch08.html#bind">§8.7.5</a>) if you need
        your reduction function invoked as a method of a particular object.</p>
        
        <p>The examples shown so far have been numeric for simplicity, but
        <code>reduce()</code> and <code>reduceRight()</code> are not intended solely for
        mathematical computations. Any function that can combine two values
        (such as two objects) into one value of the same type can be used as a
        reduction function. On the other hand, algorithms expressed using
        array reductions can quickly become complex and hard to understand,
        and you may find that it is easier to read, write, and reason about
        your code if you use regular looping constructs to process your arrays.<a data-type="indexterm" data-primary="" data-startref="Aamethiter07" id="idm46198545519256"></a></p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.8.2 Flattening arrays with flat() and flatMap()"><div class="sect2" id="idm46198546224024">
        <h2>7.8.2 Flattening arrays with flat() and flatMap()</h2>
        
        <p>In<a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="flattening arrays" id="idm46198545516952"></a><a data-type="indexterm" data-primary="flat() method" id="idm46198545515672"></a><a data-type="indexterm" data-primary="flatMap() method" id="idm46198545515000"></a><a data-type="indexterm" data-primary="ES2019" data-secondary="flattening arrays" id="idm46198545514328"></a> ES2019, the <code>flat()</code> method creates and returns a new array that
        contains the same elements as the array it is called on, except that
        any elements that are themselves arrays are “flattened” into the
        returned array.  For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]].</code><code class="nx">flat</code><code class="p">()</code>    <code class="c1">// =&gt; [1, 2, 3]</code>
        <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">]]].</code><code class="nx">flat</code><code class="p">()</code>  <code class="c1">// =&gt; [1, 2, [3]]</code></pre>
        
        <p>When called with no arguments, <code>flat()</code> flattens one level of
        nesting. Elements of the original array that are themselves arrays are
        flattened, but array elements of <em>those</em> arrays are not flattened. If
        you want to flatten more levels, pass a number to <code>flat()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code> <code class="p">[</code><code class="mi">4</code><code class="p">]]]];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">flat</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>   <code class="c1">// =&gt; [1, 2, [3, [4]]]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">flat</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>   <code class="c1">// =&gt; [1, 2, 3, [4]]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">flat</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>   <code class="c1">// =&gt; [1, 2, 3, 4]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">flat</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>   <code class="c1">// =&gt; [1, 2, 3, 4]</code></pre>
        
        <p>The <code>flatMap()</code> method works just like the <code>map()</code> method
        (see <a data-type="xref" href="#arraymap">“map()”</a>) except that the returned array is automatically
        flattened as if passed to <code>flat()</code>. That is, calling <code>a.flatMap(f)</code> is
        the same as (but more efficient than) <code>a.map(f).flat()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">phrases</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"hello world"</code><code class="p">,</code> <code class="s2">"the definitive guide"</code><code class="p">];</code>
        <code class="kd">let</code> <code class="nx">words</code> <code class="o">=</code> <code class="nx">phrases</code><code class="p">.</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">phrase</code> <code class="o">=&gt;</code> <code class="nx">phrase</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">" "</code><code class="p">));</code>
        <code class="nx">words</code> <code class="c1">// =&gt; ["hello", "world", "the", "definitive", "guide"];</code></pre>
        
        <p>You can think of <code>flatMap()</code> as a generalization of <code>map()</code> that
        allows each element of the input array to map to any number of
        elements of the output array. In particular, <code>flatMap()</code> allows you to
        map input elements to an empty array, which flattens to nothing in the
        output array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Map non-negative numbers to their square roots</code>
        <code class="p">[</code><code class="o">-</code><code class="mi">2</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">].</code><code class="nx">flatMap</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">0</code> <code class="o">?</code> <code class="p">[]</code> <code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code> <code class="c1">// =&gt; [1, 2**0.5]</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.8.3 Adding arrays with concat()"><div class="sect2" id="arrayconcat">
        <h2>7.8.3 Adding arrays with concat()</h2>
        
        <p>The<a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="adding arrays" id="idm46198545241784"></a><a data-type="indexterm" data-primary="concat() method" id="idm46198545240504"></a> <code>concat()</code> method creates and returns a new array that contains the
        elements of the original array on which <code>concat()</code> was invoked, followed by
        each of the arguments to <code>concat()</code>. If any of these arguments is itself an
        array, then it is the array elements that are concatenated, not the array
        itself. Note, however, that <code>concat()</code> does not recursively flatten arrays of
        arrays. <code>concat()</code> does not modify the array on which it is invoked:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code>          <code class="c1">// =&gt; [1,2,3,4,5]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">concat</code><code class="p">([</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">],[</code><code class="mi">6</code><code class="p">,</code><code class="mi">7</code><code class="p">])</code>   <code class="c1">// =&gt; [1,2,3,4,5,6,7]; arrays are flattened</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="mi">4</code><code class="p">,</code> <code class="p">[</code><code class="mi">5</code><code class="p">,[</code><code class="mi">6</code><code class="p">,</code><code class="mi">7</code><code class="p">]])</code>  <code class="c1">// =&gt; [1,2,3,4,5,[6,7]]; but not nested arrays</code>
        <code class="nx">a</code>                       <code class="c1">// =&gt; [1,2,3]; the original array is unmodified</code></pre>
        
        <p>Note that <code>concat()</code> makes a new copy of the array it is called on. In
        many cases, this is the right thing to do, but it is an expensive
        operation. If you find yourself writing code like <code>a = a.concat(x)</code>,
        then you should think about modifying your array in place with
        <code>push()</code> or <code>splice()</code> instead of creating a new one.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.8.4 Stacks and Queues with push(), pop(), shift(), and unshift()"><div class="sect2" id="arraypush">
        <h2>7.8.4 Stacks and Queues with push(), pop(), shift(), and unshift()</h2>
        
        <p>The<a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="stacks and queues" id="idm46198545140856"></a><a data-type="indexterm" data-primary="push() method" id="idm46198545139192"></a><a data-type="indexterm" data-primary="pop() method" id="idm46198545138520"></a> <code>push()</code> and <code>pop()</code> methods allow you to work with arrays as if
        they were stacks. The <code>push()</code> method appends one or more new elements
        to the end of an array and returns the new length of the array. Unlike
        <code>concat()</code>, <code>push()</code> does not flatten array arguments. The <code>pop()</code> method does
        the reverse: it deletes the last element of an array, decrements the
        array length, and returns the value that it removed. Note that both
        methods modify the array in place. The combination of <code>push()</code> and
        <code>pop()</code> allows you to use a JavaScript array to implement a first-in,
        last-out stack. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">stack</code> <code class="o">=</code> <code class="p">[];</code>       <code class="c1">// stack == []</code>
        <code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">);</code>      <code class="c1">// stack == [1,2];</code>
        <code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">();</code>          <code class="c1">// stack == [1]; returns 2</code>
        <code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>        <code class="c1">// stack == [1,3]</code>
        <code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">();</code>          <code class="c1">// stack == [1]; returns 3</code>
        <code class="nx">stack</code><code class="p">.</code><code class="nx">push</code><code class="p">([</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">]);</code>    <code class="c1">// stack == [1,[4,5]]</code>
        <code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>           <code class="c1">// stack == [1]; returns [4,5]</code>
        <code class="nx">stack</code><code class="p">.</code><code class="nx">pop</code><code class="p">();</code>          <code class="c1">// stack == []; returns 1</code></pre>
        
        <p>The <code>push()</code> method does not flatten an array you pass to it, but if
        you want to push all of the elements from one array onto another
        array, you can use the spread operator
        (<a data-type="xref" href="ch08.html#spread-operator-for-functions">§8.3.4</a>) to flatten it explicitly:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(...</code><code class="nx">values</code><code class="p">);</code></pre>
        
        <p>The<a data-type="indexterm" data-primary="unshift() method" id="idm46198545074232"></a><a data-type="indexterm" data-primary="shift() method" id="idm46198545073208"></a> <code>unshift()</code> and <code>shift()</code> methods behave much like <code>push()</code> and
        <code>pop()</code>, except that they insert and remove elements from the
        beginning of an array rather than from the end. <code>unshift()</code> adds an
        element or elements to the beginning of the array, shifts the existing
        array elements up to higher indexes to make room, and returns the new
        length of the array. <code>shift()</code> removes and returns the first element
        of the array, shifting all subsequent elements down one place to
        occupy the newly vacant space at the start of the array. You could use
        <code>unshift()</code> and <code>shift()</code> to implement a stack, but it would be less
        efficient than using <code>push()</code> and <code>pop()</code> because the array elements
        need to be shifted up or down every time an element is added or
        removed at the start of the array. Instead, though, you can implement
        a queue data structure by using <code>push()</code> to add elements at the end of
        an array and <code>shift()</code> to remove them from the start of the array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">q</code> <code class="o">=</code> <code class="p">[];</code>            <code class="c1">// q == []</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">);</code>           <code class="c1">// q == [1,2]</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">shift</code><code class="p">();</code>             <code class="c1">// q == [2]; returns 1</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>              <code class="c1">// q == [2, 3]</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">shift</code><code class="p">()</code>              <code class="c1">// q == [3]; returns 2</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">shift</code><code class="p">()</code>              <code class="c1">// q == []; returns 3</code></pre>
        
        <p>There is one feature of <code>unshift()</code> that is worth calling out because
        you may find it surprising. When passing multiple arguments to <code>unshift()</code>,
        they are inserted all at once, which means that they end up in the
        array in a different order than they would be if you inserted them one
        at a time:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[];</code>            <code class="c1">// a == []</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">unshift</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>           <code class="c1">// a == [1]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">unshift</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>           <code class="c1">// a == [2, 1]</code>
        <code class="nx">a</code> <code class="o">=</code> <code class="p">[];</code>                <code class="c1">// a == []</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">unshift</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">)</code>         <code class="c1">// a == [1, 2]</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.8.5 Subarrays with slice(), splice(), fill(), and copyWithin()"><div class="sect2" id="idm46198545142360">
        <h2>7.8.5 Subarrays with slice(), splice(), fill(), and copyWithin()</h2>
        
        <p>Arrays<a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="subarrays" id="idm46198544893064"></a><a data-type="indexterm" data-primary="subarrays" id="idm46198544891816"></a> define a number of methods that work on contiguous regions, or
        subarrays or “slices” of an array. The following sections describe
        methods for extracting, replacing, filling, and copying slices.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="slice()"><div class="sect3" id="arrayslice">
        <h3>slice()</h3>
        
        <p>The<a data-type="indexterm" data-primary="slice() method" id="idm46198544889112"></a> <code>slice()</code> method returns a <em>slice</em>, or subarray, of the specified
        array. Its two arguments specify the start and end of the slice to be returned.
        The returned array contains the element specified by the first argument and all
        subsequent elements up to, but not including, the element specified by the
        second argument. If only one argument is specified, the returned array contains
        all elements from the start position to the end of the array. If either
        argument is negative, it specifies an array element relative to the length
        of the array. An argument of –1, for example, specifies the last
        element in the array, and an argument of –2 specifies the element
        before that one. Note that <code>slice()</code> does not modify the array on which it
        is invoked. Here are some <span class="keep-together">examples:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>    <code class="c1">// Returns [1,2,3]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">3</code><code class="p">);</code>      <code class="c1">// Returns [4,5]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="o">-</code><code class="mi">1</code><code class="p">);</code>   <code class="c1">// Returns [2,3,4]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="o">-</code><code class="mi">3</code><code class="p">,</code><code class="o">-</code><code class="mi">2</code><code class="p">);</code>  <code class="c1">// Returns [3]</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="splice()"><div class="sect3" id="arraysplice">
        <h3>splice()</h3>
        
        <p><code>splice()</code> is<a data-type="indexterm" data-primary="splice() method" id="idm46198544818680"></a> a general-purpose method for inserting or removing
        elements from an array. Unlike <code>slice()</code> and <code>concat()</code>, <code>splice()</code>
        modifies the array on which it is invoked. Note that <code>splice()</code> and
        <code>slice()</code> have very similar names but perform substantially different
        operations.</p>
        
        <p><code>splice()</code> can delete elements from an array, insert new elements into
        an array, or perform both operations at the same time. Elements of the
        array that come after the insertion or deletion point have their
        indexes increased or decreased as necessary so that they remain
        contiguous with the rest of the array. The first argument to
        <code>splice()</code> specifies the array position at which the insertion and/or
        deletion is to begin. The second argument specifies the number of
        elements that should be deleted from (spliced out of) the array. (Note
        that this is another difference between these two methods. The second
        argument to <code>slice()</code> is an end position. The second argument to
        <code>splice()</code> is a length.) If this second argument is omitted, all array
        elements from the start element to the end of the array are
        removed. <code>splice()</code> returns an array of the deleted elements, or an
        empty array if no elements were deleted. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">6</code><code class="p">,</code><code class="mi">7</code><code class="p">,</code><code class="mi">8</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">splice</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>    <code class="c1">// =&gt; [5,6,7,8]; a is now [1,2,3,4]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">splice</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">)</code>  <code class="c1">// =&gt; [2,3]; a is now [1,4]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">splice</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">)</code>  <code class="c1">// =&gt; [4]; a is now [1]</code></pre>
        
        <p>The first two arguments to <code>splice()</code> specify which array elements are to be
        deleted. These arguments may be followed by any number of additional arguments
        that specify elements to be inserted into the array, starting at the position
        specified by the first argument. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">splice</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">0</code><code class="p">,</code><code class="s2">"a"</code><code class="p">,</code><code class="s2">"b"</code><code class="p">)</code>  <code class="c1">// =&gt; []; a is now [1,2,"a","b",3,4,5]</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">splice</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">2</code><code class="p">,[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">],</code><code class="mi">3</code><code class="p">)</code>  <code class="c1">// =&gt; ["a","b"]; a is now [1,2,[1,2],3,3,4,5]</code></pre>
        
        <p>Note that, unlike <code>concat()</code>, <code>splice()</code> inserts arrays themselves, not the
        elements of those arrays.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="fill()"><div class="sect3" id="arrayfill">
        <h3>fill()</h3>
        
        <p>The<a data-type="indexterm" data-primary="fill() method" id="idm46198544693896"></a> <code>fill()</code> method sets the elements of an array, or a slice of an
        array, to a specified value. It mutates the array it is called on, and
        also returns the modified array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Array</code><code class="p">(</code><code class="mi">5</code><code class="p">);</code>   <code class="c1">// Start with no elements and length 5</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">fill</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>               <code class="c1">// =&gt; [0,0,0,0,0]; fill the array with zeros</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">fill</code><code class="p">(</code><code class="mi">9</code><code class="p">,</code> <code class="mi">1</code><code class="p">)</code>            <code class="c1">// =&gt; [0,9,9,9,9]; fill with 9 starting at index 1</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">fill</code><code class="p">(</code><code class="mi">8</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">)</code>        <code class="c1">// =&gt; [0,9,8,8,9]; fill with 8 at indexes 2, 3</code></pre>
        
        <p>The first argument to <code>fill()</code> is the value to set array elements
        to. The optional second argument specifies the starting index. If
        omitted, filling starts at index 0. The optional third argument
        specifies the ending index—array elements up to, but not including,
        this index will be filled. If this argument is omitted, then the array
        is filled from the start index to the end. You can specify indexes
        relative to the end of the array by passing negative numbers, just as
        you can for <code>slice()</code>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="copyWithin()"><div class="sect3" id="arraycopywithin">
        <h3>copyWithin()</h3>
        
        <p><code>copyWithin()</code> copies<a data-type="indexterm" data-primary="copyWithin() method" id="idm46198544554856"></a> a slice of an array to a new position within the
        array. It modifies the array in place and returns the modified array,
        but it will not change the length of the array. The first argument
        specifies the destination index to which the first element will be
        copied. The second argument specifies the index of the first element
        to be copied. If this second argument is omitted, 0 is used. The third
        argument specifies the end of the slice of elements to be copied. If
        omitted, the length of the array is used. Elements from the start
        index up to, but not including, the end index will be copied. You can
        specify indexes relative to the end of the array by passing negative
        numbers, just as you can for <code>slice()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">copyWithin</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>       <code class="c1">// =&gt; [1,1,2,3,4]: copy array elements up one</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">copyWithin</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">5</code><code class="p">)</code> <code class="c1">// =&gt; [1,1,3,4,4]: copy last 2 elements to index 2</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">copyWithin</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code> <code class="o">-</code><code class="mi">2</code><code class="p">)</code>   <code class="c1">// =&gt; [4,4,3,4,4]: negative offsets work, too</code></pre>
        
        <p><code>copyWithin()</code> is intended as a high-performance method that is
        particularly useful with typed arrays (see <a data-type="xref" href="ch11.html#typedarrays">§11.2</a>). It is
        modeled after the <code>memmove()</code> function from the C standard
        library. Note that the copy will work correctly even if there is
        overlap between the source and destination regions.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.8.6 Array Searching and Sorting Methods"><div class="sect2" id="arraysearchandsort">
        <h2>7.8.6 Array Searching and Sorting Methods</h2>
        
        <p>Arrays<a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="searching and sorting" id="Aamethsearch07"></a> implement <code>indexOf()</code>, <code>lastIndexOf()</code>, and <code>includes()</code> methods
        that are similar to the same-named methods of strings. There are also
        <code>sort()</code> and <code>reverse()</code> methods for reordering the elements of an
        array. These methods are described in the subsections that follow.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="indexOf() and lastIndexOf()"><div class="sect3" id="arrayindexof">
        <h3>indexOf() and lastIndexOf()</h3>
        
        <p><code>indexOf()</code> and<a data-type="indexterm" data-primary="indexOf() method" id="idm46198544480904"></a><a data-type="indexterm" data-primary="lastIndexOf() method" id="idm46198544480168"></a> <code>lastIndexOf()</code> search an array for an element with a
        specified value and return the index of the first such element found,
        or <code>-1</code> if none is found. <code>indexOf()</code> searches the array from
        beginning to end, and <code>lastIndexOf()</code> searches from end to beginning:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">0</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>       <code class="c1">// =&gt; 1: a[1] is 1</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">lastIndexOf</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>   <code class="c1">// =&gt; 3: a[3] is 1</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>       <code class="c1">// =&gt; -1: no element has value 3</code></pre>
        
        <p><code>indexOf()</code> and <code>lastIndexOf()</code> compare their argument to the array
        elements using the equivalent of the <code>===</code> operator. If your array
        contains objects instead of primitive values, these methods check to
        see if two references both refer to exactly the same object. If you
        want to actually look at the content of an object, try using the
        <code>find()</code> method with your own custom predicate function instead.</p>
        
        <p><code>indexOf()</code> and <code>lastIndexOf()</code> take an optional second argument that
        specifies the array index at which to begin the search. If this
        argument is omitted, <code>indexOf()</code> starts at the beginning and
        <code>lastIndexOf()</code> starts at the end. Negative values are allowed for the
        second argument and are treated as an offset from the end of the
        array, as they are for the <code>slice()</code> method: a value of –1, for
        example, specifies the last element of the array.</p>
        
        <p>The following function searches an array for a specified value and returns an
        array of <em>all</em> matching indexes. This demonstrates how the second argument to
        <code>indexOf()</code> can be used to find matches beyond the first.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Find all occurrences of a value x in an array a and return an array</code>
        <code class="c1">// of matching indexes</code>
        <code class="kd">function</code> <code class="nx">findall</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">results</code> <code class="o">=</code> <code class="p">[],</code>            <code class="c1">// The array of indexes we'll return</code>
                <code class="nx">len</code> <code class="o">=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">,</code>          <code class="c1">// The length of the array to be searched</code>
                <code class="nx">pos</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>                 <code class="c1">// The position to search from</code>
            <code class="k">while</code><code class="p">(</code><code class="nx">pos</code> <code class="o">&lt;</code> <code class="nx">len</code><code class="p">)</code> <code class="p">{</code>           <code class="c1">// While more elements to search...</code>
                <code class="nx">pos</code> <code class="o">=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">pos</code><code class="p">);</code> <code class="c1">// Search</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">pos</code> <code class="o">===</code> <code class="o">-</code><code class="mi">1</code><code class="p">)</code> <code class="k">break</code><code class="p">;</code>   <code class="c1">// If nothing found, we're done.</code>
                <code class="nx">results</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">pos</code><code class="p">);</code>       <code class="c1">// Otherwise, store index in array</code>
                <code class="nx">pos</code> <code class="o">=</code> <code class="nx">pos</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>           <code class="c1">// And start next search at next element</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">results</code><code class="p">;</code>              <code class="c1">// Return array of indexes</code>
        <code class="p">}</code></pre>
        
        <p>Note that strings have <code>indexOf()</code> and <code>lastIndexOf()</code> methods that work like
        these array methods, except that a negative second argument is treated as zero.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="includes()"><div class="sect3" id="arrayincludes">
        <h3>includes()</h3>
        
        <p>The<a data-type="indexterm" data-primary="includes() method" id="idm46198544297352"></a><a data-type="indexterm" data-primary="ES2016" data-secondary="includes() method" id="idm46198544296616"></a> ES2016 <code>includes()</code> method takes a single argument and returns
        <code>true</code> if the array contains that value or <code>false</code> otherwise. It does
        not tell you the index of the value, only whether it exists. The
        <code>includes()</code> method is effectively a set membership test for
        arrays. Note, however, that arrays are not an efficient representation
        for sets, and if you are working with more than a few elements, you
        should use a real Set object (<a data-type="xref" href="ch11.html#setclass">§11.1.1</a>).</p>
        
        <p>The <code>includes()</code> method is slightly different than the <code>indexOf()</code>
        method in one important way. <code>indexOf()</code> tests equality using the same
        algorithm that the <code>===</code> operator does, and that equality algorithm
        considers the not-a-number value to be different from every other
        value, including itself. <code>includes()</code> uses a slightly different version of
        equality that does consider <code>NaN</code> to be equal to itself.  This means
        that <code>indexOf()</code> will not detect the <code>NaN</code> value in an array, but
        <code>includes()</code> will:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="kc">true</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="kc">NaN</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="kc">true</code><code class="p">)</code>            <code class="c1">// =&gt; true</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>               <code class="c1">// =&gt; false</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="kc">NaN</code><code class="p">)</code>             <code class="c1">// =&gt; true</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="kc">NaN</code><code class="p">)</code>              <code class="c1">// =&gt; -1; indexOf can't find NaN</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="sort()"><div class="sect3" id="arraysort">
        <h3>sort()</h3>
        
        <p><code>sort()</code> sorts<a data-type="indexterm" data-primary="sort() method" id="idm46198544164424"></a> the elements of an array in place and returns the sorted
        array. When <code>sort()</code> is called with no arguments, it sorts the array elements
        in alphabetical order (temporarily converting them to strings to perform the
        comparison, if necessary):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"banana"</code><code class="p">,</code> <code class="s2">"cherry"</code><code class="p">,</code> <code class="s2">"apple"</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">sort</code><code class="p">();</code> <code class="c1">// a == ["apple", "banana", "cherry"]</code></pre>
        
        <p>If an array contains undefined elements, they are sorted to the end of the
        array.</p>
        
        <p>To sort an array into some order other than alphabetical, you must pass a
        comparison function as an argument to <code>sort()</code>. This function decides which of
        its two arguments should appear first in the sorted array. If the first
        argument should appear before the second, the comparison function should return
        a number less than zero. If the first argument should appear after the second
        in the sorted array, the function should return a number greater than zero. And
        if the two values are equivalent (i.e., if their order is irrelevant), the
        comparison function should return 0. So, for example, to sort array elements
        into numerical rather than alphabetical order, you might do this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">33</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">1111</code><code class="p">,</code> <code class="mi">222</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">sort</code><code class="p">();</code>               <code class="c1">// a == [1111, 222, 33, 4]; alphabetical order</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">sort</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code class="nx">b</code><code class="p">)</code> <code class="p">{</code>  <code class="c1">// Pass a comparator function</code>
            <code class="k">return</code> <code class="nx">a</code><code class="o">-</code><code class="nx">b</code><code class="p">;</code>         <code class="c1">// Returns &lt; 0, 0, or &gt; 0, depending on order</code>
        <code class="p">});</code>                     <code class="c1">// a == [4, 33, 222, 1111]; numerical order</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">sort</code><code class="p">((</code><code class="nx">a</code><code class="p">,</code><code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">b</code><code class="o">-</code><code class="nx">a</code><code class="p">);</code>   <code class="c1">// a == [1111, 222, 33, 4]; reverse numerical order</code></pre>
        
        <p>As another example of sorting array items, you might perform a case-insensitive
        alphabetical sort on an array of strings by passing a comparison function that
        converts both of its arguments to lowercase (with the <code>toLowerCase()</code> method)
        before comparing them:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"ant"</code><code class="p">,</code> <code class="s2">"Bug"</code><code class="p">,</code> <code class="s2">"cat"</code><code class="p">,</code> <code class="s2">"Dog"</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">sort</code><code class="p">();</code>    <code class="c1">// a == ["Bug","Dog","ant","cat"]; case-sensitive sort</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">sort</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">s</code><code class="p">,</code><code class="nx">t</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">s</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">();</code>
            <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">t</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">();</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">&lt;</code> <code class="nx">b</code><code class="p">)</code> <code class="k">return</code> <code class="o">-</code><code class="mi">1</code><code class="p">;</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">&gt;</code> <code class="nx">b</code><code class="p">)</code> <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
            <code class="k">return</code> <code class="mi">0</code><code class="p">;</code>
        <code class="p">});</code>   <code class="c1">// a == ["ant","Bug","cat","Dog"]; case-insensitive sort</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="reverse()"><div class="sect3" id="arrayreverse">
        <h3>reverse()</h3>
        
        <p>The <code>reverse()</code> method<a data-type="indexterm" data-primary="reverse() method" id="idm46198544020072"></a> reverses the order of the elements of an array and
        returns the reversed array. It does this in place; in other words, it
        doesn’t
        create a new array with the elements rearranged but instead rearranges them in
        the already existing<a data-type="indexterm" data-primary="" data-startref="Aamethsearch07" id="idm46198544018968"></a> array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">reverse</code><code class="p">();</code>   <code class="c1">// a == [3,2,1]</code></pre>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.8.7 Array to String Conversions"><div class="sect2" id="arrayjoin">
        <h2>7.8.7 Array to String Conversions</h2>
        
        <p>The<a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="array to string conversions" id="idm46198543994360"></a><a data-type="indexterm" data-primary="strings" data-secondary="array to string conversions" id="idm46198543993112"></a> Array class defines three methods that can convert arrays to
        strings, which is generally something you might do when creating log
        and error messages. (If you want to save the contents of an array in
        textual form for later reuse, serialize the array with
        <code>JSON.stringify()</code> [<a data-type="xref" href="ch06.html#serializingobjects">§6.8</a>] instead of using the
        methods described here.)</p>
        
        <p>The<a data-type="indexterm" data-primary="join() method" id="idm46198543982712"></a> <code>join()</code> method converts all the elements of an array to strings
        and concatenates them, returning the resulting string. You can specify
        an optional string that separates the elements in the resulting
        string. If no separator string is specified, a comma is used:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">join</code><code class="p">()</code>               <code class="c1">// =&gt; "1,2,3"</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">" "</code><code class="p">)</code>            <code class="c1">// =&gt; "1 2 3"</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">""</code><code class="p">)</code>             <code class="c1">// =&gt; "123"</code>
        <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Array</code><code class="p">(</code><code class="mi">10</code><code class="p">);</code> <code class="c1">// An array of length 10 with no elements</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"-"</code><code class="p">)</code>            <code class="c1">// =&gt; "---------": a string of 9 hyphens</code></pre>
        
        <p>The <code>join()</code> method is the inverse of the <code>String.split()</code> method, which
        creates an array by breaking a string into pieces.</p>
        
        <p>Arrays, like all JavaScript objects, have a <code>toString()</code> method. For
        an array, this method works just like the <code>join()</code> method with no
        arguments:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">].</code><code class="nx">toString</code><code class="p">()</code>          <code class="c1">// =&gt; "1,2,3"</code>
        <code class="p">[</code><code class="s2">"a"</code><code class="p">,</code> <code class="s2">"b"</code><code class="p">,</code> <code class="s2">"c"</code><code class="p">].</code><code class="nx">toString</code><code class="p">()</code>  <code class="c1">// =&gt; "a,b,c"</code>
        <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code><code class="s2">"c"</code><code class="p">]].</code><code class="nx">toString</code><code class="p">()</code>     <code class="c1">// =&gt; "1,2,c"</code></pre>
        
        <p>Note that the output does not include square brackets or any other
        sort of delimiter around the array value.</p>
        
        <p><code>toLocaleString()</code> is<a data-type="indexterm" data-primary="toLocaleString() method" id="idm46198543799304"></a> the localized version of <code>toString()</code>. It
        converts each array element to a string by calling the
        <code>toLocaleString()</code> method of the element, and then it concatenates the
        resulting strings using a locale-specific (and implementation-defined)
        separator string.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="7.8.8 Static Array Functions"><div class="sect2" id="arrayisarray">
        <h2>7.8.8 Static Array Functions</h2>
        
        <p>In<a data-type="indexterm" data-primary="arrays" data-secondary="array methods" data-tertiary="static array functions" id="idm46198543795608"></a><a data-type="indexterm" data-primary="functions" data-secondary="static array functions" id="idm46198543794328"></a><a data-type="indexterm" data-primary="Array.of() function" id="idm46198543793384"></a><a data-type="indexterm" data-primary="Array.from() function" id="idm46198543792712"></a><a data-type="indexterm" data-primary="Array.isArray() function" id="idm46198543792040"></a> addition to the array methods we’ve already documented, the Array class
        also defines three static functions that you can invoke through the
        <code>Array</code> constructor rather than on arrays. <code>Array.of()</code> and
        <code>Array.from()</code> are factory methods for creating new arrays. They were
        documented in <a data-type="xref" href="#arrayof">§7.1.4</a> and <a data-type="xref" href="#arrayfrom">§7.1.5</a>.</p>
        
        <p>The one other static array function is <code>Array.isArray()</code>, which is
        useful for determining whether an unknown value is an array or not:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">([])</code>     <code class="c1">// =&gt; true</code>
        <code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">({})</code>     <code class="c1">// =&gt; false</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.9 Array-Like Objects"><div class="sect1" id="arraylike">
        <h1>7.9 Array-Like Objects</h1>
        
        <p>As<a data-type="indexterm" data-primary="arrays" data-secondary="array-like objects" id="Alike07"></a><a data-type="indexterm" data-primary="objects" data-secondary="array-like objects" id="Oarray07"></a> we’ve seen, JavaScript arrays have some special features that other objects
        do not have:</p>
        
        <ul>
        <li>
        <p>The <code>length</code> property is automatically updated as new elements are added to
        the list.</p>
        </li>
        <li>
        <p>Setting <code>length</code> to a smaller value truncates the array.</p>
        </li>
        <li>
        <p>Arrays<a data-type="indexterm" data-primary="Array.prototype" id="idm46198543754504"></a> inherit useful methods from <code>Array.prototype</code>.</p>
        </li>
        <li>
        <p><code>Array.isArray()</code> returns <code>true</code> for arrays.</p>
        </li>
        </ul>
        
        <p>These are the features that make JavaScript arrays distinct from regular
        objects. But they are not the essential features that define an array. It is
        often perfectly reasonable to treat any object with a numeric <code>length</code> property
        and corresponding non-negative integer properties as a kind of array.</p>
        
        <p>These “array-like” objects actually do occasionally appear in practice, and
        although you cannot directly invoke array methods on them or expect special
        behavior from the <code>length</code> property, you can still iterate through them with
        the same code you’d use for a true array. It turns out that many array
        algorithms work just as well with array-like objects as they do with real
        arrays. This is especially true if your algorithms treat the array as read-only
        or if they at least leave the array length unchanged.</p>
        
        <p>The following code takes a regular object, adds properties to make it an
        array-like object, and then iterates through the “elements” of the resulting
        pseudo-array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">{};</code>  <code class="c1">// Start with a regular empty object</code>
        
        <code class="c1">// Add properties to make it "array-like"</code>
        <code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="k">while</code><code class="p">(</code><code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">i</code> <code class="o">*</code> <code class="nx">i</code><code class="p">;</code>
            <code class="nx">i</code><code class="o">++</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="nx">i</code><code class="p">;</code>
        
        <code class="c1">// Now iterate through it as if it were a real array</code>
        <code class="kd">let</code> <code class="nx">total</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">j</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">j</code> <code class="o">&lt;</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">j</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">total</code> <code class="o">+=</code> <code class="nx">a</code><code class="p">[</code><code class="nx">j</code><code class="p">];</code>
        <code class="p">}</code></pre>
        
        <p>In client-side JavaScript, a number of methods for working with HTML
        documents (such as <code>document.querySelectorAll()</code>, for example) return
        array-like objects. Here’s a function you might use to test for
        objects that work like arrays:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Determine if o is an array-like object.</code>
        <code class="c1">// Strings and functions have numeric length properties, but are</code>
        <code class="c1">// excluded by the typeof test. In client-side JavaScript, DOM text</code>
        <code class="c1">// nodes have a numeric length property, and may need to be excluded</code>
        <code class="c1">// with an additional o.nodeType !== 3 test.</code>
        <code class="kd">function</code> <code class="nx">isArrayLike</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">o</code> <code class="o">&amp;&amp;</code>                            <code class="c1">// o is not null, undefined, etc.</code>
                <code class="k">typeof</code> <code class="nx">o</code> <code class="o">===</code> <code class="s2">"object"</code> <code class="o">&amp;&amp;</code>        <code class="c1">// o is an object</code>
                <code class="nb">Number</code><code class="p">.</code><code class="nb">isFinite</code><code class="p">(</code><code class="nx">o</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="o">&amp;&amp;</code>    <code class="c1">// o.length is a finite number</code>
                <code class="nx">o</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;=</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code>                <code class="c1">// o.length is non-negative</code>
                <code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="nx">o</code><code class="p">.</code><code class="nx">length</code><code class="p">)</code> <code class="o">&amp;&amp;</code>   <code class="c1">// o.length is an integer</code>
                <code class="nx">o</code><code class="p">.</code><code class="nx">length</code> <code class="o">&lt;</code> <code class="mi">4294967295</code><code class="p">)</code> <code class="p">{</code>        <code class="c1">// o.length &lt; 2^32 - 1</code>
                <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>                    <code class="c1">// Then o is array-like.</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>                   <code class="c1">// Otherwise it is not.</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>We’ll see in a later section that strings behave like arrays. Nevertheless,
        tests like this one for array-like objects typically return <code>false</code> for
        strings—they are usually best handled as strings, not as arrays.</p>
        
        <p>Most JavaScript array methods are purposely defined to be generic so
        that they work correctly when applied to array-like objects in
        addition to true arrays.  Since array-like objects do not inherit from
        <code>Array.prototype</code>, you cannot invoke array methods on them
        directly. You can invoke them indirectly using the <code>Function.call</code>
        method, however (see <a data-type="xref" href="ch08.html#applyandcall">§8.7.4</a> for details):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">{</code><code class="s2">"0"</code><code class="o">:</code> <code class="s2">"a"</code><code class="p">,</code> <code class="s2">"1"</code><code class="o">:</code> <code class="s2">"b"</code><code class="p">,</code> <code class="s2">"2"</code><code class="o">:</code> <code class="s2">"c"</code><code class="p">,</code> <code class="nx">length</code><code class="o">:</code> <code class="mi">3</code><code class="p">};</code> <code class="c1">// An array-like object</code>
        <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">join</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="s2">"+"</code><code class="p">)</code>                  <code class="c1">// =&gt; "a+b+c"</code>
        <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">())</code>  <code class="c1">// =&gt; ["A","B","C"]</code>
        <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">slice</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="mi">0</code><code class="p">)</code>   <code class="c1">// =&gt; ["a","b","c"]: true array copy</code>
        <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code>                      <code class="c1">// =&gt; ["a","b","c"]: easier array copy</code></pre>
        
        <p>The second-to-last line of this code invokes the Array <code>slice()</code>
        method on an array-like object in order to copy the elements of that
        object into a true array object. This is an idiomatic trick that
        exists in much legacy code, but is now much easier to<a data-type="indexterm" data-primary="" data-startref="Oarray07" id="idm46198543501160"></a><a data-type="indexterm" data-primary="" data-startref="Alike07" id="idm46198543378600"></a> do with
        <code>Array.from()</code>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.10 Strings as Arrays"><div class="sect1" id="stringarrays">
        <h1>7.10 Strings as Arrays</h1>
        
        <p>JavaScript<a data-type="indexterm" data-primary="strings" data-secondary="strings as arrays" id="idm46198543375304"></a><a data-type="indexterm" data-primary="arrays" data-secondary="strings as arrays" id="idm46198543374296"></a><a data-type="indexterm" data-primary="charAt() method" id="idm46198543373352"></a><a data-type="indexterm" data-primary="[] (square brackets)" id="idm46198543372680"></a><a data-type="indexterm" data-primary="square brackets ([])" id="idm46198543372008"></a> strings behave like read-only arrays of UTF-16 Unicode
        characters. Instead of accessing individual characters with the
        <code>charAt()</code> method, you can use square brackets:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="s2">"test"</code><code class="p">;</code>
        <code class="nx">s</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>    <code class="c1">// =&gt; "t"</code>
        <code class="nx">s</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>           <code class="c1">// =&gt; "e"</code></pre>
        
        <p>The <code>typeof</code> operator still returns “string” for strings, of course, and the
        <code>Array.isArray()</code> method returns <code>false</code> if you pass it a string.</p>
        
        <p>The primary benefit of indexable strings is simply that we can replace calls to
        <code>charAt()</code> with square brackets, which are more concise and readable, and
        potentially more efficient. The fact that strings behave like arrays also
        means, however, that we can apply generic array methods to them. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">join</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="s2">"JavaScript"</code><code class="p">,</code> <code class="s2">" "</code><code class="p">)</code>  <code class="c1">// =&gt; "J a v a S c r i p t"</code></pre>
        
        <p>Keep in mind that strings are immutable values, so when they are treated as
        arrays, they are read-only arrays. Array methods like <code>push()</code>, <code>sort()</code>,
        <code>reverse()</code>, and <code>splice()</code> modify an array in place and do not work on
        strings. Attempting to modify a string using an array method does not, however,
        cause an error: it simply fails silently.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="7.11 Summary"><div class="sect1" id="idm46198543341496">
        <h1>7.11 Summary</h1>
        
        <p>This chapter has covered JavaScript arrays in depth, including
        esoteric details about sparse arrays and array-like objects. The main
        points to take from this chapter are:</p>
        
        <ul>
        <li>
        <p>Array literals are written as comma-separated lists of values within
        square <span class="keep-together">brackets.</span></p>
        </li>
        <li>
        <p>Individual array elements are accessed by specifying the desired
        array index within square brackets.</p>
        </li>
        <li>
        <p>The <code>for/of</code> loop and <code>...</code> spread operator introduced in ES6 are
        particularly useful ways to iterate arrays.</p>
        </li>
        <li>
        <p>The Array class defines a rich set of methods for manipulating
        arrays, and you should be sure to familiarize yourself with the
        Array API.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->