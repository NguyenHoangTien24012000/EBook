<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Server-Side JavaScript with Node"><div class="chapter" id="serverside">
        <h1><span class="label">Chapter 16. </span>Server-Side JavaScript with Node</h1>
        
        
        <p>Node<a data-type="indexterm" data-primary="server-side JavaScript" id="idm46198490524920"></a><a data-type="indexterm" data-primary="Node" data-secondary="benefits of" id="idm46198490524184"></a> is JavaScript with bindings to the underlying operating system,
        making it possible to write JavaScript programs that read and write
        files, execute child processes, and communicate over the network. This
        makes Node useful as a:</p>
        
        <ul>
        <li>
        <p>Modern alternative to shell scripts that does not suffer from the
        arcane syntax of bash and other Unix shells.</p>
        </li>
        <li>
        <p>General-purpose programming language for running trusted programs,
        not subject to the security constraints imposed by web browsers on
        untrusted code.</p>
        </li>
        <li>
        <p>Popular environment for writing efficient and highly concurrent
        web servers.</p>
        </li>
        </ul>
        
        <p>The<a data-type="indexterm" data-primary="Node" data-secondary="defining feature of" id="idm46198490519016"></a> defining feature of Node is its single-threaded event-based
        concurrency enabled by an<a data-type="indexterm" data-primary="asynchronous programming" data-see="also Node" id="idm46198490517880"></a> asynchronous-by-default API. If you have
        programmed in other languages but have not done much JavaScript
        coding, or if you’re an experienced client-side JavaScript programmer
        used to writing code for web browers, using Node will be a bit of an
        adjustment, as is any new programming language or environment. This
        chapter begins by explaining the Node programming model, with an
        emphasis on concurrency, Node’s API for working with streaming data,
        and Node’s Buffer type for working with binary data.  These initial
        sections are followed by sections that highlight and demonstrate some
        of the most important Node APIs, including those for working with
        files, networks, processes, and threads.</p>
        
        <p>One chapter is not enough to document all of Node’s APIs, but my hope
        is that this chapter will explain enough of the fundamentals to make
        you productive with Node, and confident that you can master any new
        APIs you need.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198490515368">
        <h5>Installing Node</h5>
        <p>Node<a data-type="indexterm" data-primary="Node" data-secondary="installing" id="idm46198490514040"></a> is open source software.  Visit <a href="https://nodejs.org"><em class="hyperlink">https://nodejs.org</em></a> to download
        and install Node for Windows and MacOS. On Linux, you may be able to
        install Node with your normal package manager, or you can visit
        <a href="https://nodejs.org/en/download"><em class="hyperlink">https://nodejs.org/en/download</em></a> to download the binaries directly. If
        you work on containerized software, you can find official Node Docker
        images at <a href="https://hub.docker.com"><em class="hyperlink">https://hub.docker.com</em></a>.</p>
        
        <p>In addition to the Node executable, a Node installation also
        includes npm, a package manager that enables easy access to a vast
        ecosystem of JavaScript tools and libraries. The examples in this
        chapter will use only Node’s built-in packages and will not require
        npm or any external libraries.</p>
        
        <p>Finally, do not overlook the official Node documentation, available at
        <a href="https://nodejs.org/api"><em class="hyperlink">https://nodejs.org/api</em></a> and <a href="https://nodejs.org/docs/guides"><em class="hyperlink">https://nodejs.org/docs/guides</em></a>. I have
        found it to be well organized and well written.</p>
        </div></aside>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.1 Node Programming Basics"><div class="sect1" id="idm46198490505352">
        <h1>16.1 Node Programming Basics</h1>
        
        <p>We’ll<a data-type="indexterm" data-primary="Node" data-secondary="programming basics" id="Nprog16"></a> begin this chapter with a quick look at how Node programs are
        structured and how they interact with the operating system.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.1.1 Console Output"><div class="sect2" id="idm46198490502152">
        <h2>16.1.1 Console Output</h2>
        
        <p>If<a data-type="indexterm" data-primary="Node" data-secondary="programming basics" data-tertiary="console output" id="idm46198490500680"></a><a data-type="indexterm" data-primary="console.log() function" id="idm46198490499400"></a> you are used to JavaScript programming for web browsers, one of the
        minor surprises about Node is that <code>console.log()</code> is not just for
        debugging, but is Node’s easiest way to display a message to the user,
        or, more generally, to send output to the stdout stream. Here’s<a data-type="indexterm" data-primary="Hello World" id="idm46198490497912"></a> the
        classic “Hello World” program in Node:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Hello World!"</code><code class="p">);</code></pre>
        
        <p>There are lower-level ways to write to stdout, but no fancier or more
        official way than simply calling <code>console.log()</code>.</p>
        
        <p>In web browsers, <code>console.log()</code>, <code>console.warn()</code>, and
        <code>console.error()</code> typically display little icons next to their output
        in the developer console to indicate the variety of the log
        message. Node does not do this, but output displayed with
        <code>console.error()</code> is distinguished from output displayed with
        <code>console.log()</code> because <code>console.error()</code> writes to the stderr
        stream. If you’re using Node to write a program that is designed to
        have stdout redirected to a file or a pipe, you can use
        <code>console.error()</code> to display text to the console where the user will
        see it, even though text printed with <code>console.log()</code> is hidden.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.1.2 Command-Line Arguments and Environment Variables"><div class="sect2" id="idm46198490490488">
        <h2>16.1.2 Command-Line Arguments and Environment Variables</h2>
        
        <p>If<a data-type="indexterm" data-primary="Node" data-secondary="programming basics" data-tertiary="command-line arguments" id="idm46198490488760"></a><a data-type="indexterm" data-primary="Node" data-secondary="programming basics" data-tertiary="environment variables" id="idm46198490487480"></a> you have previously written Unix-style programs designed to be
        invoked from a terminal or other command-line interface, you know that
        these programs typically get their input primarily from command-line
        arguments and secondarily from environment variables.</p>
        
        <p>Node follows these Unix conventions. A Node program can read its
        command-line arguments from the array of strings <code>process.argv</code>. The
        first element of this array is always the path to the Node
        executable. The second argument is the path to the file of JavaScript
        code that Node is executing. Any remaining elements in this array are
        the space-separated arguments that you passed on the command-line when
        you invoked Node.</p>
        
        <p>For example, suppose you save this very short Node program to the file
        <em>argv.js</em>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">);</code></pre>
        
        <p>You can then execute the program and see output like this:</p>
        
        <pre data-type="programlisting">$ node --trace-uncaught argv.js --arg1 --arg2 filename
        [
          '/usr/local/bin/node',
          '/private/tmp/argv.js',
          '--arg1',
          '--arg2',
          'filename'
        ]</pre>
        
        <p>There are a couple of things to note here:</p>
        
        <ul>
        <li>
        <p>The first and second elements of <code>process.argv</code> will be
        fully qualified filesystem paths to the Node executable and the file
        of JavaScript that is being executed, even if you did not type them
        that way.</p>
        </li>
        <li>
        <p>Command-line arguments that are intended for and interpreted by the
        Node executable itself are consumed by the Node executable and do
        not appear in <code>process.argv</code>. (The <code>--trace-uncaught</code> command-line
        argument isn’t actually doing anything useful in the previous example;
        it is just there to demonstrate that it does not appear in the
        output.)  Any arguments (such as <code>--arg1</code> and <code>filename</code>) that
        appear after the name of the JavaScript file will appear in
        <code>process.argv</code>.</p>
        </li>
        </ul>
        
        <p>Node programs can also take input from Unix-style environment
        variables. Node makes these available though the <code>process.env</code>
        object. The property names of this object are environment variable
        names, and the property values (always strings) are the values of
        those variables.</p>
        
        <p>Here is a partial list of environment variables on my system:</p>
        
        <pre data-type="programlisting">$ node -p -e 'process.env'
        {
          SHELL: '/bin/bash',
          USER: 'david',
          PATH: '/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin',
          PWD: '/tmp',
          LANG: 'en_US.UTF-8',
          HOME: '/Users/david',
        }</pre>
        
        <p>You can use <code>node -h</code> or <code>node --help</code> to find out what the <code>-p</code> and
        <code>-e</code> command-line arguments do. However, as a hint, note that you could rewrite
        the line above as <code>node --eval 'process.env' --print</code>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.1.3 Program Life Cycle"><div class="sect2" id="idm46198490489832">
        <h2>16.1.3 Program Life Cycle</h2>
        
        <p>The <code>node</code> command<a data-type="indexterm" data-primary="Node" data-secondary="programming basics" data-tertiary="program life cycle" id="idm46198490436728"></a> expects a command-line argument that specifies the
        file of JavaScript code to be run. This initial file typically imports
        other modules of JavaScript code, and may also define its own classes
        and functions. Fundamentally, however, Node executes the JavaScript
        code in the specified file from top to bottom. Some Node programs exit
        when they are done executing the last line of code in the file. Often,
        however, a Node program will keep running long after the initial file
        has been executed. As we’ll discuss in the following sections, Node programs are often
        asynchronous and based on callbacks and event handlers. Node programs
        do not exit until they are done running the initial file and until all
        callbacks have been called and there are no more pending events. A
        Node-based server program that listens for incoming network
        connections will theoretically run forever because it will always be
        waiting for more events.</p>
        
        <p>A program can force itself to exit by calling <code>process.exit()</code>. Users
        can usually terminate a Node program by typing Ctrl-C in the terminal
        window where the program is running. A program can ignore Ctrl-C by
        registering a signal handler function with <code>process.on("SIGINT",
        ()=&gt;{})</code>.</p>
        
        <p>If code in your program throws an exception and no <code>catch</code> clause
        catches it, the program will print a stack trace and exit. Because of
        Node’s asynchronous nature, exceptions that occur in callbacks or
        event handlers must be handled locally or not handled at all, which
        means that handling exceptions that occur in the asynchronous parts of
        your program can be a difficult problem. If you don’t want these
        exceptions to cause your program to completely crash, register a
        global handler function that will be invoked instead of crashing:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">process</code><code class="p">.</code><code class="nx">setUncaughtExceptionCaptureCallback</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="s2">"Uncaught exception:"</code><code class="p">,</code> <code class="nx">e</code><code class="p">);</code>
        <code class="p">});</code></pre>
        
        <p>A similar situation arises if a Promise created by your program is
        rejected and there is no <code>.catch()</code> invocation to handle it. As of
        Node 13, this is not a fatal error that causes your program to exit,
        but it does print a verbose error message to the console. In some
        future version of Node, unhandled Promise rejections are expected to
        become fatal errors. If you do not want unhandled rejections, to print
        error messages or terminate your program, register a global handler
        function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">process</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"unhandledRejection"</code><code class="p">,</code> <code class="p">(</code><code class="nx">reason</code><code class="p">,</code> <code class="nx">promise</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="c1">// reason is whatever value would have been passed to a .catch() function</code>
            <code class="c1">// promise is the Promise object that rejected</code>
        <code class="p">});</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.1.4 Node Modules"><div class="sect2" id="idm46198490386280">
        <h2>16.1.4 Node Modules</h2>
        
        <p><a data-type="xref" href="ch10.html#modules">Chapter&nbsp;10</a> documented<a data-type="indexterm" data-primary="modules" data-secondary="in Node" data-secondary-sortas="Node" id="idm46198490381992"></a><a data-type="indexterm" data-primary="Node" data-secondary="programming basics" data-tertiary="modules" id="idm46198490380744"></a> JavaScript module systems, covering both Node
        modules and ES6 modules. Because Node was created before JavaScript
        had a module system, Node had to create its own. Node’s module system
        uses the <code>require()</code> function to import values into a module and the
        <code>exports</code> object or the <code>module.exports</code> property to export values
        from a module. These are a fundamental part of the Node programming
        model, and they are covered in detail in <a data-type="xref" href="ch10.html#nodemodules">§10.2</a>.</p>
        
        <p>Node 13 adds support for standard ES6 modules as well as
        require-based modules (which Node calls “CommonJS modules”). The two
        module systems are not fully compatible, so this is somewhat tricky to
        do. Node needs to know—before it loads a module—whether that module
        will be using <code>require()</code> and <code>module.exports</code> or if it will be using
        <code>import</code> and <code>export</code>. When Node loads a file of JavaScript code as a
        CommonJS module, it automatically defines the <code>require()</code> function
        along with identifiers <code>exports</code> and <code>module</code>, and it does not enable
        the <code>import</code> and <code>export</code> keywords. On the other hand, when Node loads
        a file of code as an ES6 module, it must enable the <code>import</code> and
        <code>export</code> declarations, and it must <em>not</em> define extra identifiers like
        <code>require</code>, <code>module</code>, and <code>exports</code>.</p>
        
        <p>The simplest way to tell Node what kind of module it is loading is to
        encode this information in the file extension. If you save your
        JavaScript code in a file that ends with <em>.mjs</em>, then Node will always
        load it as an ES6 module, will expect it to use <code>import</code> and <code>export</code>,
        and will not provide a <code>require()</code> function. And if you save your code
        in a file that ends with <em>.cjs</em>, then Node will always treat it as a
        CommonJS module, will provide a <code>require()</code> function, and will throw a
        SyntaxError if you use <code>import</code> or <code>export</code> declarations.</p>
        
        <p>For files that do not have an explicit <em>.mjs</em> or <em>.cjs</em> extension,
        Node looks for a file named <em>package.json</em> in the same directory as
        the file and then in each of the containing directories. Once the
        nearest <em>package.json</em> file is found, Node checks for a top-level
        <code>type</code> property in the JSON object. If the value of the <code>type</code>
        property is “module”, then Node loads the file as an ES6 module.  If
        the value of that property is 
        <span class="keep-together">“commonjs”,</span> then Node loads the file as
        a CommonJS module. Note that you do not need to have a <em>package.json</em>
        file to run Node programs: when no such file is found (or when the
        file is found but it does not have a <code>type</code> property), Node defaults to
        using CommonJS modules. This <em>package.json</em> trick only becomes
        necessary if you want to use ES6 modules with Node and do not want
        to use the <em>.mjs</em> file extension.</p>
        
        <p>Because there is an enormous amount of existing Node code written
        using CommonJS module format, Node allows ES6 modules to load CommonJS
        modules using the <code>import</code> keyword. The reverse is not true,
        however: a CommonJS module cannot use <code>require()</code> to load an ES6
        module.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.1.5 The Node Package Manager"><div class="sect2" id="npm">
        <h2>16.1.5 The Node Package Manager</h2>
        
        <p>When<a data-type="indexterm" data-primary="Node" data-secondary="programming basics" data-tertiary="package manager" id="idm46198490304040"></a><a data-type="indexterm" data-primary="package manager (Node)" id="idm46198490302824"></a> you install Node, you typically get a program named npm as
        well. This is the Node Package Manager, and it helps you download
        and manage libraries that your program depends on. npm keeps track of
        those dependencies (as well as other information about your program)
        in a file named <em>package.json</em> in the root directory of your
        project. This <em>package.json</em> file created by npm is where you would
        add <code>"type":"module"</code> if you wanted to use ES6 modules for your
        project.</p>
        
        <p>This chapter does not cover npm in any detail (but see
        <a data-type="xref" href="ch17.html#packagemanagers">§17.4</a> for a little more depth). I’m mentioning
        it here because unless you write programs that do not use any external
        libraries, you will almost certainly be using npm or a tool like
        it. Suppose, for example, that you are going to be developing a web server
        and plan to use the Express framework (<a href="https://expressjs.com"><em class="hyperlink">https://expressjs.com</em></a>) to
        simplify the task. To get started, you might create a directory for
        your project, and then, in that directory type <code>npm init</code>. npm will
        ask you for your project name, version number, etc., and will then
        create an initial <em>package.json</em> file based on your responses.</p>
        
        <p>Now to start using Express, you’d type <code>npm install express</code>.
        This tells npm to download the Express library along with
        all of its dependencies and install all the packages in a local
        <em>node_modules/</em> directory:</p>
        
        <pre data-type="programlisting">$ npm install express
        npm notice created a lockfile as package-lock.json. You should commit this file.
        npm WARN my-server@1.0.0 No description
        npm WARN my-server@1.0.0 No repository field.
        
        + express@4.17.1
        added 50 packages from 37 contributors and audited 126 packages in 3.058s
        found 0 vulnerabilities</pre>
        
        <p>When you install a package with npm, npm records this dependency—that
        your project depends on Express—in the
        <em>package.json</em> file. With this dependency recorded in <em>package.json</em>,
        you could give another programmer a copy of your code and your
        <em>package.json</em>, and they could simply type <code>npm install</code> to
        automatically download and install all of the libraries that your
        program needs in order to run.<a data-type="indexterm" data-primary="" data-startref="Nprog16" id="idm46198490291576"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.2 Node Is Asynchronous by Default"><div class="sect1" id="idm46198490290472">
        <h1>16.2 Node Is Asynchronous by Default</h1>
        
        <p>JavaScript<a data-type="indexterm" data-primary="Node" data-secondary="asynchronous iteration in" id="Nasync16"></a> is a general-purpose programming language, so it is
        perfectly possible to write CPU-intensive programs that multiply large
        matrices or perform complicated statistical analyses. But Node was
        designed and optimized for programs—like network servers—that are I/O
        intensive. And in particular, Node was designed to make it possible to
        easily implement highly concurrent servers that can handle many
        requests at the same time.</p>
        
        <p>Unlike many programming languages, however, Node does not achieve
        concurrency with threads. Multithreaded programming is notoriously
        hard to do correctly, and difficult to debug. Also, threads are a
        relatively heavyweight abstraction and if you want to write a server
        that can handle hundreds of concurrent requests, using hundreds of
        threads may require a prohibitive amount of memory. So Node adopts the
        single-threaded JavaScript programming model that the web uses, and
        this turns out to be a vast simplification that makes the creation of
        network servers a routine skill rather than an arcane one.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198490285560">
        <h5>True Parallelism with Node</h5>
        <p>Node<a data-type="indexterm" data-primary="parallelization" id="idm46198490284264"></a><a data-type="indexterm" data-primary="Node" data-secondary="parallelism with" id="idm46198490283528"></a><a data-type="indexterm" data-primary="multithreaded programming" id="idm46198490282584"></a> programs can run multiple operating system processes, and Node 10
        and later support Worker objects (<a data-type="xref" href="#node-worker-threads">§16.11</a>), which are
        a kind of thread borrowed from web browsers. If you use multiple
        processes or create one or more Worker threads and run your program on
        a system with more than one CPU, then your program will no longer be
        single-threaded and your program will truly be executing multiple
        streams of code in parallel. These techniques can be valuable for
        CPU-intensive operations but are not commonly used for I/O-intensive
        programs like servers.</p>
        
        <p>It is worth noting, however, that Node’s processes and Workers avoid
        the typical complexity of multithreaded programming because
        interprocess and inter-Worker communication is via message passing
        and they cannot easily share memory with each other.</p>
        </div></aside>
        
        <p>Node achieves high levels of concurrency while maintaining a
        single-threaded programming model by making its API asynchronous and
        nonblocking by default. Node takes its nonblocking approach very
        seriously and to an extreme that may surprise you. You probably expect
        functions that read from and write to the network to be asynchronous,
        but Node goes further and defines nonblocking asynchronous functions
        for reading and writing files from the local filesystem. This makes
        sense, when you think about it: the Node API was designed in the days
        when spinning hard drives were still the norm and there really were
        milliseconds of blocking “seek time” while waiting for the disc to
        spin around before a file operation could begin. And in modern
        datacenters, the “local” filesystem may actually be across the network
        somewhere with network latencies on top of drive latencies. But even
        if reading a file asynchronously seems normal to you, Node takes it
        still further: the default functions for initiating a network
        connection or looking up a file modification time, for example, are
        also nonblocking.</p>
        
        <p>Some functions in Node’s API are synchronous but nonblocking: they
        run to completion and return without ever needing to block. But most
        of the interesting functions perform some kind of input or output, and
        these are asynchronous functions so they can avoid even the tiniest
        amount of blocking. Node was created before JavaScript had a
        Promise class, so asynchronous Node APIs are callback-based. (If you
        have not yet read or have already forgotten <a data-type="xref" href="ch13.html#async">Chapter&nbsp;13</a>, this would be
        a good time to skip back to that chapter.) Generally, the last argument
        you pass to an asynchronous Node function is a callback. Node uses
        <em>error-first callbacks</em>, which are typically invoked with two
        arguments. The first argument to an error-first callback is normally
        <code>null</code> in the case where no error occurred, and the second argument is
        whatever data or response was produced by the original asynchronous
        function you called. The reason for putting the error argument first
        is to make it impossible for you to omit it, and you should always
        check for a non-null value in this argument. If it is an Error object,
        or even an integer error code or string error message, then something
        went wrong. In this case, the second argument to your callback
        function is likely to be <code>null</code>.</p>
        
        <p>The following code demonstrates how to use the nonblocking
        <code>readFile()</code> function to read a configuration file, parse it as JSON,
        and then pass the parsed configuration object to another callback:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>  <code class="c1">// Require the filesystem module</code>
        
        <code class="c1">// Read a config file, parse its contents as JSON, and pass the</code>
        <code class="c1">// resulting value to the callback. If anything goes wrong,</code>
        <code class="c1">// print an error message to stderr and invoke the callback with null</code>
        <code class="kd">function</code> <code class="nx">readConfigFile</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="s2">"utf8"</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">text</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>    <code class="c1">// Something went wrong reading the file</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
                    <code class="nx">callback</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>
                    <code class="k">return</code><code class="p">;</code>
                <code class="p">}</code>
                <code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
                <code class="k">try</code> <code class="p">{</code>
                    <code class="nx">data</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
                <code class="p">}</code> <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>  <code class="c1">// Something went wrong parsing the file contents</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="nx">callback</code><code class="p">(</code><code class="nx">data</code><code class="p">);</code>
            <code class="p">});</code>
        <code class="p">}</code></pre>
        
        <p>Node predates standardized promises, but because it is fairly
        consistent about its error-first callbacks, it is easy to create
        Promise-based variants of its callback-based APIs using the
        <code>util.promisify()</code> wrapper. Here’s how we could rewrite the
        <code>readConfigFile()</code> function to return a Promise:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">util</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"util"</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>  <code class="c1">// Require the filesystem module</code>
        <code class="kr">const</code> <code class="nx">pfs</code> <code class="o">=</code> <code class="p">{</code>              <code class="c1">// Promise-based variants of some fs functions</code>
            <code class="nx">readFile</code><code class="o">:</code> <code class="nx">util</code><code class="p">.</code><code class="nx">promisify</code><code class="p">(</code><code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">)</code>
        <code class="p">};</code>
        
        <code class="kd">function</code> <code class="nx">readConfigFile</code><code class="p">(</code><code class="nx">path</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">pfs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="s2">"utf-8"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">text</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
            <code class="p">});</code>
        <code class="p">}</code></pre>
        
        <p>We can also simpify the preceding Promise-based function using <code>async</code> and
        <code>await</code> (again, if you have not yet read through <a data-type="xref" href="ch13.html#async">Chapter&nbsp;13</a>, this
        would be a good time to do so):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">async</code> <code class="kd">function</code> <code class="nx">readConfigFile</code><code class="p">(</code><code class="nx">path</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">text</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">pfs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="s2">"utf-8"</code><code class="p">);</code>
            <code class="k">return</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>The <code>util.promisify()</code> wrapper can produce a Promise-based version of
        many Node functions. In Node 10 and later, the <code>fs.promises</code> object
        has a number of predefined Promise-based functions for working with
        the filesystem. We’ll discuss them later in this chapter, but note
        that in the preceding code, we could replace <code>pfs.readFile()</code> with
        <code>fs.promises.readFile()</code>.</p>
        
        <p>We had said that Node’s programming model is async-by-default. But
        for programmer convenience, Node does define blocking, synchronous
        variants of many of its functions, especially in the filesystem
        module. These functions typically have names that are clearly labeled
        with <code>Sync</code> at the end.</p>
        
        <p>When a server is first starting up and is reading its configuration
        files, it is not handling network requests yet, and little or no
        concurrency is actually possible. So in this situation, there is
        really no need to avoid blocking, and we can safely use blocking
        functions like <code>fs.readFileSync()</code>. We can drop the <code>async</code> and
        <code>await</code> from this code and write a purely synchronous version of
        our <code>readConfigFile()</code> function. Instead of invoking a callback or
        returning a Promise, this function simply returns the parsed JSON
        value or throws an exception:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        <code class="kd">function</code> <code class="nx">readConfigFileSync</code><code class="p">(</code><code class="nx">path</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">text</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readFileSync</code><code class="p">(</code><code class="nx">path</code><code class="p">,</code> <code class="s2">"utf-8"</code><code class="p">);</code>
            <code class="k">return</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">text</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>In addition to its error-first two-argument callbacks, Node also has a
        number of APIs that use event-based asynchrony, typically for handling
        streaming data. We’ll cover Node events in more detail later.</p>
        
        <p>Now that we’ve discussed Node’s aggressively nonblocking API, let’s
        turn back to the topic of concurrency. Node’s built-in nonblocking
        functions work using the operating system’s version of callbacks and
        event handlers. When you call one of these functions, Node takes
        action to get the operation started, then registers some kind of
        event handler with the operating system so that it will be notified
        when the operation is complete. The callback you passed to the Node
        function gets stored internally so that Node can invoke your callback
        when the operating system sends the appropriate event to Node.</p>
        
        <p>This kind of concurrency is often called event-based concurrency. At its core, Node has a single thread that runs an “event loop.” When
        a Node program starts, it runs whatever code you’ve told it to
        run. This code presumably calls at least one nonblocking function
        causing a callback or event handler to be registered with the
        operating system. (If not, then you’ve written a synchronous Node
        program, and Node simply exits when it reaches the end.) When Node
        reaches the end of your program, it blocks until an event happens, at
        which time the OS starts it running again. Node maps the OS event to
        the JavaScript callback you registered and then invokes that
        function. Your callback function may invoke more nonblocking Node
        functions, causing more OS event handlers to be registered. Once your
        callback function is done running, Node goes back to sleep again and
        the cycle repeats.</p>
        
        <p>For web servers and other I/O-intensive applications that spend most
        of their time waiting for input and output, this style of event-based
        concurrency is efficient and effective. A web server can concurrently
        handle requests from 50 different clients without needing 50 different
        threads as long as it uses nonblocking APIs and there is some kind of
        internal mapping from network sockets to JavaScript functions to
        invoke when activity occurs on those sockets.<a data-type="indexterm" data-primary="" data-startref="Nasync16" id="idm46198489941672"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.3 Buffers"><div class="sect1" id="idm46198490289560">
        <h1>16.3 Buffers</h1>
        
        <p>One<a data-type="indexterm" data-primary="Node" data-secondary="buffers" id="idm46198489939576"></a><a data-type="indexterm" data-primary="Buffer class (Node)" id="idm46198489938568"></a><a data-type="indexterm" data-primary="Uint8Array" id="idm46198489937896"></a> of the datatypes you’re likely to use frequently in
        Node—especially when reading data from files or from the network—is
        the Buffer class. A Buffer is a lot like a string, except that it is a
        sequence of bytes instead of a sequence of characters. Node was
        created before core JavaScript supported typed arrays (see
        <a data-type="xref" href="ch11.html#typedarrays">§11.2</a>) and there was no Uint8Array to represent an array of
        unsigned bytes. Node defined the Buffer class to fill that need. Now
        that Uint8Array is part of the JavaScript language, Node’s Buffer
        class is a subclass of Uint8Array.</p>
        
        <p>What distinguishes Buffer from its Uint8Array superclass is that it is
        designed to interoperate with JavaScript strings: the bytes in a
        buffer can be initialized from character strings or converted to
        character strings. A character encoding maps each character in some
        set of characters to an integer. Given a string of text and a
        character encoding, we can <em>encode</em> the characters in the string into
        a sequence of bytes. And given a (properly encoded) sequence of bytes
        and a character encoding, we can <em>decode</em> those bytes into a sequence
        of characters. Node’s Buffer class has methods that perform both
        encoding and decoding, and you can recognize these methods because
        they expect an <code>encoding</code> argument that specifies the encoding to be
        used.</p>
        
        <p>Encodings in Node are specified by name, as strings. The supported
        encodings are:</p>
        <dl>
        <dt><code>"utf8"</code></dt>
        <dd>
        <p>This is the default when no encoding is specified, and is the
        Unicode encoding you are most likely to use.</p>
        </dd>
        <dt><code>"utf16le"</code></dt>
        <dd>
        <p>Two-byte Unicode characters, with little-endian
        ordering. Codepoints above <code>\uffff</code> are encoded as a pair of
        two-byte sequences. Encoding <code>"ucs2"</code> is an alias.</p>
        </dd>
        <dt><code>"latin1"</code></dt>
        <dd>
        <p>The one-byte-per-character ISO-8859-1 encoding that
        defines a character set suitable for many Western European
        languages. Because there is a one-to-one mapping between bytes and
        latin-1 characters, this encoding is also known as <code>"binary"</code>.</p>
        </dd>
        <dt><code>"ascii"</code></dt>
        <dd>
        <p>The 7-bit English-only ASCII encoding, a strict subset of
        the <code>"utf8"</code> encoding.</p>
        </dd>
        <dt><code>"hex"</code></dt>
        <dd>
        <p>This encoding converts each byte to a pair of ASCII
        hexadecimal digits.</p>
        </dd>
        <dt><code>"base64"</code></dt>
        <dd>
        <p>This encoding converts each sequence of three bytes into
        a sequence of four ascii characters.</p>
        </dd>
        </dl>
        
        <p>Here is some example code that demonstrates how to work with Buffers
        and how to convert to and from strings:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">Buffer</code><code class="p">.</code><code class="nx">from</code><code class="p">([</code><code class="mh">0x41</code><code class="p">,</code> <code class="mh">0x42</code><code class="p">,</code> <code class="mh">0x43</code><code class="p">]);</code>          <code class="c1">// &lt;Buffer 41 42 43&gt;</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>                                      <code class="c1">// =&gt; "ABC"; default "utf8"</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="s2">"hex"</code><code class="p">)</code>                                 <code class="c1">// =&gt; "414243"</code>
        
        <code class="kd">let</code> <code class="nx">computer</code> <code class="o">=</code> <code class="nx">Buffer</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="s2">"IBM3111"</code><code class="p">,</code> <code class="s2">"ascii"</code><code class="p">);</code>   <code class="c1">// Convert string to Buffer</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">computer</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>        <code class="c1">// Use Buffer as byte array</code>
            <code class="nx">computer</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="o">--</code><code class="p">;</code>                                <code class="c1">// Buffers are mutable</code>
        <code class="p">}</code>
        <code class="nx">computer</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="s2">"ascii"</code><code class="p">)</code>                        <code class="c1">// =&gt; "HAL2000"</code>
        <code class="nx">computer</code><code class="p">.</code><code class="nx">subarray</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">3</code><code class="p">).</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code><code class="o">=&gt;</code><code class="nx">x</code><code class="o">+</code><code class="mi">1</code><code class="p">).</code><code class="nx">toString</code><code class="p">()</code>     <code class="c1">// =&gt; "IBM"</code>
        
        <code class="c1">// Create new "empty" buffers with Buffer.alloc()</code>
        <code class="kd">let</code> <code class="nx">zeros</code> <code class="o">=</code> <code class="nx">Buffer</code><code class="p">.</code><code class="nx">alloc</code><code class="p">(</code><code class="mi">1024</code><code class="p">);</code>                   <code class="c1">// 1024 zeros</code>
        <code class="kd">let</code> <code class="nx">ones</code> <code class="o">=</code> <code class="nx">Buffer</code><code class="p">.</code><code class="nx">alloc</code><code class="p">(</code><code class="mi">128</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>                  <code class="c1">// 128 ones</code>
        <code class="kd">let</code> <code class="nx">dead</code> <code class="o">=</code> <code class="nx">Buffer</code><code class="p">.</code><code class="nx">alloc</code><code class="p">(</code><code class="mi">1024</code><code class="p">,</code> <code class="s2">"DEADBEEF"</code><code class="p">,</code> <code class="s2">"hex"</code><code class="p">);</code> <code class="c1">// Repeating pattern of bytes</code>
        
        <code class="c1">// Buffers have methods for reading and writing multi-byte values</code>
        <code class="c1">// from and to a buffer at any specified offset.</code>
        <code class="nx">dead</code><code class="p">.</code><code class="nx">readUInt32BE</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>       <code class="c1">// =&gt; 0xDEADBEEF</code>
        <code class="nx">dead</code><code class="p">.</code><code class="nx">readUInt32BE</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>       <code class="c1">// =&gt; 0xADBEEFDE</code>
        <code class="nx">dead</code><code class="p">.</code><code class="nx">readBigUInt64BE</code><code class="p">(</code><code class="mi">6</code><code class="p">)</code>    <code class="c1">// =&gt; 0xBEEFDEADBEEFDEADn</code>
        <code class="nx">dead</code><code class="p">.</code><code class="nx">readUInt32LE</code><code class="p">(</code><code class="mi">1020</code><code class="p">)</code>    <code class="c1">// =&gt; 0xEFBEADDE</code></pre>
        
        <p>If you write a Node program that actually manipulates binary data, you
        may find yourself using the Buffer class extensively. On the other
        hand, if you are just working with text that is read from or written
        to a file or the network, then you may only encounter Buffer as an
        intermediate representation of your data. A number of Node APIs can
        take input or return output as either strings or Buffer
        objects. Typically, if you pass a string, or expect a string to be
        returned, from one of these APIs, you’ll need to specify the name of
        the text encoding you want to use. And if you do this, then you may
        not need to use a Buffer object at all.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.4 Events and EventEmitter"><div class="sect1" id="idm46198489917688">
        <h1>16.4 Events and EventEmitter</h1>
        
        <p>As<a data-type="indexterm" data-primary="Node" data-secondary="events and EventEmitter" id="idm46198489735672"></a><a data-type="indexterm" data-primary="EventEmitter class" id="idm46198489734664"></a> described, all of Node’s APIs are
        asynchronous by default. For many of them, this asynchrony takes the
        form of two-argument error-first callbacks that are invoked when the
        requested operation is complete. But some of the more complicated APIs are
        event-based instead. This is typically the case when the API is
        designed around an object rather than a function, or when a callback
        function needs to be invoked multiple times, or when there are
        multiple types of callback functions that may be required. Consider
        the <code>net.Server</code> class, for example: an object of this type is a
        server socket that is used to accept incoming connections from
        clients. It emits a “listening” event when it first starts listening
        for connections, a “connection” event every time a client connects,
        and a “close” event when it has been closed and is no longer
        listening.</p>
        
        <p>In Node, objects that emit events are instances of EventEmitter or a
        subclass of <span class="keep-together">EventEmitter:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">EventEmitter</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"events"</code><code class="p">);</code> <code class="c1">// Module name does not match class name</code>
        <code class="kr">const</code> <code class="nx">net</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"net"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">net</code><code class="p">.</code><code class="nx">Server</code><code class="p">();</code>          <code class="c1">// create a Server object</code>
        <code class="nx">server</code> <code class="k">instanceof</code> <code class="nx">EventEmitter</code>          <code class="c1">// =&gt; true: Servers are EventEmitters</code></pre>
        
        <p>The main feature of EventEmitters is that they allow you to register
        event handler functions with the <code>on()</code> method. EventEmitters can emit
        multiple types of events, and event types are identified by name. To
        register an event handler, call the <code>on()</code> method, passing the name of
        the event type and the function that should be invoked when an event
        of that type occurs. EventEmitters can invoke handler functions with
        any number of arguments, and you need to read the documentation for a
        specific kind of event from a specific EventEmitter to know what
        arguments you should expect to be passed:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">net</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"net"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">net</code><code class="p">.</code><code class="nx">Server</code><code class="p">();</code>          <code class="c1">// create a Server object</code>
        <code class="nx">server</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"connection"</code><code class="p">,</code> <code class="nx">socket</code> <code class="o">=&gt;</code> <code class="p">{</code>     <code class="c1">// Listen for "connection" events</code>
            <code class="c1">// Server "connection" events are passed a socket object</code>
            <code class="c1">// for the client that just connected. Here we send some data</code>
            <code class="c1">// to the client and disconnect.</code>
            <code class="nx">socket</code><code class="p">.</code><code class="nx">end</code><code class="p">(</code><code class="s2">"Hello World"</code><code class="p">,</code> <code class="s2">"utf8"</code><code class="p">);</code>
        <code class="p">});</code></pre>
        
        <p>If you prefer more explicit method names for registering event
        listeners, you can also use <code>addListener()</code>. And you can remove a
        previously registered event listener with <code>off()</code> or
        <code>removeListener()</code>.  As a special case, you can register an event
        listener that will be automatically removed after it is triggered for
        the first time by calling <code>once()</code> instead of <code>on()</code>.</p>
        
        <p>When an event of a particular type occurs for a particular
        EventEmitter object, Node invokes all of the handler functions that
        are currently registered on that EventEmitter for events of that
        type. They are invoked in order from the first registered to the last
        registered. If there is more than one handler function, they are
        invoked sequentially on a single thread: there is no parallelism in
        Node, remember. And, importantly, event handling functions are invoked
        synchronously, not asynchronously. What this means is that the
        <code>emit()</code> method does not queue up event handlers to be invoked at some
        later time. <code>emit()</code> invokes all the registered handlers, one after
        the other, and does not return until the last event handler has
        returned.</p>
        
        <p>What this means, in effect, is that when one of the built-in Node APIs
        emits an event, that API is basically blocking on your event
        handlers. If you write an event handler that calls a blocking function
        like <code>fs.readFileSync()</code>, no further event handling will happen until
        your synchronous file read is complete. If your program is one—like a
        network server—that needs to be responsive, then it is important that
        you keep your event handler functions nonblocking and fast. If you
        need to do a lot of computation when an event occurs, it is often best
        to use the handler to schedule that computation asynchronously using
        <code>setTimeout()</code> (see <a data-type="xref" href="ch11.html#timerapi">§11.10</a>). Node also defines <code>setImmediate()</code>,
        which schedules a function to be invoked immediately after all pending
        callbacks and events have been handled.</p>
        
        <p>The EventEmitter class also defines an <code>emit()</code> method that causes the
        registered event handler functions to be invoked. This is useful if
        you are defining your own event-based API, but is not commonly used
        when you’re just programming with existing APIs. <code>emit()</code> must be
        invoked with the name of the event type as its first argument. Any
        additional arguments that are passed to <code>emit()</code> become arguments to
        the registered event handler functions. The handler functions are also
        invoked with the <code>this</code> value set to the EventEmitter object itself,
        which is often convenient. (Remember, though, that arrow functions
        always use the <code>this</code> value of the context in which they are defined,
        and they cannot be invoked with any other <code>this</code> value. Nevertheless,
        arrow functions are often the most convenient way to write event
        handlers.)</p>
        
        <p>Any value returned by an event handler function is ignored. If an
        event handler function throws an exception, however, it propagates out
        from the <code>emit()</code> call and prevents the execution of any handler
        functions that were registered after the one that threw the exception.</p>
        
        <p>Recall that Node’s callback-based APIs use error-first callbacks, and
        it is important that you always check the first callback argument to
        see if an error occurred. With event-based APIs, the equivalent is
        “error” events. Since event-based APIs are often used for networking
        and other forms of streaming I/O, they are vulnerable to unpredictable
        asynchronous errors, and most EventEmitters define an “error” event
        that they emit when an error occurs. Whenever you use an event-based
        API, you should make it a habit to register a handler for “error”
        events. “Error” events get special treatment by the EventEmitter
        class. If <code>emit()</code> is called to emit an “error” event, and if there
        are no handlers registered for that event type, then an exception will
        be thrown. Since this occurs asynchronously, there is no way for you
        to handle the exception in a <code>catch</code> block, so this kind of error
        typically causes your program to exit.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.5 Streams"><div class="sect1" id="idm46198489917096">
        <h1>16.5 Streams</h1>
        
        <p>When<a data-type="indexterm" data-primary="Node" data-secondary="streams" data-tertiary="overview of" id="idm46198489631688"></a><a data-type="indexterm" data-primary="streams (Node)" data-secondary="overview of" id="idm46198489630408"></a><a data-type="indexterm" data-primary="Node" data-secondary="streams" id="Nstream16"></a><a data-type="indexterm" data-primary="streams (Node)" id="stnode16"></a> implementing an algorithm to process data, it is almost always
        easiest to read all the data into memory, do the processing, and then
        write the data out. For example, you could write a Node function to
        copy a file like this.<sup><a data-type="noteref" id="idm46198489626936-marker" href="ch16.html#idm46198489626936">1</a></sup></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        
        <code class="c1">// An asynchronous but nonstreaming (and therefore inefficient) function.</code>
        <code class="kd">function</code> <code class="nx">copyFile</code><code class="p">(</code><code class="nx">sourceFilename</code><code class="p">,</code> <code class="nx">destinationFilename</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="nx">sourceFilename</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">buffer</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">callback</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
                <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                    <code class="nx">fs</code><code class="p">.</code><code class="nx">writeFile</code><code class="p">(</code><code class="nx">destinationFilename</code><code class="p">,</code> <code class="nx">buffer</code><code class="p">,</code> <code class="nx">callback</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">});</code>
        <code class="p">}</code></pre>
        
        <p>This <code>copyFile()</code> function uses asynchronous functions and callbacks,
        so it does not block and is suitable for use in concurrent programs
        like servers. But notice that it must allocate enough memory to hold the
        entire contents of the file in memory at once. This may be fine in some
        use cases, but it starts to fail if the files to be copied are very
        large, or if your program is highly concurrent and there may be many
        files being copied at the same time. Another shortcoming of this
        <code>copyFile()</code> implementation is that it cannot start writing the new
        file until it has finished reading the old file.</p>
        
        <p>The solution to these problems is to use streaming algorithms where
        data “flows” into your program, is processed, and then flows out of
        your program. The idea is that your algorithm processes the data in
        small chunks and the full dataset is never held in memory at
        once. When streaming solutions are possible, they are more memory
        efficient and can also be faster. Node’s networking APIs are
        stream-based and Node’s filesystem module defines streaming APIs for
        reading and writing files, so you are likely to use a streaming API in
        many of the Node programs that you write. We’ll see a streaming
        version of the <code>copyFile()</code> function in <a data-type="xref" href="#flowing_mode">“Flowing mode”</a>.</p>
        
        <p>Node supports four basic stream types:</p>
        <dl>
        <dt>Readable</dt>
        <dd>
        <p>Readable<a data-type="indexterm" data-primary="Node" data-secondary="streams" data-tertiary="types of" id="idm46198489431080"></a><a data-type="indexterm" data-primary="streams (Node)" data-secondary="types of" id="idm46198489429800"></a> streams are sources of data. The stream returned
        by <code>fs.createReadStream()</code>, for example, is a stream from which the
        content of a specified file can be read. <code>process.stdin</code> is another
        Readable stream that returns data from standard input.</p>
        </dd>
        <dt>Writable</dt>
        <dd>
        <p>Writable streams are sinks or destinations for data. The
        return value of <code>fs.createWriteStream()</code>, for example, is a Writable
        stream: it allows data to be written to it in chunks, and outputs all
        of that data to a specified file.</p>
        </dd>
        <dt>Duplex</dt>
        <dd>
        <p>Duplex streams combine a Readable stream and a Writable
        stream into one object. The Socket objects returned by <code>net.connect()</code>
        and other Node networking APIs, for example, are Duplex streams. If
        you write to a socket, your data is sent across the network to
        whatever computer the socket is connected to. And if you read from a
        socket, you access the data written by that other computer.</p>
        </dd>
        <dt>Transform</dt>
        <dd>
        <p>Transform streams are also readable and writable, but they
        differ from Duplex streams in an important way: data written to a
        Transform stream becomes readable—usually in some transformed
        form—from the same stream. The <code>zlib.createGzip()</code> function, for
        example, returns a Transform stream that compresses (with the <em>gzip</em>
        algorithm) the data written to it. In a similar way, the
        
        <span class="keep-together"><code>crypto.createCipheriv()</code></span> function returns a Transform stream that
        encrypts or decrypts data that is written to it.</p>
        </dd>
        </dl>
        
        <p>By default, streams read and write buffers. If you call the
        <code>setEncoding()</code> method of a Readable stream, it will return decoded
        strings to you instead of Buffer objects. And if you write a string to
        a Writable buffer, it will be automatically encoded using the buffer’s
        default encoding or whatever encoding you specify. Node’s stream API
        also supports an “object mode” where streams read and write objects
        more complex than buffers and strings. None of Node’s core APIs
        use this object mode, but you may encounter it in other libraries.</p>
        
        <p>Readable streams have to read their data from somewhere, and Writable
        streams have to write their data to somewhere, so every stream has two
        ends: an input and an output or a source and a destination. The tricky
        thing about stream-based APIs is that the two ends of the stream will
        almost always flow at different speeds.  Perhaps the code that reads from a
        stream wants to read and process data more quickly than the data is
        actually being written into the stream. Or the reverse: perhaps data
        is written to a stream more quickly than it can be read and pulled out
        of the stream on the other end. Stream implementations almost always
        include an internal buffer to hold data that has been written but not
        yet read. Buffering helps to ensure that there is data available to
        read when it’s requested, and that there is space to hold data when it
        is written. But neither of these things can ever be guaranteed, and it
        is the nature of stream-based programming that readers will sometimes
        have to wait for data to be written (because the stream buffer is
        empty), and writers will sometimes have to wait for data to be read
        (because the stream buffer is full).</p>
        
        <p>In programming environments that use thread-based concurrency, stream
        APIs typically have blocking calls: a call to read data does not
        return until data arrives in the stream and a call to write data
        blocks until there is enough room in the stream’s internal buffer to
        accommodate the new data. With an event-based concurrency model,
        however, blocking calls do not make sense, and Node’s stream APIs are
        event- and callback-based. Unlike other Node APIs, there are not “Sync”
        versions of the methods that will be described later in this chapter.</p>
        
        <p>The need to coordinate stream readability (buffer not empty) and
        writability (buffer not full) via events makes Node’s stream APIs
        somewhat complicated. This is compounded by the fact that these APIs
        have evolved and changed over the years: for Readable streams, there
        are two completely distinct APIs that you can use. Despite the
        complexity, it is worth understanding and mastering Node’s streaming
        APIs because they enable high-throughput I/O in your programs.</p>
        
        <p>The subsections that follow demonstrate how to read and write from
        Node’s stream classes.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.5.1 Pipes"><div class="sect2" id="idm46198489414840">
        <h2>16.5.1 Pipes</h2>
        
        <p>Sometimes, you<a data-type="indexterm" data-primary="Node" data-secondary="streams" data-tertiary="pipes" id="idm46198489413448"></a><a data-type="indexterm" data-primary="streams (Node)" data-secondary="pipes" id="idm46198489412168"></a> need to read data from a stream simply to turn around
        and write that same data to another stream. Imagine, for example, that
        you are writing a simple HTTP server that serves a directory of static
        files. In this case, you will need to read data from a file input
        stream and write it out to a network socket. But instead of writing
        your own code to handle the reading and writing, you can instead
        simply connect the two sockets together as a “pipe” and let Node
        handle the complexities for you. Simply pass the Writable stream to
        the <code>pipe()</code> method of the Readable stream:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        
        <code class="kd">function</code> <code class="nx">pipeFileToSocket</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="nx">socket</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">fs</code><code class="p">.</code><code class="nx">createReadStream</code><code class="p">(</code><code class="nx">filename</code><code class="p">).</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">socket</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>The following utility function pipes one stream to another and invokes
        a callback when done or when an error occurs:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">pipe</code><code class="p">(</code><code class="nx">readable</code><code class="p">,</code> <code class="nx">writable</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// First, set up error handling</code>
            <code class="kd">function</code> <code class="nx">handleError</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">readable</code><code class="p">.</code><code class="nx">close</code><code class="p">();</code>
                <code class="nx">writable</code><code class="p">.</code><code class="nx">close</code><code class="p">();</code>
                <code class="nx">callback</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
            <code class="p">}</code>
        
            <code class="c1">// Next define the pipe and handle the normal termination case</code>
            <code class="nx">readable</code>
                <code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">handleError</code><code class="p">)</code>
                <code class="p">.</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">writable</code><code class="p">)</code>
                <code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">handleError</code><code class="p">)</code>
                <code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"finish"</code><code class="p">,</code> <code class="nx">callback</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>Transform streams are particularly useful with pipes, and create
        pipelines that involve more than two streams. Here’s an example
        function that compresses a file:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">zlib</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"zlib"</code><code class="p">);</code>
        
        <code class="kd">function</code> <code class="nx">gzip</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Create the streams</code>
            <code class="kd">let</code> <code class="nx">source</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">createReadStream</code><code class="p">(</code><code class="nx">filename</code><code class="p">);</code>
            <code class="kd">let</code> <code class="nx">destination</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">createWriteStream</code><code class="p">(</code><code class="nx">filename</code> <code class="o">+</code> <code class="s2">".gz"</code><code class="p">);</code>
            <code class="kd">let</code> <code class="nx">gzipper</code> <code class="o">=</code> <code class="nx">zlib</code><code class="p">.</code><code class="nx">createGzip</code><code class="p">();</code>
        
            <code class="c1">// Set up the pipeline</code>
            <code class="nx">source</code>
                <code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code>   <code class="c1">// call callback on read error</code>
                <code class="p">.</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">gzipper</code><code class="p">)</code>
                <code class="p">.</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">destination</code><code class="p">)</code>
                <code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code>   <code class="c1">// call callback on write error</code>
                <code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"finish"</code><code class="p">,</code> <code class="nx">callback</code><code class="p">);</code> <code class="c1">// call callback when writing is complete</code>
        <code class="p">}</code></pre>
        
        <p>Using the <code>pipe()</code> method to copy data from a Readable stream to a
        Writable stream is easy, but in practice, you often need to process the data somehow as it streams through your program. One way to do
        this is to implement your own Transform stream to do that processing,
        and this approach allows you to avoid manually reading and writing
        the streams. Here, for example, is a function that works like the Unix
        <code>grep</code> utility: it reads lines of text from an input stream, but
        writes only the lines that match a specified regular expression:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">stream</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"stream"</code><code class="p">);</code>
        
        <code class="kr">class</code> <code class="nx">GrepStream</code> <code class="kr">extends</code> <code class="nx">stream</code><code class="p">.</code><code class="nx">Transform</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">pattern</code><code class="p">)</code> <code class="p">{</code>
                <code class="kr">super</code><code class="p">({</code><code class="nx">decodeStrings</code><code class="o">:</code> <code class="kc">false</code><code class="p">});</code><code class="c1">// Don't convert strings back to buffers</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">pattern</code> <code class="o">=</code> <code class="nx">pattern</code><code class="p">;</code>       <code class="c1">// The regular expression we want to match</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">incompleteLine</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>     <code class="c1">// Any remnant of the last chunk of data</code>
            <code class="p">}</code>
        
            <code class="c1">// This method is invoked when there is a string ready to be</code>
            <code class="c1">// transformed. It should pass transformed data to the specified</code>
            <code class="c1">// callback function. We expect string input so this stream should</code>
            <code class="c1">// only be connected to readable streams that have had</code>
            <code class="c1">// setEncoding() called on them.</code>
            <code class="nx">_transform</code><code class="p">(</code><code class="nx">chunk</code><code class="p">,</code> <code class="nx">encoding</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">chunk</code> <code class="o">!==</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">callback</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Expected a string but got a buffer"</code><code class="p">));</code>
                    <code class="k">return</code><code class="p">;</code>
                <code class="p">}</code>
                <code class="c1">// Add the chunk to any previously incomplete line and break</code>
                <code class="c1">// everything into lines</code>
                <code class="kd">let</code> <code class="nx">lines</code> <code class="o">=</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">incompleteLine</code> <code class="o">+</code> <code class="nx">chunk</code><code class="p">).</code><code class="nx">split</code><code class="p">(</code><code class="s2">"\n"</code><code class="p">);</code>
        
                <code class="c1">// The last element of the array is the new incomplete line</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">incompleteLine</code> <code class="o">=</code> <code class="nx">lines</code><code class="p">.</code><code class="nx">pop</code><code class="p">();</code>
        
                <code class="c1">// Find all matching lines</code>
                <code class="kd">let</code> <code class="nx">output</code> <code class="o">=</code> <code class="nx">lines</code>                     <code class="c1">// Start with all complete lines,</code>
                    <code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">l</code> <code class="o">=&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">pattern</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">l</code><code class="p">))</code> <code class="c1">// filter them for matches,</code>
                    <code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"\n"</code><code class="p">);</code>                       <code class="c1">// and join them back up.</code>
        
                <code class="c1">// If anything matched, add a final newline</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">output</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">output</code> <code class="o">+=</code> <code class="s2">"\n"</code><code class="p">;</code>
                <code class="p">}</code>
        
                <code class="c1">// Always call the callback even if there is no output</code>
                <code class="nx">callback</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">output</code><code class="p">);</code>
            <code class="p">}</code>
        
            <code class="c1">// This is called right before the stream is closed.</code>
            <code class="c1">// It is our chance to write out any last data.</code>
            <code class="nx">_flush</code><code class="p">(</code><code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// If we still have an incomplete line, and it matches</code>
                <code class="c1">// pass it to the callback</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">pattern</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">incompleteLine</code><code class="p">))</code> <code class="p">{</code>
                    <code class="nx">callback</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">incompleteLine</code> <code class="o">+</code> <code class="s2">"\n"</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// Now we can write a program like 'grep' with this class.</code>
        <code class="kd">let</code> <code class="nx">pattern</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">[</code><code class="mi">2</code><code class="p">]);</code> <code class="c1">// Get a RegExp from command line.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">stdin</code>                              <code class="c1">// Start with standard input,</code>
            <code class="p">.</code><code class="nx">setEncoding</code><code class="p">(</code><code class="s2">"utf8"</code><code class="p">)</code>                   <code class="c1">// read it as Unicode strings,</code>
            <code class="p">.</code><code class="nx">pipe</code><code class="p">(</code><code class="k">new</code> <code class="nx">GrepStream</code><code class="p">(</code><code class="nx">pattern</code><code class="p">))</code>         <code class="c1">// pipe it to our GrepStream,</code>
            <code class="p">.</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">stdout</code><code class="p">)</code>                  <code class="c1">// and pipe that to standard out.</code>
            <code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">());</code>    <code class="c1">// Exit gracefully if stdout closes.</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.5.2 Asynchronous Iteration"><div class="sect2" id="idm46198489141128">
        <h2>16.5.2 Asynchronous Iteration</h2>
        
        <p>In<a data-type="indexterm" data-primary="Node" data-secondary="streams" data-tertiary="asynchronous iteration in" id="idm46198489139880"></a><a data-type="indexterm" data-primary="streams (Node)" data-secondary="asynchronous iteration in" id="idm46198489138632"></a> Node 12 and later, Readable streams are asynchronous iterators,
        which means that within an <code>async</code> function you can use a <code>for/await</code>
        loop to read string or Buffer chunks from a stream using code that is
        structured like synchronous code would be. (See <a data-type="xref" href="ch13.html#async-iterators">§13.4</a>
        for more on asynchronous iterators and <code>for/await</code> loops.)</p>
        
        <p>Using an asynchronous iterator is almost as easy as using the <code>pipe()</code>
        method, and is probably easier when you need to process each chunk you
        read in some way.  Here’s how we could rewrite the <code>grep</code> program
        in the previous section using an <code>async</code> function and a <code>for/await</code> loop:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Read lines of text from the source stream, and write any lines</code>
        <code class="c1">// that match the specified pattern to the destination stream.</code>
        <code class="nx">async</code> <code class="kd">function</code> <code class="nx">grep</code><code class="p">(</code><code class="nx">source</code><code class="p">,</code> <code class="nx">destination</code><code class="p">,</code> <code class="nx">pattern</code><code class="p">,</code> <code class="nx">encoding</code><code class="o">=</code><code class="s2">"utf8"</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Set up the source stream for reading strings, not Buffers</code>
            <code class="nx">source</code><code class="p">.</code><code class="nx">setEncoding</code><code class="p">(</code><code class="nx">encoding</code><code class="p">);</code>
        
            <code class="c1">// Set an error handler on the destination stream in case standard</code>
            <code class="c1">// output closes unexpectedly (when piping output to `head`, e.g.)</code>
            <code class="nx">destination</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">err</code> <code class="o">=&gt;</code> <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">());</code>
        
            <code class="c1">// The chunks we read are unlikely to end with a newline, so each will</code>
            <code class="c1">// probably have a partial line at the end. Track that here</code>
            <code class="kd">let</code> <code class="nx">incompleteLine</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
        
            <code class="c1">// Use a for/await loop to asynchronously read chunks from the input stream</code>
            <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">chunk</code> <code class="k">of</code> <code class="nx">source</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// Split the end of the last chunk plus this one into lines</code>
                <code class="kd">let</code> <code class="nx">lines</code> <code class="o">=</code> <code class="p">(</code><code class="nx">incompleteLine</code> <code class="o">+</code> <code class="nx">chunk</code><code class="p">).</code><code class="nx">split</code><code class="p">(</code><code class="s2">"\n"</code><code class="p">);</code>
                <code class="c1">// The last line is incomplete</code>
                <code class="nx">incompleteLine</code> <code class="o">=</code> <code class="nx">lines</code><code class="p">.</code><code class="nx">pop</code><code class="p">();</code>
                <code class="c1">// Now loop through the lines and write any matches to the destination</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">line</code> <code class="k">of</code> <code class="nx">lines</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">pattern</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">line</code><code class="p">))</code> <code class="p">{</code>
                        <code class="nx">destination</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">line</code> <code class="o">+</code> <code class="s2">"\n"</code><code class="p">,</code> <code class="nx">encoding</code><code class="p">);</code>
                    <code class="p">}</code>
                <code class="p">}</code>
            <code class="p">}</code>
            <code class="c1">// Finally, check for a match on any trailing text.</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">pattern</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code><code class="nx">incompleteLine</code><code class="p">))</code> <code class="p">{</code>
                <code class="nx">destination</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">incompleteLine</code> <code class="o">+</code> <code class="s2">"\n"</code><code class="p">,</code> <code class="nx">encoding</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">pattern</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">[</code><code class="mi">2</code><code class="p">]);</code>   <code class="c1">// Get a RegExp from command line.</code>
        <code class="nx">grep</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">stdin</code><code class="p">,</code> <code class="nx">process</code><code class="p">.</code><code class="nx">stdout</code><code class="p">,</code> <code class="nx">pattern</code><code class="p">)</code> <code class="c1">// Call the async grep() function.</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>                          <code class="c1">// Handle asynchronous exceptions.</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
                <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">();</code>
            <code class="p">});</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.5.3 Writing to Streams and Handling Backpressure"><div class="sect2" id="idm46198488806552">
        <h2>16.5.3 Writing to Streams and Handling Backpressure</h2>
        
        <p>The<a data-type="indexterm" data-primary="Node" data-secondary="streams" data-tertiary="writing to and handling backpressure" id="idm46198488804888"></a><a data-type="indexterm" data-primary="streams (Node)" data-secondary="writing to and handling backpressure" id="idm46198488735192"></a><a data-type="indexterm" data-primary="backpressure" id="back16"></a> async <code>grep()</code> function in the preceding code example demonstrated how to use
        a Readable stream as an asynchronous iterator, but it also
        demonstrated that you can write data to a Writable stream simply by
        passing it to the <code>write()</code> method. The <code>write()</code> method takes a
        buffer or string as the first argument. (Object streams expect other
        kinds of objects, but are beyond the scope of this chapter.) If you
        pass a buffer, the bytes of that buffer will be written directly. If
        you pass a string, it will be encoded to a buffer of bytes before
        being written. Writable streams have a default encoding that is used
        when you pass a string as the only argument to <code>write()</code>. The default
        encoding is typically “utf8,” but you can set it explicitly by calling
        <code>setDefaultEncoding()</code> on the Writable stream. Alternatively, when you
        pass a string as the first argument to <code>write()</code> you can pass an
        encoding name as the second argument.</p>
        
        <p><code>write()</code> optionally takes a callback function as its third
        argument. This will be invoked when the data has actually been written
        and is no longer in the Writable stream’s internal buffer. (This
        callback may also be invoked if an error occurs, but this is not
        guaranteed. You should register an “error” event handler on the
        Writable stream to detect errors.)</p>
        
        <p>The <code>write()</code> method has a very important return value. When you call
        <code>write()</code> on a stream, it will always accept and buffer the chunk of
        data you have passed. It then returns <code>true</code> if the internal buffer is
        not yet full. Or, if the buffer is now full or overfull, it returns
        <code>false</code>. This return value is advisory, and you can ignore it—Writable
        streams will enlarge their internal buffer as much as needed if you
        keep calling <code>write()</code>.
        But remember that the reason to use a streaming API in the first place
        is to avoid the cost of keeping lots of data in memory at once.</p>
        
        <p>A return value of <code>false</code> from the <code>write()</code> method is a form of
        <em>backpressure</em>: a message from the stream that you have written data
        more quickly than it can be handled. The proper response to this kind
        of backpressure is to stop calling <code>write()</code> until the stream emits a
        “drain” event, signaling that there is once again room in the
        buffer. Here, for example, is a function that writes to a stream, and
        then invokes a callback when it is OK to write more data to the
        stream:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">write</code><code class="p">(</code><code class="nx">stream</code><code class="p">,</code> <code class="nx">chunk</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Write the specified chunk to the specified stream</code>
            <code class="kd">let</code> <code class="nx">hasMoreRoom</code> <code class="o">=</code> <code class="nx">stream</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">chunk</code><code class="p">);</code>
        
            <code class="c1">// Check the return value of the write() method:</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">hasMoreRoom</code><code class="p">)</code> <code class="p">{</code>                  <code class="c1">// If it returned true, then</code>
                <code class="nx">setImmediate</code><code class="p">(</code><code class="nx">callback</code><code class="p">);</code>         <code class="c1">// invoke callback asynchronously.</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>                            <code class="c1">// If it returned false, then</code>
                <code class="nx">stream</code><code class="p">.</code><code class="nx">once</code><code class="p">(</code><code class="s2">"drain"</code><code class="p">,</code> <code class="nx">callback</code><code class="p">);</code> <code class="c1">// invoke callback on drain event.</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>The fact that it is sometimes OK to call <code>write()</code> multiple times in
        a row and sometimes you have to wait for an event between writes makes
        for awkward algorithms. This is one of the reasons that using the
        <code>pipe()</code> method is so appealing: when you use <code>pipe()</code>, Node handles
        backpressure for you automatically.</p>
        
        <p>If you are using <code>await</code> and <code>async</code> in your program, and are treating
        Readable streams as asynchronous iterators, it is straightforward to
        implement a Promise-based version of the <code>write()</code> utility function
        above to properly handle backpressure. In the async <code>grep()</code>
        function we just looked at, we did not handle backpressure. The async <code>copy()</code>
        function in the following example demonstrates how it can be done correctly. Note that this
        function just copies chunks from a source stream to a destination
        stream and calling <code>copy(source, destination)</code> is much like calling
        <code>source.pipe(destination)</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This function writes the specified chunk to the specified stream and</code>
        <code class="c1">// returns a Promise that will be fulfilled when it is OK to write again.</code>
        <code class="c1">// Because it returns a Promise, it can be used with await.</code>
        <code class="kd">function</code> <code class="nx">write</code><code class="p">(</code><code class="nx">stream</code><code class="p">,</code> <code class="nx">chunk</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Write the specified chunk to the specified stream</code>
            <code class="kd">let</code> <code class="nx">hasMoreRoom</code> <code class="o">=</code> <code class="nx">stream</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">chunk</code><code class="p">);</code>
        
            <code class="k">if</code> <code class="p">(</code><code class="nx">hasMoreRoom</code><code class="p">)</code> <code class="p">{</code>                     <code class="c1">// If buffer is not full, return</code>
                <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>      <code class="c1">// an already resolved Promise object</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="p">{</code>    <code class="c1">// Otherwise, return a Promise that</code>
                    <code class="nx">stream</code><code class="p">.</code><code class="nx">once</code><code class="p">(</code><code class="s2">"drain"</code><code class="p">,</code> <code class="nx">resolve</code><code class="p">);</code> <code class="c1">// resolves on the drain event.</code>
                <code class="p">});</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// Copy data from the source stream to the destination stream</code>
        <code class="c1">// respecting backpressure from the destination stream.</code>
        <code class="c1">// This is much like calling source.pipe(destination).</code>
        <code class="nx">async</code> <code class="kd">function</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">source</code><code class="p">,</code> <code class="nx">destination</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Set an error handler on the destination stream in case standard</code>
            <code class="c1">// output closes unexpectedly (when piping output to `head`, e.g.)</code>
            <code class="nx">destination</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">err</code> <code class="o">=&gt;</code> <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">());</code>
        
            <code class="c1">// Use a for/await loop to asynchronously read chunks from the input stream</code>
            <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">chunk</code> <code class="k">of</code> <code class="nx">source</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// Write the chunk and wait until there is more room in the buffer.</code>
                <code class="nx">await</code> <code class="nx">write</code><code class="p">(</code><code class="nx">destination</code><code class="p">,</code> <code class="nx">chunk</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// Copy standard input to standard output</code>
        <code class="nx">copy</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">stdin</code><code class="p">,</code> <code class="nx">process</code><code class="p">.</code><code class="nx">stdout</code><code class="p">);</code></pre>
        
        <p>Before<a data-type="indexterm" data-primary="denial-of-service attacks" id="idm46198488681128"></a><a data-type="indexterm" data-primary="security" data-secondary="denial-of-service attacks" id="idm46198488680424"></a> we conclude this discussion of writing to streams, note again
        that failing to respond to backpressure can cause your program to use
        more memory than it should when the internal buffer of a Writable
        stream overflows and grows larger and larger. If you are writing a network
        server, this can be a remotely exploitable security issue. Suppose you
        write an HTTP server that delivers files over the network, but you
        didn’t use <code>pipe()</code> and you didn’t take the time to handle
        backpressure from the <code>write()</code> method. An attacker could write an HTTP
        client that initiates requests for large files (such as images) but
        never actually reads the body of the request. Since the client is not
        reading the data over the network, and the server isn’t responding to
        backpressure, buffers on the server are going to overflow. With enough
        concurrent connections from the attacker, this can turn into a
        denial-of-service attack that slows your server down or even crashes
        it.<a data-type="indexterm" data-primary="" data-startref="back16" id="idm46198488309048"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.5.4 Reading Streams with Events"><div class="sect2" id="idm46198488805960">
        <h2>16.5.4 Reading Streams with Events</h2>
        
        <p>Node’s<a data-type="indexterm" data-primary="Node" data-secondary="streams" data-tertiary="reading with events" id="idm46198488306808"></a><a data-type="indexterm" data-primary="streams (Node)" data-secondary="reading with events" id="idm46198488305528"></a> readable streams have two modes, each of which has its own API
        for reading. If you can’t use pipes or asynchronous iteration in your
        program, you will need to pick one of these two event-based APIs for
        handling streams. It is important that you use only one or the other
        and do not mix the two APIs.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Flowing mode"><div class="sect3" id="flowing_mode">
        <h3>Flowing mode</h3>
        
        <p>In <em>flowing mode</em>, when readable data arrives, it is immediately
        emitted in the form of a “data” event. To read from a stream in this
        mode, simply register an event handler for “data” events, and the
        stream will push chunks of data (buffers or strings) to you as soon as
        they becomes available. Note that there is no need to call the
        <code>read()</code> method in flowing mode: you only need to handle “data”
        events. Note that newly 
        <span class="keep-together">created</span> streams do not start off in flowing
        mode. Registering a “data” event handler switches a stream into
        flowing mode. Conveniently, this means that a stream does not emit
        “data” events until you register the first “data” event handler.</p>
        
        <p>If you are using flowing mode to read data from a Readable stream,
        process it, then write it to a Writable stream, then you may need
        to handle backpressure from the Writable stream. If the <code>write()</code>
        method returns <code>false</code> to indicate that the write buffer is full, you
        can call <code>pause()</code> on the Readable stream to temporarily stop <code>data</code>
        events. Then, when you get a “drain” event from the Writable stream,
        you can call <code>resume()</code> on the Readable stream to start the “data”
        events flowing again.</p>
        
        <p>A stream in flowing mode emits an “end” event when the end of the
        stream is reached. This event indicates that no more “data” events
        will ever be emitted. And, as with all streams, an “error” event is
        emitted if an error occurs.</p>
        
        <p>At the beginning of this section on streams, we showed a nonstreaming
        <code>copyFile()</code> function and promised a better version to come. The
        following code shows how to implement a streaming <code>copyFile()</code>
        function that uses the flowing mode API and handles backpressure. This
        would have been easier to implement with a <code>pipe()</code> call, but it
        serves here as a useful demonstration of the multiple event handlers
        that are used to coordinate data flow from one stream to the other.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        
        <code class="c1">// A streaming file copy function, using "flowing mode".</code>
        <code class="c1">// Copies the contents of the named source file to the named destination file.</code>
        <code class="c1">// On success, invokes the callback with a null argument. On error,</code>
        <code class="c1">// invokes the callback with an Error object.</code>
        <code class="kd">function</code> <code class="nx">copyFile</code><code class="p">(</code><code class="nx">sourceFilename</code><code class="p">,</code> <code class="nx">destinationFilename</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">input</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">createReadStream</code><code class="p">(</code><code class="nx">sourceFilename</code><code class="p">);</code>
            <code class="kd">let</code> <code class="nx">output</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">createWriteStream</code><code class="p">(</code><code class="nx">destinationFilename</code><code class="p">);</code>
        
            <code class="nx">input</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"data"</code><code class="p">,</code> <code class="p">(</code><code class="nx">chunk</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>          <code class="c1">// When we get new data,</code>
                <code class="kd">let</code> <code class="nx">hasRoom</code> <code class="o">=</code> <code class="nx">output</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">chunk</code><code class="p">);</code> <code class="c1">// write it to the output stream.</code>
                <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">hasRoom</code><code class="p">)</code> <code class="p">{</code>                    <code class="c1">// If the output stream is full</code>
                    <code class="nx">input</code><code class="p">.</code><code class="nx">pause</code><code class="p">();</code>                 <code class="c1">// then pause the input stream.</code>
                <code class="p">}</code>
            <code class="p">});</code>
            <code class="nx">input</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"end"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>                <code class="c1">// When we reach the end of input,</code>
                <code class="nx">output</code><code class="p">.</code><code class="nx">end</code><code class="p">();</code>                      <code class="c1">// tell the output stream to end.</code>
            <code class="p">});</code>
            <code class="nx">input</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>             <code class="c1">// If we get an error on the input,</code>
                <code class="nx">callback</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>                     <code class="c1">// call the callback with the error</code>
                <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">();</code>                    <code class="c1">// and quit.</code>
            <code class="p">});</code>
        
            <code class="nx">output</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"drain"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>             <code class="c1">// When the output is no longer full,</code>
                <code class="nx">input</code><code class="p">.</code><code class="nx">resume</code><code class="p">();</code>                    <code class="c1">// resume data events on the input</code>
            <code class="p">});</code>
            <code class="nx">output</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>            <code class="c1">// If we get an error on the output,</code>
                <code class="nx">callback</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>                     <code class="c1">// call the callback with the error</code>
                <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">();</code>                    <code class="c1">// and quit.</code>
            <code class="p">});</code>
            <code class="nx">output</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"finish"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>            <code class="c1">// When output is fully written</code>
                <code class="nx">callback</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>                    <code class="c1">// call the callback with no error.</code>
            <code class="p">});</code>
        <code class="p">}</code>
        
        <code class="c1">// Here's a simple command-line utility to copy files</code>
        <code class="kd">let</code> <code class="nx">from</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">[</code><code class="mi">2</code><code class="p">],</code> <code class="nx">to</code> <code class="o">=</code> <code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">[</code><code class="mi">3</code><code class="p">];</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Copying file </code><code class="si">${</code><code class="nx">from</code><code class="si">}</code><code class="sb"> to </code><code class="si">${</code><code class="nx">to</code><code class="si">}</code><code class="sb">...`</code><code class="p">);</code>
        <code class="nx">copyFile</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">,</code> <code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"done."</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">});</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Paused mode"><div class="sect3" id="idm46198488286168">
        <h3>Paused mode</h3>
        
        <p>The other mode for Readable streams is “paused mode.” This is the mode
        that streams start in. If you never register a “data” event handler
        and never call the <code>pipe()</code> method, then a Readable stream remains in
        paused mode. In paused mode, the stream does not push data to you in
        the form of “data” events. Instead, you pull data from the stream by
        explicitly calling its <code>read()</code> method. This is not a blocking call,
        and if there is no data available to read on the stream, it will
        return <code>null</code>. Since there is not a synchronous API to wait for data,
        the paused mode API is also event-based. A Readable stream in paused
        mode emits “readable” events when data becomes available to read on
        the stream. In response, your code should call the <code>read()</code> method to
        read that data. You must do this in a loop, calling <code>read()</code>
        repeatedly until it returns <code>null</code>. It is necessary to completely
        drain the stream’s buffer like this in order to trigger a new
        “readable” event in the future. If you stop calling <code>read()</code> while
        there is still readable data, you will not get another “readable”
        event and your program is likely to hang.</p>
        
        <p>Streams in paused mode emit “end” and “error” events just like flowing
        mode streams do. If you are writing a program that reads data from a Readable stream
        and writes it to a Writable stream, then paused mode may not be a good
        choice. In order to properly handle backpressure, you only want to read
        when the input stream is readable and the output stream is not backed
        up. In paused mode, that means reading and writing until <code>read()</code>
        returns <code>null</code> or <code>write()</code> returns <code>false</code>, and then starting reading
        or writing again on a <code>readable</code> or <code>drain</code> event. This is inelegant,
        and you may find that flowing mode (or pipes) is easier in this case.</p>
        
        <p>The following code demonstrates how you can compute a SHA256 hash for the
        contents of a specified file. It uses a Readable stream in paused mode
        to read the contents of a file in chunks, then passes each chunk
        to the object that computes the hash. (Note that in Node 12 and later,
        it would be simpler to write this function using a <code>for/await</code> loop.)<a data-type="indexterm" data-primary="" data-startref="Nstream16" id="idm46198488048040"></a><a data-type="indexterm" data-primary="" data-startref="stnode16" id="idm46198488047032"></a></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">crypto</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"crypto"</code><code class="p">);</code>
        
        <code class="c1">// Compute a sha256 hash of the contents of the named file and pass the</code>
        <code class="c1">// hash (as a string) to the specified error-first callback function.</code>
        <code class="kd">function</code> <code class="nx">sha256</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">input</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">createReadStream</code><code class="p">(</code><code class="nx">filename</code><code class="p">);</code> <code class="c1">// The data stream.</code>
            <code class="kd">let</code> <code class="nx">hasher</code> <code class="o">=</code> <code class="nx">crypto</code><code class="p">.</code><code class="nx">createHash</code><code class="p">(</code><code class="s2">"sha256"</code><code class="p">);</code>  <code class="c1">// For computing the hash.</code>
        
            <code class="nx">input</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"readable"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>         <code class="c1">// When there is data ready to read</code>
                <code class="kd">let</code> <code class="nx">chunk</code><code class="p">;</code>
                <code class="k">while</code><code class="p">(</code><code class="nx">chunk</code> <code class="o">=</code> <code class="nx">input</code><code class="p">.</code><code class="nx">read</code><code class="p">())</code> <code class="p">{</code>    <code class="c1">// Read a chunk, and if non-null,</code>
                    <code class="nx">hasher</code><code class="p">.</code><code class="nx">update</code><code class="p">(</code><code class="nx">chunk</code><code class="p">);</code>        <code class="c1">// pass it to the hasher,</code>
                <code class="p">}</code>                                <code class="c1">// and keep looping until not readable</code>
            <code class="p">});</code>
            <code class="nx">input</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"end"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>              <code class="c1">// At the end of the stream,</code>
                <code class="kd">let</code> <code class="nx">hash</code> <code class="o">=</code> <code class="nx">hasher</code><code class="p">.</code><code class="nx">digest</code><code class="p">(</code><code class="s2">"hex"</code><code class="p">);</code> <code class="c1">// compute the hash,</code>
                <code class="nx">callback</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">hash</code><code class="p">);</code>            <code class="c1">// and pass it to the callback.</code>
            <code class="p">});</code>
            <code class="nx">input</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">callback</code><code class="p">);</code>         <code class="c1">// On error, call callback</code>
        <code class="p">}</code>
        
        <code class="c1">// Here's a simple command-line utility to compute the hash of a file</code>
        <code class="nx">sha256</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">[</code><code class="mi">2</code><code class="p">],</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">hash</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c1">// Pass filename from command line.</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>                           <code class="c1">// If we get an error</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">toString</code><code class="p">());</code>   <code class="c1">// print it as an error.</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>                             <code class="c1">// Otherwise,</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">hash</code><code class="p">);</code>               <code class="c1">// print the hash string.</code>
            <code class="p">}</code>
        <code class="p">});</code></pre>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.6 Process, CPU, and Operating System Details"><div class="sect1" id="idm46198489632792">
        <h1>16.6 Process, CPU, and Operating System Details</h1>
        
        <p>The<a data-type="indexterm" data-primary="Node" data-secondary="process details" id="idm46198488042248"></a> global Process object has a number of useful properties and
        functions that generally relate to the state of the currently running
        Node process. Consult the Node documentation for complete details, but
        here are some properties and functions you should be aware of:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">process</code><code class="p">.</code><code class="nx">argv</code>            <code class="c1">// An array of command-line arguments.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">arch</code>            <code class="c1">// The CPU architecture: "x64", for example.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">cwd</code><code class="p">()</code>           <code class="c1">// Returns the current working directory.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">chdir</code><code class="p">()</code>         <code class="c1">// Sets the current working directory.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">cpuUsage</code><code class="p">()</code>      <code class="c1">// Reports CPU usage.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">env</code>             <code class="c1">// An object of environment variables.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">execPath</code>        <code class="c1">// The absolute filesystem path to the node executable.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">()</code>          <code class="c1">// Terminates the program.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">exitCode</code>        <code class="c1">// An integer code to be reported when the program exits.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">getuid</code><code class="p">()</code>        <code class="c1">// Return the Unix user id of the current user.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">hrtime</code><code class="p">.</code><code class="nx">bigint</code><code class="p">()</code> <code class="c1">// Return a "high-resolution" nanosecond timestamp.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">kill</code><code class="p">()</code>          <code class="c1">// Send a signal to another process.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">memoryUsage</code><code class="p">()</code>   <code class="c1">// Return an object with memory usage details.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">nextTick</code><code class="p">()</code>      <code class="c1">// Like setImmediate(), invoke a function soon.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">pid</code>             <code class="c1">// The process id of the current process.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">ppid</code>            <code class="c1">// The parent process id.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">platform</code>        <code class="c1">// The OS: "linux", "darwin", or "win32", for example.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">resourceUsage</code><code class="p">()</code> <code class="c1">// Return an object with resource usage details.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">setuid</code><code class="p">()</code>        <code class="c1">// Sets the current user, by id or name.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">title</code>           <code class="c1">// The process name that appears in `ps` listings.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">umask</code><code class="p">()</code>         <code class="c1">// Set or return the default permissions for new files.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">uptime</code><code class="p">()</code>        <code class="c1">// Return Node's uptime in seconds.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">version</code>         <code class="c1">// Node's version string.</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">versions</code>        <code class="c1">// Version strings for the libraries Node depends on.</code></pre>
        
        <p>The “os” module (which, unlike <code>process</code>, needs to be explicitly loaded
        with <code>require()</code>) provides access to similarly low-level details about
        the computer and operating system that Node is running on. You may
        never need to use any of these features, but it is worth knowing that
        Node makes them available:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">os</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"os"</code><code class="p">);</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">arch</code><code class="p">()</code>              <code class="c1">// Returns CPU architecture. "x64" or "arm", for example.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">constants</code>           <code class="c1">// Useful constants such as os.constants.signals.SIGINT.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">cpus</code><code class="p">()</code>              <code class="c1">// Data about system CPU cores, including usage times.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">endianness</code><code class="p">()</code>        <code class="c1">// The CPU's native endianness "BE" or "LE".</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">EOL</code>                 <code class="c1">// The OS native line terminator: "\n" or "\r\n".</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">freemem</code><code class="p">()</code>           <code class="c1">// Returns the amount of free RAM in bytes.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">getPriority</code><code class="p">()</code>       <code class="c1">// Returns the OS scheduling priority of a process.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">homedir</code><code class="p">()</code>           <code class="c1">// Returns the current user's home directory.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">hostname</code><code class="p">()</code>          <code class="c1">// Returns the hostname of the computer.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">loadavg</code><code class="p">()</code>           <code class="c1">// Returns the 1, 5, and 15-minute load averages.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">networkInterfaces</code><code class="p">()</code> <code class="c1">// Returns details about available network. connections.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">platform</code><code class="p">()</code>          <code class="c1">// Returns OS: "linux", "darwin", or "win32", for example.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">release</code><code class="p">()</code>           <code class="c1">// Returns the version number of the OS.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">setPriority</code><code class="p">()</code>       <code class="c1">// Attempts to set the scheduling priority for a process.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">tmpdir</code><code class="p">()</code>            <code class="c1">// Returns the default temporary directory.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">totalmem</code><code class="p">()</code>          <code class="c1">// Returns the total amount of RAM in bytes.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">type</code><code class="p">()</code>              <code class="c1">// Returns OS: "Linux", "Darwin", or "Windows_NT", e.g.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">uptime</code><code class="p">()</code>            <code class="c1">// Returns the system uptime in seconds.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">userInfo</code><code class="p">()</code>          <code class="c1">// Returns uid, username, home, and shell of current user.</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.7 Working with Files"><div class="sect1" id="idm46198487627352">
        <h1>16.7 Working with Files</h1>
        
        <p>Node’s<a data-type="indexterm" data-primary="modules" data-secondary="fs module (Node)" id="Mfs16"></a><a data-type="indexterm" data-primary="fs module (Node)" id="fsmodule16"></a><a data-type="indexterm" data-primary="Node" data-secondary="file handling" id="Nfile16"></a><a data-type="indexterm" data-primary="Node" data-secondary="file handling" data-tertiary="overview of" id="idm46198487351272"></a><a data-type="indexterm" data-primary="file handling (Node)" id="filenode16"></a><a data-type="indexterm" data-primary="file handling (Node)" data-secondary="overview of" id="idm46198487349112"></a> “fs” module is a comprehensive API for working with files and
        directories. It is complemented by the “path” module, which defines
        utility functions for working with file and directory names. The “fs”
        module contains a handful of high-level functions for easily reading,
        writing, and copying files. But most of the functions in the module are
        low-level JavaScript bindings to Unix system calls (and their
        equivalents on Windows). If you have worked with low-level filesystem
        calls before (in C or other 
        <span class="keep-together">languages),</span> then the Node API will be
        familiar to you. If not, you may find parts of the “fs” API to be
        terse and unintuitive. The function to delete a file, for example, is
        called <code>unlink()</code>.</p>
        
        <p>The “fs” module defines a large API, mainly because there are usually
        multiple variants of each fundamental operation. As discussed at the
        beginning of the chapter, most functions such as <code>fs.readFile()</code> are
        nonblocking, callback-based, and asynchronous. Typically, though, each
        of these functions has a synchronous blocking variant, such as
        <code>fs.readFileSync()</code>. In Node 10 and later, many of these functions
        also have a Promise-based asynchronous variant such as
        <code>fs.promises.readFile()</code>. Most “fs” functions take a string as their
        first argument, specifying the path (filename plus optional directory
        names) to the file that is to be operated on. But a number of these
        functions also support a variant that takes an integer “file
        descriptor” as the first argument instead of a path. These variants
        have names that begin with the letter “f.” For example, <code>fs.truncate()</code>
        truncates a file specified by path, and <code>fs.ftruncate()</code> truncates a
        file specified by file descriptor. There is a Promise-based
        <code>fs.promises.truncate()</code> that expects a path and another
        Promise-based version that is implemented as a method of a FileHandle
        object. (The FileHandle class is the equivalent of a file descriptor
        in the Promise-based API.) Finally, there are a handful of functions
        in the “fs” module that have variants whose names are prefixed with
        the letter “l.” These “l” variants are like the base function but do
        not follow symbolic links in the filesystem and instead operate
        directly on the symbolic links themselves.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.7.1 Paths, File Descriptors, and FileHandles"><div class="sect2" id="idm46198487341752">
        <h2>16.7.1 Paths, File Descriptors, and FileHandles</h2>
        
        <p>In<a data-type="indexterm" data-primary="Node" data-secondary="file handling" data-tertiary="paths, file descriptors, and FileHandles" id="idm46198487339992"></a><a data-type="indexterm" data-primary="file handling (Node)" data-secondary="paths, file descriptors, and FileHandles" id="idm46198487338616"></a> order to use the “fs” module to work with files, you first need to
        be able to name the file you want to work with. Files are most often
        specified by <em>path</em>, which means the name of the file itself, plus the
        hierarchy of directories in which the file appears. If a path is
        <em>absolute</em>, it means that directories all the way up to the filesystem
        root are specified. Otherwise, the path is <em>relative</em> and is only
        meaningful in relation to some other path, usually the <em>current working directory</em>.  Working with paths can be a little tricky because
        different operating systems use different characters to separate
        directory names, it is easy to accidentally double those
        separator characters when concatenating paths, and because <code>../</code>
        parent directory path segments need special handling. Node’s “path”
        module and a couple of other important Node features help:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Some important paths</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">cwd</code><code class="p">()</code>      <code class="c1">// Absolute path of the current working directory.</code>
        <code class="nx">__filename</code>         <code class="c1">// Absolute path of the file that holds the current code.</code>
        <code class="nx">__dirname</code>          <code class="c1">// Absolute path of the directory that holds __filename.</code>
        <code class="nx">os</code><code class="p">.</code><code class="nx">homedir</code><code class="p">()</code>       <code class="c1">// The user's home directory.</code>
        
        <code class="kr">const</code> <code class="nx">path</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"path"</code><code class="p">);</code>
        
        <code class="nx">path</code><code class="p">.</code><code class="nx">sep</code>                         <code class="c1">// Either "/" or "\" depending on your OS</code>
        
        <code class="c1">// The path module has simple parsing functions</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="s2">"src/pkg/test.js"</code><code class="p">;</code>       <code class="c1">// An example path</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">basename</code><code class="p">(</code><code class="nx">p</code><code class="p">)</code>                 <code class="c1">// =&gt; "test.js"</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">extname</code><code class="p">(</code><code class="nx">p</code><code class="p">)</code>                  <code class="c1">// =&gt; ".js"</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">dirname</code><code class="p">(</code><code class="nx">p</code><code class="p">)</code>                  <code class="c1">// =&gt; "src/pkg"</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">basename</code><code class="p">(</code><code class="nx">path</code><code class="p">.</code><code class="nx">dirname</code><code class="p">(</code><code class="nx">p</code><code class="p">))</code>   <code class="c1">// =&gt; "pkg"</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">dirname</code><code class="p">(</code><code class="nx">path</code><code class="p">.</code><code class="nx">dirname</code><code class="p">(</code><code class="nx">p</code><code class="p">))</code>    <code class="c1">// =&gt; "src"</code>
        
        <code class="c1">// normalize() cleans up paths:</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">normalize</code><code class="p">(</code><code class="s2">"a/b/c/../d/"</code><code class="p">)</code>    <code class="c1">// =&gt; "a/b/d/": handles ../ segments</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">normalize</code><code class="p">(</code><code class="s2">"a/./b"</code><code class="p">)</code>          <code class="c1">// =&gt; "a/b": strips "./" segments</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">normalize</code><code class="p">(</code><code class="s2">"//a//b//"</code><code class="p">)</code>       <code class="c1">// =&gt; "/a/b/": removes duplicate /</code>
        
        <code class="c1">// join() combines path segments, adding separators, then normalizes</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"src"</code><code class="p">,</code> <code class="s2">"pkg"</code><code class="p">,</code> <code class="s2">"t.js"</code><code class="p">)</code>  <code class="c1">// =&gt; "src/pkg/t.js"</code>
        
        <code class="c1">// resolve() takes one or more path segments and returns an absolute</code>
        <code class="c1">// path. It starts with the last argument and works backward, stopping</code>
        <code class="c1">// when it has built an absolute path or resolving against process.cwd().</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">resolve</code><code class="p">()</code>                   <code class="c1">// =&gt; process.cwd()</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="s2">"t.js"</code><code class="p">)</code>             <code class="c1">// =&gt; path.join(process.cwd(), "t.js")</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="s2">"/tmp"</code><code class="p">,</code> <code class="s2">"t.js"</code><code class="p">)</code>     <code class="c1">// =&gt; "/tmp/t.js"</code>
        <code class="nx">path</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="s2">"/a"</code><code class="p">,</code> <code class="s2">"/b"</code><code class="p">,</code> <code class="s2">"t.js"</code><code class="p">)</code> <code class="c1">// =&gt; "/b/t.js"</code></pre>
        
        <p>Note that <code>path.normalize()</code> is simply a string manipulation function
        that has no access to the actual filesystem. The <code>fs.realpath()</code> and
        <code>fs.realpathSync()</code> functions perform filesystem-aware
        canonicalization: they resolve symbolic links and interpret relative
        pathnames relative to the current working directory.</p>
        
        <p>In the previous examples, we assumed that the code is running on a
        Unix-based OS and <code>path.sep</code> is “/.” If you want to work with
        Unix-style paths even when on a Windows system, then use <code>path.posix</code>
        instead of <code>path</code>. And conversely, if you want to work with Windows
        paths even when on a Unix system, <code>path.win32</code>. <code>path.posix</code>
        and <code>path.win32</code> define the same properties and functions as <code>path</code>
        itself.</p>
        
        <p>Some of the “fs” functions we’ll be covering in the next sections expect a <em>file
        descriptor</em> instead of a file name. File descriptors are integers used
        as OS-level references to “open” files. You obtain a descriptor for a
        given name by calling the <code>fs.open()</code> (or <code>fs.openSync()</code>)
        function. Processes are only allowed to have a limited number of files
        open at one time, so it is important that you call <code>fs.close()</code> on
        your file descriptors when you are done with them. You need to open
        files if you want to use the lowest-level <code>fs.read()</code> and <code>fs.write()</code>
        functions that allow you to jump around within a file, reading and
        writing bits of it at different times. There are other functions in
        the “fs” module that use file descriptors, but they all have
        name-based versions, and it only really makes sense to use the
        descriptor-based functions if you were going to open the file to read
        or write anyway.</p>
        
        <p>Finally, in the Promise-based API defined by <code>fs.promises</code>, the
        equivalent of <code>fs.open()</code> is <code>fs.promises.open()</code>, which returns a
        Promise that resolves to a FileHandle object. This FileHandle object
        serves the same purpose as a file descriptor.  Again,
        however, unless you need to use the lowest-level <code>read()</code> and
        <code>write()</code> methods of a FileHandle, there is really no reason to create
        one. And if you do create a FileHandle, you should remember to call
        its <code>close()</code> method once you are done with it.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.7.2 Reading Files"><div class="sect2" id="idm46198487171496">
        <h2>16.7.2 Reading Files</h2>
        
        <p>Node<a data-type="indexterm" data-primary="Node" data-secondary="file handling" data-tertiary="reading files" id="idm46198487169768"></a><a data-type="indexterm" data-primary="file handling (Node)" data-secondary="reading files" id="idm46198487168488"></a> allows you to read file content all at once, via a stream, or
        with the low-level API.</p>
        
        <p>If your files are small, or if memory usage and performance are not
        the highest priority, then it is often easiest to read the entire
        content of a file with a single call. You can do this synchronously,
        with a callback, or with a Promise. By default, you’ll get the bytes of
        the file as a buffer, but if you specify an encoding, you’ll get a
        decoded string instead.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">buffer</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readFileSync</code><code class="p">(</code><code class="s2">"test.data"</code><code class="p">);</code>      <code class="c1">// Synchronous, returns buffer</code>
        <code class="kd">let</code> <code class="nx">text</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readFileSync</code><code class="p">(</code><code class="s2">"data.csv"</code><code class="p">,</code> <code class="s2">"utf8"</code><code class="p">);</code> <code class="c1">// Synchronous, returns string</code>
        
        <code class="c1">// Read the bytes of the file asynchronously</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s2">"test.data"</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">buffer</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// Handle the error here</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="c1">// The bytes of the file are in buffer</code>
            <code class="p">}</code>
        <code class="p">});</code>
        
        <code class="c1">// Promise-based asynchronous read</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">promises</code>
            <code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s2">"data.csv"</code><code class="p">,</code> <code class="s2">"utf8"</code><code class="p">)</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">processFileText</code><code class="p">)</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">handleReadError</code><code class="p">);</code>
        
        <code class="c1">// Or use the Promise API with await inside an async function</code>
        <code class="nx">async</code> <code class="kd">function</code> <code class="nx">processText</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="nx">encoding</code><code class="o">=</code><code class="s2">"utf8"</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">text</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">promises</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="nx">encoding</code><code class="p">);</code>
            <code class="c1">// ... process the text here...</code>
        <code class="p">}</code></pre>
        
        <p>If you are able to process the contents of a file sequentially and do
        not need to have the entire content of the file in memory at the same
        time, then reading a file via a stream may be the most efficient
        approach. We’ve covered streams extensively: here is how you
        might use a stream and the <code>pipe()</code> method to write the contents of a
        file to standard output:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">printFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="nx">encoding</code><code class="o">=</code><code class="s2">"utf8"</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">fs</code><code class="p">.</code><code class="nx">createReadStream</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="nx">encoding</code><code class="p">).</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">stdout</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>Finally, if you need low-level control over exactly what bytes you
        read from a file and when you read them, you can open a file to get a
        file descriptor and then use <code>fs.read()</code>, <code>fs.readSync()</code>, or
        <code>fs.promises.read()</code> to read a specified number of bytes from a
        specified source location of the file into a specified buffer at the
        specified destination position:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        
        <code class="c1">// Reading a specific portion of a data file</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">open</code><code class="p">(</code><code class="s2">"data"</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">fd</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// Report error somehow</code>
                <code class="k">return</code><code class="p">;</code>
            <code class="p">}</code>
            <code class="k">try</code> <code class="p">{</code>
                <code class="c1">// Read bytes 20 through 420 into a newly allocated buffer.</code>
                <code class="nx">fs</code><code class="p">.</code><code class="nx">read</code><code class="p">(</code><code class="nx">fd</code><code class="p">,</code> <code class="nx">Buffer</code><code class="p">.</code><code class="nx">alloc</code><code class="p">(</code><code class="mi">400</code><code class="p">),</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">400</code><code class="p">,</code> <code class="mi">20</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">n</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="c1">// err is the error, if any.</code>
                    <code class="c1">// n is the number of bytes actually read</code>
                    <code class="c1">// b is the buffer that they bytes were read into.</code>
                <code class="p">});</code>
            <code class="p">}</code>
            <code class="k">finally</code> <code class="p">{</code>          <code class="c1">// Use a finally clause so we always</code>
                <code class="nx">fs</code><code class="p">.</code><code class="nx">close</code><code class="p">(</code><code class="nx">fd</code><code class="p">);</code>  <code class="c1">// close the open file descriptor</code>
            <code class="p">}</code>
        <code class="p">});</code></pre>
        
        <p>The callback-based <code>read()</code> API is awkward to use if you need to read
        more than one chunk of data from a file. If you can use the
        synchronous API (or the Promise-based API with <code>await</code>), it becomes
        easy to read multiple chunks from a file:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        
        <code class="kd">function</code> <code class="nx">readData</code><code class="p">(</code><code class="nx">filename</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">fd</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">openSync</code><code class="p">(</code><code class="nx">filename</code><code class="p">);</code>
            <code class="k">try</code> <code class="p">{</code>
                <code class="c1">// Read the file header</code>
                <code class="kd">let</code> <code class="nx">header</code> <code class="o">=</code> <code class="nx">Buffer</code><code class="p">.</code><code class="nx">alloc</code><code class="p">(</code><code class="mi">12</code><code class="p">);</code> <code class="c1">// A 12 byte buffer</code>
                <code class="nx">fs</code><code class="p">.</code><code class="nx">readSync</code><code class="p">(</code><code class="nx">fd</code><code class="p">,</code> <code class="nx">header</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">12</code><code class="p">,</code> <code class="mi">0</code><code class="p">);</code>
        
                <code class="c1">// Verify the file's magic number</code>
                <code class="kd">let</code> <code class="nx">magic</code> <code class="o">=</code> <code class="nx">header</code><code class="p">.</code><code class="nx">readInt32LE</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">magic</code> <code class="o">!==</code> <code class="mh">0xDADAFEED</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"File is of wrong type"</code><code class="p">);</code>
                <code class="p">}</code>
        
                <code class="c1">// Now get the offset and length of the data from the header</code>
                <code class="kd">let</code> <code class="nx">offset</code> <code class="o">=</code> <code class="nx">header</code><code class="p">.</code><code class="nx">readInt32LE</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code>
                <code class="kd">let</code> <code class="nx">length</code> <code class="o">=</code> <code class="nx">header</code><code class="p">.</code><code class="nx">readInt32LE</code><code class="p">(</code><code class="mi">8</code><code class="p">);</code>
        
                <code class="c1">// And read those bytes from the file</code>
                <code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="nx">Buffer</code><code class="p">.</code><code class="nx">alloc</code><code class="p">(</code><code class="nx">length</code><code class="p">);</code>
                <code class="nx">fs</code><code class="p">.</code><code class="nx">readSync</code><code class="p">(</code><code class="nx">fd</code><code class="p">,</code> <code class="nx">data</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">length</code><code class="p">,</code> <code class="nx">offset</code><code class="p">);</code>
                <code class="k">return</code> <code class="nx">data</code><code class="p">;</code>
            <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
                <code class="c1">// Always close the file, even if an exception is thrown above</code>
                <code class="nx">fs</code><code class="p">.</code><code class="nx">closeSync</code><code class="p">(</code><code class="nx">fd</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.7.3 Writing Files"><div class="sect2" id="idm46198487170872">
        <h2>16.7.3 Writing Files</h2>
        
        <p>Writing<a data-type="indexterm" data-primary="Node" data-secondary="file handling" data-tertiary="writing files" id="idm46198486830040"></a><a data-type="indexterm" data-primary="file handling (Node)" data-secondary="writing files" id="idm46198486637800"></a> files in Node is a lot like reading them, with a few extra
        details that you need to know about. One of these details is that the
        way you create a new file is simply by writing to a filename that does
        not already exist.</p>
        
        <p>As with reading, there are three basic ways to write files in Node. If
        you have the entire content of the file in a string or a buffer, you
        can write the entire thing in one call with <code>fs.writeFile()</code>
        (callback-based), <code>fs.writeFileSync()</code> (synchronous), or
        <code>fs.promises.writeFile()</code> (Promise-based):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fs</code><code class="p">.</code><code class="nx">writeFileSync</code><code class="p">(</code><code class="nx">path</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">__dirname</code><code class="p">,</code> <code class="s2">"settings.json"</code><code class="p">),</code>
                         <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">settings</code><code class="p">));</code></pre>
        
        <p>If the data you are writing to the file is a string, and you want to
        use an encoding other than “utf8,” pass the encoding as an optional
        third argument.</p>
        
        <p>The related functions <code>fs.appendFile()</code>, <code>fs.appendFileSync()</code>, and
        <code>fs.promises.appendFile()</code> are similar, but when the specified file
        already exists,
        they append their data to the end rather than overwriting the existing
        file content.</p>
        
        <p>If the data you want to write to a file is not all in one chunk, or if
        it is not all in memory at the same time, then using a Writable stream
        is a good approach, assuming that you plan to write the data from
        beginning to end without skipping around in the file:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">output</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">createWriteStream</code><code class="p">(</code><code class="s2">"numbers.txt"</code><code class="p">);</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">100</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">output</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">i</code><code class="si">}</code><code class="err">\</code><code class="sb">n`</code><code class="p">);</code>
        <code class="p">}</code>
        <code class="nx">output</code><code class="p">.</code><code class="nx">end</code><code class="p">();</code></pre>
        
        <p>Finally, if you want to write data to a file in multiple chunks, and
        you want to be able to control the exact position within the file at
        which each chunk is written, then you can open the file with
        <code>fs.open()</code>, <code>fs.openSync()</code>, or <code>fs.promises.open()</code> and then use
        the resulting file descriptor with the <code>fs.write()</code> or
        <code>fs.writeSync()</code> functions. These functions come in different forms
        for strings and buffers. The string variant takes a file descriptor, a
        string, and the file position at which to write that string (with an
        encoding as an optional fourth argument). The buffer variant takes a
        file descriptor, a buffer, an offset, and a length that specify a chunk
        of data within the buffer, and a file position at which to write the
        bytes of that chunk. And if you have an array of Buffer objects that
        you want to write, you can do this with a single <code>fs.writev()</code> or
        <code>fs.writevSync()</code>.  Similar low-level functions exist for writing
        buffers and strings using <code>fs.promises.open()</code> and the FileHandle
        object it produces.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198486559096">
        <h5>File Mode Strings</h5>
        <p>We<a data-type="indexterm" data-primary="Node" data-secondary="file handling" data-tertiary="file mode strings" id="idm46198486557528"></a><a data-type="indexterm" data-primary="file handling (Node)" data-secondary="file mode strings" id="idm46198486556248"></a> saw the <code>fs.open()</code> and <code>fs.openSync()</code> methods before when using
        the low-level API to read files. In that use case, it was sufficient to
        just pass the filename to the open function. When you want to write a
        file, however, you must also specify a second string argument that
        specifies how you intend to use the file descriptor. Some of the
        available flag strings are as follows:</p>
        <dl>
        <dt><code>"w"</code></dt>
        <dd>
        <p>Open the file for writing</p>
        </dd>
        <dt><code>"w+"</code></dt>
        <dd>
        <p>Open for writing and reading</p>
        </dd>
        <dt><code>"wx"</code></dt>
        <dd>
        <p>Open for creating a new file; fails if the named file already
        exists</p>
        </dd>
        <dt><code>"wx+"</code></dt>
        <dd>
        <p>Open for creation, and also allow reading; fails if the
        named file already exists</p>
        </dd>
        <dt><code>"a"</code></dt>
        <dd>
        <p>Open the file for appending; existing content won’t be overwritten</p>
        </dd>
        <dt><code>"a+"</code></dt>
        <dd>
        <p>Open for appending, but also allow reading</p>
        </dd>
        </dl>
        
        <p>If you do not pass one of these flag strings to <code>fs.open()</code> or
        <code>fs.openSync()</code>, they use the default “r” flag, making the file
        descriptor read-only. Note that it can also be useful to pass these
        flags to other file-writing methods:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Write to a file in one call, but append to anything that is already there.</code>
        <code class="c1">// This works like fs.appendFileSync()</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">writeFileSync</code><code class="p">(</code><code class="s2">"messages.log"</code><code class="p">,</code> <code class="s2">"hello"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">flag</code><code class="o">:</code> <code class="s2">"a"</code> <code class="p">});</code>
        
        <code class="c1">// Open a write stream, but throw an error if the file already exists.</code>
        <code class="c1">// We don't want to accidentally overwrite something!</code>
        <code class="c1">// Note that the option above is "flag" and is "flags" here</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">createWriteStream</code><code class="p">(</code><code class="s2">"messages.log"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">flags</code><code class="o">:</code> <code class="s2">"wx"</code> <code class="p">});</code></pre>
        </div></aside>
        
        <p>You can chop off the end of a file with <code>fs.truncate()</code>,
        <code>fs.truncateSync()</code>, or <code>fs.promises.truncate()</code>. These functions take
        a path as their first argument and a length as their second, and
        modify the file so that it has the specified length. If you omit the
        length, zero is used and the file becomes empty. Despite the name of
        these functions, they can also be used to extend a file: if you
        specify a length that is longer than the current file size, the file
        is extended with zero bytes to the new size. If you have already
        opened the file you wish to modify, you can use <code>ftruncate()</code> or
        
        <span class="keep-together"><code>ftruncateSync()</code></span> with the file descriptor or FileHandle.</p>
        
        <p>The various file-writing functions described here return or invoke
        their callback or resolve their Promise when the data has been
        “written” in the sense that Node has handed it off to the operating
        system. But this does not necessarily mean that the data has actually
        been written to persistent storage yet: at least some of your data may
        still be buffered somewhere in the operating system or in a device
        driver waiting to be written to disk. If you call <code>fs.writeSync()</code> to
        synchronously write some data to a file, and if there is a power
        outage immediately after the function returns, you may still lose
        data. If you want to force your data out to disk so you know for sure
        that it has been safely saved, use <code>fs.fsync()</code> or
        <code>fs.fsyncSync()</code>. These functions only work with file descriptors:
        there is no path-based version.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.7.4 File Operations"><div class="sect2" id="idm46198486831016">
        <h2>16.7.4 File Operations</h2>
        
        <p>The<a data-type="indexterm" data-primary="Node" data-secondary="file handling" data-tertiary="file operations" id="idm46198486407560"></a><a data-type="indexterm" data-primary="file handling (Node)" data-secondary="file operations" id="idm46198486406280"></a> preceding discussion of Node’s stream classes included two examples of
        <code>copyFile()</code> functions. These are not practical utilities that you
        would actually use because the “fs” module defines its own
        <code>fs.copyFile()</code> method (and also <code>fs.copyFileSync()</code> and
        <code>fs.promises.copyFile()</code>, of course).</p>
        
        <p>These functions take the name of the original file and the name of the
        copy as their first two arguments. These can be specified as strings
        or as URL or Buffer objects. An optional third argument is an integer
        whose bits specify flags that control details of the <code>copy</code>
        operation. And for the callback-based <code>fs.copyFile()</code>, the final
        argument is a callback function that will be called with no arguments
        when the copy is complete, or that will be called with an error argument if
        something fails. Following are some examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Basic synchronous file copy.</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">copyFileSync</code><code class="p">(</code><code class="s2">"ch15.txt"</code><code class="p">,</code> <code class="s2">"ch15.bak"</code><code class="p">);</code>
        
        <code class="c1">// The COPYFILE_EXCL argument copies only if the new file does not already</code>
        <code class="c1">// exist. It prevents copies from overwriting existing files.</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">copyFile</code><code class="p">(</code><code class="s2">"ch15.txt"</code><code class="p">,</code> <code class="s2">"ch16.txt"</code><code class="p">,</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">constants</code><code class="p">.</code><code class="nx">COPYFILE_EXCL</code><code class="p">,</code> <code class="nx">err</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="c1">// This callback will be called when done. On error, err will be non-null.</code>
        <code class="p">});</code>
        
        <code class="c1">// This code demonstrates the Promise-based version of the copyFile function.</code>
        <code class="c1">// Two flags are combined with the bitwise OR opeartor |. The flags mean that</code>
        <code class="c1">// existing files won't be overwritten, and that if the filesystem supports</code>
        <code class="c1">// it, the copy will be a copy-on-write clone of the original file, meaning</code>
        <code class="c1">// that no additional storage space will be required until either the original</code>
        <code class="c1">// or the copy is modified.</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">promises</code><code class="p">.</code><code class="nx">copyFile</code><code class="p">(</code><code class="s2">"Important data"</code><code class="p">,</code>
                             <code class="sb">`Important data </code><code class="si">${</code><code class="k">new</code> <code class="nb">Date</code><code class="p">().</code><code class="nx">toISOString</code><code class="p">()</code><code class="si">}</code><code class="sb">"</code>
        <code class="sb">                     fs.constants.COPYFILE_EXCL | fs.constants.COPYFILE_FICLONE)</code>
        <code class="sb">    .then(() =&gt; {</code>
        <code class="sb">        console.log("Backup complete");</code>
        <code class="sb">    });</code>
        <code class="sb">    .catch(err =&gt; {</code>
        <code class="sb">        console.error("Backup failed", err);</code>
        <code class="sb">    });</code></pre>
        
        <p>The <code>fs.rename()</code> function (along with the usual synchronous and
        Promise-based variants) moves and/or renames a file. Call it with the
        current path to the file and the desired new path to the file. There
        is no flags argument, but the callback-based version takes a callback
        as the third argument:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fs</code><code class="p">.</code><code class="nx">renameSync</code><code class="p">(</code><code class="s2">"ch15.bak"</code><code class="p">,</code> <code class="s2">"backups/ch15.bak"</code><code class="p">);</code></pre>
        
        <p>Note that there is no flag to prevent renaming from overwriting an
        existing file. Also keep in mind that files can only be renamed within
        a filesystem.</p>
        
        <p>The functions <code>fs.link()</code> and <code>fs.symlink()</code> and their variants have
        the same signatures as <code>fs.rename()</code> and behave something like
        <code>fs.copyFile()</code> except that they create hard links and symbolic links,
        respectively, rather than creating a copy.</p>
        
        <p>Finally, <code>fs.unlink()</code>, <code>fs.unlinkSync()</code>, and <code>fs.promises.unlink()</code>
        are Node’s functions for deleting a file. (The unintuitive naming is
        inherited from Unix where deleting a file is basically the opposite of
        creating a hard link to it.) Call this function with the string,
        buffer, or URL path to the file to be deleted, and pass a callback if
        you are using the callback-based version:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fs</code><code class="p">.</code><code class="nx">unlinkSync</code><code class="p">(</code><code class="s2">"backups/ch15.bak"</code><code class="p">);</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.7.5 File Metadata"><div class="sect2" id="idm46198486408888">
        <h2>16.7.5 File Metadata</h2>
        
        <p>The<a data-type="indexterm" data-primary="Node" data-secondary="file handling" data-tertiary="file metadata" id="idm46198486274952"></a><a data-type="indexterm" data-primary="file handling (Node)" data-secondary="file metadata" id="idm46198486273672"></a> <code>fs.stat()</code>, <code>fs.statSync()</code>, and <code>fs.promises.stat()</code> functions
        allow you to obtain metadata for a specified file or directory. For
        example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">stats</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">statSync</code><code class="p">(</code><code class="s2">"book/ch15.md"</code><code class="p">);</code>
        <code class="nx">stats</code><code class="p">.</code><code class="nx">isFile</code><code class="p">()</code>         <code class="c1">// =&gt; true: this is an ordinary file</code>
        <code class="nx">stats</code><code class="p">.</code><code class="nx">isDirectory</code><code class="p">()</code>    <code class="c1">// =&gt; false: it is not a directory</code>
        <code class="nx">stats</code><code class="p">.</code><code class="nx">size</code>             <code class="c1">// file size in bytes</code>
        <code class="nx">stats</code><code class="p">.</code><code class="nx">atime</code>            <code class="c1">// access time: Date when it was last read</code>
        <code class="nx">stats</code><code class="p">.</code><code class="nx">mtime</code>            <code class="c1">// modification time: Date when it was last written</code>
        <code class="nx">stats</code><code class="p">.</code><code class="nx">uid</code>              <code class="c1">// the user id of the file's owner</code>
        <code class="nx">stats</code><code class="p">.</code><code class="nx">gid</code>              <code class="c1">// the group id of the file's owner</code>
        <code class="nx">stats</code><code class="p">.</code><code class="nx">mode</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="mi">8</code><code class="p">)</code> <code class="c1">// the file's permissions, as an octal string</code></pre>
        
        <p>The returned Stats object contains other, more obscure properties and
        methods, but this code demonstrates those that you are most
        likely to use.</p>
        
        <p><code>fs.lstat()</code> and its variants work just like <code>fs.stat()</code>, except that
        if the specified file is a symbolic link, Node will return metadata
        for the link itself rather than following the link.</p>
        
        <p>If you have opened a file to produce a file descriptor or a FileHandle
        object, then you can use <code>fs.fstat()</code> or its variants to get metadata
        information for the opened file without having to specify the filename again.</p>
        
        <p>In addition to querying metadata with <code>fs.stat()</code> and all of its
        variants, there are also functions for changing metadata.</p>
        
        <p><code>fs.chmod()</code>, <code>fs.lchmod()</code>, and <code>fs.fchmod()</code> (along with synchronous
        and Promise-based versions) set the “mode” or permissions of a file or
        directory. Mode values are integers in which each bit has a specific
        meaning and are easiest to think about in octal notation. For example,
        to make a file read-only to its owner and inaccessible to everyone
        else, use <code>0o400</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fs</code><code class="p">.</code><code class="nx">chmodSync</code><code class="p">(</code><code class="s2">"ch15.md"</code><code class="p">,</code> <code class="mo">0o400</code><code class="p">);</code>  <code class="c1">// Don't delete it accidentally!</code></pre>
        
        <p><code>fs.chown()</code>, <code>fs.lchown()</code>, and <code>fs.fchown()</code> (along with synchronous
        and Promise-based versions) set the owner and group (as IDs) for a
        file or directory. (These matter because they interact with the file
        permissions set by <code>fs.chmod()</code>.)</p>
        
        <p>Finally, you can set the access time and modification time of a file
        or directory with <code>fs.utimes()</code> and <code>fs.futimes()</code> and their variants.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.7.6 Working with Directories"><div class="sect2" id="idm46198486275960">
        <h2>16.7.6 Working with Directories</h2>
        
        <p>To<a data-type="indexterm" data-primary="Node" data-secondary="file handling" data-tertiary="directories" id="idm46198486138808"></a><a data-type="indexterm" data-primary="file handling (Node)" data-secondary="directories" id="idm46198486137528"></a><a data-type="indexterm" data-primary="directories (Node)" id="idm46198486136584"></a> create a new directory in Node, use <code>fs.mkdir()</code>, <code>fs.mkdirSync()</code>,
        or <code>fs.promises.mkdir()</code>. The first argument is the path of the
        directory to be created. The optional second argument can be an
        integer that specifies the mode (permissions bits) for the new
        directory. Or you can pass an object with optional <code>mode</code> and
        <code>recursive</code> properties. If <code>recursive</code> is <code>true</code>, then this function
        will create any directories in the path that do not already exist:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Ensure that dist/ and dist/lib/ both exist.</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">mkdirSync</code><code class="p">(</code><code class="s2">"dist/lib"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">recursive</code><code class="o">:</code> <code class="kc">true</code> <code class="p">});</code></pre>
        
        <p><code>fs.mkdtemp()</code> and its variants take a path prefix you provide, append
        some random characters to it (this is important for security), create
        a directory with that name, and return (or pass to a callback) the
        directory path to you.</p>
        
        <p>To delete a directory, use <code>fs.rmdir()</code> or one of its variants. Note
        that directories must be empty before they can be deleted:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Create a random temporary directory and get its path, then</code>
        <code class="c1">// delete it when we are done</code>
        <code class="kd">let</code> <code class="nx">tempDirPath</code><code class="p">;</code>
        <code class="k">try</code> <code class="p">{</code>
            <code class="nx">tempDirPath</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">mkdtempSync</code><code class="p">(</code><code class="nx">path</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="nx">os</code><code class="p">.</code><code class="nx">tmpdir</code><code class="p">(),</code> <code class="s2">"d"</code><code class="p">));</code>
            <code class="c1">// Do something with the directory here</code>
        <code class="p">}</code> <code class="k">finally</code> <code class="p">{</code>
            <code class="c1">// Delete the temporary directory when we're done with it</code>
            <code class="nx">fs</code><code class="p">.</code><code class="nx">rmdirSync</code><code class="p">(</code><code class="nx">tempDirPath</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>The “fs” module provides two distinct APIs for listing the contents of a
        directory.  First, <code>fs.readdir()</code>, <code>fs.readdirSync()</code>, and
        <code>fs.promises.readdir()</code> read the entire directory all at once and give
        you an array of strings or an array of Dirent objects that specify
        the names and types (file or directory) of each item. Filenames
        returned by these functions are just the local name of the file, not
        the entire path. Here are <span class="keep-together">examples:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">tempFiles</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">readdirSync</code><code class="p">(</code><code class="s2">"/tmp"</code><code class="p">);</code>  <code class="c1">// returns an array of strings</code>
        
        <code class="c1">// Use the Promise-based API to get a Dirent array, and then</code>
        <code class="c1">// print the paths of subdirectories</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">promises</code><code class="p">.</code><code class="nx">readdir</code><code class="p">(</code><code class="s2">"/tmp"</code><code class="p">,</code> <code class="p">{</code><code class="nx">withFileTypes</code><code class="o">:</code> <code class="kc">true</code><code class="p">})</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">entries</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="nx">entries</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code><code class="nx">entry</code> <code class="o">=&gt;</code> <code class="nx">entry</code><code class="p">.</code><code class="nx">isDirectory</code><code class="p">())</code>
                    <code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">entry</code> <code class="o">=&gt;</code> <code class="nx">entry</code><code class="p">.</code><code class="nx">name</code><code class="p">)</code>
                    <code class="p">.</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">name</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">path</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"/tmp/"</code><code class="p">,</code> <code class="nx">name</code><code class="p">)));</code>
            <code class="p">})</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">);</code></pre>
        
        <p>If you anticipate needing to list directories that might have
        thousands of entries, you might prefer the streaming approach of
        <code>fs.opendir()</code> and its variants. These functions return a Dir object
        representing the specified directory. You can use the <code>read()</code> or
        <code>readSync()</code> methods of the Dir object to read one Dirent at a
        time. If you pass a callback function to <code>read()</code>, it will call the
        callback. And if you omit the callback argument, it will return a
        Promise. When there are no more directory entries, you’ll get <code>null</code>
        instead of a Dirent object.</p>
        
        <p>The easiest way to use Dir objects is as async iterators with a
        <code>for/await</code> loop. Here, for example, is a function that uses the
        streaming API to list directory entries, calls <code>stat()</code> on each entry,
        and prints file and directory names<a data-type="indexterm" data-primary="" data-startref="fsmodule16" id="idm46198485896232"></a><a data-type="indexterm" data-primary="" data-startref="Mfs16" id="idm46198485895256"></a><a data-type="indexterm" data-primary="" data-startref="Nfile16" id="idm46198485894312"></a><a data-type="indexterm" data-primary="" data-startref="filenode16" id="idm46198485893368"></a> and sizes:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">path</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"path"</code><code class="p">);</code>
        
        <code class="nx">async</code> <code class="kd">function</code> <code class="nx">listDirectory</code><code class="p">(</code><code class="nx">dirpath</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">dir</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">promises</code><code class="p">.</code><code class="nx">opendir</code><code class="p">(</code><code class="nx">dirpath</code><code class="p">);</code>
            <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">entry</code> <code class="k">of</code> <code class="nx">dir</code><code class="p">)</code> <code class="p">{</code>
                <code class="kd">let</code> <code class="nx">name</code> <code class="o">=</code> <code class="nx">entry</code><code class="p">.</code><code class="nx">name</code><code class="p">;</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">entry</code><code class="p">.</code><code class="nx">isDirectory</code><code class="p">())</code> <code class="p">{</code>
                    <code class="nx">name</code> <code class="o">+=</code> <code class="s2">"/"</code><code class="p">;</code>  <code class="c1">// Add a trailing slash to subdirectories</code>
                <code class="p">}</code>
                <code class="kd">let</code> <code class="nx">stats</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">promises</code><code class="p">.</code><code class="nx">stat</code><code class="p">(</code><code class="nx">path</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="nx">dirpath</code><code class="p">,</code> <code class="nx">name</code><code class="p">));</code>
                <code class="kd">let</code> <code class="nx">size</code> <code class="o">=</code> <code class="nx">stats</code><code class="p">.</code><code class="nx">size</code><code class="p">;</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nb">String</code><code class="p">(</code><code class="nx">size</code><code class="p">).</code><code class="nx">padStart</code><code class="p">(</code><code class="mi">10</code><code class="p">),</code> <code class="nx">name</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.8 HTTP Clients and Servers"><div class="sect1" id="idm46198486139976">
        <h1>16.8 HTTP Clients and Servers</h1>
        
        <p>Node’s<a data-type="indexterm" data-primary="Node" data-secondary="HTTP clients and servers" id="Nhttp16"></a><a data-type="indexterm" data-primary="HTTP clients and servers" id="httpcs16"></a> “http,” “https,” and “http2” modules are full-featured but
        relatively low-level implementations of the HTTP protocols. They
        define comprehensive APIs for implementing HTTP clients and
        servers. Because the APIs are relatively low-level, there is not room
        in this chapter to cover all the features. But the examples that
        follow demonstrate how to write basic clients and servers.</p>
        
        <p>The simplest way to make a basic HTTP GET request is with <code>http.get()</code>
        or <code>https.get()</code>. The first argument to these functions is the URL to
        fetch. (If it is an <code>http://</code> URL, you must use the “http” module, and
        if it is an <code>https://</code> URL you must use the “https” module.) The
        second argument is a callback that will be invoked with an
        IncomingMessage object when the server’s response has started to
        arrive. When the callback is called, the HTTP status and headers are
        available, but the body may not be ready yet. The IncomingMessage
        object is a Readable stream, and you can use the techniques
        demonstrated earlier in this chapter to read the response body from
        it.</p>
        
        <p>The <code>getJSON()</code> function at the end of <a data-type="xref" href="ch13.html#async-making-promises">§13.2.6</a>
        used the <code>http.get()</code> function as part of a demonstration of the
        <code>Promise()</code> constructor. Now that you know about Node streams and the
        Node programming model more generally, it is worth revisiting that
        example to see how <code>http.get()</code> is used.</p>
        
        <p><code>http.get()</code> and <code>https.get()</code> are slightly simplified variants of the
        more general <code>http.request()</code> and <code>https.request()</code> functions. The following <code>postJSON()</code> function demonstrates how to use <code>https.request()</code>
        to make an HTTPS POST request that includes a JSON request body. Like
        the <code>getJSON()</code> function of <a data-type="xref" href="ch13.html#async">Chapter&nbsp;13</a>, it expects a JSON response and
        returns a Promise that fulfills to the parsed version of that
        response:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">https</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"https"</code><code class="p">);</code>
        
        <code class="cm">/*</code>
        <code class="cm"> * Convert the body object to a JSON string then HTTPS POST it to the</code>
        <code class="cm"> * specified API endpoint on the specified host. When the response arrives,</code>
        <code class="cm"> * parse the response body as JSON and resolve the returned Promise with</code>
        <code class="cm"> * that parsed value.</code>
        <code class="cm"> */</code>
        <code class="kd">function</code> <code class="nx">postJSON</code><code class="p">(</code><code class="nx">host</code><code class="p">,</code> <code class="nx">endpoint</code><code class="p">,</code> <code class="nx">body</code><code class="p">,</code> <code class="nx">port</code><code class="p">,</code> <code class="nx">username</code><code class="p">,</code> <code class="nx">password</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Return a Promise object immediately, then call resolve or reject</code>
            <code class="c1">// when the HTTPS request succeeds or fails.</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="c1">// Convert the body object to a string</code>
                <code class="kd">let</code> <code class="nx">bodyText</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">body</code><code class="p">);</code>
        
                <code class="c1">// Configure the HTTPS request</code>
                <code class="kd">let</code> <code class="nx">requestOptions</code> <code class="o">=</code> <code class="p">{</code>
                    <code class="nx">method</code><code class="o">:</code> <code class="s2">"POST"</code><code class="p">,</code>       <code class="c1">// Or "GET", "PUT", "DELETE", etc.</code>
                    <code class="nx">host</code><code class="o">:</code> <code class="nx">host</code><code class="p">,</code>           <code class="c1">// The host to connect to</code>
                    <code class="nx">path</code><code class="o">:</code> <code class="nx">endpoint</code><code class="p">,</code>       <code class="c1">// The URL path</code>
                    <code class="nx">headers</code><code class="o">:</code> <code class="p">{</code>            <code class="c1">// HTTP headers for the request</code>
                        <code class="s2">"Content-Type"</code><code class="o">:</code> <code class="s2">"application/json"</code><code class="p">,</code>
                        <code class="s2">"Content-Length"</code><code class="o">:</code> <code class="nx">Buffer</code><code class="p">.</code><code class="nx">byteLength</code><code class="p">(</code><code class="nx">bodyText</code><code class="p">)</code>
                    <code class="p">}</code>
                <code class="p">};</code>
        
                <code class="k">if</code> <code class="p">(</code><code class="nx">port</code><code class="p">)</code> <code class="p">{</code>                      <code class="c1">// If a port is specified,</code>
                    <code class="nx">requestOptions</code><code class="p">.</code><code class="nx">port</code> <code class="o">=</code> <code class="nx">port</code><code class="p">;</code>  <code class="c1">// use it for the request.</code>
                <code class="p">}</code>
                <code class="c1">// If credentials are specified, add an Authorization header.</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">username</code> <code class="o">&amp;&amp;</code> <code class="nx">password</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">requestOptions</code><code class="p">.</code><code class="nx">auth</code> <code class="o">=</code> <code class="sb">`</code><code class="si">${</code><code class="nx">username</code><code class="si">}</code><code class="sb">:</code><code class="si">${</code><code class="nx">password</code><code class="si">}</code><code class="sb">`</code><code class="p">;</code>
                <code class="p">}</code>
        
                <code class="c1">// Now create the request based on the configuration object</code>
                <code class="kd">let</code> <code class="nx">request</code> <code class="o">=</code> <code class="nx">https</code><code class="p">.</code><code class="nx">request</code><code class="p">(</code><code class="nx">requestOptions</code><code class="p">);</code>
        
                <code class="c1">// Write the body of the POST request and end the request.</code>
                <code class="nx">request</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="nx">bodyText</code><code class="p">);</code>
                <code class="nx">request</code><code class="p">.</code><code class="nx">end</code><code class="p">();</code>
        
                <code class="c1">// Fail on request errors (such as no network connection)</code>
                <code class="nx">request</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">reject</code><code class="p">(</code><code class="nx">e</code><code class="p">));</code>
        
                <code class="c1">// Handle the response when it starts to arrive.</code>
                <code class="nx">request</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"response"</code><code class="p">,</code> <code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusCode</code> <code class="o">!==</code> <code class="mi">200</code><code class="p">)</code> <code class="p">{</code>
                        <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`HTTP status </code><code class="si">${</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusCode</code><code class="si">}</code><code class="sb">`</code><code class="p">));</code>
                        <code class="c1">// We don't care about the response body in this case, but</code>
                        <code class="c1">// we don't want it to stick around in a buffer somewhere, so</code>
                        <code class="c1">// we put the stream into flowing mode without registering</code>
                        <code class="c1">// a "data" handler so that the body is discarded.</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">resume</code><code class="p">();</code>
                        <code class="k">return</code><code class="p">;</code>
                    <code class="p">}</code>
        
                    <code class="c1">// We want text, not bytes. We're assuming the text will be</code>
                    <code class="c1">// JSON-formatted but aren't bothering to check the</code>
                    <code class="c1">// Content-Type header.</code>
                    <code class="nx">response</code><code class="p">.</code><code class="nx">setEncoding</code><code class="p">(</code><code class="s2">"utf8"</code><code class="p">);</code>
        
                    <code class="c1">// Node doesn't have a streaming JSON parser, so we read the</code>
                    <code class="c1">// entire response body into a string.</code>
                    <code class="kd">let</code> <code class="nx">body</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
                    <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"data"</code><code class="p">,</code> <code class="nx">chunk</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">body</code> <code class="o">+=</code> <code class="nx">chunk</code><code class="p">;</code> <code class="p">});</code>
        
                    <code class="c1">// And now handle the response when it is complete.</code>
                    <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"end"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>          <code class="c1">// When the response is done,</code>
                        <code class="k">try</code> <code class="p">{</code>                           <code class="c1">// try to parse it as JSON</code>
                            <code class="nx">resolve</code><code class="p">(</code><code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">body</code><code class="p">));</code>  <code class="c1">// and resolve the result.</code>
                        <code class="p">}</code> <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>                    <code class="c1">// Or, if anything goes wrong,</code>
                            <code class="nx">reject</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>                  <code class="c1">// reject with the error</code>
                        <code class="p">}</code>
                    <code class="p">});</code>
                <code class="p">});</code>
            <code class="p">});</code>
        <code class="p">}</code></pre>
        
        <p>In addition to making HTTP and HTTPS requests, the “http” and “https”
        modules also allow you to write servers that respond to those
        requests. The basic approach is as follows:</p>
        
        <ul>
        <li>
        <p>Create a new Server object.</p>
        </li>
        <li>
        <p>Call its <code>listen()</code> method to begin listening for requests on a
        specified port.</p>
        </li>
        <li>
        <p>Register an event handler for “request” events, use that handler to
        read the client’s request (particularly the <code>request.url</code> property),
        and write your response.</p>
        </li>
        </ul>
        
        <p>The code that follows creates a simple HTTP server that serves static files
        from the local filesystem and also implements a debugging endpoint
        that responds to a client’s request by echoing that request.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This is a simple static HTTP server that serves files from a specified</code>
        <code class="c1">// directory. It also implements a special /test/mirror endpoint that</code>
        <code class="c1">// echoes the incoming request, which can be useful when debugging clients.</code>
        <code class="kr">const</code> <code class="nx">http</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"http"</code><code class="p">);</code>   <code class="c1">// Use "https" if you have a certificate</code>
        <code class="kr">const</code> <code class="nx">url</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"url"</code><code class="p">);</code>     <code class="c1">// For parsing URLs</code>
        <code class="kr">const</code> <code class="nx">path</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"path"</code><code class="p">);</code>   <code class="c1">// For manipulating filesystem paths</code>
        <code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>       <code class="c1">// For reading files</code>
        
        <code class="c1">// Serve files from the specified root directory via an HTTP server that</code>
        <code class="c1">// listens on the specified port.</code>
        <code class="kd">function</code> <code class="nx">serve</code><code class="p">(</code><code class="nx">rootDirectory</code><code class="p">,</code> <code class="nx">port</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">server</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">http</code><code class="p">.</code><code class="nx">Server</code><code class="p">();</code>  <code class="c1">// Create a new HTTP server</code>
            <code class="nx">server</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="nx">port</code><code class="p">);</code>             <code class="c1">// Listen on the specified port</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Listening on port"</code><code class="p">,</code> <code class="nx">port</code><code class="p">);</code>
        
            <code class="c1">// When requests come in, handle them with this function</code>
            <code class="nx">server</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"request"</code><code class="p">,</code> <code class="p">(</code><code class="nx">request</code><code class="p">,</code> <code class="nx">response</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="c1">// Get the path portion of the request URL, ignoring</code>
                <code class="c1">// any query parameters that are appended to it.</code>
                <code class="kd">let</code> <code class="nx">endpoint</code> <code class="o">=</code> <code class="nx">url</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">request</code><code class="p">.</code><code class="nx">url</code><code class="p">).</code><code class="nx">pathname</code><code class="p">;</code>
        
                <code class="c1">// If the request was for "/test/mirror", send back the request</code>
                <code class="c1">// verbatim. Useful when you need to see the request headers and body.</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">endpoint</code> <code class="o">===</code> <code class="s2">"/test/mirror"</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// Set response header</code>
                    <code class="nx">response</code><code class="p">.</code><code class="nx">setHeader</code><code class="p">(</code><code class="s2">"Content-Type"</code><code class="p">,</code> <code class="s2">"text/plain; charset=UTF-8"</code><code class="p">);</code>
        
                    <code class="c1">// Specify response status code</code>
                    <code class="nx">response</code><code class="p">.</code><code class="nx">writeHead</code><code class="p">(</code><code class="mi">200</code><code class="p">);</code>  <code class="c1">// 200 OK</code>
        
                    <code class="c1">// Begin the response body with the request</code>
                    <code class="nx">response</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">request</code><code class="p">.</code><code class="nx">method</code><code class="si">}</code><code class="sb"> </code><code class="si">${</code><code class="nx">request</code><code class="p">.</code><code class="nx">url</code><code class="si">}</code><code class="sb"> HTTP/</code><code class="si">${</code>
                                       <code class="nx">request</code><code class="p">.</code><code class="nx">httpVersion</code>
                                   <code class="si">}</code><code class="err">\</code><code class="sb">r</code><code class="err">\</code><code class="sb">n`</code><code class="p">);</code>
        
                    <code class="c1">// Output the request headers</code>
                    <code class="kd">let</code> <code class="nx">headers</code> <code class="o">=</code> <code class="nx">request</code><code class="p">.</code><code class="nx">rawHeaders</code><code class="p">;</code>
                    <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">headers</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code> <code class="o">+=</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">headers</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">headers</code><code class="p">[</code><code class="nx">i</code><code class="o">+</code><code class="mi">1</code><code class="p">]</code><code class="si">}</code><code class="err">\</code><code class="sb">r</code><code class="err">\</code><code class="sb">n`</code><code class="p">);</code>
                    <code class="p">}</code>
        
                    <code class="c1">// End headers with an extra blank line</code>
                    <code class="nx">response</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="s2">"\r\n"</code><code class="p">);</code>
        
                    <code class="c1">// Now we need to copy any request body to the response body</code>
                    <code class="c1">// Since they are both streams, we can use a pipe</code>
                    <code class="nx">request</code><code class="p">.</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="c1">// Otherwise, serve a file from the local directory.</code>
                <code class="k">else</code> <code class="p">{</code>
                    <code class="c1">// Map the endpoint to a file in the local filesystem</code>
                    <code class="kd">let</code> <code class="nx">filename</code> <code class="o">=</code> <code class="nx">endpoint</code><code class="p">.</code><code class="nx">substring</code><code class="p">(</code><code class="mi">1</code><code class="p">);</code> <code class="c1">// strip leading /</code>
                    <code class="c1">// Don't allow "../" in the path because it would be a security</code>
                    <code class="c1">// hole to serve anything outside the root directory.</code>
                    <code class="nx">filename</code> <code class="o">=</code> <code class="nx">filename</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="sr">/\.\.\//g</code><code class="p">,</code> <code class="s2">""</code><code class="p">);</code>
                    <code class="c1">// Now convert from relative to absolute filename</code>
                    <code class="nx">filename</code> <code class="o">=</code> <code class="nx">path</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">rootDirectory</code><code class="p">,</code> <code class="nx">filename</code><code class="p">);</code>
        
                    <code class="c1">// Now guess the type file's content type based on extension</code>
                    <code class="kd">let</code> <code class="nx">type</code><code class="p">;</code>
                    <code class="k">switch</code><code class="p">(</code><code class="nx">path</code><code class="p">.</code><code class="nx">extname</code><code class="p">(</code><code class="nx">filename</code><code class="p">))</code>  <code class="p">{</code>
                    <code class="k">case</code> <code class="s2">".html"</code><code class="o">:</code>
                    <code class="k">case</code> <code class="s2">".htm"</code><code class="o">:</code> <code class="nx">type</code> <code class="o">=</code> <code class="s2">"text/html"</code><code class="p">;</code> <code class="k">break</code><code class="p">;</code>
                    <code class="k">case</code> <code class="s2">".js"</code><code class="o">:</code>  <code class="nx">type</code> <code class="o">=</code> <code class="s2">"text/javascript"</code><code class="p">;</code> <code class="k">break</code><code class="p">;</code>
                    <code class="k">case</code> <code class="s2">".css"</code><code class="o">:</code> <code class="nx">type</code> <code class="o">=</code> <code class="s2">"text/css"</code><code class="p">;</code> <code class="k">break</code><code class="p">;</code>
                    <code class="k">case</code> <code class="s2">".png"</code><code class="o">:</code> <code class="nx">type</code> <code class="o">=</code> <code class="s2">"image/png"</code><code class="p">;</code> <code class="k">break</code><code class="p">;</code>
                    <code class="k">case</code> <code class="s2">".txt"</code><code class="o">:</code> <code class="nx">type</code> <code class="o">=</code> <code class="s2">"text/plain"</code><code class="p">;</code> <code class="k">break</code><code class="p">;</code>
                    <code class="k">default</code><code class="o">:</code>     <code class="nx">type</code> <code class="o">=</code> <code class="s2">"application/octet-stream"</code><code class="p">;</code> <code class="k">break</code><code class="p">;</code>
                    <code class="p">}</code>
        
                    <code class="kd">let</code> <code class="nx">stream</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">createReadStream</code><code class="p">(</code><code class="nx">filename</code><code class="p">);</code>
                    <code class="nx">stream</code><code class="p">.</code><code class="nx">once</code><code class="p">(</code><code class="s2">"readable"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
                        <code class="c1">// If the stream becomes readable, then set the</code>
                        <code class="c1">// Content-Type header and a 200 OK status. Then pipe the</code>
                        <code class="c1">// file reader stream to the response. The pipe will</code>
                        <code class="c1">// automatically call response.end() when the stream ends.</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">setHeader</code><code class="p">(</code><code class="s2">"Content-Type"</code><code class="p">,</code> <code class="nx">type</code><code class="p">);</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">writeHead</code><code class="p">(</code><code class="mi">200</code><code class="p">);</code>
                        <code class="nx">stream</code><code class="p">.</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code>
                    <code class="p">});</code>
        
                    <code class="nx">stream</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                        <code class="c1">// Instead, if we get an error trying to open the stream</code>
                        <code class="c1">// then the file probably does not exist or is not readable.</code>
                        <code class="c1">// Send a 404 Not Found plain-text response with the</code>
                        <code class="c1">// error message.</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">setHeader</code><code class="p">(</code><code class="s2">"Content-Type"</code><code class="p">,</code> <code class="s2">"text/plain; charset=UTF-8"</code><code class="p">);</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">writeHead</code><code class="p">(</code><code class="mi">404</code><code class="p">);</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">end</code><code class="p">(</code><code class="nx">err</code><code class="p">.</code><code class="nx">message</code><code class="p">);</code>
                    <code class="p">});</code>
                <code class="p">}</code>
            <code class="p">});</code>
        <code class="p">}</code>
        
        <code class="c1">// When we're invoked from the command line, call the serve() function</code>
        <code class="nx">serve</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">||</code> <code class="s2">"/tmp"</code><code class="p">,</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">[</code><code class="mi">3</code><code class="p">])</code> <code class="o">||</code> <code class="mi">8000</code><code class="p">);</code></pre>
        
        <p>Node’s built-in modules are all you need to write simple HTTP and
        HTTPS servers. Note, however, that production servers are not
        typically built directly on top of these modules. Instead, most
        nontrivial servers are implemented using external libraries—such as
        the Express framework—that provide “middleware” and other higher-level
        utilities that backend web developers have come to expect.<a data-type="indexterm" data-primary="" data-startref="httpcs16" id="idm46198485318008"></a><a data-type="indexterm" data-primary="" data-startref="Nhttp16" id="idm46198485317160"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.9 Non-HTTP Network Servers and Clients"><div class="sect1" id="idm46198485889800">
        <h1>16.9 Non-HTTP Network Servers and Clients</h1>
        
        <p>Web<a data-type="indexterm" data-primary="Node" data-secondary="non-HTTP network servers and clients" id="idm46198485314552"></a> servers and clients have become so ubiquitous that it is easy to
        forget that it is possible to write clients and servers that do not
        use HTTP. Even though Node has a reputation as a good environment for
        writing web servers, Node also has full support for writing other
        types of network servers and clients.</p>
        
        <p>If you are comfortable working with streams, then networking is
        relatively simple, because network sockets are simply a kind of Duplex
        stream. The “net” module defines Server and Socket classes. To create
        a server, call <code>net.createServer()</code>, then call the <code>listen()</code>
        method of the resulting object to tell the server what port to listen on for connections. The Server object will generate “connection”
        events when a client connects on that port, and the value passed to
        the event listener will be a Socket object. The Socket object is
        a Duplex stream, and you can use it to read data from the
        client and write data to the client. Call <code>end()</code> on the Socket to
        disconnect.</p>
        
        <p>Writing a client is even easier: pass a port number and hostname to
        <code>net.createConnection()</code> to create a socket to communicate with
        whatever server is running on that host and listening on that
        port. Then use that socket to read and write data from and to the
        server.</p>
        
        <p>The following code demonstrates how to write a server with the “net”
        module. When the client connects, the server tells a knock-knock joke:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// A TCP server that delivers interactive knock-knock jokes on port 6789.</code>
        <code class="c1">// (Why is six afraid of seven? Because seven ate nine!)</code>
        <code class="kr">const</code> <code class="nx">net</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"net"</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">readline</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"readline"</code><code class="p">);</code>
        
        <code class="c1">// Create a Server object and start listening for connections</code>
        <code class="kd">let</code> <code class="nx">server</code> <code class="o">=</code> <code class="nx">net</code><code class="p">.</code><code class="nx">createServer</code><code class="p">();</code>
        <code class="nx">server</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code><code class="mi">6789</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Delivering laughs on port 6789"</code><code class="p">));</code>
        
        <code class="c1">// When a client connects, tell them a knock-knock joke.</code>
        <code class="nx">server</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"connection"</code><code class="p">,</code> <code class="nx">socket</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="nx">tellJoke</code><code class="p">(</code><code class="nx">socket</code><code class="p">)</code>
                <code class="p">.</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">socket</code><code class="p">.</code><code class="nx">end</code><code class="p">())</code>  <code class="c1">// When the joke is done, close the socket.</code>
                <code class="p">.</code><code class="k">catch</code><code class="p">((</code><code class="nx">err</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">err</code><code class="p">);</code>    <code class="c1">// Log any errors that occur,</code>
                    <code class="nx">socket</code><code class="p">.</code><code class="nx">end</code><code class="p">();</code>          <code class="c1">// but still close the socket!</code>
                <code class="p">});</code>
        <code class="p">});</code>
        
        <code class="c1">// These are all the jokes we know.</code>
        <code class="kr">const</code> <code class="nx">jokes</code> <code class="o">=</code> <code class="p">{</code>
            <code class="s2">"Boo"</code><code class="o">:</code> <code class="s2">"Don't cry...it's only a joke!"</code><code class="p">,</code>
            <code class="s2">"Lettuce"</code><code class="o">:</code> <code class="s2">"Let us in! It's freezing out here!"</code><code class="p">,</code>
            <code class="s2">"A little old lady"</code><code class="o">:</code> <code class="s2">"Wow, I didn't know you could yodel!"</code>
        <code class="p">};</code>
        
        <code class="c1">// Interactively perform a knock-knock joke over this socket, without blocking.</code>
        <code class="nx">async</code> <code class="kd">function</code> <code class="nx">tellJoke</code><code class="p">(</code><code class="nx">socket</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Pick one of the jokes at random</code>
            <code class="kd">let</code> <code class="nx">randomElement</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">=&gt;</code> <code class="nx">a</code><code class="p">[</code><code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code> <code class="o">*</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">)];</code>
            <code class="kd">let</code> <code class="nx">who</code> <code class="o">=</code> <code class="nx">randomElement</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">jokes</code><code class="p">));</code>
            <code class="kd">let</code> <code class="nx">punchline</code> <code class="o">=</code> <code class="nx">jokes</code><code class="p">[</code><code class="nx">who</code><code class="p">];</code>
        
            <code class="c1">// Use the readline module to read the user's input one line at a time.</code>
            <code class="kd">let</code> <code class="nx">lineReader</code> <code class="o">=</code> <code class="nx">readline</code><code class="p">.</code><code class="nx">createInterface</code><code class="p">({</code>
                <code class="nx">input</code><code class="o">:</code> <code class="nx">socket</code><code class="p">,</code>
                <code class="nx">output</code><code class="o">:</code> <code class="nx">socket</code><code class="p">,</code>
                <code class="nx">prompt</code><code class="o">:</code> <code class="s2">"&gt;&gt; "</code>
            <code class="p">});</code>
        
            <code class="c1">// A utility function to output a line of text to the client</code>
            <code class="c1">// and then (by default) display a prompt.</code>
            <code class="kd">function</code> <code class="nx">output</code><code class="p">(</code><code class="nx">text</code><code class="p">,</code> <code class="nx">prompt</code><code class="o">=</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">socket</code><code class="p">.</code><code class="nx">write</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">text</code><code class="si">}</code><code class="err">\</code><code class="sb">r</code><code class="err">\</code><code class="sb">n`</code><code class="p">);</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">prompt</code><code class="p">)</code> <code class="nx">lineReader</code><code class="p">.</code><code class="nx">prompt</code><code class="p">();</code>
            <code class="p">}</code>
        
            <code class="c1">// Knock-knock jokes have a call-and-response structure.</code>
            <code class="c1">// We expect different input from the user at different stages and</code>
            <code class="c1">// take different action when we get that input at different stages.</code>
            <code class="kd">let</code> <code class="nx">stage</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        
            <code class="c1">// Start the knock-knock joke off in the traditional way.</code>
            <code class="nx">output</code><code class="p">(</code><code class="s2">"Knock knock!"</code><code class="p">);</code>
        
            <code class="c1">// Now read lines asynchronously from the client until the joke is done.</code>
            <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">inputLine</code> <code class="k">of</code> <code class="nx">lineReader</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">stage</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">inputLine</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">()</code> <code class="o">===</code> <code class="s2">"who's there?"</code><code class="p">)</code> <code class="p">{</code>
                        <code class="c1">// If the user gives the right response at stage 0</code>
                        <code class="c1">// then tell the first part of the joke and go to stage 1.</code>
                        <code class="nx">output</code><code class="p">(</code><code class="nx">who</code><code class="p">);</code>
                        <code class="nx">stage</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
                    <code class="p">}</code> <code class="k">else</code>  <code class="p">{</code>
                        <code class="c1">// Otherwise teach the user how to do knock-knock jokes.</code>
                        <code class="nx">output</code><code class="p">(</code><code class="s1">'Please type "Who\'s there?".'</code><code class="p">);</code>
                    <code class="p">}</code>
                <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">stage</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">inputLine</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">()</code> <code class="o">===</code> <code class="sb">`</code><code class="si">${</code><code class="nx">who</code><code class="p">.</code><code class="nx">toLowerCase</code><code class="p">()</code><code class="si">}</code><code class="sb"> who?`</code><code class="p">)</code> <code class="p">{</code>
                        <code class="c1">// If the user's response is correct at stage 1, then</code>
                        <code class="c1">// deliver the punchline and return since the joke is done.</code>
                        <code class="nx">output</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">punchline</code><code class="si">}</code><code class="sb">`</code><code class="p">,</code> <code class="kc">false</code><code class="p">);</code>
                        <code class="k">return</code><code class="p">;</code>
                    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                        <code class="c1">// Make the user play along.</code>
                        <code class="nx">output</code><code class="p">(</code><code class="sb">`Please type "</code><code class="si">${</code><code class="nx">who</code><code class="si">}</code><code class="sb"> who?".`</code><code class="p">);</code>
                    <code class="p">}</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>Simple text-based servers like this do not typically need a custom
        client. If the <code>nc</code> (“netcat”) utility is installed on your system,
        you can use it to communicate with this server as follows:</p>
        
        <pre data-type="programlisting">$ nc localhost 6789
        Knock knock!
        &gt;&gt; Who's there?
        A little old lady
        &gt;&gt; A little old lady who?
        Wow, I didn't know you could yodel!</pre>
        
        <p>On the other hand, writing a custom client for the joke server is
        easy in Node. We just connect to the server, then pipe the
        server’s output to stdout and pipe stdin to the server’s input:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Connect to the joke port (6789) on the server named on the command line</code>
        <code class="kd">let</code> <code class="nx">socket</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"net"</code><code class="p">).</code><code class="nx">createConnection</code><code class="p">(</code><code class="mi">6789</code><code class="p">,</code> <code class="nx">process</code><code class="p">.</code><code class="nx">argv</code><code class="p">[</code><code class="mi">2</code><code class="p">]);</code>
        <code class="nx">socket</code><code class="p">.</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">process</code><code class="p">.</code><code class="nx">stdout</code><code class="p">);</code>              <code class="c1">// Pipe data from the socket to stdout</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">stdin</code><code class="p">.</code><code class="nx">pipe</code><code class="p">(</code><code class="nx">socket</code><code class="p">);</code>               <code class="c1">// Pipe data from stdin to the socket</code>
        <code class="nx">socket</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"close"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">process</code><code class="p">.</code><code class="nx">exit</code><code class="p">());</code> <code class="c1">// Quit when the socket closes.</code></pre>
        
        <p>In addition to supporting TCP-based servers, Node’s “net” module also
        supports interprocess communication over “Unix domain sockets” that
        are identified by a filesystem path rather than by a port number. We
        are not going to cover that kind of socket in this chapter, but the
        Node documentation has details. Other Node features that we don’t have
        space to cover here include the “dgram” module for UDP-based clients
        and servers and the “tls” module that is to “net” as “https” is to
        “http.” The <code>tls.Server</code> and <code>tls.TLSSocket</code> classes allow the
        creation of TCP servers (like the knock-knock joke server) that use
        SSL-encrypted connections like HTTPS servers do.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.10 Working with Child Processes"><div class="sect1" id="idm46198485315624">
        <h1>16.10 Working with Child Processes</h1>
        
        <p>In<a data-type="indexterm" data-primary="child processes (Node)" id="childnode16"></a><a data-type="indexterm" data-primary="Node" data-secondary="child processes" id="Nchild16"></a><a data-type="indexterm" data-primary="child processes (Node)" data-secondary="benefits of" id="idm46198484273496"></a> addition to writing highly concurrent servers, Node also works well
        for writing scripts that execute other programs. In Node the
        “child_process” module defines a number of functions for running other
        programs as child processes. This section demonstrates some of those
        functions, starting with the simplest and moving to the more
        complicated.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.10.1 execSync() and execFileSync()"><div class="sect2" id="idm46198484271928">
        <h2>16.10.1 execSync() and execFileSync()</h2>
        
        <p>The<a data-type="indexterm" data-primary="child processes (Node)" data-secondary="execSync() and execFileSync()" id="idm46198484270424"></a> easiest way to run another program is with
        <code>child_process.execSync()</code>. This function takes the command to run as
        its first argument. It creates a child process, runs a shell in that
        process, and uses the shell to execute the command you passed. Then it
        blocks until the command (and the shell) exit. If the command exits
        with an error, then <code>execSync()</code> throws an exception. Otherwise,
        <code>execSync()</code> returns whatever output the command writes to its stdout
        stream. By default
        this return value is a buffer, but you can specify an encoding in an
        optional second argument to get a string instead. If the command
        writes any output to stderr, that output just gets passed through to
        the parent process’s stderr stream.</p>
        
        <p>So, for example, if you are writing a script and performance is not a
        concern, you might use <code>child_process.execSync()</code> to list a directory
        with a familiar Unix shell command rather than using the
        <code>fs.readdirSync()</code> function:</p>
        
        <pre data-type="programlisting">const child_process = require("child_process");
        let listing = child_process.execSync("ls -l web/*.html", {encoding: "utf8"});</pre>
        
        <p>The fact that <code>execSync()</code> invokes a full Unix shell means that the
        string you pass to it can include multiple semicolon-separated
        commands, and can take advantage of shell features such as filename
        wildcards, pipes, and output redirection. This also means that you
        must be careful to never pass a command to <code>execSync()</code> if any portion
        of that command is user input or comes from a similar untrusted
        source. The complex syntax of shell commands can be easily subverted
        to allow an attacker to run arbitrary code.</p>
        
        <p>If you don’t need the features of a shell, you can avoid the overhead
        of starting a shell by using <code>child_process.execFileSync()</code>. This
        function executes a program directly, without invoking a shell. But
        since no shell is involved, it can’t parse a command line, and you
        must pass the executable as the first argument and an array of
        command-line arguments as the second argument:</p>
        
        <pre data-type="programlisting">let listing = child_process.execFileSync("ls", ["-l", "web/"],
                                                 {encoding: "utf8"});</pre>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198484261192">
        <h5>Child Process Options</h5>
        <p><code>execSync()</code> and<a data-type="indexterm" data-primary="child processes (Node)" data-secondary="options" id="idm46198484259480"></a> many of the other <code>child_process</code> functions have a
        second or third optional argument that specifies additional details
        about how the child process is to run. The <code>encoding</code> property of this
        object was used earlier to specify that we’d like the command output to
        be delivered as a string rather than as a buffer. Other important
        properties that you can specify include the following (note that not
        all options are available to all child process functions):</p>
        
        <ul>
        <li>
        <p><code>cwd</code> specifies the working directory for the child process. If you
        omit this, then the child process inherits the value of
        <code>process.cwd()</code>.</p>
        </li>
        <li>
        <p><code>env</code> specifies the environment variables that the child process
        will have access to. By default, child processes simply inherit
        <code>process.env</code>, but you can specify a different object if you want.</p>
        </li>
        <li>
        <p><code>input</code> specifies a string or buffer of input data that should be
        used as the standard input to the child process. This option is only
        available to the synchronous functions that do not return a
        ChildProcess object.</p>
        </li>
        <li>
        <p><code>maxBuffer</code> specifies the maximum number of bytes of output that
        will be collected by the <code>exec</code> functions. (It does not apply to
        <code>spawn()</code> and <code>fork()</code>, which use streams.) If a child process
        produces more output than this, it will be killed and will exit with
        an error.</p>
        </li>
        <li>
        <p><code>shell</code> specifies the path to a shell executable or <code>true</code>. For
        child process functions that normally execute a shell command, this
        option allows you to specify which shell to use. For functions that
        do not normally use a shell, this option allows you to specify that
        a shell should be used (by setting the property to <code>true</code>) or to
        specify exactly which shell to use.</p>
        </li>
        <li>
        <p><code>timeout</code> specifies the maximum number of milliseconds that the
        child process should be allowed to run. If it has not exited before
        this time elapses, it will be killed and will exit with an
        error. (This option applies to the <code>exec</code> functions but not to
        <code>spawn()</code> or <code>fork()</code>.)</p>
        </li>
        <li>
        <p><code>uid</code> specifies the user ID (a number) under which the program
        should be run. If the parent process is running in a privileged
        account, it can use this option to run the child with reduced
        privileges.</p>
        </li>
        </ul>
        </div></aside>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.10.2 exec() and execFile()"><div class="sect2" id="idm46198484242152">
        <h2>16.10.2 exec() and execFile()</h2>
        
        <p>The<a data-type="indexterm" data-primary="child processes (Node)" data-secondary="exec() and execFile()" id="idm46198484240360"></a> <code>execSync()</code> and <code>execFileSync()</code> functions are, as their names
        indicate, synchronous: they block and do not return until the child
        process exits. Using these functions is a lot like typing Unix
        commands in a terminal window: they allow you to run a sequence of
        commands one at a time. But if you’re writing a program that needs to
        accomplish a number of tasks, and those tasks don’t depend on each
        other in any way, then you may want to parallelize them and run
        multiple commands at the same time. You can do this with the
        asynchronous functions <code>child_process.exec()</code> and
        <code>child_process.execFile()</code>.</p>
        
        <p><code>exec()</code> and <code>execFile()</code> are like their synchronous variants except
        that they return immediately with a ChildProcess object that
        represents the running child process, and they take an error-first
        callback as their final argument. The callback is invoked when the
        child process exits, and it is actually called with three
        arguments. The first is the error, if any; it will be <code>null</code> if the
        process terminated normally. The second argument is the
        collected output that was sent to the child’s standard output
        stream. And the third argument is any output that was sent to the
        child’s standard error stream.</p>
        
        <p>The ChildProcess object returned by <code>exec()</code> and <code>execFile()</code> allows you
        to terminate the child process, and to write data to it (which it can
        then read from its standard  input). We’ll cover ChildProcess in more
        detail when we discuss the <code>child_process.spawn()</code> function.</p>
        
        <p>If you plan to execute multiple child processes at the same time, then
        it may be easiest to use the “promisified” version of <code>exec()</code> which
        returns a Promise object which, if the child process exits without
        error, resolves to an object with <code>stdout</code> and <code>stderr</code>
        properties. Here, for example, is a function that takes an array of
        shell commands as its input and returns a Promise that resolves to the
        result of all of those commands:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">child_process</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"child_process"</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">util</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"util"</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">execP</code> <code class="o">=</code> <code class="nx">util</code><code class="p">.</code><code class="nx">promisify</code><code class="p">(</code><code class="nx">child_process</code><code class="p">.</code><code class="nx">exec</code><code class="p">);</code>
        
        <code class="kd">function</code> <code class="nx">parallelExec</code><code class="p">(</code><code class="nx">commands</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Use the array of commands to create an array of Promises</code>
            <code class="kd">let</code> <code class="nx">promises</code> <code class="o">=</code> <code class="nx">commands</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">command</code> <code class="o">=&gt;</code> <code class="nx">execP</code><code class="p">(</code><code class="nx">command</code><code class="p">,</code> <code class="p">{</code><code class="nx">encoding</code><code class="o">:</code> <code class="s2">"utf8"</code><code class="p">}));</code>
            <code class="c1">// Return a Promise that will fulfill to an array of the fulfillment</code>
            <code class="c1">// values of each of the individual promises. (Instead of returning objects</code>
            <code class="c1">// with stdout and stderr properties we just return the stdout value.)</code>
            <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">(</code><code class="nx">promises</code><code class="p">)</code>
                <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">outputs</code> <code class="o">=&gt;</code> <code class="nx">outputs</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">out</code> <code class="o">=&gt;</code> <code class="nx">out</code><code class="p">.</code><code class="nx">stdout</code><code class="p">));</code>
        <code class="p">}</code>
        
        <code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="nx">parallelExec</code><code class="p">;</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.10.3 spawn()"><div class="sect2" id="idm46198484203304">
        <h2>16.10.3 spawn()</h2>
        
        <p>The<a data-type="indexterm" data-primary="child processes (Node)" data-secondary="spawn()" id="idm46198484124232"></a> various <code>exec</code> functions described so far—both synchronous and
        asynchronous—are designed to be used with child processes that run
        quickly and do not produce a lot of output. Even the asynchronous
        <code>exec()</code> and <code>execFile()</code> are nonstreaming: they return the process
        output in a single batch, only after the process has exited.</p>
        
        <p>The <code>child_process.spawn()</code> function allows you streaming access to
        the output of the child process, while the process is still
        running. It also allows you to write data to the child process (which
        will see that data as input on its standard input stream): this means it is
        possible to dynamically interact with a child process, sending it
        input based on the output it generates.</p>
        
        <p><code>spawn()</code> does not use a shell by default, so you must invoke it like
        <code>execFile()</code> with the executable to be run and a separate array of
        command-line arguments to pass to it. <code>spawn()</code> returns a ChildProcess
        object like <code>execFile()</code> does, but it does not take a callback
        argument. Instead of using a callback function, you listen to events
        on the ChildProcess object and on its streams.</p>
        
        <p>The ChildProcess object returned by <code>spawn()</code> is an event emitter. You
        can listen for the “exit” event to be notified when the child process
        exits. A ChildProcess object also has three stream
        properties. <code>stdout</code> and <code>stderr</code> are Readable streams: when the child
        process writes to its stdout and its stderr streams, that output
        becomes readable through the ChildProcess streams. Note the inversion
        of the names here. In the child process, “stdout” is a Writable output
        stream, but in the parent process, the <code>stdout</code> property of a
        ChildProcess object is a Readable input stream.</p>
        
        <p>Similarly, the <code>stdin</code> property of the ChildProcess object is a
        Writeable stream: anything you write to this stream becomes available
        to the child process on its standard input.</p>
        
        <p>The ChildProcess object also defines a <code>pid</code> property that specifies
        the process id of the child. And it defines a <code>kill()</code> method that you
        can use to terminate a child process.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.10.4 fork()"><div class="sect2" id="idm46198484112968">
        <h2>16.10.4 fork()</h2>
        
        <p><code>child_process.fork()</code> is<a data-type="indexterm" data-primary="child processes (Node)" data-secondary="fork()" id="idm46198484111080"></a> a specialized function for running a module
        of JavaScript code in a child Node process. <code>fork()</code> expects the same
        arguments as <code>spawn()</code>, but the first argument should specify the path
        to a file of JavaScript code instead of an executable binary file.</p>
        
        <p>A child process created with <code>fork()</code> can communicate with the parent
        process via its standard input and standard output streams, as
        described in the previous section for <code>spawn()</code>. But in addition, <code>fork()</code> enables
        another, much easier, communication channel between the parent and
        child processes.</p>
        
        <p>When you create a child process with <code>fork()</code>, you can use the
        <code>send()</code> method of the returned ChildProcess object to send a copy of
        an object to the child process. And you can listen for the “message”
        event on the ChildProcess to receive messages from the child. The<a data-type="indexterm" data-primary="message events" id="mesev16"></a> code
        running in the child process can use <code>process.send()</code> to send a
        message to the parent and can listen for “message” events on <code>process</code>
        to receive messages from the parent.</p>
        
        <p>Here, for example, is some code that uses <code>fork()</code> to create a child
        process, then sends that child a message and waits for a response:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">child_process</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"child_process"</code><code class="p">);</code>
        
        <code class="c1">// Start a new node process running the code in child.js in our directory</code>
        <code class="kd">let</code> <code class="nx">child</code> <code class="o">=</code> <code class="nx">child_process</code><code class="p">.</code><code class="nx">fork</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">__dirname</code><code class="si">}</code><code class="sb">/child.js`</code><code class="p">);</code>
        
        <code class="c1">// Send a message to the child</code>
        <code class="nx">child</code><code class="p">.</code><code class="nx">send</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">4</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">3</code><code class="p">});</code>
        
        <code class="c1">// Print the child's response when it arrives.</code>
        <code class="nx">child</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"message"</code><code class="p">,</code> <code class="nx">message</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">hypotenuse</code><code class="p">);</code> <code class="c1">// This should print "5"</code>
            <code class="c1">// Since we only send one message we only expect one response.</code>
            <code class="c1">// After we receive it we call disconnect() to terminate the connection</code>
            <code class="c1">// between parent and child. This allows both processes to exit cleanly.</code>
            <code class="nx">child</code><code class="p">.</code><code class="nx">disconnect</code><code class="p">();</code>
        <code class="p">});</code></pre>
        
        <p>And here is the code that runs in the child process:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Wait for messages from our parent process</code>
        <code class="nx">process</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"message"</code><code class="p">,</code> <code class="nx">message</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="c1">// When we receive one, do a calculation and send the result</code>
            <code class="c1">// back to the parent.</code>
            <code class="nx">process</code><code class="p">.</code><code class="nx">send</code><code class="p">({</code><code class="nx">hypotenuse</code><code class="o">:</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">hypot</code><code class="p">(</code><code class="nx">message</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">message</code><code class="p">.</code><code class="nx">y</code><code class="p">)});</code>
        <code class="p">});</code></pre>
        
        <p>Starting child processes is an expensive operation, and the child
        process would have to be doing orders of magnitude more computation
        before it would make sense to use <code>fork()</code> and interprocess
        communication in this way. If you are writing a program that needs to
        be very responsive to incoming events and also needs to perform
        time-consuming computations, then you might consider using a separate
        child process to perform the computations so that they don’t block the
        event loop and reduce the responsiveness of the parent
        process. (Though a thread—see <a data-type="xref" href="#node-worker-threads">§16.11</a>—may be a
        better choice than a child process in this scenario.)</p>
        
        <p>The first argument to <code>send()</code> will be serialized with
        <code>JSON.stringify()</code> and deserialized in the child process with
        <code>JSON.parse()</code>, so you should only include values that are supported
        by the JSON format. <code>send()</code> has a special second argument, however,
        that allows you to transfer Socket and Server objects (from the “net”
        module) to a child process. Network servers tend to be IO-bound rather
        than compute-bound, but if you have written a server that needs to do
        more computation than a single CPU can handle, and if you’re running
        that server on a machine with multiple CPUs, then you could use
        <code>fork()</code> to create multiple child processes for handling requests. In
        the parent process, you might listen for “connection” events on your
        Server object, then get the Socket object from that “connection” event
        and <code>send()</code> it—using the special second argument—to one of the child
        processes to be handled. (Note that this is an unlikely solution to an
        uncommon scenario. Rather than writing a server that forks child
        processes, it is probably simpler to keep your server single-threaded
        and deploy multiple instances of it in production to handle the load.)<a data-type="indexterm" data-primary="" data-startref="childnode16" id="idm46198483871848"></a><a data-type="indexterm" data-primary="" data-startref="Nchild16" id="idm46198483870872"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.11 Worker Threads"><div class="sect1" id="node-worker-threads">
        <h1>16.11 Worker Threads</h1>
        
        <p>As<a data-type="indexterm" data-primary="Node" data-secondary="worker threads" id="Nworker16"></a><a data-type="indexterm" data-primary="Node" data-secondary="worker threads" data-tertiary="overview of" id="idm46198483866808"></a> explained at the beginning of this chapter, Node’s concurrency
        model is single-threaded and event-based. But in version 10 and later,
        Node does allow true multithreaded programming, with an API that
        closely mirrors the<a data-type="indexterm" data-primary="Web Workers API" id="idm46198483865224"></a> Web Workers API defined by web browsers
        (<a data-type="xref" href="ch15.html#webworkers">§15.13</a>). Multithreaded programming<a data-type="indexterm" data-primary="multithreaded programming" id="idm46198483863624"></a> has a well-deserved
        reputation for being difficult. This is almost entirely because of the
        need to carefully synchronize access by threads to shared memory. But
        JavaScript threads (in both Node and browsers) do not share memory by
        default, so the dangers and difficulties of using threads do not apply
        to these “workers” in JavaScript.</p>
        
        <p>Instead of using shared memory, JavaScript’s worker threads
        communicate by message passing. The main thread can send a message to
        a worker thread by calling the <code>postMessage()</code> method of the Worker
        object that represents that thread. The worker thread can receive
        messages from its parent by listening for “message” events. And
        workers can send messages to the main thread with their own version of
        <code>postMessage()</code>, which the parent can receive with its own “message”
        event handler. The example code will make it clear how this
        works.<a data-type="indexterm" data-primary="" data-startref="mesev16" id="idm46198483860728"></a></p>
        
        <p>There are three reasons why you might want to use worker threads in a
        Node <span class="keep-together">application:</span></p>
        
        <ul>
        <li>
        <p>If your application actually needs to do more computation than one
        CPU core can handle, then threads allow you to distribute work across
        the multiple cores, which have become commonplace on computers today. If
        you’re doing scientific computing or machine learning or graphics
        processing in Node, then you may want to use threads simply to throw
        more computing power at your problem.</p>
        </li>
        <li>
        <p>Even if your application is not using the full power of one CPU, you
        may still want to use threads to maintain the responsiveness of the
        main thread. Consider a server that handles large but relatively
        infrequent requests. Suppose it gets only one request a second, but
        needs to spend about half a second of (blocking CPU-bound)
        computation to process each request. On average, it will be idle 50%
        of the time. But when two requests arrive within a few milliseconds
        of each other, the server will not even be able to begin a response
        to the second request until the computation of the first response is
        complete. Instead, if the server uses a worker thread to perform the
        computation, the server can begin the response to both requests
        immediately and provide a better experience for the server’s
        clients. Assuming the server has more than one CPU core, it can
        also compute the body of both responses in parallel, but even if
        there is only a single core, using workers still improves the
        responsiveness.</p>
        </li>
        <li>
        <p>In general, workers allow us to turn blocking synchronous
        operations into nonblocking asynchronous operations. If you are
        writing a program that depends on legacy code that is unavoidably
        synchronous, you may be able to use workers to avoid blocking when
        you need to call that legacy code.</p>
        </li>
        </ul>
        
        <p>Worker threads are not nearly as heavyweight as child processes, but
        they are not lightweight. It does not generally make sense to create a
        worker unless you have significant work for it to do. And, generally
        speaking, if your program is not CPU-bound and is not having
        responsiveness problems, then you probably do not need worker threads.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.11.1 Creating Workers and Passing Messages"><div class="sect2" id="idm46198483853272">
        <h2>16.11.1 Creating Workers and Passing Messages</h2>
        
        <p>The<a data-type="indexterm" data-primary="Node" data-secondary="worker threads" data-tertiary="creating workers and passing messages" id="idm46198483851576"></a> Node module that defines workers is known as “worker_threads.” In
        this section we’ll refer to it with the identifier <code>threads</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">threads</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"worker_threads"</code><code class="p">);</code></pre>
        
        <p>This module defines a Worker class to represent a worker thread, and
        you can create a new thread with the <code>threads.Worker()</code>
        constructor. The following code demonstrates using this constructor to
        create a worker, and shows how to pass messages from main thread to
        worker and from worker to main thread. It also demonstrates a trick
        that allows you to put the main thread code and the worker thread code
        in the same file.<sup><a data-type="noteref" id="idm46198483842088-marker" href="ch16.html#idm46198483842088">2</a></sup></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">threads</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"worker_threads"</code><code class="p">);</code>
        
        <code class="c1">// The worker_threads module exports the boolean isMainThread property.</code>
        <code class="c1">// This property is true when Node is running the main thread and it is</code>
        <code class="c1">// false when Node is running a worker. We can use this fact to implement</code>
        <code class="c1">// the main and worker threads in the same file.</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">threads</code><code class="p">.</code><code class="nx">isMainThread</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// If we're running in the main thread, then all we do is export</code>
            <code class="c1">// a function. Instead of performing a computationally intensive</code>
            <code class="c1">// task on the main thread, this function passes the task to a worker</code>
            <code class="c1">// and returns a Promise that will resolve when the worker is done.</code>
            <code class="nx">module</code><code class="p">.</code><code class="nx">exports</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">reticulateSplines</code><code class="p">(</code><code class="nx">splines</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code><code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="c1">// Create a worker that loads and runs this same file of code.</code>
                    <code class="c1">// Note the use of the special __filename variable.</code>
                    <code class="kd">let</code> <code class="nx">reticulator</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">threads</code><code class="p">.</code><code class="nx">Worker</code><code class="p">(</code><code class="nx">__filename</code><code class="p">);</code>
        
                    <code class="c1">// Pass a copy of the splines array to the worker</code>
                    <code class="nx">reticulator</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="nx">splines</code><code class="p">);</code>
        
                    <code class="c1">// And then resolve or reject the Promise when we get</code>
                    <code class="c1">// a message or error from the worker.</code>
                    <code class="nx">reticulator</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"message"</code><code class="p">,</code> <code class="nx">resolve</code><code class="p">);</code>
                    <code class="nx">reticulator</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">reject</code><code class="p">);</code>
                <code class="p">});</code>
            <code class="p">};</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="c1">// If we get here, it means we're in the worker, so we register a</code>
            <code class="c1">// handler to get messages from the main thread. This worker is designed</code>
            <code class="c1">// to only receive a single message, so we register the event handler</code>
            <code class="c1">// with once() instead of on(). This allows the worker to exit naturally</code>
            <code class="c1">// when its work is complete.</code>
            <code class="nx">threads</code><code class="p">.</code><code class="nx">parentPort</code><code class="p">.</code><code class="nx">once</code><code class="p">(</code><code class="s2">"message"</code><code class="p">,</code> <code class="nx">splines</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="c1">// When we get the splines from the parent thread, loop</code>
                <code class="c1">// through them and reticulate all of them.</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">spline</code> <code class="k">of</code> <code class="nx">splines</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// For the sake of example, assume that spline objects usually</code>
                    <code class="c1">// have a reticulate() method that does a lot of computation.</code>
                    <code class="nx">spline</code><code class="p">.</code><code class="nx">reticulate</code> <code class="o">?</code> <code class="nx">spline</code><code class="p">.</code><code class="nx">reticulate</code><code class="p">()</code> <code class="o">:</code> <code class="nx">spline</code><code class="p">.</code><code class="nx">reticulated</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
                <code class="p">}</code>
        
                <code class="c1">// When all the splines have (finally!) been reticulated</code>
                <code class="c1">// pass a copy back to the main thread.</code>
                <code class="nx">threads</code><code class="p">.</code><code class="nx">parentPort</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="nx">splines</code><code class="p">);</code>
            <code class="p">});</code>
        <code class="p">}</code></pre>
        
        <p>The first argument to the <code>Worker()</code> constructor is the path to a file
        of JavaScript code that is to run in the thread. In the preceding code, we
        used the predefined <code>__filename</code> identifier to create a worker that
        loads and runs the same file as the main thread. In general, though,
        you will be passing a file path. Note that if you specify a relative
        path, it is relative to <code>process.cwd()</code>, not relative to the currently
        running module. If you want a path relative to the current module, use
        something like <code>path.resolve(__dirname, 'workers/reticulator.js')</code>.</p>
        
        <p>The <code>Worker()</code> constructor can also accept an object as its second
        argument, and the properties of this object provide optional
        configuration for the worker. We’ll cover a number of these options
        later, but for now note that if you pass <code>{eval: true}</code> as the second
        argument, then the first argument to <code>Worker()</code> is interpreted as a
        string of JavaScript code to be evaluated instead of a filename:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">new</code> <code class="nx">threads</code><code class="p">.</code><code class="nx">Worker</code><code class="p">(</code><code class="sb">`</code>
        <code class="sb">    const threads = require("worker_threads");</code>
        <code class="sb">    threads.parentPort.postMessage(threads.isMainThread);</code>
        <code class="sb">`</code><code class="p">,</code> <code class="p">{</code><code class="nb">eval</code><code class="o">:</code> <code class="kc">true</code><code class="p">}).</code><code class="nx">on</code><code class="p">(</code><code class="s2">"message"</code><code class="p">,</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">);</code>  <code class="c1">// This will print "false"</code></pre>
        
        <p>Node makes a copy of the object passed to <code>postMessage()</code> rather than
        sharing it directly with the worker thread. This prevents the worker
        thread and the main thread from sharing memory. You might expect that
        this copying would be done with <code>JSON.stringify()</code> and <code>JSON.parse()</code>
        (<a data-type="xref" href="ch11.html#jsonapi">§11.6</a>). But in fact, Node borrows a more robust technique known
        as the structured clone algorithm from web browsers.</p>
        
        <p>The structured clone algorithm enables serialization of most
        JavaScript types, including Map, Set, Date, and RegExp objects and
        typed arrays, but it cannot, in general, copy types defined by the Node
        host environment, such as sockets and streams. Note, however, that
        Buffer objects are partially supported: if you pass a Buffer to
        <code>postMessage()</code> it will be received as a Uint8Array, and can be
        converted back into a Buffer with <code>Buffer.from()</code>. Read more about the
        structured clone algorithm in <a data-type="xref" href="ch15.html#structuredclone">“The Structured Clone Algorithm”</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.11.2 The Worker Execution Environment"><div class="sect2" id="idm46198483852648">
        <h2>16.11.2 The Worker Execution Environment</h2>
        
        <p>For<a data-type="indexterm" data-primary="Node" data-secondary="worker threads" data-tertiary="worker execution environment" id="idm46198483592824"></a> the most part, JavaScript code in a Node worker thread runs just
        like it would in Node’s main thread. There are a few differences that
        you should be aware of, and some of these differences involve
        properties of the optional second argument to the <code>Worker()</code>
        constructor:</p>
        
        <ul>
        <li>
        <p>As we’ve seen, <code>threads.isMainThread</code> is <code>true</code> in the main
        thread but is always <code>false</code> in any worker thread.</p>
        </li>
        <li>
        <p>In a worker thread, you can use <code>threads.parentPort.postMessage()</code>
        to send a message to the parent thread and <code>threads.parentPort.on</code>
        to register event handlers for messages from the parent thread. In
        the main thread, <code>threads.parentPort</code> is always <code>null</code>.</p>
        </li>
        <li>
        <p>In a worker thread, <code>threads.workerData</code> is set to a copy of the
        <code>workerData</code> property of the second argument to the <code>Worker()</code>
        constructor. In the main thread, this property is always <code>null</code>. You
        can use this <code>workerData</code> property to pass an initial message to the
        worker that will be available as soon as it starts so that the
        worker does not have to wait for a “message” event before it can start
        doing work.</p>
        </li>
        <li>
        <p>By default, <code>process.env</code> in a worker thread is a copy of
        <code>process.env</code> in the parent thread. But the parent thread can
        specify a custom set of environment variables by setting the <code>env</code>
        property of the second argument to the <code>Worker()</code> constructor. As a
        special (and potentially dangerous) case, the parent thread can set
        the <code>env</code> property to <code>threads.SHARE_ENV</code>, which will cause the two
        threads to share a single set of environment variables so that a
        change in one thread is visible in the other.</p>
        </li>
        <li>
        <p>By default, the <code>process.stdin</code> stream in a worker never has any
        readable data on it. You can change this default by passing <code>stdin:
        true</code> in the second argument to the <code>Worker()</code> constructor. If you
        do that, then the <code>stdin</code> property of the Worker object is a
        Writable stream. Any data that the parent writes to <code>worker.stdin</code>
        becomes readable on <code>process.stdin</code> in the worker.</p>
        </li>
        <li>
        <p>By default, the <code>process.stdout</code> and <code>process.stderr</code> streams in the
        worker are simply piped to the corresponding streams in the parent
        thread. This means, for example, that <code>console.log()</code> and
        <code>console.error()</code> produce output in exactly the same way in a worker
        thread as they do in the main thread. You can override this default
        by passing <code>stdout:true</code> or <code>stderr:true</code> in the second argument to
        the <code>Worker()</code> constructor. If you do this, then any output the
        worker writes to those streams becomes readable by the parent thread
        on the <code>worker.stdout</code> and <code>worker.stderr</code> threads. (There is a
        potentially confusing inversion of stream directions here, and we
        saw the same thing with with child processes earlier in the chapter:
        the output streams of a worker thread are input streams for the
        parent thread, and the input stream of a worker is an output stream
        for the parent.)</p>
        </li>
        <li>
        <p>If a worker thread calls <code>process.exit()</code>, only the thread exits,
        not the entire <span class="keep-together">process.</span></p>
        </li>
        <li>
        <p>Worker threads are not allowed to change shared state of the process
        they are part of. Functions like <code>process.chdir()</code> and
        <code>process.setuid()</code> will throw exceptions when invoked from a worker.</p>
        </li>
        <li>
        <p>Operating system signals (like <code>SIGINT</code> and <code>SIGTERM</code>) are only
        delivered to the main thread; they cannot be received or handled in
        worker threads.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.11.3 Communication Channels and MessagePorts"><div class="sect2" id="idm46198483537592">
        <h2>16.11.3 Communication Channels and MessagePorts</h2>
        
        <p>When<a data-type="indexterm" data-primary="MessagePort objects" id="idm46198483536056"></a><a data-type="indexterm" data-primary="Node" data-secondary="worker threads" data-tertiary="communication channels and MessagePorts" id="idm46198483535320"></a> a new worker thread is created, a communication channel is
        created along with it that allows messages to be passed back and forth
        between the worker and the parent thread. As we’ve seen, the worker
        thread uses <code>threads.parentPort</code> to send and receive messages to and
        from the parent thread, and the parent thread uses the Worker object
        to send and receive messages to and from the worker thread.</p>
        
        <p>The worker thread API also allows the creation of custom communication
        channels using the MessageChannel API defined by web browsers and
        covered in <a data-type="xref" href="ch15.html#messagechannel">§15.13.5</a>. If you have read that section, much of
        what follows will sound familiar to you.</p>
        
        <p>Suppose a worker needs to handle two different kinds of messages sent
        by two different modules in the main thread. These two different
        modules could both share the default channel and send messages with
        <code>worker.postMessage()</code>, but it would be cleaner if each module has its
        own private channel for sending messages to the worker. Or consider the
        case where the main thread creates two independent workers. A custom
        communication channel can allow the two workers to communicate
        directly with each other instead of having to send all their messages
        via the parent.</p>
        
        <p>Create a new message channel with the <code>MessageChannel()</code>
        constructor. A MessageChannel object has two properties, named <code>port1</code>
        and <code>port2</code>. These properties refer to a pair of MessagePort
        objects. Calling <code>postMessage()</code> on one of the ports will<a data-type="indexterm" data-primary="message events" id="idm46198483528008"></a> cause a “message” event to be generated on the other with a structured clone of the Message object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">threads</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"worker_threads"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">channel</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">threads</code><code class="p">.</code><code class="nx">MessageChannel</code><code class="p">();</code>
        <code class="nx">channel</code><code class="p">.</code><code class="nx">port2</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"message"</code><code class="p">,</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">);</code>  <code class="c1">// Log any messages we receive</code>
        <code class="nx">channel</code><code class="p">.</code><code class="nx">port1</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="s2">"hello"</code><code class="p">);</code>        <code class="c1">// Will cause "hello" to be printed</code></pre>
        
        <p>You can also call <code>close()</code> on either port to break the connection
        between the two ports and to signal that no more messages will be
        exchanged. When <code>close()</code> is called on either port, a “close” event is
        delivered to both ports.</p>
        
        <p>Note that the code example above creates a pair of MessagePort objects and
        then uses those objects to transmit a message within the main
        thread. In order to use custom communication channels with workers, we
        must transfer one of the two ports from the thread in which it is
        created to the thread in which it will be used. The next section
        explains how to do this.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.11.4 Transferring MessagePorts and Typed Arrays"><div class="sect2" id="idm46198483483480">
        <h2>16.11.4 Transferring MessagePorts and Typed Arrays</h2>
        
        <p>The <code>postMessage()</code> function<a data-type="indexterm" data-primary="Node" data-secondary="worker threads" data-tertiary="transferring MessagePorts and typed arrays" id="idm46198483481304"></a> uses the structured clone algorithm, and
        as we’ve noted, it cannot copy objects like SSockets and Streams. It
        can handle MessagePort objects, but only as a special case using a
        special technique. The <code>postMessage()</code> method (of a Worker object, of
        <code>threads.parentPort</code>, or of any MessagePort object) takes an optional
        second argument. This argument (called <code>transferList</code>) is an array of
        objects that are to be transferred between threads rather than being
        copied.</p>
        
        <p>A MessagePort object cannot be copied by the structured clone
        algorithm, but it can be transferred. If the first argument to
        <code>postMessage()</code> has included one or more 
        <span class="keep-together">MessagePorts</span> (nested arbitrarily
        deeply within the Message object), then those MessagePort objects must
        also appear as members of the array passed as the second
        argument. Doing this tells Node that it does not need to make a copy
        of the MessagePort, and can instead just give the existing object to
        the other thread. The key thing to understand, however, about
        transferring values between threads is that once a value is
        transferred, it can no longer be used in the thread that called
        <code>postMessage()</code>.</p>
        
        <p>Here is how you might create a new MessageChannel and transfer one of
        its MessagePorts to a worker:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Create a custom communication channel</code>
        <code class="kr">const</code> <code class="nx">threads</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"worker_threads"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">channel</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">threads</code><code class="p">.</code><code class="nx">MessageChannel</code><code class="p">();</code>
        
        <code class="c1">// Use the worker's default channel to transfer one end of the new</code>
        <code class="c1">// channel to the worker. Assume that when the worker receives this</code>
        <code class="c1">// message it immediately begins to listen for messages on the new channel.</code>
        <code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">({</code> <code class="nx">command</code><code class="o">:</code> <code class="s2">"changeChannel"</code><code class="p">,</code> <code class="nx">data</code><code class="o">:</code> <code class="nx">channel</code><code class="p">.</code><code class="nx">port1</code> <code class="p">},</code>
                           <code class="p">[</code> <code class="nx">channel</code><code class="p">.</code><code class="nx">port1</code> <code class="p">]);</code>
        
        <code class="c1">// Now send a message to the worker using our end of the custom channel</code>
        <code class="nx">channel</code><code class="p">.</code><code class="nx">port2</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="s2">"Can you hear me now?"</code><code class="p">);</code>
        
        <code class="c1">// And listen for responses from the worker as well</code>
        <code class="nx">channel</code><code class="p">.</code><code class="nx">port2</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"message"</code><code class="p">,</code> <code class="nx">handleMessagesFromWorker</code><code class="p">);</code></pre>
        
        <p>MessagePort objects are not the only ones that can be transferred. If
        you call <code>postMessage()</code> with a typed array as the message (or with a
        message that contains one or more typed arrays nested arbitrarily deep
        within the message), that typed array (or those typed arrays) will
        simply be copied by the structured clone algorithm. But typed arrays
        can be large; for example, if you are using a worker thread to do image
        processing on millions of pixels. So for efficiency, <code>postMessage()</code>
        also gives us the option to transfer typed arrays rather than copying
        them. (Threads share memory by default. Worker threads in JavaScript
        generally avoid shared memory, but when we allow this kind of
        controlled transfer, it can be done very efficiently.) What makes this
        safe is that when a typed array is transferred to another thread, it
        becomes unusable in the thread that transferred it. In the image-processing scenario, the main thread could transfer the pixels of an
        image to the worker thread, and then the worker thread could transfer
        the processed pixels back to the main thread when it was done. The
        memory would not need to be copied, but it would never be accessible by
        two threads at once.</p>
        
        <p>To transfer a typed array instead of copying it, include the
        ArrayBuffer that backs the array in the second argument to
        <code>postMessage()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">pixels</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint32Array</code><code class="p">(</code><code class="mi">1024</code><code class="o">*</code><code class="mi">1024</code><code class="p">);</code>  <code class="c1">// 4 megabytes of memory</code>
        
        <code class="c1">// Assume we read some data into this typed array, and then transfer the</code>
        <code class="c1">// pixels to a worker without copying. Note that we don't put the array</code>
        <code class="c1">// itself in the transfer list, but the array's Buffer object instead.</code>
        <code class="nx">worker</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="nx">pixels</code><code class="p">,</code> <code class="p">[</code> <code class="nx">pixels</code><code class="p">.</code><code class="nx">buffer</code> <code class="p">]);</code></pre>
        
        <p>As with transferred MessagePorts, a transferred typed array becomes
        unusable once transferred. No exceptions are thrown if you attempt to
        use a MessagePort or typed array that has been transferred; these
        objects simply stop doing anything when you interact with them.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="16.11.5 Sharing Typed Arrays Between Threads"><div class="sect2" id="idm46198483308776">
        <h2>16.11.5 Sharing Typed Arrays Between Threads</h2>
        
        <p>In<a data-type="indexterm" data-primary="typed arrays" data-secondary="sharing between threads" id="idm46198483295336"></a><a data-type="indexterm" data-primary="Node" data-secondary="worker threads" data-tertiary="sharing typed arrays between threads" id="idm46198483294328"></a> addition to transferring typed arrays between threads, it is
        actually possible to share a typed array between threads. Simply
        create a SharedArrayBuffer of the desired size and then use that
        buffer to create a typed array. When a typed array that is backed by a
        SharedArrayBuffer is passed via <code>postMessage()</code>, the underlying memory
        will be shared between the threads. You should not include the shared
        buffer in the second argument to <code>postMessage()</code> in this case.</p>
        
        <p>You really should not do this, however, because JavaScript was never
        designed with thread safety in mind and multithreaded programming is
        very difficult to get right. (And this is why SharedArrayBuffer was
        not covered in <a data-type="xref" href="ch11.html#typedarrays">§11.2</a>: it is a niche feature that is
        difficult to get right.) Even the simple <code>++</code> operator is not
        thread-safe because it needs to read a value, increment it, and write
        it back. If two threads are incrementing a value at the same time, it
        will often only be incremented once, as the following code
        demonstrates:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">threads</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"worker_threads"</code><code class="p">);</code>
        
        <code class="k">if</code> <code class="p">(</code><code class="nx">threads</code><code class="p">.</code><code class="nx">isMainThread</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// In the main thread, we create a shared typed array with</code>
            <code class="c1">// one element. Both threads will be able to read and write</code>
            <code class="c1">// sharedArray[0] at the same time.</code>
            <code class="kd">let</code> <code class="nx">sharedBuffer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">SharedArrayBuffer</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code>
            <code class="kd">let</code> <code class="nx">sharedArray</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Int32Array</code><code class="p">(</code><code class="nx">sharedBuffer</code><code class="p">);</code>
        
            <code class="c1">// Now create a worker thread, passing the shared array to it with</code>
            <code class="c1">// as its initial workerData value so we don't have to bother with</code>
            <code class="c1">// sending and receiving a message</code>
            <code class="kd">let</code> <code class="nx">worker</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">threads</code><code class="p">.</code><code class="nx">Worker</code><code class="p">(</code><code class="nx">__filename</code><code class="p">,</code> <code class="p">{</code> <code class="nx">workerData</code><code class="o">:</code> <code class="nx">sharedArray</code> <code class="p">});</code>
        
            <code class="c1">// Wait for the worker to start running and then increment the</code>
            <code class="c1">// shared integer 10 million times.</code>
            <code class="nx">worker</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"online"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="nx">_000_000</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">sharedArray</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="o">++</code><code class="p">;</code>
        
                <code class="c1">// Once we're done with our increments, we start listening for</code>
                <code class="c1">// message events so we know when the worker is done.</code>
                <code class="nx">worker</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"message"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="c1">// Although the shared integer has been incremented</code>
                    <code class="c1">// 20 million times, its value will generally be much less.</code>
                    <code class="c1">// On my computer the final value is typically under 12 million.</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">sharedArray</code><code class="p">[</code><code class="mi">0</code><code class="p">]);</code>
                <code class="p">});</code>
            <code class="p">});</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="c1">// In the worker thread, we get the shared array from workerData</code>
            <code class="c1">// and then increment it 10 million times.</code>
            <code class="kd">let</code> <code class="nx">sharedArray</code> <code class="o">=</code> <code class="nx">threads</code><code class="p">.</code><code class="nx">workerData</code><code class="p">;</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="nx">_000_000</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">sharedArray</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code><code class="o">++</code><code class="p">;</code>
            <code class="c1">// When we're done incrementing, let the main thread know</code>
            <code class="nx">threads</code><code class="p">.</code><code class="nx">parentPort</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="s2">"done"</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>One scenario in which it might be reasonable to use a
        SharedArrayBuffer is when the two threads operate on entirely separate
        sections of the shared memory. You might enforce this by creating two
        typed arrays that serve as views of nonoverlapping regions of the
        shared buffer, and then have your two threads use those two separate
        typed arrays. A parallel merge sort could be done like this: one
        thread sorts the bottom half of an array and the other thread sorts
        the top half, for example. Or some kinds of image-processing
        algorithms are also suitable for this approach: multiple threads
        working on disjoint regions of the image.</p>
        
        <p>If you really must allow multiple threads to access the same region of
        a shared array, you can take one step toward thread safety with the
        functions defined by the Atomics object. Atomics was added to
        JavaScript when SharedArrayBuffer was to define atomic operations on
        the elements of a shared array. For example, the <code>Atomics.add()</code>
        function reads the specified element of a shared array, adds a
        specified value to it, and writes the sum back into the array. It does
        this atomically as if it was a single operation, and ensures that no
        other thread can read or write the value while the operation is taking
        place. <code>Atomics.add()</code> allows us to rewrite the parallel increment
        code we just looked at and get the correct result of 20 million increments of a
        shared array element:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">threads</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"worker_threads"</code><code class="p">);</code>
        
        <code class="k">if</code> <code class="p">(</code><code class="nx">threads</code><code class="p">.</code><code class="nx">isMainThread</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">sharedBuffer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">SharedArrayBuffer</code><code class="p">(</code><code class="mi">4</code><code class="p">);</code>
            <code class="kd">let</code> <code class="nx">sharedArray</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Int32Array</code><code class="p">(</code><code class="nx">sharedBuffer</code><code class="p">);</code>
            <code class="kd">let</code> <code class="nx">worker</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">threads</code><code class="p">.</code><code class="nx">Worker</code><code class="p">(</code><code class="nx">__filename</code><code class="p">,</code> <code class="p">{</code> <code class="nx">workerData</code><code class="o">:</code> <code class="nx">sharedArray</code> <code class="p">});</code>
        
            <code class="nx">worker</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"online"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="nx">_000_000</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">Atomics</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">sharedArray</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>  <code class="c1">// Threadsafe atomic increment</code>
                <code class="p">}</code>
        
                <code class="nx">worker</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"message"</code><code class="p">,</code> <code class="p">(</code><code class="nx">message</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="c1">// When both threads are done, use a threadsafe function</code>
                    <code class="c1">// to read the shared array and confirm that it has the</code>
                    <code class="c1">// expected value of 20,000,000.</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">Atomics</code><code class="p">.</code><code class="nx">load</code><code class="p">(</code><code class="nx">sharedArray</code><code class="p">,</code> <code class="mi">0</code><code class="p">));</code>
                <code class="p">});</code>
            <code class="p">});</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">sharedArray</code> <code class="o">=</code> <code class="nx">threads</code><code class="p">.</code><code class="nx">workerData</code><code class="p">;</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="nx">_000_000</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">Atomics</code><code class="p">.</code><code class="nx">add</code><code class="p">(</code><code class="nx">sharedArray</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>      <code class="c1">// Threadsafe atomic increment</code>
            <code class="p">}</code>
            <code class="nx">threads</code><code class="p">.</code><code class="nx">parentPort</code><code class="p">.</code><code class="nx">postMessage</code><code class="p">(</code><code class="s2">"done"</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>This new version of the code correctly prints the number
        20,000,000. But it is about nine times slower than the incorrect code it
        replaces. It would be much simpler and much faster to just do all 20
        million increments in one thread. Also note that atomic operations may
        be able to ensure thread safety for image-processing algorithms for
        which each array element is a value entirely independent of all other
        values. But in most real-world programs, multiple array elements are
        often related to one another and some kind of higher-level thread
        synchronization is required. The low-level 
        <span class="keep-together"><code>Atomics.wait()</code></span> and
        <code>Atomics.notify()</code> function can help with this, but a discussion of
        their use is out of scope for this book.<a data-type="indexterm" data-primary="" data-startref="Nworker16" id="idm46198483032936"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="16.12 Summary"><div class="sect1" id="idm46198483869464">
        <h1>16.12 Summary</h1>
        
        <p>Although JavaScript was created to run in web browsers, Node has
        made JavaScript into a general-purpose programming language. It is
        particularly popular for implementing web servers, but its deep
        bindings to the operating system mean that it is also a good
        alternative to shell scripts.</p>
        
        <p>The most important topics covered in this long chapter include:</p>
        
        <ul>
        <li>
        <p>Node’s asynchronous-by-default APIs and its single-threaded, callback,
        and event-based style of concurrency.</p>
        </li>
        <li>
        <p>Node’s fundamental datatypes, buffers, and streams.</p>
        </li>
        <li>
        <p>Node’s “fs” and “path” modules for working with the filesystem.</p>
        </li>
        <li>
        <p>Node’s “http” and “https” modules for writing HTTP clients and
        servers.</p>
        </li>
        <li>
        <p>Node’s “net” module for writing non-HTTP clients and servers.</p>
        </li>
        <li>
        <p>Node’s “child_process” module for creating and communicating with
        child 
        <span class="keep-together">processes.</span></p>
        </li>
        <li>
        <p>Node’s “worker_threads” module for true multithreaded programming
        using message-passing instead of shared memory.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        <div data-type="footnotes"><p data-type="footnote" id="idm46198489626936"><sup><a href="ch16.html#idm46198489626936-marker">1</a></sup> Node defines a <code>fs.copyFile()</code> function that you would actually use in practice.</p><p data-type="footnote" id="idm46198483842088"><sup><a href="ch16.html#idm46198483842088-marker">2</a></sup> It is often cleaner and simpler to define the worker code in a separate file. But this trick of having two threads run different sections of the same file blew my mind when I first encountered it for the Unix <code>fork()</code> system call. And I think it is worth demonstrating this technique simply for its strange elegance.</p></div></div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->