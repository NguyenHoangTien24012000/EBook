<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 13. Asynchronous JavaScript"><div class="chapter" id="async">
        <h1><span class="label">Chapter 13. </span>Asynchronous JavaScript</h1>
        
        
        <p>Some<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="definition of term" id="idm46198519760376"></a> computer programs, such as scientific simulations and machine
        learning models, are compute-bound: they run continuously, without
        pause, until they have computed their result. Most real-world computer
        programs, however, are significantly <em>asynchronous</em>. This means that
        they often have to stop computing while waiting for data to arrive or
        for some event to occur. JavaScript<a data-type="indexterm" data-primary="event-driven programming model" data-secondary="definition of term" id="idm46198519758488"></a><a data-type="indexterm" data-primary="event-driven programming model" id="idm46198519757496"></a> programs in a web browser are
        typically <em>event-driven</em>, meaning that they wait for the user to click
        or tap before they actually do anything. And JavaScript-based servers
        typically wait for client requests to arrive over the network before
        they do anything.</p>
        
        <p>This<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="JavaScript support for" id="idm46198519755368"></a> kind of asynchronous programming is commonplace in JavaScript, and
        this chapter documents three important language features that help
        make it easier to work with asynchronous code. Promises, new in
        ES6, are objects that represent the not-yet-available result
        of an asynchronous operation. The<a data-type="indexterm" data-primary="ES2017, async and await keywords" id="idm46198519753960"></a> keywords <code>async</code> and <code>await</code> were
        introduced in ES2017 and provide new syntax that simplifies
        asynchronous programming by allowing you to structure your Promise-based
        code as if it was synchronous. Finally, asynchronous iterators and the
        <code>for/await</code> loop were introduced in ES2018 and allow you to
        work with streams of asynchronous events using simple loops that
        appear synchronous.</p>
        
        <p>Ironically, even though JavaScript provides these powerful features
        for working with asynchronous code, there are no features of the core
        language that are themselves asynchronous. In order to demonstrate
        Promises, <code>async</code>, <code>await</code>, and <code>for/await</code>, therefore, we will first take a detour into client-side and server-side JavaScript to
        explain some of the asynchronous features of web browsers and Node.
        (You can learn more about client-side and server-side JavaScript in
        Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch15.html#clientside">15</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch16.html#serverside">16</a>.)</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="13.1 Asynchronous Programming with Callbacks"><div class="sect1" id="async-callbacks">
        <h1>13.1 Asynchronous Programming with Callbacks</h1>
        
        <p>At<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="definition of term" id="idm46198519744856"></a><a data-type="indexterm" data-primary="callbacks" data-secondary="definition of term" id="idm46198519743560"></a> its most fundamental level, asynchronous programming in JavaScript
        is done with <em>callbacks</em>. A callback is a function that you write and
        then pass to some other function. That other function then invokes
        (“calls back”) your function when some condition is met or some
        (asynchronous) event occurs. The invocation of the callback function
        you provide notifies you of the condition or event, and sometimes, the
        invocation will include function arguments that provide additional
        details. This is easier to understand with some concrete examples, and
        the subsections that follow demonstrate various forms of
        callback-based asynchronous programming using both client-side
        JavaScript and Node.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.1.1 Timers"><div class="sect2" id="async-timers">
        <h2>13.1.1 Timers</h2>
        
        <p>One<a data-type="indexterm" data-primary="timers" id="idm46198519739304"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="timers" id="idm46198519738568"></a><a data-type="indexterm" data-primary="callbacks" data-secondary="timers" id="idm46198519737384"></a> of the simplest kinds of asynchrony is when you want to run some
        code after a certain amount of time has elapsed. As we saw in
        <a data-type="xref" href="ch11.html#timerapi">§11.10</a>, you<a data-type="indexterm" data-primary="setTimeout() function" id="idm46198519735368"></a> can do this with the <code>setTimeout()</code> function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">setTimeout</code><code class="p">(</code><code class="nx">checkForUpdates</code><code class="p">,</code> <code class="mi">60000</code><code class="p">);</code></pre>
        
        <p>The first argument to <code>setTimeout()</code>
        is a function and the second is a time interval measured in
        milliseconds. In the preceding code, a hypothetical <code>checkForUpdates()</code>
        function will be called 60,000 milliseconds (1 minute) after the
        <code>setTimeout()</code> call. <code>checkForUpdates()</code> is a callback function that
        your program might define, and <code>setTimeout()</code> is the function that you
        invoke to register your callback function and specify under what
        asynchronous conditions it should be invoked.</p>
        
        <p><code>setTimeout()</code> calls the specified callback function one time, passing
        no arguments, and then forgets about it. If you are writing a function
        that really does check for updates, you probably want it to run
        repeatedly. You can do this by using <span class="keep-together"><code>setInterval()</code></span> instead of
        <code>setTimeout()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Call checkForUpdates in one minute and then again every minute after that</code>
        <code class="kd">let</code> <code class="nx">updateIntervalId</code> <code class="o">=</code> <code class="nx">setInterval</code><code class="p">(</code><code class="nx">checkForUpdates</code><code class="p">,</code> <code class="mi">60000</code><code class="p">);</code>
        
        <code class="c1">// setInterval() returns a value that we can use to stop the repeated</code>
        <code class="c1">// invocations by calling clearInterval(). (Similarly, setTimeout()</code>
        <code class="c1">// returns a value that you can pass to clearTimeout())</code>
        <code class="kd">function</code> <code class="nx">stopCheckingForUpdates</code><code class="p">()</code> <code class="p">{</code>
            <code class="nx">clearInterval</code><code class="p">(</code><code class="nx">updateIntervalId</code><code class="p">);</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="13.1.2 Events"><div class="sect2" id="async-events">
        <h2>13.1.2 Events</h2>
        
        <p>Client-side<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="events" id="idm46198519710680"></a><a data-type="indexterm" data-primary="callbacks" data-secondary="events" id="idm46198519634856"></a><a data-type="indexterm" data-primary="web browser host environment" data-secondary="asynchronous APIs" id="idm46198519633880"></a> JavaScript programs are almost universally event driven:
        rather than running some kind of predetermined computation, they
        typically wait for the user to do something and then respond to the
        user’s actions. The web browser generates an <em>event</em> when the user
        presses a key on the keyboard, moves the mouse, clicks a mouse button,
        or touches a touchscreen device. Event-driven JavaScript programs
        register callback functions for specified types of events in specified
        contexts, and the web browser invokes those functions whenever the
        specified events occur. These<a data-type="indexterm" data-primary="event listeners" id="idm46198519631864"></a> callback functions are called <em>event
        handlers</em> or <em>event listeners</em>, and they are registered with
        <span class="keep-together"><code>addEventListener()</code>:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Ask the web browser to return an object representing the HTML</code>
        <code class="c1">// &lt;button&gt; element that matches this CSS selector</code>
        <code class="kd">let</code> <code class="nx">okay</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">querySelector</code><code class="p">(</code><code class="s1">'#confirmUpdateDialog button.okay'</code><code class="p">);</code>
        
        <code class="c1">// Now register a callback function to be invoked when the user</code>
        <code class="c1">// clicks on that button.</code>
        <code class="nx">okay</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="s1">'click'</code><code class="p">,</code> <code class="nx">applyUpdate</code><code class="p">);</code></pre>
        
        <p>In this example, <code>applyUpdate()</code> is a hypothetical callback function
        that we assume is implemented somewhere else. The call to
        <code>document.querySelector()</code> returns an object that represents a single
        specified element in the web page. We call <code>addEventListener()</code> on that element to register our callback. Then the first argument to <code>addEventListener()</code> is a string that
        specifies the kind of event we’re interested in—a mouse click or
        touchscreen tap, in this case. If the user clicks or taps on that
        specific element of the web page, then the browser will invoke our
        <code>applyUpdate()</code> callback function, passing an object that includes
        details (such as the time and the mouse pointer coordinates) about
        the event.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.1.3 Network Events"><div class="sect2" id="async-network">
        <h2>13.1.3 Network Events</h2>
        
        <p>Another<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="network events" id="idm46198519587992"></a><a data-type="indexterm" data-primary="callbacks" data-secondary="network events" id="idm46198519586744"></a><a data-type="indexterm" data-primary="network events" id="idm46198519585800"></a> common source of asynchrony in JavaScript programming is
        network requests. JavaScript running in the browser can fetch data
        from a web server with code like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">getCurrentVersionNumber</code><code class="p">(</code><code class="nx">versionCallback</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// Note callback argument</code>
            <code class="c1">// Make a scripted HTTP request to a backend version API</code>
            <code class="kd">let</code> <code class="nx">request</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">XMLHttpRequest</code><code class="p">();</code>
            <code class="nx">request</code><code class="p">.</code><code class="nx">open</code><code class="p">(</code><code class="s2">"GET"</code><code class="p">,</code> <code class="s2">"http://www.example.com/api/version"</code><code class="p">);</code>
            <code class="nx">request</code><code class="p">.</code><code class="nx">send</code><code class="p">();</code>
        
            <code class="c1">// Register a callback that will be invoked when the response arrives</code>
            <code class="nx">request</code><code class="p">.</code><code class="nx">onload</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">request</code><code class="p">.</code><code class="nx">status</code> <code class="o">===</code> <code class="mi">200</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// If HTTP status is good, get version number and call callback.</code>
                    <code class="kd">let</code> <code class="nx">currentVersion</code> <code class="o">=</code> <code class="nb">parseFloat</code><code class="p">(</code><code class="nx">request</code><code class="p">.</code><code class="nx">responseText</code><code class="p">);</code>
                    <code class="nx">versionCallback</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">currentVersion</code><code class="p">);</code>
                <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                    <code class="c1">// Otherwise report an error to the callback</code>
                    <code class="nx">versionCallback</code><code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusText</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">};</code>
            <code class="c1">// Register another callback that will be invoked for network errors</code>
            <code class="nx">request</code><code class="p">.</code><code class="nx">onerror</code> <code class="o">=</code> <code class="nx">request</code><code class="p">.</code><code class="nx">ontimeout</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">versionCallback</code><code class="p">(</code><code class="nx">e</code><code class="p">.</code><code class="nx">type</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
            <code class="p">};</code>
        <code class="p">}</code></pre>
        
        <p>Client-side<a data-type="indexterm" data-primary="fetch() function" id="idm46198519582216"></a> JavaScript code can use the XMLHttpRequest class plus
        callback functions to make HTTP requests and asynchronously handle the
        server’s response when it arrives.<sup><a data-type="noteref" id="idm46198519434968-marker" href="ch13.html#idm46198519434968">1</a></sup> The <code>getCurrentVersionNumber()</code> function
        defined here (we can imagine that it is used by the hypothetical
        <code>checkForUpdates()</code> function we discussed in <a data-type="xref" href="#async-timers">§13.1.1</a>) makes an HTTP
        request and defines event handlers that will be invoked when the
        server’s response is received or when a timeout or other error causes
        the request to fail.</p>
        
        <p>Notice that the code example above does not call <code>addEventListener()</code> as our
        previous example did. For most web APIs (including this one), event
        handlers can be defined by invoking <code>addEventListener()</code> on the object
        generating the event and passing the name of the event of interest
        along with the callback function. Typically, though, you can also
        register a single event listener by assigning it directly to a property of
        the object. That is what we do in this example code, assigning
        functions to the <code>onload</code>, <code>onerror</code>, and <code>ontimeout</code> properties. By
        convention, event listener properties like these always have names
        that begin with <em>on</em>. <code>addEventListener()</code> is the more flexible
        technique because it allows for multiple event handlers. But in cases
        where you are sure that no other code will need to register a listener
        for the same object and event type, it can be simpler to simply set
        the appropriate property to your callback.</p>
        
        <p>Another thing to note about the <code>getCurrentVersionNumber()</code> function
        in this example code is that, because it makes an asynchronous request, it cannot
        synchronously return the value (the current version number) that the
        caller is interested in. Instead, the caller passes a callback
        function, which is invoked when the result is ready or when an error
        occurs. In this case, the caller supplies a callback function that
        expects two arguments. If the XMLHttpRequest works correctly, then
        <code>getCurrentVersionNumber()</code> invokes the callback with a <code>null</code> first
        argument and the version number as the second argument. Or, if an
        error occurs, then <code>getCurrentVersionNumber()</code> invokes the callback
        with error details in the first argument and <code>null</code> as the second
        argument.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.1.4 Callbacks and Events in Node"><div class="sect2" id="async-node-callbacks">
        <h2>13.1.4 Callbacks and Events in Node</h2>
        
        <p>The<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="callbacks" data-tertiary="callbacks and events in Node" id="idm46198519421592"></a><a data-type="indexterm" data-primary="callbacks" data-secondary="callbacks and events in Node" id="idm46198519420280"></a><a data-type="indexterm" data-primary="Node" data-secondary="callbacks and events in" id="idm46198519419320"></a> Node.js server-side JavaScript environment is deeply asynchronous
        and defines many APIs that use callbacks and events. The default API
        for reading the contents of a file, for example, is asynchronous and
        invokes a callback function when the contents of the file have been
        read:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code> <code class="c1">// The "fs" module has filesystem-related APIs</code>
        <code class="kd">let</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code>           <code class="c1">// An object to hold options for our program</code>
            <code class="c1">// default options would go here</code>
        <code class="p">};</code>
        
        <code class="c1">// Read a configuration file, then call the callback function</code>
        <code class="nx">fs</code><code class="p">.</code><code class="nx">readFile</code><code class="p">(</code><code class="s2">"config.json"</code><code class="p">,</code> <code class="s2">"utf-8"</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="nx">text</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// If there was an error, display a warning, but continue</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">warn</code><code class="p">(</code><code class="s2">"Could not read config file:"</code><code class="p">,</code> <code class="nx">err</code><code class="p">);</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="c1">// Otherwise, parse the file contents and assign to the options object</code>
                <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">options</code><code class="p">,</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">text</code><code class="p">));</code>
            <code class="p">}</code>
        
            <code class="c1">// In either case, we can now start running the program</code>
            <code class="nx">startProgram</code><code class="p">(</code><code class="nx">options</code><code class="p">);</code>
        <code class="p">});</code></pre>
        
        <p>Node’s <code>fs.readFile()</code> function takes a two-parameter callback as its
        last argument. It reads the specified file asynchronously and then
        invokes the callback. If the file was read successfully, it passes the
        file contents as the second callback argument. If there was an error,
        it passes the error as the first callback argument. In this example, we
        express the callback as an arrow function, which is a succinct and
        natural syntax for this kind of simple operation.</p>
        
        <p>Node also defines a number of event-based APIs. The following function
        shows how to make an HTTP request for the contents of a URL in
        Node. It has two layers of asynchronous code handled with event
        listeners. Notice that Node uses an <code>on()</code> method to register event
        listeners instead of <code>addEventListener()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">https</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"https"</code><code class="p">);</code>
        
        <code class="c1">// Read the text content of the URL and asynchronously pass it to the callback.</code>
        <code class="kd">function</code> <code class="nx">getText</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">callback</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Start an HTTP GET request for the URL</code>
            <code class="nx">request</code> <code class="o">=</code> <code class="nx">https</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
        
            <code class="c1">// Register a function to handle the "response" event.</code>
            <code class="nx">request</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"response"</code><code class="p">,</code> <code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="c1">// The response event means that response headers have been received</code>
                <code class="kd">let</code> <code class="nx">httpStatus</code> <code class="o">=</code> <code class="nx">response</code><code class="p">.</code><code class="nx">statusCode</code><code class="p">;</code>
        
                <code class="c1">// The body of the HTTP response has not been received yet.</code>
                <code class="c1">// So we register more event handlers to to be called when it arrives.</code>
                <code class="nx">response</code><code class="p">.</code><code class="nx">setEncoding</code><code class="p">(</code><code class="s2">"utf-8"</code><code class="p">);</code>  <code class="c1">// We're expecting Unicode text</code>
                <code class="kd">let</code> <code class="nx">body</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>                  <code class="c1">// which we will accumulate here.</code>
        
                <code class="c1">// This event handler is called when a chunk of the body is ready</code>
                <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"data"</code><code class="p">,</code> <code class="nx">chunk</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">body</code> <code class="o">+=</code> <code class="nx">chunk</code><code class="p">;</code> <code class="p">});</code>
        
                <code class="c1">// This event handler is called when the response is complete</code>
                <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"end"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">httpStatus</code> <code class="o">===</code> <code class="mi">200</code><code class="p">)</code> <code class="p">{</code>   <code class="c1">// If the HTTP response was good</code>
                        <code class="nx">callback</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">body</code><code class="p">);</code>   <code class="c1">// Pass response body to the callback</code>
                    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>                    <code class="c1">// Otherwise pass an error</code>
                        <code class="nx">callback</code><code class="p">(</code><code class="nx">httpStatus</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
                    <code class="p">}</code>
                <code class="p">});</code>
            <code class="p">});</code>
        
            <code class="c1">// We also register an event handler for lower-level network errors</code>
            <code class="nx">request</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="nx">callback</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code> <code class="kc">null</code><code class="p">);</code>
            <code class="p">});</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="13.2 Promises"><div class="sect1" id="async-promises">
        <h1>13.2 Promises</h1>
        
        <p>Now<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="overview of" id="idm46198519305064"></a><a data-type="indexterm" data-primary="Promises" data-secondary="overview of" id="idm46198519134856"></a><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="overview of" id="idm46198519133912"></a> that we’ve seen examples of callback and event-based asynchronous
        programming in client-side and server-side JavaScript environments, we
        can introduce <em>Promises</em>, a core language feature designed to simplify
        asynchronous programming.</p>
        
        <p>A Promise is an object that represents the result of an asynchronous
        computation. That result may or may not be ready yet, and the Promise
        API is intentionally vague about this: there is no way to
        synchronously get the value of a Promise; you can only ask the Promise
        to call a callback function when the value is ready.  If you are
        defining an asynchronous API like the <code>getText()</code> function in the
        previous section, but want to make it Promise-based, omit the callback
        argument, and instead return a Promise object. The caller can then
        register one or more callbacks on this Promise object, and they will be
        invoked when the asynchronous computation is done.</p>
        
        <p>So, at the simplest level, Promises are just a different way of working
        with callbacks. However, there are practical benefits to using them. One real problem with callback-based asynchronous programming is that
        it is common to end up with callbacks inside callbacks inside
        callbacks, with lines of code so highly indented that it is difficult
        to read. Promises allow this kind of nested callback to be
        re-expressed as a more<a data-type="indexterm" data-primary="Promise chains" id="idm46198519129640"></a> linear <em>Promise chain</em> that tends to be easier
        to read and easier to reason about.</p>
        
        <p>Another problem with callbacks is that they can make handling errors
        difficult. If an asynchronous function (or an asynchronously invoked
        callback) throws an exception, there is no way for that exception to
        propagate back to the initiator of the asynchronous operation. This is
        a fundamental fact about asynchronous programming: it breaks exception
        handling. The alternative is to meticulously track and propagate
        errors with callback arguments and return values, but this is tedious
        and difficult to get right. Promises help here by standardizing a way
        to handle errors and providing a way for errors to propagate
        correctly through a chain of promises.</p>
        
        <p>Note that Promises represent the future results of single asynchronous
        computations. They cannot be used to represent repeated asynchronous
        computations, however. Later in this chapter, we’ll write a
        Promise-based alternative to the <code>setTimeout()</code> function, for
        example. But we can’t use Promises to replace <code>setInterval()</code> because
        that function invokes a callback function repeatedly, which is
        something that Promises are just not designed to do. Similarly, we
        could use a Promise instead of the “load” event handler of an
        XMLHttpRequest object, since that callback is only ever called
        once. But we typically would not use a Promise in place of a “click”
        event handler of an HTML button object, since we normally want to
        allow the user to click a button multiple times.</p>
        
        <p>The subsections that follow will:</p>
        
        <ul>
        <li>
        <p>Explain Promise terminology and show basic Promise usage</p>
        </li>
        <li>
        <p>Show how promises can be chained</p>
        </li>
        <li>
        <p>Demonstrate how to create your own Promise-based APIs</p>
        </li>
        </ul>
        <div data-type="important"><h6>Important</h6>
        <p>Promises seem simple at first, and the basic use case for
        Promises is, in fact, straightforward and simple. But they can become
        surprisingly confusing for anything beyond the simplest use cases.
        Promises are a powerful idiom for asynchronous programming, but you
        need to understand them deeply to use them correctly and
        confidently. It is worth taking the time to develop that deep
        understanding, however, and I urge you to study this long chapter
        <span class="keep-together">carefully.</span></p>
        </div>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.2.1 Using Promises"><div class="sect2" id="async-using-promises">
        <h2>13.2.1 Using Promises</h2>
        
        <p>With<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="using" id="APpromusing13"></a><a data-type="indexterm" data-primary="Promises" data-secondary="using" id="Puse13"></a><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="using" id="ESpromuse13"></a> the advent of Promises in the core JavaScript language, web
        browsers have begun to implement Promise-based APIs. In the previous
        section, we implemented a <code>getText()</code> function that made an
        asynchronous HTTP request and passed the body of the HTTP response to
        a specified callback function as a string. Imagine a variant of this
        function, <code>getJSON()</code>, which parses the body of the HTTP response as
        JSON and returns a Promise instead of accepting a callback
        argument. We will implement a <code>getJSON()</code> function later in this
        chapter, but for now, let’s look at how we would use this
        Promise-returning utility function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">jsonData</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="c1">// This is a callback function that will be asynchronously</code>
            <code class="c1">// invoked with the parsed JSON value when it becomes available.</code>
        <code class="p">});</code></pre>
        
        <p><code>getJSON()</code> starts an asynchronous HTTP request for the URL you
        specify and then, while that request is pending, it returns a Promise
        object. The Promise object defines a <code>then()</code> instance method. Instead
        of passing our callback function directly to 
        <span class="keep-together"><code>getJSON()</code>,</span> we instead
        pass it to the <code>then()</code> method. When the HTTP response arrives, the
        body of that response is parsed as JSON, and the resulting parsed
        value is passed to the function that we passed to <code>then()</code>.</p>
        
        <p>You can think of the <code>then()</code> method as a callback registration method
        like the 
        <span class="keep-together"><code>addEventListener()</code></span> method used for registering event
        handlers in client-side JavaScript. If you call the <code>then()</code> method of
        a Promise object multiple
        times, each of the functions you specify will be called when the
        promised computation is complete.</p>
        
        <p>Unlike many event listeners, though,
        a Promise represents a single computation, and each function
        registered with <code>then()</code> will be invoked only once. It is worth noting
        that the function you pass to <code>then()</code> is invoked asynchronously, even
        if the asynchronous computation is already complete when you call <code>then()</code>.</p>
        
        <p>At<a data-type="indexterm" data-primary=".then() method" data-primary-sortas="then() method" id="idm46198519087592"></a> a simple syntactical level, the <code>then()</code> method is the distinctive
        feature of Promises, and it is idiomatic to append <code>.then()</code> directly
        to the function invocation that returns the Promise, without the
        intermediate step of assigning the Promise object to a <span class="keep-together">variable.</span></p>
        
        <p>It is
        also idiomatic to name functions that return Promises and functions
        that use the results of Promises with verbs, and these idioms lead to
        code that is particularly easy to read:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Suppose you have a function like this to display a user profile</code>
        <code class="kd">function</code> <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* implementation omitted */</code> <code class="p">}</code>
        
        <code class="c1">// Here's how you might use that function with a Promise.</code>
        <code class="c1">// Notice how this line of code reads almost like an English sentence:</code>
        <code class="nx">getJSON</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayUserProfile</code><code class="p">);</code></pre>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Handling errors with Promises"><div class="sect3" id="async-promises-errors">
        <h3>Handling errors with Promises</h3>
        
        <p>Asynchronous<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="error handling with" id="idm46198519039128"></a><a data-type="indexterm" data-primary="Promises" data-secondary="error handling with" id="idm46198519037880"></a><a data-type="indexterm" data-primary="error handling" data-secondary="using Promises" id="idm46198519036936"></a> operations, particularly those that involve networking,
        can typically fail in a number of ways, and robust code has to be
        written to handle the errors that will inevitably occur.</p>
        
        <p>For Promises,
        we can do this by passing a second function to the <code>then()</code> method:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">getJSON</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayUserProfile</code><code class="p">,</code> <code class="nx">handleProfileError</code><code class="p">);</code></pre>
        
        <p>A Promise represents the future result of an asynchronous computation
        that occurs after the Promise object is created. Because the
        computation is performed after the Promise object is returned to us,
        there is no way that the computation can traditionally return a value
        or throw an exception that we can catch. The functions that we pass to
        <code>then()</code> provide alternatives. When a synchronous computation
        completes normally, it simply returns its result to its caller. When a
        Promise-based asynchronous computation completes normally, it passes
        its result to the function that is the first argument to <code>then()</code>.</p>
        
        <p>When something goes wrong in a synchronous computation, it throws an
        exception that propagates up the call stack until there is a <code>catch</code>
        clause to handle it. When an asynchronous computation runs, its caller
        is no longer on the stack, so if something goes wrong, it is simply
        not possible to throw an exception back to the caller.</p>
        
        <p>Instead,
        Promise-based asynchronous computations pass the exception (typically
        as an Error object of some kind, though this is not required) to the
        second function passed to <code>then()</code>. So, in the code above, if
        <code>getJSON()</code> runs normally, it passes its result to
        <code>displayUserProfile()</code>. If there is an error (the user is not logged
        in, the server is down, the user’s internet connection dropped, the
        request timed out, etc.), then <code>getJSON()</code> passes an Error object to
        <code>handleProfileError()</code>.</p>
        
        <p>In practice, it is rare to see two functions passed to <code>then()</code>. There
        is a better and more idiomatic way of handling errors when working
        with Promises. To understand it, first consider what happens if
        <code>getJSON()</code> completes normally but an error occurs in
        <span class="keep-together"><code>displayUserProfile()</code>.</span> That callback function is invoked
        asynchronously when <code>getJSON()</code> returns, so it is also asynchronous
        and cannot meaningfully throw an exception (because there is no code
        on the call stack to handle it).</p>
        
        <p>The more idiomatic way to handle errors in this code looks like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">getJSON</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayUserProfile</code><code class="p">).</code><code class="k">catch</code><code class="p">(</code><code class="nx">handleProfileError</code><code class="p">);</code></pre>
        
        <p>With this code, a normal result from <code>getJSON()</code> is still passed to
        <code>displayUserProfile()</code>, but any error in <code>getJSON()</code> or in
        <code>displayUserProfile()</code> (including any exceptions thrown by
        <code>displayUserProfile</code>) get passed to <code>handleProfileError()</code>. The
        <code>catch()</code> method is just a shorthand for calling <code>then()</code> with a
        <code>null</code> first argument and the specified error handler function as the
        second argument.</p>
        
        <p>We’ll have more to say about <code>catch()</code> and this error-handling idiom when we discuss Promise chains in the next section.<a data-type="indexterm" data-primary="" data-startref="APpromusing13" id="idm46198518934008"></a><a data-type="indexterm" data-primary="" data-startref="Puse13" id="idm46198518933032"></a><a data-type="indexterm" data-primary="" data-startref="ESpromuse13" id="idm46198518909128"></a></p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="async-promise-terminology">
        <h5>Promise Terminology</h5>
        <p>Before<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="terminology" id="idm46198518906072"></a><a data-type="indexterm" data-primary="Promises" data-secondary="terminology" id="idm46198518904824"></a> we discuss Promises further, it is worth pausing to define some
        terms. When we are not programming and we talk about human promises, we say
        that a promise is “kept” or “broken.” When discussing JavaScript
        Promises, the equivalent terms are “fulfilled” and “rejected.” Imagine
        that you have called the <code>then()</code> method of a Promise and have passed
        two callback functions to it. We say that the promise has been
        <em>fulfilled</em> if and when the first callback is called. And we say that
        the Promise has been <em>rejected</em> if and when the second callback is
        called. If a Promise is neither fulfilled nor rejected, then it is
        <em>pending</em>. And once a promise is fulfilled or rejected, we say that it
        is <em>settled</em>. Note that a Promise can never be both fulfilled <em>and</em>
        rejected. Once a Promise settles, it will never change from fulfilled
        to rejected or vice versa.</p>
        
        <p>Remember how we defined Promises at the start of this section: “a
        Promise is an object that represents the <em>result</em> of an asynchronous
        operation.” It is important to remember that Promises are not just
        abstract ways registering callbacks to run when some async code
        finishes—they represent the results of that async code. If the async
        code runs normally (and the Promise is fulfilled), then that result is
        essentially the return value of the code. And if the async code does
        not complete normally (and the Promise is rejected), then the result is
        an Error object or some other value that the code might have thrown if
        it was not asynchronous. Any Promise that has settled has a value
        associated with it, and that value will not change. If the Promise is
        fulfilled, then the value is a return value that gets passed to any
        callback functions registered as the first argument of <code>then()</code>. If
        the Promise is rejected, then the value is an error of some sort that
        is passed to any callback functions registered with <code>catch()</code> or as
        the second argument of <code>then()</code>.</p>
        
        <p>The reason that I want to be precise about Promise terminology is
        that Promises can also be <em>resolved</em>. It is
        easy to confuse this resolved state with the fulfilled state or with
        settled state, but it is not precisely the same as
        either. Understanding the resolved state is one of the keys to a deep
        understanding of Promises, and I’ll come back to it after we’ve
        discussed Promise chains below.</p>
        </div></aside>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.2.2 Chaining Promises"><div class="sect2" id="async-chaining-promises">
        <h2>13.2.2 Chaining Promises</h2>
        
        <p>One<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="chaining Promises" id="APpromchain13"></a><a data-type="indexterm" data-primary="Promises" data-secondary="chaining Promises" id="Pchain13"></a><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="chaining Promises" id="ESpromchain13"></a><a data-type="indexterm" data-primary="Promise chains" id="pcomchain13"></a> of the most important benefits of Promises is that they provide a
        natural way to express a sequence of asynchronous operations as a
        linear chain of <code>then()</code> method invocations, without having to nest
        each operation within the callback of the previous one. Here, for
        example, is a hypothetical Promise chain:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="nx">documentURL</code><code class="p">)</code>                      <code class="c1">// Make an HTTP request</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">())</code>  <code class="c1">// Ask for the JSON body of the response</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nb">document</code> <code class="o">=&gt;</code> <code class="p">{</code>                 <code class="c1">// When we get the parsed JSON</code>
                <code class="k">return</code> <code class="nx">render</code><code class="p">(</code><code class="nb">document</code><code class="p">);</code>        <code class="c1">// display the document to the user</code>
            <code class="p">})</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">rendered</code> <code class="o">=&gt;</code> <code class="p">{</code>                 <code class="c1">// When we get the rendered document</code>
                <code class="nx">cacheInDatabase</code><code class="p">(</code><code class="nx">rendered</code><code class="p">);</code>      <code class="c1">// cache it in the local database.</code>
            <code class="p">})</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">error</code> <code class="o">=&gt;</code> <code class="nx">handle</code><code class="p">(</code><code class="nx">error</code><code class="p">));</code>     <code class="c1">// Handle any errors that occur</code></pre>
        
        <p>This code illustrates how a chain of Promises can make it easy to
        express a sequence of asynchronous operations. We’re not going to discuss
        this particular Promise chain at all, however. We will continue to explore the idea of using Promise chains to make HTTP requests, however.</p>
        
        <p>Earlier in this chapter, we saw the XMLHttpRequest object used to make
        an HTTP request in JavaScript. That strangely named object has an old
        and awkward API, and it has largely been replaced by the newer,
        Promise-based Fetch API (<a data-type="xref" href="ch15.html#fetch">§15.11.1</a>). In its simplest form, this new
        HTTP API is just the function <code>fetch()</code>. You pass it a URL, and it
        returns a Promise. That promise is fulfilled when the HTTP response
        begins to arrive and the HTTP status and headers are available:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="c1">// When the promise resolves, we have status and headers</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code> <code class="o">&amp;&amp;</code>
                <code class="nx">response</code><code class="p">.</code><code class="nx">headers</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"Content-Type"</code><code class="p">)</code> <code class="o">===</code> <code class="s2">"application/json"</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// What can we do here? We don't actually have the response body yet.</code>
            <code class="p">}</code>
        <code class="p">});</code></pre>
        
        <p>When the Promise returned by <code>fetch()</code> is fulfilled, it passes a
        Response object to the function you passed to its <code>then()</code>
        method. This response object gives you access to request status and
        headers, and it also defines methods like <code>text()</code> and <code>json()</code>, which
        give you access to the body of the response in text and JSON-parsed
        forms, respectively. But although the initial Promise is fulfilled,
        the body of the response may not yet have arrived. So these <code>text()</code>
        and <code>json()</code> methods for accessing the body of the response themselves
        return Promises. Here’s a naive way of using <code>fetch()</code> and the
        <code>response.json()</code> method to get the body of an HTTP response:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">().</code><code class="nx">then</code><code class="p">(</code><code class="nx">profile</code> <code class="o">=&gt;</code> <code class="p">{</code>  <code class="c1">// Ask for the JSON-parsed body</code>
                <code class="c1">// When the body of the response arrives, it will be automatically</code>
                <code class="c1">// parsed as JSON and passed to this function.</code>
                <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">);</code>
            <code class="p">});</code>
        <code class="p">});</code></pre>
        
        <p>This is a naive way to use Promises because we nested them, like
        callbacks, which defeats the purpose. The preferred idiom is
        to use Promises in a sequential chain with code like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">)</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
            <code class="p">})</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">profile</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">);</code>
            <code class="p">});</code></pre>
        
        <p>Let’s look at the method invocations in this code, ignoring the
        arguments that are passed to the methods:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">().</code><code class="nx">then</code><code class="p">().</code><code class="nx">then</code><code class="p">()</code></pre>
        
        <p>When<a data-type="indexterm" data-primary=".then() method" data-primary-sortas="then() method" id="idm46198518579272"></a> more than one method is invoked in a single expression like this,
        we call it a <em>method chain</em>. We know that the <code>fetch()</code> function
        returns a Promise object, and we can see that the first <code>.then()</code> in
        this chain invokes a method on that returned Promise object. But there
        is a second <code>.then()</code> in the chain, which means that the first
        invocation of the <code>then()</code> method must itself return a Promise.</p>
        
        <p>Sometimes, when an API is designed to use this kind of method
        chaining, there is just a single object, and each method of that object
        returns the object itself in order to facilitate chaining. That is not how
        Promises work, however. When we write a chain of <code>.then()</code>
        invocations, we are not registering multiple callbacks on a single
        Promise object. Instead, each invocation of the <code>then()</code> method
        returns a new Promise object. That new Promise object is not fulfilled
        until the function passed to <code>then()</code> is <span class="keep-together">complete.</span></p>
        
        <p>Let’s return to a simplified form of the original <code>fetch()</code> chain
        above. If we define the functions passed to the <code>then()</code> invocations
        elsewhere, we might refactor the code to look like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="nx">theURL</code><code class="p">)</code>          <code class="c1">// task 1; returns promise 1</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">callback1</code><code class="p">)</code>   <code class="c1">// task 2; returns promise 2</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">callback2</code><code class="p">);</code>  <code class="c1">// task 3; returns promise 3</code></pre>
        
        <p>Let’s walk through this code in detail:</p>
        <ol>
        <li>
        <p>On the first line, <code>fetch()</code> is invoked with a URL. It initiates an
        HTTP GET request for that URL and returns a Promise. We’ll call this
        HTTP request “task 1” and we’ll call the Promise “promise 1”.</p>
        </li>
        <li>
        <p>On the second line, we invoke the <code>then()</code> method of promise 1,
        passing the <code>callback1</code> function that we want to be invoked when
        promise 1 is fulfilled. The <code>then()</code> method stores our callback
        somewhere, then returns a new Promise. We’ll call the new Promise
        returned at this step “promise 2”, and we’ll say that “task 2” begins
        when <code>callback1</code> is invoked.</p>
        </li>
        <li>
        <p>On the third line, we invoke the <code>then()</code> method of promise 2,
        passing the <code>callback2</code> function we want invoked when promise 2 is
        fulfilled. This <code>then()</code> method remembers our callback and returns yet
        another Promise. We’ll say that “task 3” begins when <code>callback2</code> is
        invoked. We can call this latest Promise “promise 3”, but we don’t
        really need a name for it because we won’t be using it at all.</p>
        </li>
        <li>
        <p>The previous three steps all happen synchronously when the
        expression is first executed. Now we have an asynchronous pause while
        the HTTP request initiated in step 1 is sent out across the internet.</p>
        </li>
        <li>
        <p>Eventually, the HTTP response starts to arrive. The asynchronous part
        of the <code>fetch()</code> call wraps the HTTP status and headers in a Response
        object and fulfills promise 1 with that Response object as the value.</p>
        </li>
        <li>
        <p>When promise 1 is fulfilled, its value (the Response object) is
        passed to our <code>callback1()</code> function, and task 2
        begins. The job of this task, given a Response object as input, is to
        obtain the response body as a JSON object.</p>
        </li>
        <li>
        <p>Let’s assume that task 2 completes normally and is able to parse the
        body of the HTTP response to produce a JSON object. This JSON object is
        used to fulfill promise 2.</p>
        </li>
        <li>
        <p>The value that fulfills promise 2 becomes the input to task 3 when
        it is passed to the <code>callback2()</code> function. This third task now
        displays the data to the user in some unspecified way. When task 3 is
        complete (assuming it completes normally), then promise 3 will be
        fulfilled. But because we never did anything with promise 3, nothing
        happens when that Promise settles, and the chain of asynchronous
        computation ends at this point.<a data-type="indexterm" data-primary="" data-startref="pcomchain13" id="idm46198518537080"></a><a data-type="indexterm" data-primary="" data-startref="ESpromchain13" id="idm46198518536216"></a><a data-type="indexterm" data-primary="" data-startref="Pchain13" id="idm46198518535272"></a><a data-type="indexterm" data-primary="" data-startref="APpromchain13" id="idm46198518534328"></a></p>
        </li>
        
        </ol>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.2.3 Resolving Promises"><div class="sect2" id="async-resolving-promises">
        <h2>13.2.3 Resolving Promises</h2>
        
        <p>While<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="resolving Promises" id="APpresolv13"></a><a data-type="indexterm" data-primary="Promises" data-secondary="resolving Promises" id="Presolv13"></a><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="resolving Promises" id="ESpromresol13"></a> explaining the URL-fetching Promise chain with the list in the last section,
        we talked about promises 1, 2, and 3. But there is actually a fourth
        Promise object involved as well, and this brings us to our important
        discussion of what it means for a Promise to be “resolved.”</p>
        
        <p>Remember that <code>fetch()</code> returns a Promise object which, when
        fulfilled, passes a Response object to the callback function we
        register. This Response object has <code>.text()</code>, <code>.json()</code>, and other
        methods to request the body of the HTTP response in various forms. But
        since the body may not yet have arrived, these methods must return
        Promise objects. In the example we’ve been studying, “task 2” calls
        the <code>.json()</code> method and returns its value. This is the fourth Promise
        object, and it is the return value of the <code>callback1()</code> function.</p>
        
        <p>Let’s rewrite the URL-fetching code one more time in a verbose and
        nonidiomatic way that makes the callbacks and promises explicit:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">c1</code><code class="p">(</code><code class="nx">response</code><code class="p">)</code> <code class="p">{</code>               <code class="c1">// callback 1</code>
            <code class="kd">let</code> <code class="nx">p4</code> <code class="o">=</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
            <code class="k">return</code> <code class="nx">p4</code><code class="p">;</code>                        <code class="c1">// returns promise 4</code>
        <code class="p">}</code>
        
        <code class="kd">function</code> <code class="nx">c2</code><code class="p">(</code><code class="nx">profile</code><code class="p">)</code> <code class="p">{</code>                <code class="c1">// callback 2</code>
            <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">);</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">p1</code> <code class="o">=</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">);</code>  <code class="c1">// promise 1, task 1</code>
        <code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="nx">p1</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">c1</code><code class="p">);</code>                 <code class="c1">// promise 2, task 2</code>
        <code class="kd">let</code> <code class="nx">p3</code> <code class="o">=</code> <code class="nx">p2</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">c2</code><code class="p">);</code>                 <code class="c1">// promise 3, task 3</code></pre>
        
        <p>In order for Promise chains to work usefully, the output of task 2
        must become the input to task 3. And in the example we’re considering
        here, the input to task 3 is the body of the URL that was fetched,
        parsed as a JSON object. But, as we’ve just discussed, the return
        value of callback <code>c1</code> is not a JSON object, but Promise <code>p4</code> for that
        JSON object. This seems like a contradiction, but it is not: when <code>p1</code>
        is fulfilled, <code>c1</code> is invoked, and task 2 begins. And when <code>p2</code> is
        fulfilled, <code>c2</code> is invoked, and task 3 begins. But just because task 2
        begins when <code>c1</code> is invoked, it does not mean that task 2 must end
        when <code>c1</code> returns. Promises are about managing asynchronous tasks,
        after all, and if task 2 is asynchronous (which it is, in this case),
        then that task will not be complete by the time the callback returns.</p>
        
        <p>We are now ready to discuss the final detail that you need to
        understand to really master Promises. When you pass a callback <code>c</code> to
        the <code>then()</code> method, <code>then()</code> returns a Promise <code>p</code> and arranges to
        asynchronously invoke <code>c</code> at some later time. The callback performs
        some computation and returns a value <code>v</code>. When the callback returns,
        <code>p</code> is <em>resolved</em> with the value <code>v</code>. When a Promise is resolved with
        a value that is not itself a Promise, it is immediately fulfilled with
        that value. So if <code>c</code> returns a non-Promise, that return value becomes
        the value of <code>p</code>, <code>p</code> is fulfilled and we are done. But if the return
        value <code>v</code> is itself a Promise, then <code>p</code> is <em>resolved but not yet
        fulfilled</em>. At this stage, <code>p</code> cannot settle until the Promise <code>v</code> settles. If <code>v</code> is fulfilled, then <code>p</code> will be fulfilled to the same
        value. If <code>v</code> is rejected, then <code>p</code> will be rejected for the same
        reason. This is what the “resolved” state of a Promise means: the
        Promise has become associated with, or “locked onto,” another
        Promise. We don’t know yet whether <code>p</code> will be fulfilled or rejected,
        but our callback <code>c</code> no longer has any control over that. <code>p</code> is
        “resolved” in the sense that its fate now depends entirely on what
        happens to Promise <code>v</code>.</p>
        
        <p>Let’s bring this back to our URL-fetching example. When <code>c1</code> returns
        <code>p4</code>, <code>p2</code> is resolved. But being resolved is not the same as being
        fulfilled, so task 3 does not begin yet. When the full body of the
        HTTP response becomes available, then the <code>.json()</code> method can parse
        it and use that parsed value to fulfill <code>p4</code>. When <code>p4</code> is fulfilled,
        <code>p2</code> is automatically fulfilled as well, with the same parsed JSON
        value. At this point, the parsed JSON object is passed to <code>c2</code>, and
        task 3 begins.</p>
        
        <p>This can be one of the trickiest parts of JavaScript to understand,
        and you may need to read this section more than
        once. <a data-type="xref" href="#promise-chain-diagram">Figure&nbsp;13-1</a> presents the process in visual form
        and may help clarify it for you.</p>
        
        <figure><div id="promise-chain-diagram" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/assets/js7e_1301.png" alt="js7e 1301" width="1291" height="1242">
        <h6><span class="label">Figure 13-1. </span>Fetching a URL with Promises</h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.2.4 More on Promises and Errors"><div class="sect2" id="async-more-promise-errors">
        <h2>13.2.4 More on Promises and Errors</h2>
        
        <p>Earlier<a data-type="indexterm" data-primary="error handling" data-secondary="using Promises" id="idm46198518431224"></a><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="error handling with" id="ESperror13"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="error handling with" id="APperror13"></a><a data-type="indexterm" data-primary="Promises" data-secondary="error handling with" id="Perrorhand13"></a><a data-type="indexterm" data-primary="" data-startref="ESpromresol13" id="idm46198518426008"></a><a data-type="indexterm" data-primary="" data-startref="Presolv13" id="idm46198518425064"></a><a data-type="indexterm" data-primary="" data-startref="APpresolv13" id="idm46198518424120"></a> in the chapter, we saw that you can pass a second callback<a data-type="indexterm" data-primary=".then() method" data-primary-sortas="then() method" id="idm46198518423048"></a> function to the <code>.then()</code> method and that this second function will
        be invoked if the Promise is rejected. When that happens, the argument
        to this second callback function is a value—typically an Error
        object—that represents the reason for the rejection. We also learned
        that it is uncommon (and even unidiomatic) to pass two callbacks to a
        <code>.then()</code> method. Instead, Promise-related errors are typically
        handled by adding a <code>.catch()</code> method invocation to a Promise
        chain. Now that we have examined Promise chains, we can
        return to error handling and discuss it in more detail. To preface the
        discussion, I’d like to stress that careful error handling is really
        important when doing asynchronous programming. With synchronous code,
        if you leave out error-handling code, you’ll at least get an exception
        and a stack trace that you can use to figure out what is going
        wrong. With asynchronous code, unhandled exceptions will often go
        unreported, and errors can occur silently, making them much harder to
        debug. The good news is that the <code>.catch()</code> method makes it easy to
        handle errors when working with Promises.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="The catch and finally methods"><div class="sect3" id="async-promise-catch">
        <h3>The catch and finally methods</h3>
        
        <p>The<a data-type="indexterm" data-primary=".catch() method" data-primary-sortas="catch() method" id="catch13"></a><a data-type="indexterm" data-primary=".finally() method" data-primary-sortas="finally method" id="finally13"></a> <code>.catch()</code> method of a Promise is simply
        a shorthand way to call <code>.then()</code> with <code>null</code> as the first argument
        and an error-handling callback as the second argument. Given any Promise
        <code>p</code> and a callback <code>c</code>, the following two lines are equivalent:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">p</code><code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="nx">c</code><code class="p">);</code>
        <code class="nx">p</code><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">c</code><code class="p">);</code></pre>
        
        <p>The <code>.catch()</code> shorthand is preferred because it is simpler and
        because the name matches the <code>catch</code> clause in a <code>try/catch</code> exception-handling statement. As we’ve discussed, normal exceptions don’t work
        with asynchronous code. The <code>.catch()</code> method of Promises is an
        alternative that does work for asynchronous code. When something goes
        wrong in synchronous code, we can speak of an exception “bubbling up
        the call stack” until it finds a <code>catch</code> block. With an asynchronous
        chain of Promises, the comparable metaphor might be of an error
        “trickling down the chain” until it finds a <code>.catch()</code> invocation.</p>
        
        <p>In<a data-type="indexterm" data-primary="ES2018" data-secondary=".finally() method" data-secondary-sortas="finally() method" id="idm46198518345784"></a> ES2018, Promise objects also define a <code>.finally()</code> method
        whose purpose is similar to the <code>finally</code> clause in a
        <code>try/catch/finally</code> statement. If you add a <code>.finally()</code> invocation to
        your Promise chain, then the callback you pass to <code>.finally()</code> will be
        invoked when the Promise you called it on settles. Your callback will
        be invoked if the Promise fulfills or rejects, and it will not be
        passed any arguments, so you can’t find out whether it fulfilled or
        rejected. But if you need to run some kind of cleanup code (such as
        closing open files or network connections) in either case, a
        <code>.finally()</code> callback is the ideal way to do that. Like <code>.then()</code> and
        <code>.catch()</code>, <code>.finally()</code> returns a new Promise object. The return
        value of a <code>.finally()</code> callback is generally ignored, and the Promise
        returned by <code>.finally()</code> will typically resolve or reject with the
        same value that the Promise that <code>.finally()</code> was invoked on resolves
        or rejects with. If a <code>.finally()</code> callback throws an exception,
        however, then the Promise returned by <code>.finally()</code> will reject with
        that value.</p>
        
        <p>The URL-fetching code that we studied in the previous sections did not do
        any error handling. Let’s correct that now with a more realistic
        version of the code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">)</code>    <code class="c1">// Start the HTTP request</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code>       <code class="c1">// Call this when status and headers are ready</code>
                <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">response</code><code class="p">.</code><code class="nx">ok</code><code class="p">)</code> <code class="p">{</code>   <code class="c1">// If we got a 404 Not Found or similar error</code>
                    <code class="k">return</code> <code class="kc">null</code><code class="p">;</code>      <code class="c1">// Maybe user is logged out; return null profile</code>
                <code class="p">}</code>
        
                <code class="c1">// Now check the headers to ensure that the server sent us JSON.</code>
                <code class="c1">// If not, our server is broken, and this is a serious error!</code>
                <code class="kd">let</code> <code class="nx">type</code> <code class="o">=</code> <code class="nx">response</code><code class="p">.</code><code class="nx">headers</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="s2">"content-type"</code><code class="p">);</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">type</code> <code class="o">!==</code> <code class="s2">"application/json"</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`Expected JSON, got </code><code class="si">${</code><code class="nx">type</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
                <code class="p">}</code>
        
                <code class="c1">// If we get here, then we got a 2xx status and a JSON content-type</code>
                <code class="c1">// so we can confidently return a Promise for the response</code>
                <code class="c1">// body as a JSON object.</code>
                <code class="k">return</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
            <code class="p">})</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">profile</code> <code class="o">=&gt;</code> <code class="p">{</code>        <code class="c1">// Called with the parsed response body or null</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">profile</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">displayUserProfile</code><code class="p">(</code><code class="nx">profile</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">else</code> <code class="p">{</code> <code class="c1">// If we got a 404 error above and returned null we end up here</code>
                    <code class="nx">displayLoggedOutProfilePage</code><code class="p">();</code>
                <code class="p">}</code>
            <code class="p">})</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">e</code> <code class="k">instanceof</code> <code class="nx">NetworkError</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// fetch() can fail this way if the internet connection is down</code>
                    <code class="nx">displayErrorMessage</code><code class="p">(</code><code class="s2">"Check your internet connection."</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">e</code> <code class="k">instanceof</code> <code class="nx">TypeError</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// This happens if we throw TypeError above</code>
                    <code class="nx">displayErrorMessage</code><code class="p">(</code><code class="s2">"Something is wrong with our server!"</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">else</code> <code class="p">{</code>
                    <code class="c1">// This must be some kind of unanticipated error</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">});</code></pre>
        
        <p>Let’s analyze this code by looking at what happens when things go
        wrong. We’ll use the naming scheme we used before: <code>p1</code> is the Promise
        returned by the <code>fetch()</code> call. <code>p2</code> is the Promise returned by the
        first <code>.then()</code> call, and <code>c1</code> is the callback that we pass to that
        <code>.then()</code> call. <code>p3</code> is the Promise returned by the second <code>.then()</code>
        call, and <code>c2</code> is the callback we pass to that call. Finally, <code>c3</code> is
        the callback that we pass to the <code>.catch()</code> call. (That call returns a
        Promise, but we don’t need to refer to it by name.)</p>
        
        <p>The first thing that could fail is the <code>fetch()</code> request itself. If
        the network connection is down (or for some other reason an HTTP
        request cannot be made), then Promise <code>p1</code> will be rejected with a
        NetworkError object. We didn’t pass an error-handling callback
        function as the second argument to the <code>.then()</code> call, so <code>p2</code> rejects
        as well with the same NetworkError object. (If we had passed an error
        handler to that first <code>.then()</code> call, the error handler would be
        invoked, and if it returned normally, <code>p2</code> would be resolved and/or
        fulfilled with the return value from that handler.) Without a handler,
        though, <code>p2</code> is rejected, and then <code>p3</code> is rejected for the same
        reason. At this point, the <code>c3</code> error-handling callback is called, and
        the NetworkError-specific code within it runs.</p>
        
        <p>Another way our code could fail is if our HTTP request returns a 404
        Not Found or another HTTP error. These are valid HTTP responses, so the
        <code>fetch()</code> call does not consider them errors. <code>fetch()</code> encapsulates a
        404 Not Found in a Response object and fulfills <code>p1</code> with that object,
        causing <code>c1</code> to be invoked. Our code in <code>c1</code> checks the <code>ok</code> property
        of the Response object to detect that it has not received a normal
        HTTP response and handles that case by simply returning
        <code>null</code>. Because this return value is not a Promise, it fulfills <code>p2</code>
        right away, and <code>c2</code> is invoked with this value. Our code in <code>c2</code>
        explicitly checks for and handles falsy values by displaying a
        different result to the user. This is a case where we treat an
        abnormal condition as a nonerror and handle it without actually using
        an error handler.</p>
        
        <p>A more serious error occurs in <code>c1</code> if the we get a normal HTTP
        response code but the Content-Type header is not set
        appropriately. Our code expects a JSON-formatted response, so if the
        server is sending us HTML, XML, or plain text instead, we’re going to
        have a problem. <code>c1</code> includes code to check the Content-Type
        header. If the header is wrong, it treats this as a nonrecoverable
        problem and throws a TypeError. When a callback passed to <code>.then()</code>
        (or <code>.catch()</code>) throws a value, the Promise that was the return value
        of the <code>.then()</code> call is rejected with that thrown value. In this
        case, the code in <code>c1</code> that raises a TypeError causes <code>p2</code> to be
        rejected with that TypeError object. Since we did not specify an error
        handler for <code>p2</code>, <code>p3</code> will be rejected as well. <code>c2</code> will
        not be called, and the TypeError will be passed to <code>c3</code>, which has code
        to explicitly check for and handle this type of error.</p>
        
        <p>There are a couple of things worth noting about this code. First,
        notice that the error object thrown with a regular, synchronous
        <code>throw</code> statement ends up being handled asynchronously with a
        <code>.catch()</code> method invocation in a Promise chain. This should make it
        clear why this shorthand method is preferred over passing a second
        argument to <code>.then()</code>, and also why it is so idiomatic to end Promise
        chains with a <code>.catch()</code> call.</p>
        
        <p>Before we leave the topic of error handling, I want to point out that, although it is idiomatic to end every Promise chain with a <code>.catch()</code>
        to clean up (or at least log) any errors that occurred in the chain,
        it is also perfectly valid to use <code>.catch()</code> elsewhere in a Promise
        chain. If one of the stages in your Promise chain can fail with an
        error, and if the error is some kind of recoverable error that should
        not stop the rest of the chain from running, then you can insert a
        <code>.catch()</code> call in the chain, resulting in code that might look like
        this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">startAsyncOperation</code><code class="p">()</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">doStageTwo</code><code class="p">)</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">recoverFromStageTwoError</code><code class="p">)</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">doStageThree</code><code class="p">)</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">doStageFour</code><code class="p">)</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">logStageThreeAndFourErrors</code><code class="p">);</code></pre>
        
        <p>Remember that the callback you pass to <code>.catch()</code> will only be invoked
        if the callback at a previous stage throws an error. If the callback
        returns normally, then the <code>.catch()</code> callback will be skipped, and the
        return value of the previous callback will become the input to the
        next <code>.then()</code> callback. Also remember that <code>.catch()</code> callbacks are
        not just for reporting errors, but for handling and recovering from
        errors. Once an error has been passed to a <code>.catch()</code> callback, it
        stops propagating down the Promise chain. A <code>.catch()</code> callback can
        throw a new error, but if it returns normally, than that return value
        is used to resolve and/or fulfill the associated Promise, and the error
        stops propagating.</p>
        
        <p>Let’s be concrete about this: in the preceding code example, if
        either <code>startAsyncOperation()</code> or <code>doStageTwo()</code> throws an error, then the
        <code>recoverFromStageTwoError()</code> function will be invoked. If
        <code>recoverFromStageTwoError()</code> returns normally, then its return value
        will be passed to <code>doStageThree()</code> and the asynchronous operation
        continues normally. On the other hand, if <code>recoverFromStageTwoError()</code>
        was unable to recover, it will itself throw an error (or it will
        rethrow the error that it was passed). In this case, neither
        <code>doStageThree()</code> nor <code>doStageFour()</code> will be invoked, and the error
        thrown by <code>recoverFromStageTwoError()</code> would be passed to
        <code>logStageThreeAndFourErrors()</code>.</p>
        
        <p>Sometimes, in complex network environments, errors can occur more or
        less at random, and it can be appropriate to handle those errors by
        simply retrying the asynchronous request. Imagine you’ve written a
        Promise-based operation to query a database:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">queryDatabase</code><code class="p">()</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayTable</code><code class="p">)</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">displayDatabaseError</code><code class="p">);</code></pre>
        
        <p>Now suppose that transient network load issues are causing this to
        fail about 1% of the time. A simple solution might be to retry the
        query with a <code>.catch()</code> call:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">queryDatabase</code><code class="p">()</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">wait</code><code class="p">(</code><code class="mi">500</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">queryDatabase</code><code class="p">))</code>  <code class="c1">// On failure, wait and retry</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayTable</code><code class="p">)</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">displayDatabaseError</code><code class="p">);</code></pre>
        
        <p>If the hypothetical failures are truly random, then adding this one
        line of code should reduce your error rate from 1% to .01%.<a data-type="indexterm" data-primary="" data-startref="finally13" id="idm46198518061336"></a><a data-type="indexterm" data-primary="" data-startref="catch13" id="idm46198518060488"></a><a data-type="indexterm" data-primary="" data-startref="ESperror13" id="idm46198517971288"></a><a data-type="indexterm" data-primary="" data-startref="APperror13" id="idm46198517970344"></a><a data-type="indexterm" data-primary="" data-startref="Perrorhand13" id="idm46198517969400"></a></p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="async-promise-return">
        <h5>Returning from a Promise Callback</h5>
        <p>Let’s<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="returning from Promise callbacks" id="idm46198517966552"></a><a data-type="indexterm" data-primary="Promises" data-secondary="returning from Promise callbacks" id="idm46198517964952"></a><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="returning from Promise callbacks" id="idm46198517964040"></a> return one last time to the earlier URL-fetching example, and
        consider the <code>c1</code> callback that we passed to the first <code>.then()</code>
        invocation. Notice that there are three ways that <code>c1</code> can
        terminate. It can return normally with the Promise returned by the
        <code>.json()</code> call. This causes <code>p2</code> to be resolved, but whether that
        Promise is fulfilled or rejected depends on what happens with the
        newly returned Promise. <code>c1</code> can also return normally with the value
        <code>null</code>, which causes <code>p2</code> to be fulfilled immediately. Finally, <code>c1</code> can
        terminate by throwing an error, which causes <code>p2</code> to be
        rejected. These are the three possible outcomes for a Promise, and the
        code in <code>c1</code> demonstrates how the callback can cause each outcome.</p>
        
        <p>In a Promise chain, the value returned (or thrown) at one stage of the
        chain becomes the input to the next stage of the chain, so it is
        critical to get this right. In practice, forgetting to return a value
        from a callback function is actually a common source of
        Promise-related bugs, and this is exacerbated by JavaScript’s arrow
        function shortcut syntax. Consider this line of code that we saw earlier:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">wait</code><code class="p">(</code><code class="mi">500</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">queryDatabase</code><code class="p">))</code></pre>
        
        <p>Recall from <a data-type="xref" href="ch08.html#functions">Chapter&nbsp;8</a> that arrow functions allow a lot of
        shortcuts. Since there is exactly one argument (the error value), we
        can omit the parentheses. Since the body of the function is a single
        expression, we can omit the curly braces around the function body, and
        the value of the expression becomes the return value of the
        function. Because of these shortcuts, the preceding code is correct. But
        consider this innocuous-seeming change:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">wait</code><code class="p">(</code><code class="mi">500</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">queryDatabase</code><code class="p">)</code> <code class="p">})</code></pre>
        
        <p>By adding the curly braces, we no longer get the automatic return. This
        function now returns <code>undefined</code> instead of returning a Promise, which
        means that the next stage in this Promise chain will be invoked with
        <code>undefined</code> as its input rather than the result of the retried
        query. It is a subtle error that may not be easy to debug.</p>
        </div></aside>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.2.5 Promises in Parallel"><div class="sect2" id="async-promises-parallel">
        <h2>13.2.5 Promises in Parallel</h2>
        
        <p>We’ve<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="parallel operations" id="idm46198517901544"></a><a data-type="indexterm" data-primary="Promises" data-secondary="parallel operations" id="idm46198517900296"></a><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="parallel operations" id="idm46198517899352"></a> spent a lot of time talking about Promise chains for
        sequentially running the asynchronous steps of a larger asynchronous
        operation. Sometimes, though, we want to execute a number of
        asynchronous operations in parallel. The<a data-type="indexterm" data-primary="Promise.all() function" id="idm46198517897768"></a> function <code>Promise.all()</code> can
        do this. <code>Promise.all()</code> takes an array of Promise objects as its
        input and returns a Promise. The returned Promise will be rejected if
        any of the input Promises are rejected. Otherwise, it will be
        fulfilled with an array of the fulfillment values of each of the input
        Promises. So, for example, if you want to fetch the text content of
        multiple URLs, you could use code like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// We start with an array of URLs</code>
        <code class="kr">const</code> <code class="nx">urls</code> <code class="o">=</code> <code class="p">[</code> <code class="cm">/* zero or more URLs here */</code> <code class="p">];</code>
        <code class="c1">// And convert it to an array of Promise objects</code>
        <code class="nx">promises</code> <code class="o">=</code> <code class="nx">urls</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">url</code> <code class="o">=&gt;</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">.</code><code class="nx">text</code><code class="p">()));</code>
        <code class="c1">// Now get a Promise to run all those Promises in parallel</code>
        <code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">(</code><code class="nx">promises</code><code class="p">)</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">bodies</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* do something with the array of strings */</code> <code class="p">})</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">));</code></pre>
        
        <p><code>Promise.all()</code> is slightly more flexible than described before. The
        input array can contain both Promise objects and non-Promise
        values. If an element of the array is not a Promise, it is treated as
        if it is the value of an already fulfilled Promise and is simply
        copied unchanged into the output array.</p>
        
        <p>The Promise returned by <code>Promise.all()</code> rejects when any of the
        input Promises is rejected. This happens immediately upon the first
        rejection and can happen while other input Promises are still
        pending. In<a data-type="indexterm" data-primary="ES2020" data-secondary="Promise.allSettled()" id="idm46198517785240"></a> ES2020, <code>Promise.allSettled()</code> takes an array of input
        Promises and returns a Promise, just like <code>Promise.all()</code> does. But
        <code>Promise.allSettled()</code> never rejects the returned Promise, and it does
        not fulfill that Promise until all of the input Promises have
        settled. The Promise resolves to an array of objects, with one object
        for each input Promise. Each of these returned objects has a <code>status</code>
        property set to “fulfilled” or “rejected.” If the status is
        “fulfilled”, then the object will also have a <code>value</code> property that
        gives the fulfillment value. And if the status is “rejected”, then the
        object will also have a <code>reason</code> property that gives the error or
        rejection value of the corresponding Promise:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Promise</code><code class="p">.</code><code class="nx">allSettled</code><code class="p">([</code><code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="mi">1</code><code class="p">),</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">reject</code><code class="p">(</code><code class="mi">2</code><code class="p">),</code> <code class="mi">3</code><code class="p">]).</code><code class="nx">then</code><code class="p">(</code><code class="nx">results</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="nx">results</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>  <code class="c1">// =&gt; { status: "fulfilled", value: 1 }</code>
            <code class="nx">results</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>  <code class="c1">// =&gt; { status: "rejected", reason: 2 }</code>
            <code class="nx">results</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code>  <code class="c1">// =&gt; { status: "fulfilled", value: 3 }</code>
        <code class="p">});</code></pre>
        
        <p>Occasionally, you may want to run a number of Promises at once but may
        only care about the value of the first one to fulfill. In that case,
        you can use <code>Promise.race()</code> instead of <code>Promise.all()</code>. It returns a
        Promise that is fulfilled or rejected when the first of the Promises
        in the input array is fulfilled or rejected. (Or, if there are any
        non-Promise values in the input array, it simply returns the first of
        those.)</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.2.6 Making Promises"><div class="sect2" id="async-making-promises">
        <h2>13.2.6 Making Promises</h2>
        
        <p>We’ve<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="making Promises" id="APpmaking13"></a><a data-type="indexterm" data-primary="Promises" data-secondary="making Promises" id="Pmake13"></a><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="making Promises" id="ESPmake13"></a> used the Promise-returning function <code>fetch()</code> in many of the
        previous examples because it is one of the simplest functions built in to web
        browsers that returns a Promise. Our discussion of Promises has also
        relied on hypothetical Promise-returning functions <code>getJSON()</code> and
        <code>wait()</code>. Functions written to return Promises really are quite
        useful, and this section shows how you can create your own
        Promise-based APIs. In particular, we’ll show implementations of
        <code>getJSON()</code> and <code>wait()</code>.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Promises based on other Promises"><div class="sect3" id="idm46198517693784">
        <h3>Promises based on other Promises</h3>
        
        <p>It<a data-type="indexterm" data-primary="Promises" data-secondary="making Promises" data-tertiary="based on other Promises" id="idm46198517692168"></a> is easy to write a function that returns a Promise if you have some
        other Promise-returning function to start with. Given a Promise, you
        can always create (and return) a new one by calling <code>.then()</code>. So if
        we use the existing <code>fetch()</code> function as a starting point, we can
        write <code>getJSON()</code> like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">());</code>
        <code class="p">}</code></pre>
        
        <p>The code is trivial because the Response object of the <code>fetch()</code> API
        has a predefined <code>json()</code> method. The <code>json()</code> method returns a
        Promise, which we return from our callback (the callback is an arrow
        function with a single-expression body, so the return is implicit), so
        the Promise returned by <code>getJSON()</code> resolves to the Promise returned
        by <code>response.json()</code>. When that Promise fulfills, the Promise
        returned by <code>getJSON()</code> fulfills to the same value. Note that there is
        no error handling in this <code>getJSON()</code> implementation. Instead of
        checking <code>response.ok</code> and the Content-Type header, we instead just
        allow the <code>json()</code> method to reject the Promise it returned with a
        SyntaxError if the response body cannot be parsed as JSON.</p>
        
        <p>Let’s write another Promise-returning function, this time using
        <code>getJSON()</code> as the source of the initial Promise:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">getHighScore</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">getJSON</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">profile</code> <code class="o">=&gt;</code> <code class="nx">profile</code><code class="p">.</code><code class="nx">highScore</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>We’re assuming that this function is part of some sort of web-based
        game and that the URL “/api/user/profile” returns a JSON-formatted
        data structure that includes a <code>highScore</code> property.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Promises based on synchronous values"><div class="sect3" id="idm46198517631560">
        <h3>Promises based on synchronous values</h3>
        
        <p>Sometimes, you<a data-type="indexterm" data-primary="Promises" data-secondary="making Promises" data-tertiary="based on synchronous values" id="idm46198517630248"></a> may need to implement an existing Promise-based API and
        return a Promise from a function, even though the computation
        to be performed does not actually require any asynchronous
        operations. In that case, the static methods <code>Promise.resolve()</code> and
        <code>Promise.reject()</code> will do what you want. <code>Promise.resolve()</code> takes a
        value as its single argument and returns a Promise that will
        immediately (but asynchronously) be fulfilled to that
        value. Similarly, <code>Promise.reject()</code> takes a single argument and
        returns a Promise that will be rejected with that value as the
        reason. (To be clear: the Promises returned by these static methods
        are not already fulfilled or rejected when they are returned, but they
        will fulfill or reject immediately after the current synchronous chunk
        of code has finished running. Typically, this happens within a few
        milliseconds unless there are many pending asynchronous tasks waiting
        to run.)</p>
        
        <p>Recall from <a data-type="xref" href="#async-resolving-promises">§13.2.3</a> that a resolved Promise is
        not the same thing as a fulfilled Promise. When we call
        <code>Promise.resolve()</code>, we typically pass the fulfillment value to create
        a Promise object that will very soon fulfill to that value. The method
        is not named <code>Promise.fulfill()</code>, however. If you pass a Promise <code>p1</code>
        to <code>Promise.resolve()</code>, it will return a new Promise <code>p2</code>, which is
        immediately resolved, but which will not be fulfilled or rejected
        until <code>p1</code> is fulfilled or rejected.</p>
        
        <p>It is possible, but unusual, to write a Promise-based function where
        the value is computed synchronously and returned asynchronously with
        <code>Promise.resolve()</code>. It is fairly common, however, to have synchronous
        special cases within an asynchronous function, and you can handle
        these special cases with <code>Promise.resolve()</code> and
        <code>Promise.reject()</code>. In particular, if you detect error conditions
        (such as bad argument values) before beginning an asynchronous
        operation, you can report that error by returning a Promise created
        with <code>Promise.reject()</code>. (You could also just throw an error
        synchronously in that case, but that is considered poor form because
        then the caller of your function needs to write both a synchronous
        <code>catch</code> clause and use an asynchronous <code>.catch()</code> method to handle errors.)
        Finally, <code>Promise.resolve()</code> is sometimes useful to create the initial
        Promise in a chain of Promises. We’ll see a couple of examples
        that use it this way.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Promises from scratch"><div class="sect3" id="async-promises-from-scratch">
        <h3>Promises from scratch</h3>
        
        <p>For<a data-type="indexterm" data-primary="Promises" data-secondary="making Promises" data-tertiary="from scratch" id="idm46198517589352"></a> both <code>getJSON()</code> and <code>getHighScore()</code>, we started off by calling
        an existing function to get an initial Promise, and created and
        returned a new Promise by calling the <code>.then()</code> method of that initial
        Promise. But what about writing a Promise-returning function when you
        can’t use another Promise-returning function as the starting point? In
        that case, you use the <code>Promise()</code> constructor to create a new Promise
        object that you have complete control over. Here’s how it works: you
        invoke the <code>Promise()</code> constructor and pass a function as its only
        argument. The function you pass should be written to expect two
        parameters, which, by convention, should be named <code>resolve</code> and
        <code>reject</code>. The constructor synchronously calls your function with
        function arguments for the <code>resolve</code> and <code>reject</code> parameters. After
        calling your function, the <code>Promise()</code> constructor returns the newly
        created Promise. That returned Promise is under the control of the
        function you passed to the constructor. That function should perform
        some asynchronous operation and then call the <code>resolve</code> function to
        resolve or fulfill the returned Promise or call the <code>reject</code> function
        to reject the returned Promise. Your function does not have to be
        asynchronous: it can call <code>resolve</code> or <code>reject</code> synchronously, but the
        Promise will still be resolved, fulfilled, or rejected asynchronously if
        you do this.</p>
        
        <p>It can be hard to understand the functions passed to a function passed
        to a constructor by just reading about it, but hopefully some examples
        will make this clear. Here’s how to write the Promise-based <code>wait()</code>
        function that we used in various examples earlier in the chapter:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">wait</code><code class="p">(</code><code class="nx">duration</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Create and return a new Promise</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c1">// These control the Promise</code>
                <code class="c1">// If the argument is invalid, reject the Promise</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">duration</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Time travel not yet implemented"</code><code class="p">));</code>
                <code class="p">}</code>
                <code class="c1">// Otherwise, wait asynchronously and then resolve the Promise.</code>
                <code class="c1">// setTimeout will invoke resolve() with no arguments, which means</code>
                <code class="c1">// that the Promise will fulfill with the undefined value.</code>
                <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">duration</code><code class="p">);</code>
            <code class="p">});</code>
        <code class="p">}</code></pre>
        
        <p>Note that the pair of functions that you use to control the fate of a
        Promise created with the <code>Promise()</code> constructor are named <code>resolve()</code>
        and <code>reject()</code>, not <code>fulfill()</code> and <code>reject()</code>. If you pass a Promise
        to <code>resolve()</code>, the returned Promise will resolve to that new
        Promise. Often, however, you will pass a non-Promise value,
        which fulfills the returned Promise with that value.</p>
        
        <p><a data-type="xref" href="#getJSON-js">Example&nbsp;13-1</a> is another example of using the <code>Promise()</code> constructor. This one
        implements our <code>getJSON()</code> function for use in Node, where the
        <code>fetch()</code> API is not built in. Remember that we started this chapter
        with a discussion of asynchronous callbacks and events. This example
        uses both callbacks and event handlers and is a good demonstration,
        therefore, of how we can implement Promise-based APIs on top of other
        styles of asynchronous programming.</p>
        <div id="getJSON-js" data-type="example">
        <h5><span class="label">Example 13-1. </span>An asynchronous getJSON() function</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">http</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"http"</code><code class="p">);</code>
        
        <code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Create and return a new Promise</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="c1">// Start an HTTP GET request for the specified URL</code>
                <code class="nx">request</code> <code class="o">=</code> <code class="nx">http</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">response</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="c1">// called when response starts</code>
                    <code class="c1">// Reject the Promise if the HTTP status is wrong</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusCode</code> <code class="o">!==</code> <code class="mi">200</code><code class="p">)</code> <code class="p">{</code>
                        <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="sb">`HTTP status </code><code class="si">${</code><code class="nx">response</code><code class="p">.</code><code class="nx">statusCode</code><code class="si">}</code><code class="sb">`</code><code class="p">));</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">resume</code><code class="p">();</code>  <code class="c1">// so we don't leak memory</code>
                    <code class="p">}</code>
                    <code class="c1">// And reject if the response headers are wrong</code>
                    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">response</code><code class="p">.</code><code class="nx">headers</code><code class="p">[</code><code class="s2">"content-type"</code><code class="p">]</code> <code class="o">!==</code> <code class="s2">"application/json"</code><code class="p">)</code> <code class="p">{</code>
                        <code class="nx">reject</code><code class="p">(</code><code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Invalid content-type"</code><code class="p">));</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">resume</code><code class="p">();</code>  <code class="c1">// don't leak memory</code>
                    <code class="p">}</code>
                    <code class="k">else</code> <code class="p">{</code>
                        <code class="c1">// Otherwise, register events to read the body of the response</code>
                        <code class="kd">let</code> <code class="nx">body</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">setEncoding</code><code class="p">(</code><code class="s2">"utf-8"</code><code class="p">);</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"data"</code><code class="p">,</code> <code class="nx">chunk</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">body</code> <code class="o">+=</code> <code class="nx">chunk</code><code class="p">;</code> <code class="p">});</code>
                        <code class="nx">response</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"end"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
                            <code class="c1">// When the response body is complete, try to parse it</code>
                            <code class="k">try</code> <code class="p">{</code>
                                <code class="kd">let</code> <code class="nx">parsed</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">body</code><code class="p">);</code>
                                <code class="c1">// If it parsed successfully, fulfill the Promise</code>
                                <code class="nx">resolve</code><code class="p">(</code><code class="nx">parsed</code><code class="p">);</code>
                            <code class="p">}</code> <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
                                <code class="c1">// If parsing failed, reject the Promise</code>
                                <code class="nx">reject</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
                            <code class="p">}</code>
                        <code class="p">});</code>
                    <code class="p">}</code>
                <code class="p">});</code>
                <code class="c1">// We also reject the Promise if the request fails before we</code>
                <code class="c1">// even get a response (such as when the network is down)</code>
                <code class="nx">request</code><code class="p">.</code><code class="nx">on</code><code class="p">(</code><code class="s2">"error"</code><code class="p">,</code> <code class="nx">error</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="nx">reject</code><code class="p">(</code><code class="nx">error</code><code class="p">);</code>
                <code class="p">});</code>
            <code class="p">});</code>
        <code class="p">}</code></pre></div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.2.7 Promises in Sequence"><div class="sect2" id="async-promises-sequence">
        <h2>13.2.7 Promises in Sequence</h2>
        
        <p><code>Promise.all()</code> makes<a data-type="indexterm" data-primary="" data-startref="APpmaking13" id="idm46198517497304"></a><a data-type="indexterm" data-primary="" data-startref="Pmake13" id="idm46198517235352"></a><a data-type="indexterm" data-primary="" data-startref="ESPmake13" id="idm46198517234408"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="Promises" data-tertiary="Promises in sequence" id="APpseq13"></a><a data-type="indexterm" data-primary="Promises" data-secondary="Promises in sequence" id="Pseq13"></a><a data-type="indexterm" data-primary="ES6" data-secondary="Promises" data-tertiary="Promises in sequence" id="ESpseq13"></a> it easy to run an arbitrary number of Promises
        in parallel. And Promise chains make it easy to express a sequence of a
        fixed number of Promises. Running an arbitrary number of Promises in
        sequence is trickier, however. Suppose, for example, that you have an
        array of URLs to fetch, but that to avoid overloading your network,
        you want to fetch them one at a time. If the array is of arbitrary
        length and unknown content, you can’t write out a Promise chain in
        advance, so you need to build one dynamically, with code like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">fetchSequentially</code><code class="p">(</code><code class="nx">urls</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// We'll store the URL bodies here as we fetch them</code>
            <code class="kr">const</code> <code class="nx">bodies</code> <code class="o">=</code> <code class="p">[];</code>
        
            <code class="c1">// Here's a Promise-returning function that fetches one body</code>
            <code class="kd">function</code> <code class="nx">fetchOne</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code>
                    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">response</code> <code class="o">=&gt;</code> <code class="nx">response</code><code class="p">.</code><code class="nx">text</code><code class="p">())</code>
                    <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">body</code> <code class="o">=&gt;</code> <code class="p">{</code>
                        <code class="c1">// We save the body to the array, and we're purposely</code>
                        <code class="c1">// omitting a return value here (returning undefined)</code>
                        <code class="nx">bodies</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">body</code><code class="p">);</code>
                    <code class="p">});</code>
            <code class="p">}</code>
        
            <code class="c1">// Start with a Promise that will fulfill right away (with value undefined)</code>
            <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="kc">undefined</code><code class="p">);</code>
        
            <code class="c1">// Now loop through the desired URLs, building a Promise chain</code>
            <code class="c1">// of arbitrary length, fetching one URL at each stage of the chain</code>
            <code class="k">for</code><code class="p">(</code><code class="nx">url</code> <code class="k">of</code> <code class="nx">urls</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">p</code> <code class="o">=</code> <code class="nx">p</code><code class="p">.</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">fetchOne</code><code class="p">(</code><code class="nx">url</code><code class="p">));</code>
            <code class="p">}</code>
        
            <code class="c1">// When the last Promise in that chain is fulfilled, then the</code>
            <code class="c1">// bodies array is ready. So let's return a Promise for that</code>
            <code class="c1">// bodies array. Note that we don't include any error handlers:</code>
            <code class="c1">// we want to allow errors to propagate to the caller.</code>
            <code class="k">return</code> <code class="nx">p</code><code class="p">.</code><code class="nx">then</code><code class="p">(()</code> <code class="o">=&gt;</code> <code class="nx">bodies</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>With this <code>fetchSequentially()</code> function defined, we could fetch the
        URLs one at a time with code much like the fetch-in-parallel code we
        used earlier to demonstrate <code>Promise.all()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">fetchSequentially</code><code class="p">(</code><code class="nx">urls</code><code class="p">)</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">bodies</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* do something with the array of strings */</code> <code class="p">})</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">e</code> <code class="o">=&gt;</code> <code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">(</code><code class="nx">e</code><code class="p">));</code></pre>
        
        <p>The <code>fetchSequentially()</code> function starts by creating a Promise that
        will fulfill immediately after it returns. It then builds a long,
        linear Promise chain off of that initial Promise and returns the last
        Promise in the chain. It is like setting up a row of dominoes and then
        knocking the first one over.</p>
        
        <p>There is another (possibly more elegant) approach that we can
        take. Rather than creating the Promises in advance, we can have the
        callback for each Promise create and return the next Promise. That is,
        instead of creating and chaining a bunch of Promises, we instead
        create Promises that resolve to other Promises. Rather than creating a
        domino-like chain of Promises, we are instead creating a sequence of
        Promises nested one inside the other like a set of matryoshka
        dolls. With this approach, our code can return the first (outermost)
        Promise, knowing that it will eventually fulfill (or reject!) to the
        same value that the last (innermost) Promise in the sequence does. The
        <code>promiseSequence()</code> function that follows is written to be generic and is not
        specific to URL fetching. It is here at the end of our discussion of
        Promises because it is complicated. If you’ve read this chapter
        carefully, however, I hope you’ll be able to understand how it
        works. In particular, note that the nested function inside
        <code>promiseSequence()</code> appears to call itself recursively, but because
        the “recursive” call is through a <code>then()</code> method, there is not
        actually any traditional recursion happening:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This function takes an array of input values and a "promiseMaker" function.</code>
        <code class="c1">// For any input value x in the array, promiseMaker(x) should return a Promise</code>
        <code class="c1">// that will fulfill to an output value. This function returns a Promise</code>
        <code class="c1">// that fulfills to an array of the computed output values.</code>
        <code class="c1">//</code>
        <code class="c1">// Rather than creating the Promises all at once and letting them run in</code>
        <code class="c1">// parallel, however, promiseSequence() only runs one Promise at a time</code>
        <code class="c1">// and does not call promiseMaker() for a value until the previous Promise</code>
        <code class="c1">// has fulfilled.</code>
        <code class="kd">function</code> <code class="nx">promiseSequence</code><code class="p">(</code><code class="nx">inputs</code><code class="p">,</code> <code class="nx">promiseMaker</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Make a private copy of the array that we can modify</code>
            <code class="nx">inputs</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">inputs</code><code class="p">];</code>
        
            <code class="c1">// Here's the function that we'll use as a Promise callback</code>
            <code class="c1">// This is the pseudorecursive magic that makes this all work.</code>
            <code class="kd">function</code> <code class="nx">handleNextInput</code><code class="p">(</code><code class="nx">outputs</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">inputs</code><code class="p">.</code><code class="nx">length</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// If there are no more inputs left, then return the array</code>
                    <code class="c1">// of outputs, finally fulfilling this Promise and all the</code>
                    <code class="c1">// previous resolved-but-not-fulfilled Promises.</code>
                    <code class="k">return</code> <code class="nx">outputs</code><code class="p">;</code>
                <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                    <code class="c1">// If there are still input values to process, then we'll</code>
                    <code class="c1">// return a Promise object, resolving the current Promise</code>
                    <code class="c1">// with the future value from a new Promise.</code>
                    <code class="kd">let</code> <code class="nx">nextInput</code> <code class="o">=</code> <code class="nx">inputs</code><code class="p">.</code><code class="nx">shift</code><code class="p">();</code> <code class="c1">// Get the next input value,</code>
                    <code class="k">return</code> <code class="nx">promiseMaker</code><code class="p">(</code><code class="nx">nextInput</code><code class="p">)</code>  <code class="c1">// compute the next output value,</code>
                        <code class="c1">// Then create a new outputs array with the new output value</code>
                        <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">output</code> <code class="o">=&gt;</code> <code class="nx">outputs</code><code class="p">.</code><code class="nx">concat</code><code class="p">(</code><code class="nx">output</code><code class="p">))</code>
                        <code class="c1">// Then "recurse", passing the new, longer, outputs array</code>
                        <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">handleNextInput</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="c1">// Start with a Promise that fulfills to an empty array and use</code>
            <code class="c1">// the function above as its callback.</code>
            <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">([]).</code><code class="nx">then</code><code class="p">(</code><code class="nx">handleNextInput</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>This <code>promiseSequence()</code> function is intentionally generic. We can use
        it to fetch URLs with code<a data-type="indexterm" data-primary="" data-startref="ESpseq13" id="idm46198517175480"></a><a data-type="indexterm" data-primary="" data-startref="Pseq13" id="idm46198516865800"></a><a data-type="indexterm" data-primary="" data-startref="APpseq13" id="idm46198516864856"></a> like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Given a URL, return a Promise that fulfills to the URL body text</code>
        <code class="kd">function</code> <code class="nx">fetchBody</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">r</code> <code class="o">=&gt;</code> <code class="nx">r</code><code class="p">.</code><code class="nx">text</code><code class="p">());</code> <code class="p">}</code>
        <code class="c1">// Use it to sequentially fetch a bunch of URL bodies</code>
        <code class="nx">promiseSequence</code><code class="p">(</code><code class="nx">urls</code><code class="p">,</code> <code class="nx">fetchBody</code><code class="p">)</code>
            <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">bodies</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="cm">/* do something with the array of strings */</code> <code class="p">})</code>
            <code class="p">.</code><code class="k">catch</code><code class="p">(</code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">);</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="13.3 async and await"><div class="sect1" id="async-await">
        <h1>13.3 async and await</h1>
        
        <p>ES2017<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="async and await keywords" id="APasync13"></a><a data-type="indexterm" data-primary="async keyword" id="async13"></a><a data-type="indexterm" data-primary="await keyword" id="await13"></a><a data-type="indexterm" data-primary="keywords" data-secondary="async keyword" id="Kasync13"></a><a data-type="indexterm" data-primary="keywords" data-secondary="await keyword" id="Kawait13"></a><a data-type="indexterm" data-primary="ES2017, async and await keywords" id="ESasync13"></a> introduces two new keywords—<code>async</code> and <code>await</code>—that
        represent a paradigm shift in asynchronous JavaScript
        programming. These new keywords dramatically simplify the use of
        Promises and allow us to write Promise-based, asynchronous code that
        looks like synchronous code that blocks while waiting for network
        responses or other asynchronous events. Although it is still important
        to understand how <span class="keep-together">Promises</span> work, much of their complexity (and
        sometimes even their very presence!) vanishes when you use them with
        <code>async</code> and <code>await</code>.</p>
        
        <p>As we discussed earlier in the chapter, asynchronous code can’t
        return a value or throw an exception the way that regular synchronous
        code can. And this is why Promises are designed the way the are. The
        value of a fulfilled Promise is like the return value of a synchronous
        function. And the value of a rejected Promise is like a value thrown
        by a synchronous function. This latter similarity is made explicit by
        the naming of the <code>.catch()</code> method. <code>async</code> and <code>await</code> take
        efficient, Promise-based code and hide the Promises so that your
        asynchronous code can be as easy to read and as easy to reason about
        as inefficient, blocking, synchronous code.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.3.1 await Expressions"><div class="sect2" id="async-await-expressions">
        <h2>13.3.1 await Expressions</h2>
        
        <p>The <code>await</code> keyword takes a Promise and turns it back into a return
        value or a thrown exception. Given a Promise object <code>p</code>, the
        expression <code>await p</code> waits until <code>p</code> settles. If <code>p</code> fulfills, then
        the value of <code>await p</code> is the fulfillment value of <code>p</code>. On the other
        hand, if <code>p</code> is rejected, then the <code>await p</code> expression throws the
        rejection value of <code>p</code>. We don’t usually use <code>await</code> with a variable
        that holds a Promise; instead, we use it before the invocation of a
        function that returns a Promise:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">profile</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code></pre>
        
        <p>It is critical to understand right away that the <code>await</code> keyword does
        not cause your program to block and literally do nothing until the
        specified Promise settles. The code remains asynchronous, and the
        <code>await</code> simply disguises this fact. This means that <em>any code that uses</em>
        <code>await</code> <em>is itself asynchronous</em>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.3.2 async Functions"><div class="sect2" id="async-async-functions">
        <h2>13.3.2 async Functions</h2>
        
        <p>Because any code that uses <code>await</code> is asynchronous, there is one
        critical rule: <em>you can only use the <code>await</code> keyword within functions
        that have been declared with the <code>async</code> keyword</em>. Here’s a version of
        the <code>getHighScore()</code> function from earlier in the chapter, rewritten
        to use <code>async</code> and <code>await</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">async</code> <code class="kd">function</code> <code class="nx">getHighScore</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="s2">"/api/user/profile"</code><code class="p">);</code>
            <code class="kd">let</code> <code class="nx">profile</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
            <code class="k">return</code> <code class="nx">profile</code><code class="p">.</code><code class="nx">highScore</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>Declaring a function <code>async</code> means that the return value of the
        function will be a Promise even if no Promise-related code appears in
        the body of the function. If an <code>async</code> function appears to return
        normally, then the Promise object that is the real return value of the
        function will resolve to that apparent return value. And if an <code>async</code>
        function appears to throw an exception, then the Promise object that
        it returns will be rejected with that exception.</p>
        
        <p>The <code>getHighScore()</code> function is declared <code>async</code>, so it returns a
        Promise. And because it returns a Promise, we can use the <code>await</code>
        keyword with it:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">displayHighScore</code><code class="p">(</code><code class="nx">await</code> <code class="nx">getHighScore</code><code class="p">());</code></pre>
        
        <p>But remember, that line of code will only work if it is inside another
        <code>async</code> function! You can nest <code>await</code> expressions within <code>async</code>
        functions as deeply as you want. But if you’re at the top level<sup><a data-type="noteref" id="idm46198516659992-marker" href="ch13.html#idm46198516659992">2</a></sup> or are inside a
        function that is not <code>async</code> for some reason, then you can’t use
        <code>await</code> and have to deal with a returned Promise in the regular way:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">getHighScore</code><code class="p">().</code><code class="nx">then</code><code class="p">(</code><code class="nx">displayHighScore</code><code class="p">).</code><code class="k">catch</code><code class="p">(</code><code class="nx">console</code><code class="p">.</code><code class="nx">error</code><code class="p">);</code></pre>
        
        <p>You can use the <code>async</code> keyword with any kind of function. It works
        with the <code>function</code> keyword as a statement or as an expression. It
        works with arrow functions and with the method shortcut form in
        classes and object literals. (See <a data-type="xref" href="ch08.html#functions">Chapter&nbsp;8</a> for more about the
        various ways to write functions.)</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.3.3 Awaiting Multiple Promises"><div class="sect2" id="async-awaiting-multiple-promises">
        <h2>13.3.3 Awaiting Multiple Promises</h2>
        
        <p>Suppose that we’ve written our <code>getJSON()</code> function using <code>async</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">async</code> <code class="kd">function</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">);</code>
            <code class="kd">let</code> <code class="nx">body</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">response</code><code class="p">.</code><code class="nx">json</code><code class="p">();</code>
            <code class="k">return</code> <code class="nx">body</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>And now suppose that we want to fetch two JSON values with this
        function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">value1</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url1</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">value2</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url2</code><code class="p">);</code></pre>
        
        <p>The problem with this code is that it is unnecessarily sequential: the
        fetch of the second URL will not begin until the first fetch is
        complete.  If the second URL does not depend on the value obtained
        from the first URL, then we should probably try to fetch the two
        values at the same time. This is a case where the Promise-based nature
        of <code>async</code> functions shows. In order to await a set of
        concurrently executing <code>async</code> functions, we use <code>Promise.all()</code> just
        as we would if working with Promises directly:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="p">[</code><code class="nx">value1</code><code class="p">,</code> <code class="nx">value2</code><code class="p">]</code> <code class="o">=</code> <code class="nx">await</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">([</code><code class="nx">getJSON</code><code class="p">(</code><code class="nx">url1</code><code class="p">),</code> <code class="nx">getJSON</code><code class="p">(</code><code class="nx">url2</code><code class="p">)]);</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.3.4 Implementation Details"><div class="sect2" id="async-syntax-transform">
        <h2>13.3.4 Implementation Details</h2>
        
        <p>Finally, in order to understand how <code>async</code> functions work, it may help
        to think about what is going on under the hood.</p>
        
        <p>Suppose you write an <code>async</code> function like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">async</code> <code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* body */</code> <code class="p">}</code></pre>
        
        <p>You can think about this as a Promise-returning function wrapped
        around the body of your original function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">reject</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">try</code> <code class="p">{</code>
                    <code class="nx">resolve</code><code class="p">((</code><code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="cm">/* body */</code> <code class="p">})(</code><code class="nx">x</code><code class="p">));</code>
                <code class="p">}</code>
                <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">reject</code><code class="p">(</code><code class="nx">e</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">});</code>
        <code class="p">}</code></pre>
        
        <p>It is harder to express the <code>await</code> keyword in terms of a syntax
        transformation like this one. But think of the <code>await</code> keyword
        as a marker that breaks a function body up into separate, synchronous
        chunks. An ES2017 interpreter can break the function body up
        into a sequence of separate subfunctions, each of which gets passed
        to the <code>then()</code> method of the <code>await</code>-marked Promise that precedes
        it.<a data-type="indexterm" data-primary="" data-startref="ESasync13" id="idm46198516347976"></a><a data-type="indexterm" data-primary="" data-startref="Kawait13" id="idm46198516347000"></a><a data-type="indexterm" data-primary="" data-startref="Kasync13" id="idm46198516346056"></a><a data-type="indexterm" data-primary="" data-startref="await13" id="idm46198516345112"></a><a data-type="indexterm" data-primary="" data-startref="async13" id="idm46198516344168"></a><a data-type="indexterm" data-primary="" data-startref="APasync13" id="idm46198516343224"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="13.4 Asynchronous Iteration"><div class="sect1" id="async-iterators">
        <h1>13.4 Asynchronous Iteration</h1>
        
        <p>We began this chapter with a discussion of callback- and event-based
        asynchrony, and when we introduced Promises, we noted that they were
        useful for single-shot asynchronous computations but were not
        suitable for use with sources of repetitive asynchronous events, such
        as <code>setInterval()</code>, the “click” event in a web browser, or the “data”
        event on a Node stream. Because single Promises do not work for
        sequences of asynchronous events, we also cannot use regular <code>async</code>
        functions and the <code>await</code> statements for these things.</p>
        
        <p>ES2018<a data-type="indexterm" data-primary="ES2018" data-secondary="asynchronous iterator" id="idm46198516338056"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="asynchronous iteration" data-tertiary="for/await loops" id="idm46198516337048"></a><a data-type="indexterm" data-primary="for/await loops" id="idm46198516335864"></a><a data-type="indexterm" data-primary="looping statements" data-secondary="for/await loops" id="idm46198516335192"></a> provides a solution, however. Asynchronous iterators
        are like the iterators described in <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>, but they are Promise-based and are meant to be used with a new form of the <code>for/of</code> loop:
        <code>for/await</code>.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.4.1 The for/await Loop"><div class="sect2" id="async-for-await">
        <h2>13.4.1 The for/await Loop</h2>
        
        <p>Node<a data-type="indexterm" data-primary="Node" data-secondary="asynchronous iteration in" id="idm46198516330344"></a> 12 makes its readable streams asynchronously iterable. This means
        you can read successive chunks of data from a stream with a
        <code>for/await</code> loop like this one:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">fs</code> <code class="o">=</code> <code class="nx">require</code><code class="p">(</code><code class="s2">"fs"</code><code class="p">);</code>
        
        <code class="nx">async</code> <code class="kd">function</code> <code class="nx">parseFile</code><code class="p">(</code><code class="nx">filename</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">stream</code> <code class="o">=</code> <code class="nx">fs</code><code class="p">.</code><code class="nx">createReadStream</code><code class="p">(</code><code class="nx">filename</code><code class="p">,</code> <code class="p">{</code> <code class="nx">encoding</code><code class="o">:</code> <code class="s2">"utf-8"</code><code class="p">});</code>
            <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">chunk</code> <code class="k">of</code> <code class="nx">stream</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">parseChunk</code><code class="p">(</code><code class="nx">chunk</code><code class="p">);</code> <code class="c1">// Assume parseChunk() is defined elsewhere</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>Like a regular <code>await</code> expression, the <code>for/await</code> loop is
        Promise-based. Roughly speaking, the asynchronous iterator produces a
        Promise and the <code>for/await</code> loop waits for that Promise to fulfill,
        assigns the fulfillment value to the loop variable, and runs the body
        of the loop. And then it starts over, getting another Promise from the
        iterator and waiting for that new Promise to fulfill.</p>
        
        <p>Suppose you have an array of URLs:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">urls</code> <code class="o">=</code> <code class="p">[</code><code class="nx">url1</code><code class="p">,</code> <code class="nx">url2</code><code class="p">,</code> <code class="nx">url3</code><code class="p">];</code></pre>
        
        <p>You can call <code>fetch()</code> on each URL to get an array of Promises:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">promises</code> <code class="o">=</code> <code class="nx">urls</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">url</code> <code class="o">=&gt;</code> <code class="nx">fetch</code><code class="p">(</code><code class="nx">url</code><code class="p">));</code></pre>
        
        <p>We saw earlier in the chapter that we could now use <code>Promise.all()</code> to
        wait for all the Promises in the array to be fulfilled. But suppose we
        want the results of the first fetch as soon as they become available
        and don’t want to wait for all the URLs to be fetched. (Of course, the
        first fetch might take longer than any of the others, so this is not
        necessarily faster than using <code>Promise.all()</code>.) Arrays are
        iterable, so we can iterate through the array of promises with a
        regular <code>for/of</code> loop:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kr">const</code> <code class="nx">promise</code> <code class="k">of</code> <code class="nx">promises</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">response</code> <code class="o">=</code> <code class="nx">await</code> <code class="nx">promise</code><code class="p">;</code>
            <code class="nx">handle</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>This example code uses a regular <code>for/of</code> loop with a regular
        iterator. But because this iterator returns Promises, we can also use
        the new <code>for/await</code> for slightly simpler code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">response</code> <code class="k">of</code> <code class="nx">promises</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">handle</code><code class="p">(</code><code class="nx">response</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>In this case, the <code>for/await</code> loop just builds the <code>await</code> call into
        the loop and makes our code slightly more compact, but the two
        examples do exactly the same thing. Importantly, both examples will
        only work if they are within functions declared <code>async</code>; a <code>for/await</code>
        loop is no different than a regular <code>await</code> expression in that way.</p>
        
        <p>It is important to realize, however, that we’re using <code>for/await</code> with
        a regular iterator in this example. Things are more interesting with
        fully asynchronous iterators.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.4.2 Asynchronous Iterators"><div class="sect2" id="async-async-iterators">
        <h2>13.4.2 Asynchronous Iterators</h2>
        
        <p>Let’s<a data-type="indexterm" data-primary="iterators and generators" data-secondary="asynchronous" id="IAGasynch13"></a><a data-type="indexterm" data-primary="asynchronous programming" data-secondary="asynchronous iteration" data-tertiary="asynchronous iterators" id="idm46198516092472"></a> review some terminology from <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>. An <em>iterable</em> object
        is one that can be used with a <code>for/of</code> loop. It defines a method
        with the symbolic name <code>Symbol.iterator</code>. This method returns an
        <em>iterator</em> object. The iterator object has a <code>next()</code> method, which can
        be called repeatedly to obtain the values of the iterable object. The
        <code>next()</code> method of the iterator object returns <em>iteration result</em>
        objects. The iteration result object has a <code>value</code> property and/or a
        <code>done</code> property.</p>
        
        <p>Asynchronous iterators are quite similar to regular iterators, but
        there are two important differences. First, an asynchronously iterable
        object implements a method with the symbolic name
        <code>Symbol.asyncIterator</code> instead of <code>Symbol.iterator</code>. (As we saw earlier,
        <code>for/await</code> is compatible with regular iterable objects but it
        prefers asynchronously iterable objects, and tries the
        <code>Symbol.asyncIterator</code> method before it tries the <code>Symbol.iterator</code>
        method.) Second, the <code>next()</code> method of an asynchronous iterator
        returns a Promise that resolves to an iterator result object instead
        of returning an iterator result object directly.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>In the previous section, when we used <code>for/await</code> on a regular,
        synchronously iterable array of Promises, we were working with
        synchronous iterator result objects in which the <code>value</code> property
        was a Promise object but the <code>done</code> property was synchronous. True
        asynchronous iterators return Promises for iteration result objects,
        and both the <code>value</code> and the <code>done</code> properties are asynchronous. The
        difference is a subtle one: with asynchronous iterators, the choice
        about when iteration ends can be made asynchronously.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.4.3 Asynchronous Generators"><div class="sect2" id="async-async-generators">
        <h2>13.4.3 Asynchronous Generators</h2>
        
        <p>As<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="asynchronous iteration" data-tertiary="asynchronous generators" id="idm46198516077432"></a> we saw in <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>, the easiest way to implement an iterator is
        often to use a generator. The same is true for asynchronous iterators,
        which we can implement with generator functions that we declare
        <code>async</code>. An async generator has the features of async functions and
        the features of generators: you can use <code>await</code> as you would in a
        regular async function, and you can use <code>yield</code> as you would in a
        regular generator. But values that you <code>yield</code> are automatically wrapped
        in Promises. Even the syntax for async generators is a combination:
        <code>async function</code> and <code>function *</code> combine into <code>async function *</code>.
        Here is an example that shows how you might use an async generator and
        a <code>for/await</code> loop to repetitively run code at fixed intervals using
        loop syntax instead of a <code>setInterval()</code> callback function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// A Promise-based wrapper around setTimeout() that we can use await with.</code>
        <code class="c1">// Returns a Promise that fulfills in the specified number of milliseconds</code>
        <code class="kd">function</code> <code class="nx">elapsedTime</code><code class="p">(</code><code class="nx">ms</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">ms</code><code class="p">));</code>
        <code class="p">}</code>
        
        <code class="c1">// An async generator function that increments a counter and yields it</code>
        <code class="c1">// a specified (or infinite) number of times at a specified interval.</code>
        <code class="nx">async</code> <code class="kd">function</code><code class="o">*</code> <code class="nx">clock</code><code class="p">(</code><code class="nx">interval</code><code class="p">,</code> <code class="nx">max</code><code class="o">=</code><code class="kc">Infinity</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">count</code> <code class="o">&lt;=</code> <code class="nx">max</code><code class="p">;</code> <code class="nx">count</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// regular for loop</code>
                <code class="nx">await</code> <code class="nx">elapsedTime</code><code class="p">(</code><code class="nx">interval</code><code class="p">);</code>            <code class="c1">// wait for time to pass</code>
                <code class="k">yield</code> <code class="nx">count</code><code class="p">;</code>                            <code class="c1">// yield the counter</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// A test function that uses the async generator with for/await</code>
        <code class="nx">async</code> <code class="kd">function</code> <code class="nx">test</code><code class="p">()</code> <code class="p">{</code>                       <code class="c1">// Async so we can use for/await</code>
            <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">tick</code> <code class="k">of</code> <code class="nx">clock</code><code class="p">(</code><code class="mi">300</code><code class="p">,</code> <code class="mi">100</code><code class="p">))</code> <code class="p">{</code> <code class="c1">// Loop 100 times every 300ms</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">tick</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="13.4.4 Implementing Asynchronous Iterators"><div class="sect2" id="async-async-iterator-implementation">
        <h2>13.4.4 Implementing Asynchronous Iterators</h2>
        
        <p>Instead<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="asynchronous iteration" data-tertiary="implementation" id="APasynimp13"></a> of using async generators to implement asynchronous iterators,
        it is also possible to implement them directly by defining an object
        with a <code>Symbol.asyncIterator()</code> method that returns an object with a
        <code>next()</code> method that returns a Promise that resolves to an iterator
        result object. In the following code, we re-implement the <code>clock()</code>
        function from the preceding example so that it is not a generator and instead just returns
        an asynchronously iterable object. Notice that the <code>next()</code> method in
        this example does not explicitly return a Promise; instead, we just
        declare <code>next()</code> to be async:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">clock</code><code class="p">(</code><code class="nx">interval</code><code class="p">,</code> <code class="nx">max</code><code class="o">=</code><code class="kc">Infinity</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// A Promise-ified version of setTimeout that we can use await with.</code>
            <code class="c1">// Note that this takes an absolute time instead of an interval.</code>
            <code class="kd">function</code> <code class="nx">until</code><code class="p">(</code><code class="nx">time</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code><code class="nx">resolve</code> <code class="o">=&gt;</code> <code class="nx">setTimeout</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code> <code class="nx">time</code> <code class="o">-</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">()));</code>
            <code class="p">}</code>
        
            <code class="c1">// Return an asynchronously iterable object</code>
            <code class="k">return</code> <code class="p">{</code>
                <code class="nx">startTime</code><code class="o">:</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">(),</code>  <code class="c1">// Remember when we started</code>
                <code class="nx">count</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>               <code class="c1">// Remember which iteration we're on</code>
                <code class="nx">async</code> <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>          <code class="c1">// The next() method makes this an iterator</code>
                    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">count</code> <code class="o">&gt;</code> <code class="nx">max</code><code class="p">)</code> <code class="p">{</code>     <code class="c1">// Are we done?</code>
                        <code class="k">return</code> <code class="p">{</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">};</code>  <code class="c1">// Iteration result indicating done</code>
                    <code class="p">}</code>
                    <code class="c1">// Figure out when the next iteration should begin,</code>
                    <code class="kd">let</code> <code class="nx">targetTime</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">startTime</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code> <code class="o">*</code> <code class="nx">interval</code><code class="p">;</code>
                    <code class="c1">// wait until that time,</code>
                    <code class="nx">await</code> <code class="nx">until</code><code class="p">(</code><code class="nx">targetTime</code><code class="p">);</code>
                    <code class="c1">// and return the count value in an iteration result object.</code>
                    <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code><code class="o">++</code> <code class="p">};</code>
                <code class="p">},</code>
                <code class="c1">// This method means that this iterator object is also an iterable.</code>
                <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">asyncIterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">}</code>
            <code class="p">};</code>
        <code class="p">}</code></pre>
        
        <p>This iterator-based version of the <code>clock()</code> function fixes a flaw in
        the generator-based version. Note that, in this newer code, we target
        the absolute time at which each iteration should begin and subtract the
        current time from that in order to compute the interval that we pass
        to <code>setTimeout()</code>. If we use <code>clock()</code> with a <code>for/await</code> loop, this
        version will run loop iterations more precisely at the specified
        interval because it accounts for the time required to actually run the
        body of the loop. But this fix isn’t just about timing accuracy. The
        <code>for/await</code> loop always waits for the Promise returned by one iteration to
        be fulfilled before it begins the next iteration. But if you use an
        asynchronous iterator without a <code>for/await</code> loop, there is nothing to
        prevent you from calling the <code>next()</code> method whenever you want. With
        the generator-based version of <code>clock()</code>, if you call the <code>next()</code>
        method three times sequentially, you’ll get three Promises that will
        all fulfill at almost exactly the same time, which is probably not
        what you want. The iterator-based version we’ve implemented here does
        not have that problem.</p>
        
        <p>The benefit of asynchronous iterators is that they allow us to
        represent streams of asynchronous events or data. The <code>clock()</code>
        function discussed previously was fairly simple to write because the source of the
        asynchrony was the <code>setTimeout()</code> calls we were making ourselves. But
        when we are trying to work with other asynchronous sources, such as
        the triggering of event handlers, it becomes substantially harder to
        implement asynchronous iterators—we typically have a single event
        handler function that responds to events, but each call to the
        iterator’s <code>next()</code> method must return a distinct Promise object, and
        multiple calls to <code>next()</code> may occur before the first Promise
        resolves. This means that any asynchronous iterator method must be
        able to maintain an internal queue of Promises that it resolves in
        order as asynchronous events are occurring. If we encapsulate this Promise-queueing behavior into an AsyncQueue class, then it becomes much
        easier to write asynchronous iterators based on
        AsyncQueue.<sup><a data-type="noteref" id="idm46198515815416-marker" href="ch13.html#idm46198515815416">3</a></sup></p>
        
        <p>The AsyncQueue class that follows has <code>enqueue()</code> and <code>dequeue()</code> methods as
        you’d expect for a queue class. The <code>dequeue()</code> method returns a
        Promise rather than an actual value, however, which means that it is
        OK to call <code>dequeue()</code> before <code>enqueue()</code> has ever been called. The AsyncQueue
        class is also an asynchronous iterator, and is intended to be used
        with a <code>for/await</code> loop whose body runs once each time a new value is
        asynchronously enqueued. (AsyncQueue has a <code>close()</code> method. Once
        called, no more values can be enqueued. When a closed queue is empty,
        the <code>for/await</code> loop will stop looping.)</p>
        
        <p>Note that the implementation of AsyncQueue does not use <code>async</code> or
        <code>await</code> and instead works directly with Promises. The code is somewhat
        complicated, and you can use it to test your understanding of the
        material we’ve covered in this long chapter. Even if you don’t fully
        understand the AsyncQueue implementation, do take a look at the
        shorter example that follows it: it implements a simple but very
        interesting asynchronous iterator on top of AsyncQueue.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="cm">/**</code>
        <code class="cm"> * An asynchronously iterable queue class. Add values with enqueue()</code>
        <code class="cm"> * and remove them with dequeue(). dequeue() returns a Promise, which</code>
        <code class="cm"> * means that values can be dequeued before they are enqueued. The</code>
        <code class="cm"> * class implements [Symbol.asyncIterator] and next() so that it can</code>
        <code class="cm"> * be used with the for/await loop (which will not terminate until</code>
        <code class="cm"> * the close() method is called.)</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">AsyncQueue</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
                <code class="c1">// Values that have been queued but not dequeued yet are stored here</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">values</code> <code class="o">=</code> <code class="p">[];</code>
                <code class="c1">// When Promises are dequeued before their corresponding values are</code>
                <code class="c1">// queued, the resolve methods for those Promises are stored here.</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code> <code class="o">=</code> <code class="p">[];</code>
                <code class="c1">// Once closed, no more values can be enqueued, and no more unfulfilled</code>
                <code class="c1">// Promises returned.</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">closed</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="nx">enqueue</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">closed</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"AsyncQueue closed"</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// If this value has already been promised, resolve that Promise</code>
                    <code class="kr">const</code> <code class="nx">resolve</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">shift</code><code class="p">();</code>
                    <code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">else</code> <code class="p">{</code>
                    <code class="c1">// Otherwise, queue it up</code>
                    <code class="k">this</code><code class="p">.</code><code class="nx">values</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="nx">dequeue</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">values</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// If there is a queued value, return a resolved Promise for it</code>
                    <code class="kr">const</code> <code class="nx">value</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">values</code><code class="p">.</code><code class="nx">shift</code><code class="p">();</code>
                    <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">value</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">closed</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// If no queued values and we're closed, return a resolved</code>
                    <code class="c1">// Promise for the "end-of-stream" marker</code>
                    <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code><code class="nx">AsyncQueue</code><code class="p">.</code><code class="nx">EOS</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">else</code> <code class="p">{</code>
                    <code class="c1">// Otherwise, return an unresolved Promise,</code>
                    <code class="c1">// queuing the resolver function for later use</code>
                    <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">((</code><code class="nx">resolve</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">resolve</code><code class="p">);</code> <code class="p">});</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="nx">close</code><code class="p">()</code> <code class="p">{</code>
                <code class="c1">// Once the queue is closed, no more values will be enqueued.</code>
                <code class="c1">// So resolve any pending Promises with the end-of-stream marker</code>
                <code class="k">while</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">this</code><code class="p">.</code><code class="nx">resolvers</code><code class="p">.</code><code class="nx">shift</code><code class="p">()(</code><code class="nx">AsyncQueue</code><code class="p">.</code><code class="nx">EOS</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">closed</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="c1">// Define the method that makes this class asynchronously iterable</code>
            <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">asyncIterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="c1">// Define the method that makes this an asynchronous iterator. The</code>
            <code class="c1">// dequeue() Promise resolves to a value or the EOS sentinel if we're</code>
            <code class="c1">// closed. Here, we need to return a Promise that resolves to an</code>
            <code class="c1">// iterator result object.</code>
            <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">dequeue</code><code class="p">().</code><code class="nx">then</code><code class="p">(</code><code class="nx">value</code> <code class="o">=&gt;</code> <code class="p">(</code><code class="nx">value</code> <code class="o">===</code> <code class="nx">AsyncQueue</code><code class="p">.</code><code class="nx">EOS</code><code class="p">)</code>
                                           <code class="o">?</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code>
                                           <code class="o">:</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code> <code class="p">});</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// A sentinel value returned by dequeue() to mark "end of stream" when closed</code>
        <code class="nx">AsyncQueue</code><code class="p">.</code><code class="nx">EOS</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"end-of-stream"</code><code class="p">);</code></pre>
        
        <p>Because this AsyncQueue class defines the asynchronous iteration
        basics, we can create our own, more interesting asynchronous iterators
        simply by asynchronously queueing values. Here’s an example that uses
        AsyncQueue to produce a stream of web browser events that can be
        handled<a data-type="indexterm" data-primary="" data-startref="APasynimp13" id="idm46198515797848"></a><a data-type="indexterm" data-primary="" data-startref="IAGasynch13" id="idm46198515797000"></a> with a <code>for/await</code> loop:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Push events of the specified type on the specified document element</code>
        <code class="c1">// onto an AsyncQueue object, and return the queue for use as an event stream</code>
        <code class="kd">function</code> <code class="nx">eventStream</code><code class="p">(</code><code class="nx">elt</code><code class="p">,</code> <code class="nx">type</code><code class="p">)</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">q</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">AsyncQueue</code><code class="p">();</code>                  <code class="c1">// Create a queue</code>
            <code class="nx">elt</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code><code class="nx">type</code><code class="p">,</code> <code class="nx">e</code><code class="o">=&gt;</code><code class="nx">q</code><code class="p">.</code><code class="nx">enqueue</code><code class="p">(</code><code class="nx">e</code><code class="p">));</code> <code class="c1">// Enqueue events</code>
            <code class="k">return</code> <code class="nx">q</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="nx">async</code> <code class="kd">function</code> <code class="nx">handleKeys</code><code class="p">()</code> <code class="p">{</code>
            <code class="c1">// Get a stream of keypress events and loop once for each one</code>
            <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kr">const</code> <code class="nx">event</code> <code class="k">of</code> <code class="nx">eventStream</code><code class="p">(</code><code class="nb">document</code><code class="p">,</code> <code class="s2">"keypress"</code><code class="p">))</code> <code class="p">{</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">event</code><code class="p">.</code><code class="nx">key</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="13.5 Summary"><div class="sect1" id="idm46198516050840">
        <h1>13.5 Summary</h1>
        
        <p>In this chapter, you have learned:</p>
        
        <ul>
        <li>
        <p>Most real-world JavaScript programming is asynchronous.</p>
        </li>
        <li>
        <p>Traditionally, asynchrony has been handled with events and callback
        functions. This can get complicated, however, because you can end up
        with multiple levels of callbacks nested inside other callbacks, and
        because it is difficult to do robust error handling.</p>
        </li>
        <li>
        <p>Promises provide a new way of structuring callback functions. If
        used correctly (and unfortunately, Promises are easy to use
        incorrectly), they can convert asynchronous code that would have
        been nested into linear chains of <code>then()</code> calls where one
        asynchronous step of a computation follows another. Also, Promises
        allow you to centralize your error-handling code into a single
        <code>catch()</code> call at the end of a chain of <code>then()</code> calls.</p>
        </li>
        <li>
        <p>The <code>async</code> and <code>await</code> keywords allow us to write asynchronous code
        that is Promise-based under the hood but that looks like
        synchronous code. This makes the code easier to understand and
        reason about. If a function is declared <code>async</code>, it will implicitly
        return a Promise. Inside an <code>async</code> function, you can <code>await</code>
        a Promise (or a function that returns a Promise) as if the Promise
        value was synchronously computed.</p>
        </li>
        <li>
        <p>Objects that are asynchronously iterable can be used with a
        <code>for/await</code> loop. You can create asynchronously iterable objects by
        implementing a <code>[Symbol.asyncIterator]()</code> method or by invoking an
        <code>async function *</code> generator function. Asynchronous iterators
        provide an alternative to “data” events on streams in Node and can
        be used to represent a stream of user input events in client-side
        JavaScript.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        <div data-type="footnotes"><p data-type="footnote" id="idm46198519434968"><sup><a href="ch13.html#idm46198519434968-marker">1</a></sup> The XMLHttpRequest class has nothing in particular to do with XML. In modern client-side JavaScript, it has largely been replaced by the <code>fetch()</code> API, which is covered in <a data-type="xref" href="ch15.html#fetch">§15.11.1</a>. The code example shown here is the last XMLHttpRequest-based example remaining in this book.</p><p data-type="footnote" id="idm46198516659992"><sup><a href="ch13.html#idm46198516659992-marker">2</a></sup> You can typically use <code>await</code> at the top level in a browser’s developer console. And there is a pending proposal to allow top-level <code>await</code> in a future version of JavaScript.</p><p data-type="footnote" id="idm46198515815416"><sup><a href="ch13.html#idm46198515815416-marker">3</a></sup> I learned about this approach to asynchronous iteration from the blog of Dr. Axel Rauschmayer, <a href="https://2ality.com"><em class="hyperlink">https://2ality.com</em></a>.</p></div></div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->