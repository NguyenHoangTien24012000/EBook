<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Classes"><div class="chapter" id="classes">
        <h1><span class="label">Chapter 9. </span>Classes</h1>
        
        
        <p>JavaScript<a data-type="indexterm" data-primary="classes" data-secondary="overview of" id="idm46198536023816"></a> objects were covered in <a data-type="xref" href="ch06.html#objects">Chapter&nbsp;6</a>. That chapter treated
        each object as a unique set of properties, different from every other
        object. It is often useful, however, to define a <em>class</em> of objects
        that share certain properties. Members, or <em>instances</em>, of the class
        have their own properties to hold or define their state, but they also
        have methods that define their behavior. These methods are defined by
        the class and shared by all instances. Imagine a class named Complex
        that represents and performs arithmetic on complex numbers, for
        example. A Complex instance would have properties to hold the real and
        imaginary parts (the state) of the complex number. And the Complex
        class would define methods to perform addition and multiplication (the
        behavior) of those numbers.</p>
        
        <p>In JavaScript, classes use prototype-based inheritance: if two objects
        inherit properties (generally function-valued properties, or methods)
        from the same prototype, then we say that those objects are instances
        of the same class. That, in a nutshell, is how JavaScript classes
        work.  JavaScript prototypes and inheritance were covered in
        <a data-type="xref" href="ch06.html#prototypes">§6.2.3</a> and <a data-type="xref" href="ch06.html#inheritance">§6.3.2</a>, and you will need to be familiar
        with the material in those sections to understand this chapter. This
        chapter covers prototypes in <a data-type="xref" href="#classesandprototypes">§9.1</a>.</p>
        
        <p>If two objects inherit from the same prototype, this typically (but
        not necessarily) means that they were created and initialized by the
        same constructor function or factory function. Constructors have been
        covered in <a data-type="xref" href="ch04.html#newexprs">§4.6</a>, <a data-type="xref" href="ch06.html#creatingobjectswithnew">§6.2.2</a>, and
        <a data-type="xref" href="ch08.html#constructorinvocation">§8.2.3</a>, and this chapter has more in
        <a data-type="xref" href="#classesandconstructors">§9.2</a>.</p>
        
        <p>JavaScript has always allowed the definition of classes. ES6
        introduced a brand-new syntax (including a <code>class</code> keyword) that makes
        it even easier to create classes. These new JavaScript classes work
        in the same way that old-style classes do, and this chapter starts by
        explaining the old way of creating classes because that demonstrates
        more clearly what is going on behind the scenes to make classes
        work. Once we’ve explained those fundamentals, we’ll shift and start
        using the new, simplified class definition syntax.</p>
        
        <p>If you’re familiar with strongly typed object-oriented programming
        languages like Java or C++, you’ll notice that JavaScript classes are
        quite different from classes in those languages. There are some
        syntactic similarities, and you can emulate many features of
        “classical” classes in JavaScript, but it is best to understand up
        front that <span class="keep-together">JavaScript’s</span> classes and prototype-based inheritance
        mechanism are substantially different from the classes and class-based
        inheritance mechanism of Java and similar languages.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="9.1 Classes and Prototypes"><div class="sect1" id="classesandprototypes">
        <h1>9.1 Classes and Prototypes</h1>
        
        <p>In<a data-type="indexterm" data-primary="classes" data-secondary="classes and prototypes" id="idm46198536007816"></a><a data-type="indexterm" data-primary="prototypes" id="idm46198536006808"></a> JavaScript, a class is a set of objects that inherit properties
        from the same prototype object. The prototype object, therefore, is
        the central feature of a class. <a data-type="xref" href="ch06.html#objects">Chapter&nbsp;6</a> covered the
        <code>Object.create()</code> function that returns a newly created object that
        inherits from a specified prototype object. If we define a prototype
        object and then use <code>Object.create()</code> to create objects that inherit
        from it, we have defined a JavaScript class. Usually, the instances of
        a class require further initialization, and it is common to define a
        function that creates and initializes the new object. <a data-type="xref" href="#range1.js">Example&nbsp;9-1</a>
        demonstrates this: it defines a prototype object for a class that
        represents a range of values and also<a data-type="indexterm" data-primary="factory functions" id="idm46198536002840"></a><a data-type="indexterm" data-primary="functions" data-secondary="factory functions" id="idm46198536002168"></a> defines a <em>factory
        function</em> that creates and initializes a new instance of the class.</p>
        <div id="range1.js" data-type="example">
        <h5><span class="label">Example 9-1. </span>A simple JavaScript class</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This is a factory function that returns a new range object.</code>
        <code class="kd">function</code> <code class="nx">range</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Use Object.create() to create an object that inherits from the</code>
            <code class="c1">// prototype object defined below.  The prototype object is stored as</code>
            <code class="c1">// a property of this function, and defines the shared methods (behavior)</code>
            <code class="c1">// for all range objects.</code>
            <code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">range</code><code class="p">.</code><code class="nx">methods</code><code class="p">);</code>
        
            <code class="c1">// Store the start and end points (state) of this new range object.</code>
            <code class="c1">// These are noninherited properties that are unique to this object.</code>
            <code class="nx">r</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">from</code><code class="p">;</code>
            <code class="nx">r</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">to</code><code class="p">;</code>
        
            <code class="c1">// Finally return the new object</code>
            <code class="k">return</code> <code class="nx">r</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="c1">// This prototype object defines methods inherited by all range objects.</code>
        <code class="nx">range</code><code class="p">.</code><code class="nx">methods</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// Return true if x is in the range, false otherwise</code>
            <code class="c1">// This method works for textual and Date ranges as well as numeric.</code>
            <code class="nx">includes</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&lt;=</code> <code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="p">},</code>
        
            <code class="c1">// A generator function that makes instances of the class iterable.</code>
            <code class="c1">// Note that it only works for numeric ranges.</code>
            <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="p">);</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="nx">x</code><code class="o">++</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
            <code class="p">},</code>
        
            <code class="c1">// Return a string representation of the range</code>
            <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="s2">"("</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">+</code> <code class="s2">"..."</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">+</code> <code class="s2">")"</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="c1">// Here are example uses of a range object.</code>
        <code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="nx">range</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>      <code class="c1">// Create a range object</code>
        <code class="nx">r</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>            <code class="c1">// =&gt; true: 2 is in the range</code>
        <code class="nx">r</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>             <code class="c1">// =&gt; "(1...3)"</code>
        <code class="p">[...</code><code class="nx">r</code><code class="p">]</code>                   <code class="c1">// =&gt; [1, 2, 3]; convert to an array via iterator</code></pre></div>
        
        <p>There are a few things worth noting in the code of <a data-type="xref" href="#range1.js">Example&nbsp;9-1</a>:</p>
        
        <ul>
        <li>
        <p>This code defines a factory function <code>range()</code> for creating new
        Range objects.</p>
        </li>
        <li>
        <p>It uses the <code>methods</code> property of this <code>range()</code> function as a
        convenient place to store the prototype object that defines the
        class. There is nothing special or idiomatic about putting the
        prototype object here.</p>
        </li>
        <li>
        <p>The <code>range()</code> function defines <code>from</code> and <code>to</code> properties on each
        Range object. These are the unshared, noninherited properties that
        define the unique state of each individual Range object.</p>
        </li>
        <li>
        <p>The <code>range.methods</code> object uses the ES6 shorthand syntax for
        defining methods, which is why you don’t see the <code>function</code> keyword
        anywhere. (See <a data-type="xref" href="ch06.html#object-literal-shorthand-methods">§6.10.5</a> to
        review object literal shorthand method syntax.)</p>
        </li>
        <li>
        <p>One of the methods in the prototype has the computed name
        (<a data-type="xref" href="ch06.html#computed-property-names">§6.10.2</a>) <code>Symbol.iterator</code>, which means that it
        is defining an iterator for Range objects. The name of this method
        is prefixed with <code>*</code>, which indicates that it is a generator function
        instead of a regular function. Iterators and generators are covered
        in detail in <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>. For now, the upshot is that instances of
        this Range class can be used with the <code>for/of</code> loop and with the
        <code>...</code> spread operator.</p>
        </li>
        <li>
        <p>The shared, inherited methods defined in <code>range.methods</code> all use the
        <code>from</code> and <code>to</code> properties that were initialized in the <code>range()</code>
        factory function. In order to refer to them, they use the <code>this</code>
        keyword to refer to the object through which they were invoked. This
        use of <code>this</code> is a fundamental characteristic of the methods of any
        class.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="9.2 Classes and Constructors"><div class="sect1" id="classesandconstructors">
        <h1>9.2 Classes and Constructors</h1>
        
        <p><a data-type="xref" href="#range1.js">Example&nbsp;9-1</a> demonstrates<a data-type="indexterm" data-primary="classes" data-secondary="classes and constructors" id="Cconst09"></a><a data-type="indexterm" data-primary="constructors" data-secondary="classes and" id="Cclass09"></a> a simple way to define a JavaScript
        class. It is not the idiomatic way to do so, however, because it did
        not define a <em>constructor</em>. A constructor is a function designed for
        the initialization of newly created objects. Constructors are invoked
        using the <code>new</code> keyword as described in
        <a data-type="xref" href="ch08.html#constructorinvocation">§8.2.3</a>. Constructor invocations using <code>new</code>
        automatically create the new object, so the constructor itself only
        needs to initialize the state of that new object. The critical feature
        of constructor invocations is that the <code>prototype</code> property of the
        constructor is used as the prototype of the new object. <a data-type="xref" href="ch06.html#prototypes">§6.2.3</a> introduced prototypes and emphasized that while almost all objects have a prototype, only a few objects have a <code>prototype</code> property. Finally, we can clarify this: it is function objects that have a <code>prototype</code> property. This means
        that all objects created with the same constructor function inherit from the
        same object and are therefore members of the same class.
        <a data-type="xref" href="#range2.js">Example&nbsp;9-2</a> shows how we could alter the Range class of
        <a data-type="xref" href="#range1.js">Example&nbsp;9-1</a> to use a constructor function instead of a factory
        function. <a data-type="xref" href="#range2.js">Example&nbsp;9-2</a> demonstrates the idiomatic way to create a
        class in versions of JavaScript that do not support the ES6 <code>class</code>
        keyword. Even though <code>class</code> is well supported now, there is still
        lots of older JavaScript code around that defines classes like this,
        and you should be familiar with the idiom so that you can read old
        code and so that you understand what is going on “under the hood”
        when you use the <code>class</code> keyword.</p>
        <div id="range2.js" data-type="example">
        <h5><span class="label">Example 9-2. </span>A Range class using a constructor</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This is a constructor function that initializes new Range objects.</code>
        <code class="c1">// Note that it does not create or return the object. It just initializes this.</code>
        <code class="kd">function</code> <code class="nx">Range</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Store the start and end points (state) of this new range object.</code>
            <code class="c1">// These are noninherited properties that are unique to this object.</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">from</code><code class="p">;</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">to</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="c1">// All Range objects inherit from this object.</code>
        <code class="c1">// Note that the property name must be "prototype" for this to work.</code>
        <code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// Return true if x is in the range, false otherwise</code>
            <code class="c1">// This method works for textual and Date ranges as well as numeric.</code>
            <code class="nx">includes</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&lt;=</code> <code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="p">},</code>
        
            <code class="c1">// A generator function that makes instances of the class iterable.</code>
            <code class="c1">// Note that it only works for numeric ranges.</code>
            <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]</code><code class="o">:</code> <code class="kd">function</code><code class="o">*</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="p">);</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="nx">x</code><code class="o">++</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
            <code class="p">},</code>
        
            <code class="c1">// Return a string representation of the range</code>
            <code class="nx">toString</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="s2">"("</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">+</code> <code class="s2">"..."</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">+</code> <code class="s2">")"</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="c1">// Here are example uses of this new Range class</code>
        <code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Range</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>   <code class="c1">// Create a Range object; note the use of new</code>
        <code class="nx">r</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>             <code class="c1">// =&gt; true: 2 is in the range</code>
        <code class="nx">r</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>              <code class="c1">// =&gt; "(1...3)"</code>
        <code class="p">[...</code><code class="nx">r</code><code class="p">]</code>                    <code class="c1">// =&gt; [1, 2, 3]; convert to an array via iterator</code></pre></div>
        
        <p>It is worth comparing Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range1.js">9-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range2.js">9-2</a> fairly carefully
        and noting the differences between these two techniques for defining
        classes.  First, notice that we renamed the <code>range()</code> factory function
        to <code>Range()</code> when we converted it to a constructor. This is a very
        common coding convention: constructor functions define, in a sense,
        classes, and classes have names that (by convention) begin with capital
        letters. Regular functions and methods have names that begin with
        lowercase letters.</p>
        
        <p>Next, notice that the <code>Range()</code> constructor is invoked (at the end
        of the example) with the <code>new</code> keyword while the <code>range()</code> factory
        function was invoked without it. <a data-type="xref" href="#range1.js">Example&nbsp;9-1</a> uses regular function
        invocation (<a data-type="xref" href="ch08.html#functioninvocation">§8.2.1</a>) to create the new object, and
        <a data-type="xref" href="#range2.js">Example&nbsp;9-2</a> uses constructor invocation
        (<a data-type="xref" href="ch08.html#constructorinvocation">§8.2.3</a>). Because the <code>Range()</code> constructor is
        invoked with <code>new</code>, it does not have to call <code>Object.create()</code> or take
        any action to create a new object. The new object is automatically
        created before the constructor is called, and it is accessible as the
        <code>this</code> value. The <code>Range()</code> constructor merely has to initialize
        <code>this</code>. Constructors do not even have to return the newly created
        object. Constructor invocation automatically creates a new object,
        invokes the constructor as a method of that object, and returns the
        new object. The fact that constructor invocation is so different from
        regular function invocation is another reason that we give
        constructors names that start with capital letters. Constructors are
        written to be invoked as constructors, with the <code>new</code> keyword, and
        they usually won’t work properly if they are invoked as regular
        functions. A naming convention that keeps constructor functions
        distinct from regular functions helps programmers know when to use
        <code>new</code>.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198535520280">
        <h5>Constructors and new.target</h5>
        <p>Within<a data-type="indexterm" data-primary="new.target expression" id="idm46198535509928"></a><a data-type="indexterm" data-primary="expressions" data-secondary="new.target expression" id="idm46198535509192"></a><a data-type="indexterm" data-primary="classes" data-secondary="classes and constructors" data-tertiary="new.target expression" id="idm46198535508248"></a><a data-type="indexterm" data-primary="constructors" data-secondary="classes and" data-tertiary="new.target expression" id="idm46198535507064"></a> a function body, you can tell whether the function has been
        invoked as a constructor with the special expression <code>new.target</code>. If
        the value of that expression is defined, then you know that the
        function was invoked as a constructor, with the <code>new</code> keyword. When we
        discuss subclasses in <a data-type="xref" href="#subclasses">§9.5</a>, we’ll see that <code>new.target</code> is
        not always a reference to the constructor it is used in: it might also
        refer to the constructor function of a subclass.</p>
        
        <p>If <code>new.target</code> is <code>undefined</code>, then the containing function was
        invoked as a function, without the <code>new</code> keyword. JavaScript’s various
        error constructors can be invoked without <code>new</code>, and if you want to
        emulate this feature in your own constructors, you can write them like
        this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">C</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">new</code><code class="p">.</code><code class="nx">target</code><code class="p">)</code> <code class="k">return</code> <code class="k">new</code> <code class="nx">C</code><code class="p">();</code>
            <code class="c1">// initialization code goes here</code>
        <code class="p">}</code></pre>
        
        <p>This technique only works for constructors defined in this
        old-fashioned way. Classes created with the <code>class</code> keyword do not
        allow their constructors to be invoked without <code>new</code>.</p>
        </div></aside>
        
        <p>Another critical difference between Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range1.js">9-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range2.js">9-2</a>  is
        the way the prototype object is named. In the first example, the
        prototype was <code>range.methods</code>. This was a convenient and descriptive
        name, but arbitrary. In the second example, the prototype is
        <code>Range.prototype</code>, and this name is mandatory. An invocation of the
        <code>Range()</code> constructor automatically uses <code>Range.prototype</code> as the
        prototype of the new Range object.</p>
        
        <p>Finally, also note the things that do not change between Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range1.js">9-1</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range2.js">9-2</a> : the range methods are defined and invoked in the
        same way for both classes. Because <a data-type="xref" href="#range2.js">Example&nbsp;9-2</a> demonstrates the
        idiomatic way to create classes in versions of JavaScript before ES6,
        it does not use the ES6 shorthand method syntax in the prototype
        object and explicitly spells out the methods with the <code>function</code>
        keyword. But you can see that the implementation of the methods is the
        same in both examples.</p>
        
        <p>Importantly, note that neither of the two range examples uses arrow
        functions when defining constructors or methods. Recall from
        <a data-type="xref" href="ch08.html#arrowfunctions">§8.1.3</a> that functions defined in this way do not have a
        <code>prototype</code> property and so cannot be used as constructors. Also,
        arrow functions inherit the <code>this</code> keyword from the context in which
        they are defined rather than setting it based on the object through which they
        are invoked, and this makes them useless for methods because
        the defining characteristic of methods is that they use <code>this</code> to
        refer to the instance on which they were invoked.</p>
        
        <p>Fortunately, the new ES6 class syntax doesn’t allow the option of
        defining methods with arrow functions, so this is not a mistake that
        you can accidentally make when using that syntax. We will cover the
        ES6 <code>class</code> keyword soon, but first, there are more details to cover
        about constructors.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.2.1 Constructors, Class Identity, and instanceof"><div class="sect2" id="idm46198535464824">
        <h2>9.2.1 Constructors, Class Identity, and instanceof</h2>
        
        <p>As<a data-type="indexterm" data-primary="classes" data-secondary="classes and constructors" data-tertiary="constructors, class identity, and instanceof" id="idm46198535463128"></a><a data-type="indexterm" data-primary="constructors" data-secondary="classes and" data-tertiary="constructors, class identity, and instanceof" id="idm46198535461784"></a><a data-type="indexterm" data-primary="instanceof operator" id="idm46198535460536"></a> we’ve seen, the prototype object is fundamental to the identity of
        a class: two objects are instances of the same class if and only if
        they inherit from the same prototype object. The constructor function
        that initializes the state of a new object is not fundamental: two
        constructor functions may have <code>prototype</code> properties that point to
        the same prototype object. Then, both constructors can be used to
        create instances of the same class.</p>
        
        <p>Even though constructors are not as fundamental as prototypes, the
        constructor serves as the public face of a class. Most obviously, the
        name of the constructor function is usually adopted as the name of the
        class. We say, for example, that the <code>Range()</code> constructor creates
        Range objects. More fundamentally, however, constructors are used
        as the righthand operand of
        the <code>instanceof</code> operator when testing objects for membership in a
        class. If we have an object <code>r</code> and want to know if it is a Range
        object, we can write:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">r</code> <code class="k">instanceof</code> <code class="nx">Range</code>   <code class="c1">// =&gt; true: r inherits from Range.prototype</code></pre>
        
        <p>The <code>instanceof</code> operator was described in <a data-type="xref" href="ch04.html#instanceof">§4.9.4</a>. The
        lefthand operand should be the object that is being tested, and the
        righthand operand should be a constructor function that names a
        class. The expression <code>o instanceof C</code> evaluates to <code>true</code> if <code>o</code>
        inherits from <code>C.prototype</code>. The inheritance need not be direct: if
        <code>o</code> inherits from an object that inherits from an object that inherits
        from <code>C.prototype</code>, the expression will still evaluate to <code>true</code>.</p>
        
        <p>Technically speaking, in the previous code example, the <code>instanceof</code> operator is
        not checking whether <code>r</code> was actually initialized by the <code>Range</code>
        constructor. Instead, it is checking whether <code>r</code> inherits from
        <code>Range.prototype</code>. If we define a function <code>Strange()</code> and set its
        prototype to be the same as <code>Range.prototype</code>, then objects created
        with <code>new Strange()</code> will count as Range objects as far as
        <code>instanceof</code> is concerned (they won’t actually work as Range objects,
        however, because their <code>from</code> and <code>to</code> properties have not been
        initialized):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">Strange</code><code class="p">()</code> <code class="p">{}</code>
        <code class="nx">Strange</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">;</code>
        <code class="k">new</code> <code class="nx">Strange</code><code class="p">()</code> <code class="k">instanceof</code> <code class="nx">Range</code>   <code class="c1">// =&gt; true</code></pre>
        
        <p>Even though <code>instanceof</code> cannot actually verify the use of a
        constructor, it still uses a constructor function as its righthand
        side because constructors are the public identity of a class.</p>
        
        <p>If you want to test the prototype chain of an object for a specific
        prototype and do not want to use the constructor function as an
        intermediary, you can use the <span class="keep-together"><code>isPrototypeOf()</code></span> method. In
        <a data-type="xref" href="#range1.js">Example&nbsp;9-1</a>, for example, we defined a class without a constructor
        function, so there is no way to use <code>instanceof</code> with that
        class. Instead, however, we could test whether an object <code>r</code> was a
        member of that constructor-less class with this code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">range</code><code class="p">.</code><code class="nx">methods</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">r</code><code class="p">);</code>  <code class="c1">// range.methods is the prototype object.</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.2.2 The constructor Property"><div class="sect2" id="constructorproperty">
        <h2>9.2.2 The constructor Property</h2>
        
        <p>In<a data-type="indexterm" data-primary="classes" data-secondary="classes and constructors" data-tertiary="constructor property" id="Cccconst09"></a><a data-type="indexterm" data-primary="constructors" data-secondary="classes and" data-tertiary="constructor property" id="COcprop09"></a> <a data-type="xref" href="#range2.js">Example&nbsp;9-2</a>, we set <code>Range.prototype</code> to a new object that
        contained the methods for our class. Although it was convenient to
        express those methods as properties of a single object literal, it was
        not actually necessary to create a new object. Any regular JavaScript
        function (excluding arrow functions, generator functions, and async
        functions) can be used as a constructor, and constructor
        invocations need a <code>prototype</code> property. Therefore, every regular
        JavaScript function<sup><a data-type="noteref" id="idm46198535317032-marker" href="ch09.html#idm46198535317032">1</a></sup>
        automatically has a <code>prototype</code> property. The value of this property
        is an object that has a single, non-enumerable <code>constructor</code>
        property. The value of the <code>constructor</code> property is the function
        object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">F</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{};</code> <code class="c1">// This is a function object.</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="nx">F</code><code class="p">.</code><code class="nx">prototype</code><code class="p">;</code>   <code class="c1">// This is the prototype object associated with F.</code>
        <code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">p</code><code class="p">.</code><code class="nx">constructor</code><code class="p">;</code> <code class="c1">// This is the function associated with the prototype.</code>
        <code class="nx">c</code> <code class="o">===</code> <code class="nx">F</code>                <code class="c1">// =&gt; true: F.prototype.constructor === F for any F</code></pre>
        
        <p>The existence of this predefined prototype object with its <code>constructor</code>
        property means that objects typically inherit a <code>constructor</code> property that
        refers to their constructor. Since constructors serve as the public identity of
        a class, this constructor property gives the class of an object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">F</code><code class="p">();</code>      <code class="c1">// Create an object o of class F</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">constructor</code> <code class="o">===</code> <code class="nx">F</code>   <code class="c1">// =&gt; true: the constructor property specifies the class</code></pre>
        
        <p><a data-type="xref" href="#prototypefig">Figure&nbsp;9-1</a> illustrates this relationship between the constructor
        function, its prototype object, the back reference from the prototype
        to the constructor, and the instances created with the constructor.</p>
        
        <figure><div id="prototypefig" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/assets/js7e_0901.png" alt="js7e 0901" width="1019" height="280">
        <h6><span class="label">Figure 9-1. </span>A constructor function, its prototype, and instances</h6>
        </div></figure>
        
        <p>Notice that <a data-type="xref" href="#prototypefig">Figure&nbsp;9-1</a> uses our <code>Range()</code> constructor as an
        example. In fact, however, the Range class defined in <a data-type="xref" href="#range2.js">Example&nbsp;9-2</a>
        overwrites the predefined <code>Range.prototype</code> object with an object of
        its own. And the new prototype object it defines does not have a
        <code>constructor</code> property. So instances of the Range class, as defined,
        do not have a <code>constructor</code> property.  We can remedy this problem by
        explicitly adding a constructor to the prototype:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="o">:</code> <code class="nx">Range</code><code class="p">,</code>  <code class="c1">// Explicitly set the constructor back-reference</code>
        
            <code class="cm">/* method definitions go here */</code>
        <code class="p">};</code></pre>
        
        <p>Another common technique that you are likely to see in older JavaScript
        code is to use the predefined prototype object with its <code>constructor</code>
        property and add methods to it one at a time with code<a data-type="indexterm" data-primary="" data-startref="Cconst09" id="idm46198535166888"></a><a data-type="indexterm" data-primary="" data-startref="Cclass09" id="idm46198535166040"></a><a data-type="indexterm" data-primary="" data-startref="COcprop09" id="idm46198535141624"></a><a data-type="indexterm" data-primary="" data-startref="COcprop09" id="idm46198535140680"></a> like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Extend the predefined Range.prototype object so we don't overwrite</code>
        <code class="c1">// the automatically created Range.prototype.constructor property.</code>
        <code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">includes</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&lt;=</code> <code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code>
        <code class="p">};</code>
        <code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="s2">"("</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">+</code> <code class="s2">"..."</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">+</code> <code class="s2">")"</code><code class="p">;</code>
        <code class="p">};</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="9.3 Classes with the class Keyword"><div class="sect1" id="es6classes">
        <h1>9.3 Classes with the class Keyword</h1>
        
        <p>Classes<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" id="Cckey09"></a><a data-type="indexterm" data-primary="class keyword" id="class09"></a><a data-type="indexterm" data-primary="keywords" data-secondary="class keyword" id="Kclass09"></a><a data-type="indexterm" data-primary="ES6" data-secondary="class keyword" id="ESclass09"></a> have been part of JavaScript since the very first version of
        the language, but in ES6, they finally got their own syntax
        with the introduction of the <code>class</code> keyword. <a data-type="xref" href="#range3.js">Example&nbsp;9-3</a> shows what
        our Range class looks like when written with this new <span class="keep-together">syntax.</span></p>
        <div id="range3.js" data-type="example">
        <h5><span class="label">Example 9-3. </span>The Range class rewritten using <em>class</em></h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Range</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// Store the start and end points (state) of this new range object.</code>
                <code class="c1">// These are noninherited properties that are unique to this object.</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">from</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">to</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="c1">// Return true if x is in the range, false otherwise</code>
            <code class="c1">// This method works for textual and Date ranges as well as numeric.</code>
            <code class="nx">includes</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&lt;=</code> <code class="nx">x</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="c1">// A generator function that makes instances of the class iterable.</code>
            <code class="c1">// Note that it only works for numeric ranges.</code>
            <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="p">);</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="nx">x</code><code class="o">++</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="c1">// Return a string representation of the range</code>
            <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`(</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="si">}</code><code class="sb">...</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="si">}</code><code class="sb">)`</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// Here are example uses of this new Range class</code>
        <code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Range</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>   <code class="c1">// Create a Range object</code>
        <code class="nx">r</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>             <code class="c1">// =&gt; true: 2 is in the range</code>
        <code class="nx">r</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>              <code class="c1">// =&gt; "(1...3)"</code>
        <code class="p">[...</code><code class="nx">r</code><code class="p">]</code>                    <code class="c1">// =&gt; [1, 2, 3]; convert to an array via iterator</code></pre></div>
        
        <p>It is important to understand that the classes defined in Examples <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range2.js">9-2</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="#range3.js">9-3</a> work in exactly the same way. The
        introduction of the <code>class</code> keyword to the language does not alter the
        fundamental nature of JavaScript’s prototype-based classes. And
        although <a data-type="xref" href="#range3.js">Example&nbsp;9-3</a> uses the <code>class</code> keyword, the resulting Range
        object is a constructor function, just like the version defined in
        <a data-type="xref" href="#range2.js">Example&nbsp;9-2</a>. The new <code>class</code> syntax is clean and convenient but is
        best thought of as “syntactic sugar” for the more fundamental class
        definition mechanism shown in <a data-type="xref" href="#range2.js">Example&nbsp;9-2</a>.</p>
        
        <p>Note the following things about the class syntax in <a data-type="xref" href="#range3.js">Example&nbsp;9-3</a>:</p>
        
        <ul>
        <li>
        <p>The class is declared with the <code>class</code> keyword, which is followed by
        the name of class and a class body in curly braces.</p>
        </li>
        <li>
        <p>The class body includes method definitions that use object literal
        method shorthand (which we also used in <a data-type="xref" href="#range1.js">Example&nbsp;9-1</a>), where the
        <code>function</code> keyword is omitted. Unlike object literals, however, no
        commas are used to separate the methods from each other. (Although
        class bodies are superficially similar to object literals, they are
        not the same thing. In particular, they do not support the
        definition of properties with name/value pairs.)</p>
        </li>
        <li>
        <p>The keyword <code>constructor</code> is used to define the constructor function
        for the class. The function defined is not actually named
        “constructor”, however. The <code>class</code> declaration statement defines a
        new variable <code>Range</code> and assigns the value of this special
        <code>constructor</code> function to that variable.</p>
        </li>
        <li>
        <p>If your class does not need to do any initialization, you can omit
        the <code>constructor</code> keyword and its body, and an empty constructor
        function will be implicitly created for you.</p>
        </li>
        </ul>
        
        <p>If you want to define a class that subclasses—or <em>inherits
        from</em>—another class, you can use the <code>extends</code> keyword with the
        <code>class</code> keyword:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// A Span is like a Range, but instead of initializing it with</code>
        <code class="c1">// a start and an end, we initialize it with a start and a length</code>
        <code class="kr">class</code> <code class="nx">Span</code> <code class="kr">extends</code> <code class="nx">Range</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">length</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">length</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                    <code class="kr">super</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">start</code> <code class="o">+</code> <code class="nx">length</code><code class="p">);</code>
                <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                    <code class="kr">super</code><code class="p">(</code><code class="nx">start</code> <code class="o">+</code> <code class="nx">length</code><code class="p">,</code> <code class="nx">start</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>Creating subclasses is a whole topic of its own. We’ll return to it,
        and explain the <code>extends</code> and <code>super</code> keywords shown here, in
        <a data-type="xref" href="#subclasses">§9.5</a>.</p>
        
        <p>Like function declarations, class declarations have both statement and
        expression forms. Just as we can write:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">square</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code> <code class="p">};</code>
        <code class="nx">square</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>  <code class="c1">// =&gt; 9</code></pre>
        
        <p>we can also write:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">Square</code> <code class="o">=</code> <code class="kr">class</code> <code class="p">{</code> <code class="nx">constructor</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">area</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code> <code class="p">}</code> <code class="p">};</code>
        <code class="k">new</code> <code class="nx">Square</code><code class="p">(</code><code class="mi">3</code><code class="p">).</code><code class="nx">area</code>  <code class="c1">// =&gt; 9</code></pre>
        
        <p>As with function definition expressions, class definition expressions
        can include an optional class name. If you provide such a name, that
        name is only defined within the class body itself.</p>
        
        <p>Although function expressions are quite common (particularly with the
        arrow function shorthand), in JavaScript programming, class definition
        expressions are not something that you are likely to use much unless
        you find yourself writing a function that takes a class as its
        argument and returns a subclass.</p>
        
        <p>We’ll conclude this introduction to the <code>class</code> keyword by mentioning
        a couple of important things you should know that are not apparent
        from <code>class</code> syntax:</p>
        
        <ul>
        <li>
        <p>All<a data-type="indexterm" data-primary="strict mode" data-secondary="default application of" id="idm46198534657656"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="default application of strict mode" id="idm46198534656648"></a> code within the body of a <code>class</code> declaration is implicitly in
        strict mode (<a data-type="xref" href="ch05.html#strictmode">§5.6.3</a>), even if no <code>"use strict"</code> directive
        appears. This means, for example, that you can’t use octal integer
        literals or the <code>with</code> statement within class bodies and that you
        are more likely to get syntax errors if you forget to declare a
        variable before using it.</p>
        </li>
        <li>
        <p>Unlike function declarations, class declarations are not
        “hoisted.” Recall from <a data-type="xref" href="ch08.html#functiondeclarations">§8.1.1</a> that function definitions
        behave as if they had been moved to the top of the enclosing file or
        enclosing function, meaning that you can invoke a function in code
        that comes before the actual definition of the function. Although
        class declarations are like function declarations in some ways, they
        do not share this hoisting behavior: you <em>cannot</em> instantiate a
        class before you declare it.</p>
        </li>
        </ul>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.3.1 Static Methods"><div class="sect2" id="idm46198534650616">
        <h2>9.3.1 Static Methods</h2>
        
        <p>You<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" data-tertiary="static methods" id="idm46198534649048"></a><a data-type="indexterm" data-primary="methods" data-secondary="static methods" id="idm46198534647800"></a><a data-type="indexterm" data-primary="static methods" id="idm46198534646856"></a> can define a static method within a <code>class</code> body by prefixing the
        method declaration with the <code>static</code> keyword. Static methods are
        defined as properties of the constructor function rather than
        properties of the prototype object.</p>
        
        <p>For example, suppose we added the following code to <a data-type="xref" href="#range3.js">Example&nbsp;9-3</a>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">static</code> <code class="nx">parse</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">matches</code> <code class="o">=</code> <code class="nx">s</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="sr">/^\((\d+)\.\.\.(\d+)\)$/</code><code class="p">);</code>
            <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">matches</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`Cannot parse Range from "</code><code class="si">${</code><code class="nx">s</code><code class="si">}</code><code class="sb">".`</code><code class="p">)</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nx">Range</code><code class="p">(</code><code class="nb">parseInt</code><code class="p">(</code><code class="nx">matches</code><code class="p">[</code><code class="mi">1</code><code class="p">]),</code> <code class="nb">parseInt</code><code class="p">(</code><code class="nx">matches</code><code class="p">[</code><code class="mi">2</code><code class="p">]));</code>
        <code class="p">}</code></pre>
        
        <p>The method defined by this code is <code>Range.parse()</code>, not
        <code>Range.prototype.parse()</code>, and you must invoke it through the
        constructor, not through an instance:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="nx">Range</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="s1">'(1...10)'</code><code class="p">);</code> <code class="c1">// Returns a new Range object</code>
        <code class="nx">r</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="s1">'(1...10)'</code><code class="p">);</code>             <code class="c1">// TypeError: r.parse is not a function</code></pre>
        
        <p>You’ll<a data-type="indexterm" data-primary="class methods" id="idm46198534552680"></a><a data-type="indexterm" data-primary="methods" data-secondary="class versus instance methods" id="idm46198534552072"></a> sometimes see static methods called <em>class methods</em> because
        they are invoked using the name of the class/constructor. When this
        term is used, it is to contrast class methods with the<a data-type="indexterm" data-primary="instance methods" id="idm46198534488552"></a> regular
        <em>instance methods</em> that are invoked on instances of the class.
        Because static methods are invoked on the constructor rather than on
        any particular instance, it almost never makes sense to use the <code>this</code>
        keyword in a static method.</p>
        
        <p>We’ll see examples of static methods in <a data-type="xref" href="#Complex.js">Example&nbsp;9-4</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.3.2 Getters, Setters, and other Method Forms"><div class="sect2" id="idm46198534485400">
        <h2>9.3.2 Getters, Setters, and other Method Forms</h2>
        
        <p>Within<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" data-tertiary="getters, setters, and other method forms" id="idm46198534483880"></a><a data-type="indexterm" data-primary="getter methods" id="idm46198534482536"></a><a data-type="indexterm" data-primary="setter methods" id="idm46198534481864"></a> a <code>class</code> body, you can define getter and setter methods
        (<a data-type="xref" href="ch06.html#gettersandsetters">§6.10.6</a>) just as you can in object literals. The only
        difference is that in class bodies, you don’t put a comma after the
        getter or setter. <a data-type="xref" href="#Complex.js">Example&nbsp;9-4</a> includes a practical example of a
        getter method in a class.</p>
        
        <p>In general, all of the<a data-type="indexterm" data-primary="shorthand methods" id="idm46198534540968"></a><a data-type="indexterm" data-primary="methods" data-secondary="shorthand methods" id="idm46198534540232"></a> shorthand method definition syntaxes
        allowed in object literals are also allowed in class bodies. This
        includes generator methods (marked with <code>*</code>) and methods whose names
        are the value of an expression in square brackets. In fact, you’ve
        already seen (in <a data-type="xref" href="#range3.js">Example&nbsp;9-3</a>) a generator method with a computed
        name that makes the Range class iterable:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">ceil</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="p">);</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="nx">x</code><code class="o">++</code><code class="p">)</code> <code class="k">yield</code> <code class="nx">x</code><code class="p">;</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.3.3 Public, Private, and Static Fields"><div class="sect2" id="idm46198534402296">
        <h2>9.3.3 Public, Private, and Static Fields</h2>
        
        <p>In<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" data-tertiary="public private, and static fields" id="Ckeypub09"></a><a data-type="indexterm" data-primary="public fields" id="idm46198534439224"></a><a data-type="indexterm" data-primary="private fields" id="idm46198534438552"></a><a data-type="indexterm" data-primary="static fields" id="idm46198534437880"></a><a data-type="indexterm" data-primary="fields, public, private, and static" id="idm46198534437208"></a> the discussion here of classes defined with the <code>class</code> keyword,
        we have only described the definition of methods within the class
        body. The ES6 standard only allows the creation of methods (including
        getters, setters, and generators) and static methods; it does not
        include syntax for defining fields. If you want to define a field
        (which is just an object-oriented synonym for “property”) on a class
        instance, you must do that in the constructor function or in one of
        the methods. And if you want to define a static field for a class, you
        must do that outside the class body, after the class has been
        defined. <a data-type="xref" href="#Complex.js">Example&nbsp;9-4</a> includes examples of both kinds of fields.</p>
        
        <p>Standardization is underway, however, for extended class syntax that
        allows the definition of instance and static fields, in both public
        and private forms. The code shown in the rest of this section is not
        yet standard JavaScript as of early 2020 but is already supported in Chrome
         and partially supported (public instance fields only) in Firefox. The
        syntax for public instance fields is in common use by JavaScript
        programmers using the React framework and the Babel transpiler.</p>
        
        <p>Suppose you’re writing a class like this one, with a constructor that
        initializes three fields:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Buffer</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">size</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">capacity</code> <code class="o">=</code> <code class="mi">4096</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">buffer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">capacity</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>With the new instance field syntax that is likely to be standardized,
        you could instead write:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Buffer</code> <code class="p">{</code>
            <code class="nx">size</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
            <code class="nx">capacity</code> <code class="o">=</code> <code class="mi">4096</code><code class="p">;</code>
            <code class="nx">buffer</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">capacity</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>The field initialization code has moved out of the constructor and now
        appears directly in the class body. (That code is still run as part of
        the constructor, of course. If you do not define a constructor, the
        fields are initialized as part of the implicitly created constructor.)
        The <code>this.</code> prefixes that appeared on the lefthand side of the
        assignments are gone, but note that you still must use
        <code>this.</code> to refer to these fields, even on the righthand side of the
        initializer assignments. The advantage of initializing your instance
        fields in this way is that this syntax allows (but does not require)
        you to put the initializers up at the top of the class definition,
        making it clear to readers exactly what fields will hold the state of
        each instance. You can declare fields without an initializer by just
        writing the name of the field followed by a semicolon. If you do that,
        the initial value of the field will be <code>undefined</code>. It is better style
        to always make the initial value explicit for all of your class
        fields.</p>
        
        <p>Before the addition of this field syntax, class bodies looked a lot
        like object literals using shortcut method syntax, except that the
        commas had been removed. This field syntax—with equals signs and
        semicolons instead of colons and commas—makes it clear that
        class bodies are not at all the same as object literals.</p>
        
        <p>The same proposal that seeks to standardize these instance fields also
        defines private instance fields. If you use the instance field
        initialization syntax shown in the previous example to define a field whose name begins
        with <code>#</code> (which is not normally a legal character in JavaScript
        identifiers), that field will be usable (with the <code>#</code> prefix) within
        the class body but will be invisible and inaccessible (and therefore
        immutable) to any code outside of the class body. If, for the preceding hypothetical Buffer class, you wanted to ensure that users of the
        class could not inadvertently modify the <code>size</code> field of an instance,
        you could use a private <code>#size</code> field instead, then define a getter
        function to provide read-only access to the value:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Buffer</code> <code class="p">{</code>
            <code class="err">#</code><code class="nx">size</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
            <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="err">#</code><code class="nx">size</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>Note that private fields must be declared using this new field syntax
        before they can be used. You can’t just write <code>this.#size = 0;</code> in the
        constructor of a class unless you include a “declaration” of the field
        directly in the class body.</p>
        
        <p>Finally, a related proposal seeks to standardize the use of the
        <code>static</code> keyword for fields. If you add <code>static</code> before a public or
        private field declaration, those fields will be created as properties
        of the constructor function instead of properties of
        instances. Consider the static <code>Range.parse()</code> method we’ve defined. It included a fairly complex regular expression that might be
        good to factor out into its own static field. With the proposed new
        static field syntax, we could do that like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">static</code> <code class="nx">integerRangePattern</code> <code class="o">=</code> <code class="sr">/^\((\d+)\.\.\.(\d+)\)$/</code><code class="p">;</code>
        <code class="kr">static</code> <code class="nx">parse</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">matches</code> <code class="o">=</code> <code class="nx">s</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="nx">Range</code><code class="p">.</code><code class="nx">integerRangePattern</code><code class="p">);</code>
            <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">matches</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`Cannot parse Range from "</code><code class="si">${</code><code class="nx">s</code><code class="si">}</code><code class="sb">".`</code><code class="p">)</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nx">Range</code><code class="p">(</code><code class="nb">parseInt</code><code class="p">(</code><code class="nx">matches</code><code class="p">[</code><code class="mi">1</code><code class="p">]),</code> <code class="nx">matches</code><code class="p">[</code><code class="mi">2</code><code class="p">]);</code>
        <code class="p">}</code></pre>
        
        <p>If we wanted this static field to be accessible only within the class,
        we could make it private using a name like <code>#pattern</code>.<a data-type="indexterm" data-primary="" data-startref="Ckeypub09" id="idm46198534186536"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.3.4 Example: A Complex Number Class"><div class="sect2" id="idm46198534441880">
        <h2>9.3.4 Example: A Complex Number Class</h2>
        
        <p><a data-type="xref" href="#Complex.js">Example&nbsp;9-4</a> defines<a data-type="indexterm" data-primary="classes" data-secondary="classes with class keyword" data-tertiary="complex number class example" id="Ckeycomp09"></a> a class to represent complex numbers. The
        class is a relatively simple one, but it includes instance methods
        (including getters), static methods, instance fields, and static
        fields. It includes some commented-out code demonstrating how we might
        use the not-yet-standard syntax for defining instance fields and
        static fields within the class body.</p>
        <div id="Complex.js" data-type="example">
        <h5><span class="label">Example 9-4. </span>Complex.js: a complex number class</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="cm">/**</code>
        <code class="cm"> * Instances of this Complex class represent complex numbers.</code>
        <code class="cm"> * Recall that a complex number is the sum of a real number and an</code>
        <code class="cm"> * imaginary number and that the imaginary number i is the square root of -1.</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">Complex</code> <code class="p">{</code>
            <code class="c1">// Once class field declarations are standardized, we could declare</code>
            <code class="c1">// private fields to hold the real and imaginary parts of a complex number</code>
            <code class="c1">// here, with code like this:</code>
            <code class="c1">//</code>
            <code class="c1">// #r = 0;</code>
            <code class="c1">// #i = 0;</code>
        
            <code class="c1">// This constructor function defines the instance fields r and i on every</code>
            <code class="c1">// instance it creates. These fields hold the real and imaginary parts of</code>
            <code class="c1">// the complex number: they are the state of the object.</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">real</code><code class="p">,</code> <code class="nx">imaginary</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">=</code> <code class="nx">real</code><code class="p">;</code>       <code class="c1">// This field holds the real part of the number.</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">=</code> <code class="nx">imaginary</code><code class="p">;</code>  <code class="c1">// This field holds the imaginary part.</code>
            <code class="p">}</code>
        
            <code class="c1">// Here are two instance methods for addition and multiplication</code>
            <code class="c1">// of complex numbers. If c and d are instances of this class, we</code>
            <code class="c1">// might write c.plus(d) or d.times(c)</code>
            <code class="nx">plus</code><code class="p">(</code><code class="nx">that</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">+</code> <code class="nx">that</code><code class="p">.</code><code class="nx">r</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">+</code> <code class="nx">that</code><code class="p">.</code><code class="nx">i</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="nx">times</code><code class="p">(</code><code class="nx">that</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">*</code> <code class="nx">that</code><code class="p">.</code><code class="nx">r</code> <code class="o">-</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">*</code> <code class="nx">that</code><code class="p">.</code><code class="nx">i</code><code class="p">,</code>
                                   <code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">*</code> <code class="nx">that</code><code class="p">.</code><code class="nx">i</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">*</code> <code class="nx">that</code><code class="p">.</code><code class="nx">r</code><code class="p">);</code>
            <code class="p">}</code>
        
            <code class="c1">// And here are static variants of the complex arithmetic methods.</code>
            <code class="c1">// We could write Complex.sum(c,d) and Complex.product(c,d)</code>
            <code class="kr">static</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">c</code><code class="p">,</code> <code class="nx">d</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">c</code><code class="p">.</code><code class="nx">plus</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="p">}</code>
            <code class="kr">static</code> <code class="nx">product</code><code class="p">(</code><code class="nx">c</code><code class="p">,</code> <code class="nx">d</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">c</code><code class="p">.</code><code class="nx">times</code><code class="p">(</code><code class="nx">d</code><code class="p">);</code> <code class="p">}</code>
        
            <code class="c1">// These are some instance methods that are defined as getters</code>
            <code class="c1">// so they're used like fields. The real and imaginary getters would</code>
            <code class="c1">// be useful if we were using private fields this.#r and this.#i</code>
            <code class="nx">get</code> <code class="nx">real</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">get</code> <code class="nx">imaginary</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">get</code> <code class="nx">magnitude</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">hypot</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">i</code><code class="p">);</code> <code class="p">}</code>
        
            <code class="c1">// Classes should almost always have a toString() method</code>
            <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`{</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="si">}</code><code class="sb">,</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">i</code><code class="si">}</code><code class="sb">}`</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="c1">// It is often useful to define a method for testing whether</code>
            <code class="c1">// two instances of your class represent the same value</code>
            <code class="nx">equals</code><code class="p">(</code><code class="nx">that</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nx">that</code> <code class="k">instanceof</code> <code class="nx">Complex</code> <code class="o">&amp;&amp;</code>
                    <code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">===</code> <code class="nx">that</code><code class="p">.</code><code class="nx">r</code> <code class="o">&amp;&amp;</code>
                    <code class="k">this</code><code class="p">.</code><code class="nx">i</code> <code class="o">===</code> <code class="nx">that</code><code class="p">.</code><code class="nx">i</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="c1">// Once static fields are supported inside class bodies, we could</code>
            <code class="c1">// define a useful Complex.ZERO constant like this:</code>
            <code class="c1">// static ZERO = new Complex(0,0);</code>
        <code class="p">}</code>
        
        <code class="c1">// Here are some class fields that hold useful predefined complex numbers.</code>
        <code class="nx">Complex</code><code class="p">.</code><code class="nx">ZERO</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">0</code><code class="p">);</code>
        <code class="nx">Complex</code><code class="p">.</code><code class="nx">ONE</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">0</code><code class="p">);</code>
        <code class="nx">Complex</code><code class="p">.</code><code class="nx">I</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">1</code><code class="p">);</code></pre></div>
        
        <p>With the Complex class of <a data-type="xref" href="#Complex.js">Example&nbsp;9-4</a> defined, we can use the constructor,
        instance fields, instance methods, class fields, and class methods with code
        like<a data-type="indexterm" data-primary="" data-startref="Cckey09" id="idm46198534170712"></a><a data-type="indexterm" data-primary="" data-startref="class09" id="idm46198534169864"></a><a data-type="indexterm" data-primary="" data-startref="Kclass09" id="idm46198534168920"></a><a data-type="indexterm" data-primary="" data-startref="ESclass09" id="idm46198534167976"></a><a data-type="indexterm" data-primary="" data-startref="Ckeycomp09" id="idm46198534167032"></a> this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">);</code>     <code class="c1">// Create a new object with the constructor</code>
        <code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="nx">c</code><code class="p">.</code><code class="nx">i</code><code class="p">,</code> <code class="nx">c</code><code class="p">.</code><code class="nx">r</code><code class="p">);</code> <code class="c1">// Use instance fields of c</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">plus</code><code class="p">(</code><code class="nx">d</code><code class="p">).</code><code class="nx">toString</code><code class="p">()</code>           <code class="c1">// =&gt; "{5,5}"; use instance methods</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">magnitude</code>                    <code class="c1">// =&gt; Math.hypot(2,3); use a getter function</code>
        <code class="nx">Complex</code><code class="p">.</code><code class="nx">product</code><code class="p">(</code><code class="nx">c</code><code class="p">,</code> <code class="nx">d</code><code class="p">)</code>          <code class="c1">// =&gt; new Complex(0, 13); a static method</code>
        <code class="nx">Complex</code><code class="p">.</code><code class="nx">ZERO</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>        <code class="c1">// =&gt; "{0,0}"; a static property</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="9.4 Adding Methods to Existing Classes"><div class="sect1" id="augmentingclasses">
        <h1>9.4 Adding Methods to Existing Classes</h1>
        
        <p>JavaScript’s<a data-type="indexterm" data-primary="classes" data-secondary="adding methods to existing classes" id="idm46198533749624"></a><a data-type="indexterm" data-primary="methods" data-secondary="adding methods to existing classes" id="idm46198533748584"></a> prototype-based inheritance mechanism is dynamic: an
        object inherits properties from its prototype, even if the properties
        of the prototype change after the object is created. This means that
        we can augment JavaScript classes simply by adding new methods to
        their prototype objects.</p>
        
        <p>Here, for example, is code that adds a method for computing the complex conjugate to the Complex class of <a data-type="xref" href="#Complex.js">Example&nbsp;9-4</a>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Return a complex number that is the complex conjugate of this one.</code>
        <code class="nx">Complex</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">conj</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">new</code> <code class="nx">Complex</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="p">,</code> <code class="o">-</code><code class="k">this</code><code class="p">.</code><code class="nx">i</code><code class="p">);</code> <code class="p">};</code></pre>
        
        <p>The prototype object of built-in JavaScript classes is also open like
        this, which means that we can add methods to numbers, strings, arrays,
        functions, and so on. This is useful for implementing new language
        features in older versions of the language:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// If the new String method startsWith() is not already defined...</code>
        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nb">String</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// ...then define it like this using the older indexOf() method.</code>
            <code class="nb">String</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">startsWith</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="o">===</code> <code class="mi">0</code><code class="p">;</code>
            <code class="p">};</code>
        <code class="p">}</code></pre>
        
        <p>Here is another example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Invoke the function f this many times, passing the iteration number</code>
        <code class="c1">// For example, to print "hello" 3 times:</code>
        <code class="c1">//     let n = 3;</code>
        <code class="c1">//     n.times(i =&gt; { console.log(`hello ${i}`); });</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">times</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="nx">context</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">valueOf</code><code class="p">();</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">n</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">f</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">context</code><code class="p">,</code> <code class="nx">i</code><code class="p">);</code>
        <code class="p">};</code></pre>
        
        <p>Adding methods to the prototypes of built-in types like this is
        generally considered to be a bad idea because it will cause confusion
        and compatibility problems in the future if a new version of
        JavaScript defines a method with the same name. It is even possible to
        add methods to <code>Object.prototype</code>, making them available for all
        objects. But this is never a good thing to do because properties added
        to <code>Object.prototype</code> are visible to <code>for/in</code> loops (though you can
        avoid this by using <code>Object.defineProperty()</code>
        [<a data-type="xref" href="ch14.html#propertydescriptors">§14.1</a>] to make the new property non-enumerable).</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="9.5 Subclasses"><div class="sect1" id="subclasses">
        <h1>9.5 Subclasses</h1>
        
        <p>In<a data-type="indexterm" data-primary="subclasses" data-secondary="overview of" id="idm46198533592680"></a><a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="overview of" id="idm46198533591672"></a> object-oriented programming, a class B can <em>extend</em> or <em>subclass</em>
        another class A. We say that A is the <em>superclass</em> and B is the
        <em>subclass</em>. Instances of B inherit the methods of A. The class B can
        define its own methods, some of which may <em>override</em> methods of the
        same name defined by class A. If a method of B overrides a method of
        A, the overriding method in B often needs to invoke the overridden
        method in A. Similarly, the subclass constructor <code>B()</code> must typically
        invoke the superclass constructor <code>A()</code> in order to ensure that
        instances are completely initialized.</p>
        
        <p>This section starts by showing how to define subclasses the old,
        pre-ES6 way, and then quickly moves on to demonstrate subclassing
        using the <code>class</code> and <code>extends</code> keywords and superclass constructor
        method invocation with the <code>super</code> keyword. Next is a
        subsection about avoiding subclasses and relying on object
        composition instead of inheritance. The section ends with an extended
        example that defines a hierarchy of Set classes and demonstrates how
        abstract classes can be used to separate interface from
        implementation.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.5.1 Subclasses and Prototypes"><div class="sect2" id="idm46198533497944">
        <h2>9.5.1 Subclasses and Prototypes</h2>
        
        <p>Suppose<a data-type="indexterm" data-primary="subclasses" data-secondary="prototypes and" id="idm46198533496184"></a><a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="subclasses and prototypes" id="idm46198533495176"></a> we wanted to define a Span subclass of the Range class from
        <a data-type="xref" href="#range2.js">Example&nbsp;9-2</a>. This subclass will work just like a Range, but instead
        of initializing it with a start and an end, we’ll instead specify a
        start and a distance, or span. An instance of this Span class is also
        an instance of the Range superclass. A span instance inherits a
        customized <code>toString()</code> method from <code>Span.prototype</code>, but in order to
        be a subclass of Range, it must also inherit methods (such as
        <code>includes()</code>) from <code>Range.prototype</code>.</p>
        <div id="Span.js" data-type="example">
        <h5><span class="label">Example 9-5. </span>Span.js: a simple subclass of Range</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This is the constructor function for our subclass</code>
        <code class="kd">function</code> <code class="nx">Span</code><code class="p">(</code><code class="nx">start</code><code class="p">,</code> <code class="nx">span</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">span</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">start</code> <code class="o">+</code> <code class="nx">span</code><code class="p">;</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">start</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">start</code> <code class="o">+</code> <code class="nx">span</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// Ensure that the Span prototype inherits from the Range prototype</code>
        <code class="nx">Span</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code>
        
        <code class="c1">// We don't want to inherit Range.prototype.constructor, so we</code>
        <code class="c1">// define our own constructor property.</code>
        <code class="nx">Span</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">constructor</code> <code class="o">=</code> <code class="nx">Span</code><code class="p">;</code>
        
        <code class="c1">// By defining its own toString() method, Span overrides the</code>
        <code class="c1">// toString() method that it would otherwise inherit from Range.</code>
        <code class="nx">Span</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="sb">`(</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="si">}</code><code class="sb">... +</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">-</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="si">}</code><code class="sb">)`</code><code class="p">;</code>
        <code class="p">};</code></pre></div>
        
        <p>In order to make Span a subclass of Range, we need to arrange for
        <code>Span.prototype</code> to inherit from <code>Range.prototype</code>. The key line of
        code in the preceding example is this one, and if it makes sense to you, you
        understand how subclasses work in JavaScript:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">Span</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">Range</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code></pre>
        
        <p>Objects created with the <code>Span()</code> constructor will inherit from the
        <code>Span.prototype</code> object. But we created that object to inherit from
        <code>Range.prototype</code>, so Span objects will inherit from both
        <code>Span.prototype</code> and <code>Range.prototype</code>.</p>
        
        <p>You may notice that our <code>Span()</code> constructor sets the same <code>from</code> and
        <code>to</code> properties that the <code>Range()</code> constructor does and so does not
        need to invoke the <code>Range()</code> constructor to initialize the new
        object. Similarly, Span’s <code>toString()</code> method completely re-implements
        the string conversion without needing to call Range’s version of
        <code>toString()</code>. This makes Span a special case, and we can only really
        get away with this kind of subclassing because we know the
        implementation details of the superclass. A robust subclassing
        mechanism needs to allow classes to invoke the methods and constructor
        of their superclass, but prior to ES6, JavaScript did not have a
        simple way to do these things.</p>
        
        <p>Fortunately, ES6 solves these problems with the <code>super</code> keyword as
        part of the <code>class</code> syntax. The next section demonstrates how it
        works.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.5.2 Subclasses with extends and super"><div class="sect2" id="extendsandsuper">
        <h2>9.5.2 Subclasses with extends and super</h2>
        
        <p>In<a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="with extends clause" id="Csubext09"></a><a data-type="indexterm" data-primary="subclasses" data-secondary="with extends clause" id="subext09"></a><a data-type="indexterm" data-primary="ES6" data-secondary="subclasses with extends clause" id="ESsubext09"></a> ES6 and later, you can create a superclass simply by adding an
        <code>extends</code> clause to a class declaration, and you can do this even for
        built-in classes:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// A trivial Array subclass that adds getters for the first and last elements.</code>
        <code class="kr">class</code> <code class="nx">EZArray</code> <code class="kr">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="nx">get</code> <code class="nx">first</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code> <code class="p">}</code>
            <code class="nx">get</code> <code class="nx">last</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">];</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">EZArray</code><code class="p">();</code>
        <code class="nx">a</code> <code class="k">instanceof</code> <code class="nx">EZArray</code>  <code class="c1">// =&gt; true: a is subclass instance</code>
        <code class="nx">a</code> <code class="k">instanceof</code> <code class="nb">Array</code>    <code class="c1">// =&gt; true: a is also a superclass instance.</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">);</code>      <code class="c1">// a.length == 4; we can use inherited methods</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">pop</code><code class="p">()</code>               <code class="c1">// =&gt; 4: another inherited method</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">first</code>               <code class="c1">// =&gt; 1: first getter defined by subclass</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">last</code>                <code class="c1">// =&gt; 3: last getter defined by subclass</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>                  <code class="c1">// =&gt; 2: regular array access syntax still works.</code>
        <code class="nb">Array</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code>      <code class="c1">// =&gt; true: subclass instance really is an array</code>
        <code class="nx">EZArray</code><code class="p">.</code><code class="nx">isArray</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code>    <code class="c1">// =&gt; true: subclass inherits static methods, too!</code></pre>
        
        <p>This EZArray subclass defines two simple getter methods. Instances of
        EZArray behave like ordinary arrays, and we can use inherited methods
        and properties like <code>push()</code>, <code>pop()</code>, and <code>length</code>. But we can also
        use the <code>first</code> and <code>last</code> getters defined in the subclass. Not only
        are instance methods like <code>pop()</code> inherited, but static methods like
        <code>Array.isArray</code> are also inherited. This is a new feature enabled by
        ES6 class syntax: <code>EZArray()</code> is a function, but it inherits from
        <code>Array()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// EZArray inherits instance methods because EZArray.prototype</code>
        <code class="c1">// inherits from Array.prototype</code>
        <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">EZArray</code><code class="p">.</code><code class="nx">prototype</code><code class="p">)</code> <code class="c1">// =&gt; true</code>
        
        <code class="c1">// And EZArray inherits static methods and properties because</code>
        <code class="c1">// EZArray inherits from Array. This is a special feature of the</code>
        <code class="c1">// extends keyword and is not possible before ES6.</code>
        <code class="nb">Array</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">EZArray</code><code class="p">)</code> <code class="c1">// =&gt; true</code></pre>
        
        <p>Our EZArray subclass is too simple to be very instructive.
        <a data-type="xref" href="#TypedMap.js">Example&nbsp;9-6</a> is a more fully fleshed-out example. It defines a
        TypedMap subclass of the built-in Map class that adds type checking to
        ensure that the keys and values of the map are of the specified types
        (according to <code>typeof</code>). Importantly, this example demonstrates the
        use of the <code>super</code> keyword to invoke the constructor and methods of
        the superclass.</p>
        <div id="TypedMap.js" data-type="example">
        <h5><span class="label">Example 9-6. </span>TypedMap.js: a subclass of Map that checks key and value types</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">TypedMap</code> <code class="kr">extends</code> <code class="nx">Map</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">keyType</code><code class="p">,</code> <code class="nx">valueType</code><code class="p">,</code> <code class="nx">entries</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// If entries are specified, check their types</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">entries</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="p">[</code><code class="nx">k</code><code class="p">,</code> <code class="nx">v</code><code class="p">]</code> <code class="k">of</code> <code class="nx">entries</code><code class="p">)</code> <code class="p">{</code>
                        <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">k</code> <code class="o">!==</code> <code class="nx">keyType</code> <code class="o">||</code> <code class="k">typeof</code> <code class="nx">v</code> <code class="o">!==</code> <code class="nx">valueType</code><code class="p">)</code> <code class="p">{</code>
                            <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`Wrong type for entry [</code><code class="si">${</code><code class="nx">k</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="nx">v</code><code class="si">}</code><code class="sb">]`</code><code class="p">);</code>
                        <code class="p">}</code>
                    <code class="p">}</code>
                <code class="p">}</code>
        
                <code class="c1">// Initialize the superclass with the (type-checked) initial entries</code>
                <code class="kr">super</code><code class="p">(</code><code class="nx">entries</code><code class="p">);</code>
        
                <code class="c1">// And then initialize this subclass by storing the types</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">keyType</code> <code class="o">=</code> <code class="nx">keyType</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">valueType</code> <code class="o">=</code> <code class="nx">valueType</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="c1">// Now redefine the set() method to add type checking for any</code>
            <code class="c1">// new entries added to the map.</code>
            <code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// Throw an error if the key or value are of the wrong type</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">keyType</code> <code class="o">&amp;&amp;</code> <code class="k">typeof</code> <code class="nx">key</code> <code class="o">!==</code> <code class="k">this</code><code class="p">.</code><code class="nx">keyType</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">key</code><code class="si">}</code><code class="sb"> is not of type </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">keyType</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">valueType</code> <code class="o">&amp;&amp;</code> <code class="k">typeof</code> <code class="nx">value</code> <code class="o">!==</code> <code class="k">this</code><code class="p">.</code><code class="nx">valueType</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">value</code><code class="si">}</code><code class="sb"> is not of type </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">valueType</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
                <code class="p">}</code>
        
                <code class="c1">// If the types are correct, we invoke the superclass's version of</code>
                <code class="c1">// the set() method, to actually add the entry to the map. And we</code>
                <code class="c1">// return whatever the superclass method returns.</code>
                <code class="k">return</code> <code class="kr">super</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code></pre></div>
        
        <p>The first two arguments to the <code>TypedMap()</code> constructor are the
        desired key and value types. These should be strings, such as “number”
        and “boolean”, that the <code>typeof</code> operator returns. You can also specify
        a third argument: an array (or any iterable object) of <code>[key,value]</code>
        arrays that specify the initial entries in the map. If you specify any
        initial entries, then the first thing the constructor does is verify
        that their types are correct. Next, the constructor invokes the
        superclass constructor, using the <code>super</code> keyword as if it was a
        function name. The <code>Map()</code> constructor takes one optional argument: an
        iterable object of <code>[key,value]</code> arrays. So the optional third
        argument of the <code>TypedMap()</code> constructor is the optional first
        argument to the <code>Map()</code> constructor, and we pass it to that superclass
        constructor with <code>super(entries)</code>.</p>
        
        <p>After invoking the superclass constructor to initialize superclass
        state, the <span class="keep-together"><code>TypedMap()</code></span> constructor next initializes its own subclass
        state by setting <code>this.keyType</code> and <code>this.valueType</code> to the specified
        types. It needs to set these properties so that it can use them again
        in the <code>set()</code> method.</p>
        
        <p>There are a few important rules that you will need to know about using <code>super()</code> in constructors:</p>
        
        <ul>
        <li>
        <p>If you define a class with the <code>extends</code> keyword, then the
        constructor for your class must use <code>super()</code> to invoke the
        superclass constructor.</p>
        </li>
        <li>
        <p>If you don’t define a constructor in your subclass, one will be
        defined automatically for you. This implicitly defined constructor
        simply takes whatever values are passed to it and passes those
        values to <code>super()</code>.</p>
        </li>
        <li>
        <p>You may not use the <code>this</code> keyword in your constructor until after
        you have invoked the superclass constructor with <code>super()</code>. This
        enforces a rule that superclasses get to initialize themselves
        before subclasses do.</p>
        </li>
        <li>
        <p>The special expression <code>new.target</code> is undefined in functions that
        are invoked without the <code>new</code> keyword. In constructor functions,
        however, <code>new.target</code> is a reference to the constructor that was
        invoked. When a subclass constructor is invoked and uses <code>super()</code>
        to invoke the superclass constructor, that superclass constructor
        will see the subclass constructor as the value of <code>new.target</code>. A
        well-designed superclass should not need to know whether it has been
        subclassed, but it might be useful to be able to use
        <code>new.target.name</code> in logging messages, for example.</p>
        </li>
        </ul>
        
        <p>After the constructor, the next part of <a data-type="xref" href="#TypedMap.js">Example&nbsp;9-6</a> is a method
        named <code>set()</code>. The Map superclass defines a method named <code>set()</code> to
        add a new entry to the map. We say that this <code>set()</code> method in
        TypedMap <em>overrides</em> the <code>set()</code> method of its superclass. This simple
        TypedMap subclass doesn’t know anything about adding new entries to
        map, but it does know how to check types, so that is what it does
        first, verifying that the key and value to be added to the map have
        the correct types and throwing an error if they do not. This <code>set()</code>
        method doesn’t have any way to add the key and value to the map
        itself, but that is what the superclass <code>set()</code> method is for. So we
        use the <code>super</code> keyword again to invoke the superclass’s version of
        the method. In this context, <code>super</code> works much like the <code>this</code>
        keyword does: it refers to the current object but allows access to
        overridden methods defined in the superclass.</p>
        
        <p>In constructors, you are required to invoke the superclass constructor
        before you can access <code>this</code> and initialize the new object
        yourself. There are no such rules when you override a method. A method
        that overrides a superclass method is not required to invoke the
        superclass method. If it does use <code>super</code> to invoke the overridden
        method (or any method) in the superclass, it can do that at the
        beginning or the middle or the end of the overriding method.</p>
        
        <p>Finally, before we leave the TypedMap example behind, it is worth
        noting that this class is an ideal candidate for the use of private
        fields. As the class is written now, a user could change the
        <code>keyType</code> or <code>valueType</code> properties to subvert the type checking. Once
        private fields are supported, we could change these properties to
        <code>#keyType</code> and <code>#valueType</code> so that they could not be altered from the
        outside.<a data-type="indexterm" data-primary="" data-startref="ESsubext09" id="idm46198532826424"></a><a data-type="indexterm" data-primary="" data-startref="subext09" id="idm46198532825448"></a><a data-type="indexterm" data-primary="" data-startref="Csubext09" id="idm46198532824504"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.5.3 Delegation Instead of Inheritance"><div class="sect2" id="idm46198533299720">
        <h2>9.5.3 Delegation Instead of Inheritance</h2>
        
        <p>The<a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="delegation versus inheritance" id="idm46198532821960"></a><a data-type="indexterm" data-primary="subclasses" data-secondary="delegation versus inheritance" id="idm46198532820712"></a><a data-type="indexterm" data-primary="delegation" id="idm46198532819752"></a><a data-type="indexterm" data-primary="inheritance" id="idm46198532819080"></a> <code>extends</code> keyword makes it easy to create subclasses. But that
        does not mean that you <em>should</em> create lots of subclasses. If you want
        to write a class that shares the behavior of some other class, you can
        try to inherit that behavior by creating a subclass. But it is often
        easier and more flexible to get that desired behavior into your class
        by having your class create an instance of the other class and simply
        delegating to that instance as needed. You create a new class not by
        subclassing, but instead by wrapping or “composing” other
        classes. This delegation approach is often called “composition,” and
        it is an oft-quoted maxim of object-oriented programming that one
        should “favor composition over inheritance.”<sup><a data-type="noteref" id="idm46198532816792-marker" href="ch09.html#idm46198532816792">2</a></sup></p>
        
        <p>Suppose, for example, we wanted a Histogram class that behaves
        something like <span class="keep-together">JavaScript’s</span> Set class, except that instead of just
        keeping track of whether a value has been added to set or not, it
        instead maintains a count of the number of times the value has been
        added. Because the API for this Histogram class is similar to Set, we
        might consider subclassing Set and adding a <code>count()</code> method. On the
        other hand, once we start thinking about how we might implement this
        <code>count()</code> method, we might realize that the Histogram class is more
        like a Map than a Set because it needs to maintain a mapping between
        values and the number of times they have been added. So instead of
        subclassing Set, we can create a class that defines a Set-like
        API but implements those methods by delegating to an internal Map
        object. <a data-type="xref" href="#Histogram.js">Example&nbsp;9-7</a> shows how we could do this.</p>
        <div id="Histogram.js" data-type="example">
        <h5><span class="label">Example 9-7. </span>Histogram.js: a Set-like class implemented with delegation</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="cm">/**</code>
        <code class="cm"> * A Set-like class that keeps track of how many times a value has</code>
        <code class="cm"> * been added. Call add() and remove() like you would for a Set, and</code>
        <code class="cm"> * call count() to find out how many times a given value has been added.</code>
        <code class="cm"> * The default iterator yields the values that have been added at least</code>
        <code class="cm"> * once. Use entries() if you want to iterate [value, count] pairs.</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">Histogram</code> <code class="p">{</code>
            <code class="c1">// To initialize, we just create a Map object to delegate to</code>
            <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">();</code> <code class="p">}</code>
        
            <code class="c1">// For any given key, the count is the value in the Map, or zero</code>
            <code class="c1">// if the key does not appear in the Map.</code>
            <code class="nx">count</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">||</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="c1">// The Set-like method has() returns true if the count is non-zero</code>
            <code class="nx">has</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="c1">// The size of the histogram is just the number of entries in the Map.</code>
            <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">size</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="c1">// To add a key, just increment its count in the Map.</code>
            <code class="nx">add</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">);</code> <code class="p">}</code>
        
            <code class="c1">// Deleting a key is a little trickier because we have to delete</code>
            <code class="c1">// the key from the Map if the count goes back down to zero.</code>
            <code class="k">delete</code><code class="p">(</code><code class="nx">key</code><code class="p">)</code> <code class="p">{</code>
                <code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">count</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">count</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="k">delete</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
                <code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">count</code> <code class="o">&gt;</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">count</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="c1">// Iterating a Histogram just returns the keys stored in it</code>
            <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">keys</code><code class="p">();</code> <code class="p">}</code>
        
            <code class="c1">// These other iterator methods just delegate to the Map object</code>
            <code class="nx">keys</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">keys</code><code class="p">();</code> <code class="p">}</code>
            <code class="nx">values</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">values</code><code class="p">();</code> <code class="p">}</code>
            <code class="nx">entries</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">map</code><code class="p">.</code><code class="nx">entries</code><code class="p">();</code> <code class="p">}</code>
        <code class="p">}</code></pre></div>
        
        <p>All the <code>Histogram()</code> constructor does in <a data-type="xref" href="#Histogram.js">Example&nbsp;9-7</a> is create a
        Map object. And most of the methods are one-liners that just delegate
        to a method of the map, making the implementation quite
        simple. Because we used delegation rather than inheritance, a
        Histogram object is not an instance of Set or Map. But Histogram
        implements a number of commonly used Set methods, and in an untyped
        language like JavaScript, that is often good enough: a formal
        inheritance relationship is sometimes nice, but often optional.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="9.5.4 Class Hierarchies and Abstract Classes"><div class="sect2" id="idm46198532805480">
        <h2>9.5.4 Class Hierarchies and Abstract Classes</h2>
        
        <p><a data-type="xref" href="#TypedMap.js">Example&nbsp;9-6</a> demonstrated<a data-type="indexterm" data-primary="classes" data-secondary="subclasses" data-tertiary="class hierarchies and abstract classes" id="Csubhier09"></a><a data-type="indexterm" data-primary="subclasses" data-secondary="class hierarchies and abstract classes" id="Shier09"></a><a data-type="indexterm" data-primary="abstract classes" id="abstc09"></a> how we can subclass Map. <a data-type="xref" href="#Histogram.js">Example&nbsp;9-7</a>
        demonstrated how we can instead delegate to a Map object without
        actually subclassing anything. Using JavaScript classes to encapsulate
        data and modularize your code is often a great technique, and you may
        find yourself using the <code>class</code> keyword frequently. But you may find
        that you prefer composition to inheritance and that you rarely need to
        use <code>extends</code> (except when you’re using a library or framework that
        requires you to extend its base classes).</p>
        
        <p>There are some circumstances when multiple levels of subclassing are
        appropriate, however, and we’ll end this chapter with an extended
        example that demonstrates a hierarchy of classes representing
        different kinds of sets. (The set classes defined in <a data-type="xref" href="#sets.js">Example&nbsp;9-8</a> are
        similar to, but not completely compatible with, JavaScript’s built-in
        Set class.)</p>
        
        <p><a data-type="xref" href="#sets.js">Example&nbsp;9-8</a> defines lots of subclasses, but it also demonstrates how
        you can define <em>abstract classes</em>—classes that do not include a
        complete implementation—to serve as a common superclass for a group
        of related subclasses. An abstract superclass can define a partial
        implementation that all subclasses inherit and share. The subclasses,
        then, only need to define their own unique behavior by implementing
        the abstract methods defined—but not implemented—by the superclass.
        Note that JavaScript does not have any formal definition of abstract
        methods or abstract classes; I’m simply using that name here for
        unimplemented methods and incompletely implemented classes.</p>
        
        <p><a data-type="xref" href="#sets.js">Example&nbsp;9-8</a> is well commented and stands on its own. I encourage you
        to read it as a capstone example for this chapter on classes. The
        final class in <a data-type="xref" href="#sets.js">Example&nbsp;9-8</a> does a lot of bit manipulation with the
        <code>&amp;</code>, <code>|</code>, and <code>~</code> operators, which you can review in <a data-type="xref" href="ch04.html#bitwiseoperators">§4.8.3</a>.</p>
        <div id="sets.js" data-type="example">
        <h5><span class="label">Example 9-8. </span>Sets.js: a hierarchy of abstract and concrete set classes</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="cm">/**</code>
        <code class="cm"> * The AbstractSet class defines a single abstract method, has().</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">AbstractSet</code> <code class="p">{</code>
            <code class="c1">// Throw an error here so that subclasses are forced</code>
            <code class="c1">// to define their own working version of this method.</code>
            <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="cm">/**</code>
        <code class="cm"> * NotSet is a concrete subclass of AbstractSet.</code>
        <code class="cm"> * The members of this set are all values that are not members of some</code>
        <code class="cm"> * other set. Because it is defined in terms of another set it is not</code>
        <code class="cm"> * writable, and because it has infinite members, it is not enumerable.</code>
        <code class="cm"> * All we can do with it is test for membership and convert it to a</code>
        <code class="cm"> * string using mathematical notation.</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">NotSet</code> <code class="kr">extends</code> <code class="nx">AbstractSet</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
                <code class="kr">super</code><code class="p">();</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">set</code> <code class="o">=</code> <code class="nx">set</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="c1">// Our implementation of the abstract method we inherited</code>
            <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">set</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code> <code class="p">}</code>
            <code class="c1">// And we also override this Object method</code>
            <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`{ x| x ∉ </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">set</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb"> }`</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="cm">/**</code>
        <code class="cm"> * Range set is a concrete subclass of AbstractSet. Its members are</code>
        <code class="cm"> * all values that are between the from and to bounds, inclusive.</code>
        <code class="cm"> * Since its members can be floating point numbers, it is not</code>
        <code class="cm"> * enumerable and does not have a meaningful size.</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">RangeSet</code> <code class="kr">extends</code> <code class="nx">AbstractSet</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">)</code> <code class="p">{</code>
                <code class="kr">super</code><code class="p">();</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">=</code> <code class="nx">from</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">to</code> <code class="o">=</code> <code class="nx">to</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">&gt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">from</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`{ x| </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">from</code><code class="si">}</code><code class="sb"> ≤ x ≤ </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">to</code><code class="si">}</code><code class="sb"> }`</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="cm">/*</code>
        <code class="cm"> * AbstractEnumerableSet is an abstract subclass of AbstractSet.  It defines</code>
        <code class="cm"> * an abstract getter that returns the size of the set and also defines an</code>
        <code class="cm"> * abstract iterator. And it then implements concrete isEmpty(), toString(),</code>
        <code class="cm"> * and equals() methods on top of those. Subclasses that implement the</code>
        <code class="cm"> * iterator, the size getter, and the has() method get these concrete</code>
        <code class="cm"> * methods for free.</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">AbstractEnumerableSet</code> <code class="kr">extends</code> <code class="nx">AbstractSet</code> <code class="p">{</code>
            <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>
            <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>
        
            <code class="nx">isEmpty</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">size</code> <code class="o">===</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`{</code><code class="si">${</code><code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code><code class="k">this</code><code class="p">).</code><code class="nx">join</code><code class="p">(</code><code class="s2">", "</code><code class="p">)</code><code class="si">}</code><code class="sb">}`</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">equals</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// If the other set is not also Enumerable, it isn't equal to this one</code>
                <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">set</code> <code class="k">instanceof</code> <code class="nx">AbstractEnumerableSet</code><code class="p">))</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
        
                <code class="c1">// If they don't have the same size, they're not equal</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">size</code> <code class="o">!==</code> <code class="nx">set</code><code class="p">.</code><code class="nx">size</code><code class="p">)</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
        
                <code class="c1">// Loop through the elements of this set</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// If an element isn't in the other set, they aren't equal</code>
                    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">set</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
                <code class="p">}</code>
        
                <code class="c1">// The elements matched, so the sets are equal</code>
                <code class="k">return</code> <code class="kc">true</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="cm">/*</code>
        <code class="cm"> * SingletonSet is a concrete subclass of AbstractEnumerableSet.</code>
        <code class="cm"> * A singleton set is a read-only set with a single member.</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">SingletonSet</code> <code class="kr">extends</code> <code class="nx">AbstractEnumerableSet</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">member</code><code class="p">)</code> <code class="p">{</code>
                <code class="kr">super</code><code class="p">();</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">member</code> <code class="o">=</code> <code class="nx">member</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="c1">// We implement these three methods, and inherit isEmpty, equals()</code>
            <code class="c1">// and toString() implementations based on these methods.</code>
            <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">===</code> <code class="k">this</code><code class="p">.</code><code class="nx">member</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="mi">1</code><code class="p">;</code> <code class="p">}</code>
            <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">yield</code> <code class="k">this</code><code class="p">.</code><code class="nx">member</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="cm">/*</code>
        <code class="cm"> * AbstractWritableSet is an abstract subclass of AbstractEnumerableSet.</code>
        <code class="cm"> * It defines the abstract methods insert() and remove() that insert and</code>
        <code class="cm"> * remove individual elements from the set, and then implements concrete</code>
        <code class="cm"> * add(), subtract(), and intersect() methods on top of those. Note that</code>
        <code class="cm"> * our API diverges here from the standard JavaScript Set class.</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">AbstractWritableSet</code> <code class="kr">extends</code>  <code class="nx">AbstractEnumerableSet</code> <code class="p">{</code>
            <code class="nx">insert</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>
            <code class="nx">remove</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"Abstract method"</code><code class="p">);</code> <code class="p">}</code>
        
            <code class="nx">add</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">this</code><code class="p">.</code><code class="nx">insert</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="nx">subtract</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">this</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="nx">intersect</code><code class="p">(</code><code class="nx">set</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="k">this</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">set</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">element</code><code class="p">))</code> <code class="p">{</code>
                        <code class="k">this</code><code class="p">.</code><code class="nx">remove</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
                    <code class="p">}</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="cm">/**</code>
        <code class="cm"> * A BitSet is a concrete subclass of AbstractWritableSet with a</code>
        <code class="cm"> * very efficient fixed-size set implementation for sets whose</code>
        <code class="cm"> * elements are non-negative integers less than some maximum size.</code>
        <code class="cm"> */</code>
        <code class="kr">class</code> <code class="nx">BitSet</code> <code class="kr">extends</code> <code class="nx">AbstractWritableSet</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">max</code><code class="p">)</code> <code class="p">{</code>
                <code class="kr">super</code><code class="p">();</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">max</code> <code class="o">=</code> <code class="nx">max</code><code class="p">;</code>  <code class="c1">// The maximum integer we can store.</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>      <code class="c1">// How many integers are in the set</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">numBytes</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">max</code> <code class="o">/</code> <code class="mi">8</code><code class="p">)</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code>   <code class="c1">// How many bytes we need</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">data</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">numBytes</code><code class="p">);</code> <code class="c1">// The bytes</code>
            <code class="p">}</code>
        
            <code class="c1">// Internal method to check if a value is a legal member of this set</code>
            <code class="nx">_valid</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&gt;=</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">max</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="c1">// Tests whether the specified bit of the specified byte of our</code>
            <code class="c1">// data array is set or not. Returns true or false.</code>
            <code class="nx">_has</code><code class="p">(</code><code class="kr">byte</code><code class="p">,</code> <code class="nx">bit</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">data</code><code class="p">[</code><code class="kr">byte</code><code class="p">]</code> <code class="o">&amp;</code> <code class="nx">BitSet</code><code class="p">.</code><code class="nx">bits</code><code class="p">[</code><code class="nx">bit</code><code class="p">])</code> <code class="o">!==</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="c1">// Is the value x in this BitSet?</code>
            <code class="nx">has</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_valid</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code> <code class="p">{</code>
                    <code class="kd">let</code> <code class="kr">byte</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">x</code> <code class="o">/</code> <code class="mi">8</code><code class="p">);</code>
                    <code class="kd">let</code> <code class="nx">bit</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">8</code><code class="p">;</code>
                    <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_has</code><code class="p">(</code><code class="kr">byte</code><code class="p">,</code> <code class="nx">bit</code><code class="p">);</code>
                <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                    <code class="k">return</code> <code class="kc">false</code><code class="p">;</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="c1">// Insert the value x into the BitSet</code>
            <code class="nx">insert</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_valid</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code> <code class="p">{</code>               <code class="c1">// If the value is valid</code>
                    <code class="kd">let</code> <code class="kr">byte</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">x</code> <code class="o">/</code> <code class="mi">8</code><code class="p">);</code>   <code class="c1">// convert to byte and bit</code>
                    <code class="kd">let</code> <code class="nx">bit</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">8</code><code class="p">;</code>
                    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="k">this</code><code class="p">.</code><code class="nx">_has</code><code class="p">(</code><code class="kr">byte</code><code class="p">,</code> <code class="nx">bit</code><code class="p">))</code> <code class="p">{</code>    <code class="c1">// If that bit is not set yet</code>
                        <code class="k">this</code><code class="p">.</code><code class="nx">data</code><code class="p">[</code><code class="kr">byte</code><code class="p">]</code> <code class="o">|=</code> <code class="nx">BitSet</code><code class="p">.</code><code class="nx">bits</code><code class="p">[</code><code class="nx">bit</code><code class="p">];</code> <code class="c1">// then set it</code>
                        <code class="k">this</code><code class="p">.</code><code class="nx">n</code><code class="o">++</code><code class="p">;</code>                            <code class="c1">// and increment set size</code>
                    <code class="p">}</code>
                <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s2">"Invalid set element: "</code> <code class="o">+</code> <code class="nx">x</code> <code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="nx">remove</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_valid</code><code class="p">(</code><code class="nx">x</code><code class="p">))</code> <code class="p">{</code>              <code class="c1">// If the value is valid</code>
                    <code class="kd">let</code> <code class="kr">byte</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nx">x</code> <code class="o">/</code> <code class="mi">8</code><code class="p">);</code>  <code class="c1">// compute the byte and bit</code>
                    <code class="kd">let</code> <code class="nx">bit</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">8</code><code class="p">;</code>
                    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">_has</code><code class="p">(</code><code class="kr">byte</code><code class="p">,</code> <code class="nx">bit</code><code class="p">))</code> <code class="p">{</code>    <code class="c1">// If that bit is already set</code>
                        <code class="k">this</code><code class="p">.</code><code class="nx">data</code><code class="p">[</code><code class="kr">byte</code><code class="p">]</code> <code class="o">&amp;=</code> <code class="nx">BitSet</code><code class="p">.</code><code class="nx">masks</code><code class="p">[</code><code class="nx">bit</code><code class="p">];</code>  <code class="c1">// then unset it</code>
                        <code class="k">this</code><code class="p">.</code><code class="nx">n</code><code class="o">--</code><code class="p">;</code>                              <code class="c1">// and decrement size</code>
                    <code class="p">}</code>
                <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s2">"Invalid set element: "</code> <code class="o">+</code> <code class="nx">x</code> <code class="p">);</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="c1">// A getter to return the size of the set</code>
            <code class="nx">get</code> <code class="nx">size</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">n</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="c1">// Iterate the set by just checking each bit in turn.</code>
            <code class="c1">// (We could be a lot more clever and optimize this substantially)</code>
            <code class="o">*</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="k">this</code><code class="p">.</code><code class="nx">max</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">i</code><code class="p">))</code> <code class="p">{</code>
                        <code class="k">yield</code> <code class="nx">i</code><code class="p">;</code>
                    <code class="p">}</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// Some pre-computed values used by the has(), insert() and remove() methods</code>
        <code class="nx">BitSet</code><code class="p">.</code><code class="nx">bits</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">16</code><code class="p">,</code> <code class="mi">32</code><code class="p">,</code> <code class="mi">64</code><code class="p">,</code> <code class="mi">128</code><code class="p">]);</code>
        <code class="nx">BitSet</code><code class="p">.</code><code class="nx">masks</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Uint8Array</code><code class="p">([</code><code class="o">~</code><code class="mi">1</code><code class="p">,</code> <code class="o">~</code><code class="mi">2</code><code class="p">,</code> <code class="o">~</code><code class="mi">4</code><code class="p">,</code> <code class="o">~</code><code class="mi">8</code><code class="p">,</code> <code class="o">~</code><code class="mi">16</code><code class="p">,</code> <code class="o">~</code><code class="mi">32</code><code class="p">,</code> <code class="o">~</code><code class="mi">64</code><code class="p">,</code> <code class="o">~</code><code class="mi">128</code><code class="p">]);</code></pre></div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="9.6 Summary"><div class="sect1" id="idm46198532598344">
        <h1>9.6 Summary</h1>
        
        <p>This<a data-type="indexterm" data-primary="" data-startref="abstc09" id="idm46198532597208"></a><a data-type="indexterm" data-primary="" data-startref="Shier09" id="idm46198532596200"></a><a data-type="indexterm" data-primary="" data-startref="Csubhier09" id="idm46198532595256"></a> chapter has explained the key features of JavaScript classes:</p>
        
        <ul>
        <li>
        <p>Objects that are members of the same class inherit properties from
        the same prototype object. The prototype object is the key feature
        of JavaScript classes, and it is possible to define classes with
        nothing more than the <code>Object.create()</code> method.</p>
        </li>
        <li>
        <p>Prior to ES6, classes were more typically defined by first defining
        a constructor function. Functions created with the <code>function</code>
        keyword have a <code>prototype</code> property, and the value of this property
        is an object that is used as the prototype of all objects created
        when the function is invoked with <code>new</code> as a constructor. By
        initializing this prototype object, you can define the shared methods
        of your class. Although the prototype object is the key
        feature of the class, the constructor function is the public
        identity of the class.</p>
        </li>
        <li>
        <p>ES6 introduces a <code>class</code> keyword that makes it easier to define
        classes, but under the hood, constructor and prototype mechanism
        remains the same.</p>
        </li>
        <li>
        <p>Subclasses are defined using the <code>extends</code> keyword in a class
        declaration.</p>
        </li>
        <li>
        <p>Subclasses can invoke the constructor of their superclass or
        overridden methods of their superclass with the <code>super</code> keyword.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        <div data-type="footnotes"><p data-type="footnote" id="idm46198535317032"><sup><a href="ch09.html#idm46198535317032-marker">1</a></sup> Except functions returned by the ES5<a data-type="indexterm" data-primary="ES5" data-secondary="Function.bind() method" id="idm46198535316472"></a> <code>Function.bind()</code> method. Bound functions have no prototype property of their own, but they use the prototype of the underlying function if they are invoked as constructors.</p><p data-type="footnote" id="idm46198532816792"><sup><a href="ch09.html#idm46198532816792-marker">2</a></sup> See <em>Design Patterns</em> (Addison-Wesley Professional) by Erich Gamma et al. or <em>Effective Java</em> (Addison-Wesley Professional) by Joshua Bloch, for example.</p></div></div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->