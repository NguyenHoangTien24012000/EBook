<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 14. Metaprogramming"><div class="chapter" id="metaprogramming">
        <h1><span class="label">Chapter 14. </span>Metaprogramming</h1>
        
        
        <p>This<a data-type="indexterm" data-primary="advanced features" data-secondary="overview of" id="idm46198515208280"></a> chapter covers a number of advanced JavaScript features that are
        not commonly used in day-to-day programming but that may be valuable
        to programmers writing reusable libraries and of interest to anyone
        who wants to tinker with the details about how JavaScript objects
        behave.</p>
        
        <p>Many<a data-type="indexterm" data-primary="metaprogramming" id="idm46198515206472"></a> of the features described here can loosely be described as
        “metaprogramming”: if regular programming is writing code to
        manipulate data, then metaprogramming is writing code to manipulate
        other code. In a dynamic language like JavaScript, the lines between
        programming and metaprogramming are blurry—even the simple ability to
        iterate over the properties of an object with a <code>for/in</code> loop might be
        considered “meta” by programmers accustomed to more static languages.</p>
        
        <p>The metaprogramming topics covered in this chapter include:</p>
        
        <ul>
        <li>
        <p><a data-type="xref" href="#propertydescriptors">§14.1</a> Controlling the enumerability, deleteability, and
        configurability of object properties</p>
        </li>
        <li>
        <p><a data-type="xref" href="#extensibleattr">§14.2</a> Controlling the extensibility of objects, and
        creating “sealed” and “frozen” objects</p>
        </li>
        <li>
        <p><a data-type="xref" href="#prototypeattr">§14.3</a> Querying and setting the prototypes of objects</p>
        </li>
        <li>
        <p><a data-type="xref" href="#wellknownsymbols">§14.4</a> Fine-tuning the behavior of your types with
        well-known Symbols</p>
        </li>
        <li>
        <p><a data-type="xref" href="#templatetags">§14.5</a> Creating DSLs (domain-specific languages) with
        template tag functions</p>
        </li>
        <li>
        <p><a data-type="xref" href="#reflectapi">§14.6</a> Probing objects with <code>reflect</code> methods</p>
        </li>
        <li>
        <p><a data-type="xref" href="#proxy">§14.7</a> Controlling object behavior with Proxy</p>
        </li>
        </ul>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="14.1 Property Attributes"><div class="sect1" id="propertydescriptors">
        <h1>14.1 Property Attributes</h1>
        
        <p>The<a data-type="indexterm" data-primary="properties" data-secondary="property attributes" id="Ppatt14"></a><a data-type="indexterm" data-primary="advanced features" data-secondary="property attributes" id="AFprop14"></a> properties of a JavaScript object have names and values, of
        course, but each property also has three associated attributes that
        specify how that property behaves and what you can do with it:</p>
        
        <ul>
        <li>
        <p>The <em>writable</em> attribute<a data-type="indexterm" data-primary="writable attribute" id="idm46198515185720"></a> specifies whether or not the value of a property
        can change.</p>
        </li>
        <li>
        <p>The <em>enumerable</em> attribute<a data-type="indexterm" data-primary="enumerable attribute" id="idm46198515183576"></a> specifies whether the property is
        enumerated by the <code>for/in</code> loop and the <code>Object.keys()</code> method.</p>
        </li>
        <li>
        <p>The <em>configurable</em> attribute<a data-type="indexterm" data-primary="configurable attribute" id="idm46198515180472"></a> specifies whether a property can be
        deleted and also whether the property’s attributes can be changed.</p>
        </li>
        </ul>
        
        <p>Properties defined in object literals or by ordinary assignment to an
        object are writable, enumerable, and configurable. But many of the
        properties defined by the JavaScript standard library are not.</p>
        
        <p>This section explains the API for querying and setting property
        attributes. This API is particularly important to library authors
        because:</p>
        
        <ul>
        <li>
        <p>It allows them to add methods to prototype objects and make them
        non-enumerable, like built-in methods.</p>
        </li>
        <li>
        <p>It allows them to “lock down” their objects, defining properties that
        cannot be changed or deleted.</p>
        </li>
        </ul>
        
        <p>Recall from <a data-type="xref" href="ch06.html#gettersandsetters">§6.10.6</a> that, while “data properties” have a
        value, “accessor properties” have a getter and/or a setter method
        instead. For the purposes of this section, we are going to consider
        the getter and setter methods of an accessor property to be property
        attributes. Following this logic, we’ll even say that the value of a
        data property is an attribute as well. Thus, we can say that a
        property has a name and four attributes. The four attributes of a data
        property are <em>value</em>, <em>writable</em>, <em>enumerable</em>, and
        <em>configurable</em>. Accessor properties don’t have a <em>value</em> attribute or
        a <em>writable</em> attribute: their writability is determined by the
        presence or absence of a setter. So the four attributes of an accessor
        property are <em>get</em>, <em>set</em>, <em>enumerable</em>, and <em>configurable</em>.</p>
        
        <p>The<a data-type="indexterm" data-primary="properties" data-secondary="property descriptors" id="idm46198515168888"></a> JavaScript methods for querying and setting the attributes of a
        property use an object called a <em>property descriptor</em> to represent the
        set of four attributes. A property descriptor object has properties
        with the same names as the attributes of the property it
        describes. Thus, the property descriptor object of a data property has
        properties named <code>value</code>, <code>writable</code>, <code>enumerable</code>, and
        <code>configurable</code>. And the descriptor for an accessor property has <code>get</code>
        and <code>set</code> properties instead of <code>value</code> and <code>writable</code>. The
        <code>writable</code>, <code>enumerable</code>, and <code>configurable</code> properties are boolean
        values, and the <code>get</code> and <code>set</code> properties are function values.</p>
        
        <p>To obtain the property descriptor for a named property of a specified object,
        call <code>Object.getOwnPropertyDescriptor()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Returns {value: 1, writable:true, enumerable:true, configurable:true}</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">},</code> <code class="s2">"x"</code><code class="p">);</code>
        
        <code class="c1">// Here is an object with a read-only accessor property</code>
        <code class="kr">const</code> <code class="nx">random</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">get</code> <code class="nx">octet</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code><code class="o">*</code><code class="mi">256</code><code class="p">);</code> <code class="p">},</code>
        <code class="p">};</code>
        
        <code class="c1">// Returns { get: /*func*/, set:undefined, enumerable:true, configurable:true}</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">(</code><code class="nx">random</code><code class="p">,</code> <code class="s2">"octet"</code><code class="p">);</code>
        
        <code class="c1">// Returns undefined for inherited properties and properties that don't exist.</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">({},</code> <code class="s2">"x"</code><code class="p">)</code>        <code class="c1">// =&gt; undefined; no such prop</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">({},</code> <code class="s2">"toString"</code><code class="p">)</code> <code class="c1">// =&gt; undefined; inherited</code></pre>
        
        <p>As its name implies, <code>Object.getOwnPropertyDescriptor()</code> works only for own
        properties. To query the attributes of inherited properties, you must
        explicitly traverse the prototype chain. (See <code>Object.getPrototypeOf()</code> in <a data-type="xref" href="#prototypeattr">§14.3</a>); see also the similar <code>Reflect.getOwnPropertyDescriptor()</code> function in <a data-type="xref" href="#reflectapi">§14.6</a>.)</p>
        
        <p>To set the attributes of a property or to create a new property with the
        specified attributes, call <code>Object.defineProperty()</code>, passing the object to be
        modified, the name of the property to be created or altered, and the property
        descriptor object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{};</code>  <code class="c1">// Start with no properties at all</code>
        <code class="c1">// Add a non-enumerable data property x with value 1.</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="s2">"x"</code><code class="p">,</code> <code class="p">{</code>
            <code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
            <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
            <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
            <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">});</code>
        
        <code class="c1">// Check that the property is there but is non-enumerable</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code>            <code class="c1">// =&gt; 1</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="c1">// =&gt; []</code>
        
        <code class="c1">// Now modify the property x so that it is read-only</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="s2">"x"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code> <code class="p">});</code>
        
        <code class="c1">// Try to change the value of the property</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>      <code class="c1">// Fails silently or throws TypeError in strict mode</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code>           <code class="c1">// =&gt; 1</code>
        
        <code class="c1">// The property is still configurable, so we can change its value like this:</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="s2">"x"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">2</code> <code class="p">});</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code>           <code class="c1">// =&gt; 2</code>
        
        <code class="c1">// Now change x from a data property to an accessor property</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="s2">"x"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">get</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code> <code class="p">});</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code>           <code class="c1">// =&gt; 0</code></pre>
        
        <p>The property descriptor you pass to <code>Object.defineProperty()</code> does not
        have to include all four attributes. If you’re creating a new
        property, then omitted attributes are taken to be <code>false</code> or
        <code>undefined</code>. If you’re modifying an existing property, then the
        attributes you omit are simply left unchanged. Note that this method
        alters an existing own property or creates a new own property, but it
        will not alter an inherited property. See also the very similar
        function <code>Reflect.defineProperty()</code> in <a data-type="xref" href="#reflectapi">§14.6</a>.</p>
        
        <p>If you want to create or modify more than one property at a time, use
        <code>Object.defineProperties()</code>. The first argument is the object that is to be
        modified. The second argument is an object that maps the names of the
        properties to be created or modified to the property descriptors for those
        properties. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperties</code><code class="p">({},</code> <code class="p">{</code>
            <code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code> <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code> <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code> <code class="p">},</code>
            <code class="nx">y</code><code class="o">:</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code> <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code> <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code> <code class="p">},</code>
            <code class="nx">r</code><code class="o">:</code> <code class="p">{</code>
                <code class="nx">get</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="o">*</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="o">*</code><code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code> <code class="p">},</code>
                <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
                <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code>
            <code class="p">}</code>
        <code class="p">});</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">r</code>  <code class="c1">// =&gt; Math.SQRT2</code></pre>
        
        <p>This code starts with an empty object, then adds two data properties and one
        read-only accessor property to it. It relies on the fact that
        <code>Object.defineProperties()</code> returns the modified object (as does
        <code>Object.defineProperty()</code>).</p>
        
        <p>The<a data-type="indexterm" data-primary="Object.create() function" id="idm46198514803000"></a> <code>Object.create()</code> method was introduced in <a data-type="xref" href="ch06.html#creatingobjects">§6.2</a>. We
        learned there that the first argument to that method is the prototype object
        for the newly created object. This method also accepts a second optional
        argument, which is the same as the second argument to
        <code>Object.defineProperties()</code>. If you pass a set of property descriptors to
        <code>Object.create()</code>, then they are used to add properties to the newly created
        object.</p>
        
        <p><code>Object.defineProperty()</code> and <code>Object.defineProperties()</code> throw<a data-type="indexterm" data-primary="Object.defineProperty() method" id="idm46198514798856"></a><a data-type="indexterm" data-primary="Object.defineProperties() method" id="idm46198514798088"></a> TypeError if
        the attempt to create or modify a property is not allowed. This happens if you
        attempt to add a new property to a non-extensible (see <a data-type="xref" href="#extensibleattr">§14.2</a>)
        object. The other reasons that these methods might throw TypeError have to do
        with the attributes themselves. The <em>writable</em> attribute governs attempts to
        change the <em>value</em> attribute. And the <em>configurable</em> attribute governs attempts
        to change the other attributes (and also specifies whether a property can be
        deleted). The rules are not completely straightforward, however. It is possible
        to change the value of a nonwritable property if that property is configurable,
        for example. Also, it is possible to change a property from writable to
        nonwritable even if that property is nonconfigurable. Here are the complete
        rules. Calls to <code>Object.defineProperty()</code> or <code>Object.defineProperties()</code>
        that attempt to violate them throw a TypeError:</p>
        
        <ul>
        <li>
        <p>If an object is not extensible, you can edit its existing own
        properties, but you cannot add new properties to it.</p>
        </li>
        <li>
        <p>If a property is not configurable, you cannot change its
        configurable or enumerable attributes.</p>
        </li>
        <li>
        <p>If an accessor property is not configurable, you cannot change its
        getter or setter method, and you cannot change it to a data
        property.</p>
        </li>
        <li>
        <p>If a data property is not configurable, you cannot change it to an
        accessor <span class="keep-together">property.</span></p>
        </li>
        <li>
        <p>If a data property is not configurable, you cannot change its
        <em>writable</em> attribute from <code>false</code> to <code>true</code>, but you can change it
        from <code>true</code> to <code>false</code>.</p>
        </li>
        <li>
        <p>If a data property is not configurable and not writable, you cannot
        change its value. You can change the value of a property that is
        configurable but nonwritable, however (because that would be the
        same as making it writable, then changing the value, then converting
        it back to nonwritable).</p>
        </li>
        </ul>
        
        <p><a data-type="xref" href="ch06.html#extending-objects">§6.7</a> described the <code>Object.assign()</code> function that
        copies property values from one or more source objects into a target
        object. <code>Object.assign()</code> only copies enumerable properties, and property values, not property attributes. This is normally what
        we want, but it does mean, for example, that if one of the source
        objects has an accessor property, it is the value returned by the
        getter function that is copied to the target object, not the getter
        function itself. <a data-type="xref" href="#assignDescriptors.js">Example&nbsp;14-1</a> demonstrates how we can use
        <code>Object.getOwnPropertyDescriptor()</code> and <code>Object.defineProperty()</code> to
        create a variant of <code>Object.assign()</code> that copies entire property
        descriptors rather than just copying property values.<a data-type="indexterm" data-primary="" data-startref="Ppatt14" id="idm46198514779736"></a><a data-type="indexterm" data-primary="" data-startref="AFprop14" id="idm46198514778760"></a></p>
        <div id="assignDescriptors.js" data-type="example">
        <h5><span class="label">Example 14-1. </span>Copying properties and their attributes from one object to another</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="cm">/*</code>
        <code class="cm"> * Define a new Object.assignDescriptors() function that works like</code>
        <code class="cm"> * Object.assign() except that it copies property descriptors from</code>
        <code class="cm"> * source objects into the target object instead of just copying</code>
        <code class="cm"> * property values. This function copies all own properties, both</code>
        <code class="cm"> * enumerable and non-enumerable. And because it copies descriptors,</code>
        <code class="cm"> * it copies getter functions from source objects and overwrites setter</code>
        <code class="cm"> * functions in the target object rather than invoking those getters and</code>
        <code class="cm"> * setters.</code>
        <code class="cm"> *</code>
        <code class="cm"> * Object.assignDescriptors() propagates any TypeErrors thrown by</code>
        <code class="cm"> * Object.defineProperty(). This can occur if the target object is sealed</code>
        <code class="cm"> * or frozen or if any of the source properties try to change an existing</code>
        <code class="cm"> * non-configurable property on the target object.</code>
        <code class="cm"> *</code>
        <code class="cm"> * Note that the assignDescriptors property is added to Object with</code>
        <code class="cm"> * Object.defineProperty() so that the new function can be created as</code>
        <code class="cm"> * a non-enumerable property like Object.assign().</code>
        <code class="cm"> */</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nb">Object</code><code class="p">,</code> <code class="s2">"assignDescriptors"</code><code class="p">,</code> <code class="p">{</code>
            <code class="c1">// Match the attributes of Object.assign()</code>
            <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
            <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
            <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
            <code class="c1">// The function that is the value of the assignDescriptors property.</code>
            <code class="nx">value</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="p">...</code><code class="nx">sources</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">source</code> <code class="k">of</code> <code class="nx">sources</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">name</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyNames</code><code class="p">(</code><code class="nx">source</code><code class="p">))</code> <code class="p">{</code>
                        <code class="kd">let</code> <code class="nx">desc</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">(</code><code class="nx">source</code><code class="p">,</code> <code class="nx">name</code><code class="p">);</code>
                        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">desc</code><code class="p">);</code>
                    <code class="p">}</code>
        
                    <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">symbol</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertySymbols</code><code class="p">(</code><code class="nx">source</code><code class="p">))</code> <code class="p">{</code>
                        <code class="kd">let</code> <code class="nx">desc</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">(</code><code class="nx">source</code><code class="p">,</code> <code class="nx">symbol</code><code class="p">);</code>
                        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">symbol</code><code class="p">,</code> <code class="nx">desc</code><code class="p">);</code>
                    <code class="p">}</code>
                <code class="p">}</code>
                <code class="k">return</code> <code class="nx">target</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">});</code>
        
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">c</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">get</code> <code class="nx">count</code><code class="p">()</code> <code class="p">{</code><code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">c</code><code class="o">++</code><code class="p">;}};</code> <code class="c1">// Define object with getter</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="nx">o</code><code class="p">);</code>                   <code class="c1">// Copy the property values</code>
        <code class="kd">let</code> <code class="nx">q</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assignDescriptors</code><code class="p">({},</code> <code class="nx">o</code><code class="p">);</code>        <code class="c1">// Copy the property descriptors</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">count</code>   <code class="c1">// =&gt; 1: This is now just a data property so</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">count</code>   <code class="c1">// =&gt; 1: ...the counter does not increment.</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">count</code>   <code class="c1">// =&gt; 2: Incremented once when we copied it the first time,</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">count</code>   <code class="c1">// =&gt; 3: ...but we copied the getter method so it increments.</code></pre></div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="14.2 Object Extensibility"><div class="sect1" id="extensibleattr">
        <h1>14.2 Object Extensibility</h1>
        
        <p>The<a data-type="indexterm" data-primary="objects" data-secondary="object extensibility" id="idm46198514771464"></a><a data-type="indexterm" data-primary="advanced features" data-secondary="object extensibility" id="idm46198514770456"></a><a data-type="indexterm" data-primary="extensibility" id="idm46198514487608"></a> <em>extensible</em> attribute of an object specifies whether new
        properties can be added to the object or not. Ordinary JavaScript
        objects are extensible by default, but you can change that with the
        functions described in this section.</p>
        
        <p>To determine whether an object is extensible, pass it to
        <code>Object.isExtensible()</code>. To make an object non-extensible, pass it to
        <code>Object.preventExtensions()</code>. Once<a data-type="indexterm" data-primary="strict mode" data-secondary="TypeError" id="idm46198514484856"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="TypeError" id="idm46198514483880"></a> you have done this, any attempt to
        add a new property to the object will throw a TypeError in strict mode
        and simply fail silently without an error in non-strict mode. In
        addition, attempting to change the prototype (see <a data-type="xref" href="#prototypeattr">§14.3</a>) of
        a non-extensible object will always throw a TypeError.</p>
        
        <p>Note that there is no way to make an object extensible again once you
        have made it non-extensible. Also note that calling
        <code>Object.preventExtensions()</code> only affects the extensibility of the object
        itself. If new properties are added to the prototype of a
        non-extensible object, the non-extensible object will inherit those
        new properties.</p>
        
        <p>Two similar functions, <code>Reflect.isExtensible()</code> and
        <code>Reflect.preventExtensions()</code>, are described in <a data-type="xref" href="#reflectapi">§14.6</a>.</p>
        
        <p>The purpose of the <em>extensible</em> attribute is to be able to “lock
        down” objects into a known state and prevent outside tampering. The
        <em>extensible</em> attribute of objects is often used in conjunction with
        the <em>configurable</em> and <em>writable</em> attributes of properties, and
        JavaScript defines functions that make it easy to set these attributes
        together:</p>
        
        <ul>
        <li>
        <p><code>Object.seal()</code> works like <code>Object.preventExtensions()</code>, but in
        addition to making the object non-extensible, it also makes all of
        the own properties of that object nonconfigurable. This means that
        new properties cannot be added to the object, and existing
        properties cannot be deleted or configured. Existing properties that
        are writable can still be set, however. There is no way to unseal a
        sealed object. You can use <code>Object.isSealed()</code> to determine whether
        an object is sealed.</p>
        </li>
        <li>
        <p><code>Object.freeze()</code> locks objects down even more tightly. In addition
        to making the object non-extensible and its properties
        nonconfigurable, it also makes all of the object’s own data
        properties read-only. (If the object has accessor properties with
        setter methods, these are not affected and can still be invoked by
        assignment to the property.) Use <code>Object.isFrozen()</code> to determine
        if an object is frozen.</p>
        </li>
        </ul>
        
        <p>It is important to understand that <code>Object.seal()</code> and
        <code>Object.freeze()</code> affect only the object they are passed: they have no
        effect on the prototype of that object. If you want to thoroughly lock
        down an object, you probably need to seal or freeze the objects in the
        prototype chain as well.</p>
        
        <p><code>Object.preventExtensions()</code>, <code>Object.seal()</code>, and <code>Object.freeze()</code>
        all return the object that they are passed, which means that you can
        use them in nested function invocations:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Create a sealed object with a frozen prototype and a non-enumerable property</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">seal</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">freeze</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">}),</code>
                                          <code class="p">{</code><code class="nx">y</code><code class="o">:</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">}}));</code></pre>
        
        <p>If you are writing a JavaScript library that passes objects to
        callback functions written by the users of your library, you might use
        <code>Object.freeze()</code> on those objects to prevent the user’s code from
        modifying them. This is easy and convenient to do, but there are
        trade-offs: frozen objects can interfere with common JavaScript testing
        strategies, for example.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="14.3 The prototype Attribute"><div class="sect1" id="prototypeattr">
        <h1>14.3 The prototype Attribute</h1>
        
        <p>An<a data-type="indexterm" data-primary="prototypes" id="idm46198514428552"></a><a data-type="indexterm" data-primary="advanced features" data-secondary="prototype attribute" id="idm46198514427496"></a> object’s <code>prototype</code> attribute specifies the object from which it
        inherits properties. (Review <a data-type="xref" href="ch06.html#prototypes">§6.2.3</a> and <a data-type="xref" href="ch06.html#inheritance">§6.3.2</a> for
        more on prototypes and property inheritance.) This is such an
        important attribute that we usually simply say “the prototype of
        <code>o</code>" rather than “the <code>prototype</code> attribute of <code>o</code>.” Remember also
        that when <code>prototype</code> appears in code font, it refers to an ordinary
        object property, not to the <code>prototype</code> attribute: <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a> explained
        that the <code>prototype</code> property of a constructor function specifies the
        <code>prototype</code> attribute of the objects created with that constructor.</p>
        
        <p>The <code>prototype</code> attribute is set when an object is created. Objects
        created from object literals use <code>Object.prototype</code> as their
        prototype. Objects created with <code>new</code> use the value of the <code>prototype</code>
        property of their constructor function as their prototype. And objects
        created with <code>Object.create()</code> use the first argument to that function
        (which may be <code>null</code>) as their prototype.</p>
        
        <p>You can query the prototype of any object by passing that object to
        <code>Object.getPrototypeOf()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">({})</code>      <code class="c1">// =&gt; Object.prototype</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">([])</code>      <code class="c1">// =&gt; Array.prototype</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getPrototypeOf</code><code class="p">(()</code><code class="o">=&gt;</code><code class="p">{})</code>  <code class="c1">// =&gt; Function.prototype</code></pre>
        
        <p>A very similar function, <code>Reflect.getPrototypeOf()</code>, is described in
        <a data-type="xref" href="#reflectapi">§14.6</a>.</p>
        
        <p>To determine whether one object is the prototype of (or is part of the
        prototype chain of) another object, use the <code>isPrototypeOf()</code> method:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">};</code>                   <code class="c1">// Define a prototype object.</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">p</code><code class="p">);</code>         <code class="c1">// Create an object with that prototype.</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code>                <code class="c1">// =&gt; true: o inherits from p</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">p</code><code class="p">)</code> <code class="c1">// =&gt; true: p inherits from Object.prototype</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">isPrototypeOf</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="c1">// =&gt; true: o does too</code></pre>
        
        <p>Note that <code>isPrototypeOf()</code> performs a function similar to the <code>instanceof</code>
        operator (see <a data-type="xref" href="ch04.html#instanceof">§4.9.4</a>).</p>
        
        <p>The <code>prototype</code> attribute of an object is set when the object is
        created and normally remains fixed. You can, however, change the
        prototype of an object with <code>Object.setPrototypeOf()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">};</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code><code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">};</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">setPrototypeOf</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">p</code><code class="p">);</code> <code class="c1">// Set the prototype of o to p</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">y</code>      <code class="c1">// =&gt; 2: o now inherits the property y</code>
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">setPrototypeOf</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">p</code><code class="p">);</code> <code class="c1">// Set the prototype of array a to p</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">join</code>   <code class="c1">// =&gt; undefined: a no longer has a join() method</code></pre>
        
        <p>There is generally no need to ever use <code>Object.setPrototypeOf()</code>.
        JavaScript implementations may make aggressive optimizations based on
        the assumption that the prototype of an object is fixed and
        unchanging. This means that if you ever call
        <code>Object.setPrototypeOf()</code>, any code that uses the altered objects may
        run much slower than it would normally.</p>
        
        <p>A similar function, <code>Reflect.setPrototypeOf()</code>, is described in
        <a data-type="xref" href="#reflectapi">§14.6</a>.</p>
        
        <p>Some early browser implementations of JavaScript exposed the
        <code>prototype</code> attribute of an object through the <code>__proto__</code>
        property (written with two underscores at the start and end). This has
        long since been deprecated, but enough existing
        code on the web depends on <code>__proto__</code> that the ECMAScript standard
        mandates it for all JavaScript implementations that run in web
        browsers. (Node supports it, too, though the standard does not require
        it for Node.) In modern JavaScript, <code>__proto__</code> is readable and
        writeable, and you can (though you shouldn’t) use it as an alternative
        to <code>Object.getPrototypeOf()</code> and <code>Object.setPrototypeOf()</code>. One
        interesting use of <code>__proto__</code>, however, is to define the prototype of
        an object literal:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code><code class="nx">z</code><code class="o">:</code> <code class="mi">3</code><code class="p">};</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
            <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
            <code class="nx">__proto__</code><code class="o">:</code> <code class="nx">p</code>
        <code class="p">};</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">z</code>  <code class="c1">// =&gt; 3: o inherits from p</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="14.4 Well-Known Symbols"><div class="sect1" id="wellknownsymbols">
        <h1>14.4 Well-Known Symbols</h1>
        
        <p>The<a data-type="indexterm" data-primary="Symbols" data-secondary="well-known Symbols" id="idm46198514107112"></a><a data-type="indexterm" data-primary="advanced features" data-secondary="well-known Symbols" data-tertiary="Symbol.iterator" id="idm46198514106104"></a> Symbol type was added to JavaScript in ES6, and one of the primary
        reasons for doing so was to safely add extensions to the language
        without breaking compatibility with code already deployed on the
        web. We saw an example of this in <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>, where we learned that
        you can make a class iterable by implementing a method whose “name” is
        the Symbol <code>Symbol.iterator</code>.</p>
        
        <p><code>Symbol.iterator</code> is<a data-type="indexterm" data-primary="Symbol.iterator" id="idm46198514102456"></a> the best-known example of the “well-known
        Symbols.” These are a set of Symbol values stored as properties of the
        <code>Symbol()</code> factory function that are used to allow JavaScript
        code to control certain low-level behaviors of objects and
        classes. The subsections that follow describe each of these
        well-known Symbols and explain how they can be used.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="14.4.1 Symbol.iterator and Symbol.asyncIterator"><div class="sect2" id="idm46198514100712">
        <h2>14.4.1 Symbol.iterator and Symbol.asyncIterator</h2>
        
        <p>The <code>Symbol.iterator</code> and<a data-type="indexterm" data-primary="Symbol.asyncIterator" id="idm46198514098744"></a><a data-type="indexterm" data-primary="advanced features" data-secondary="well-known Symbols" data-tertiary="Symbol.asyncIterator" id="idm46198514098008"></a> <code>Symbol.asyncIterator</code> Symbols allow objects
        or classes to make themselves iterable or asynchronously
        iterable. They were covered in detail in <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a> and
        <a data-type="xref" href="ch13.html#async-async-iterators">§13.4.2</a>, respectively, and are mentioned again here
        only for <span class="keep-together">completeness.</span></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="14.4.2 Symbol.hasInstance"><div class="sect2" id="idm46198514163992">
        <h2>14.4.2 Symbol.hasInstance</h2>
        
        <p>When<a data-type="indexterm" data-primary="advanced features" data-secondary="well-known Symbols" data-tertiary="Symbol.hasInstance" id="idm46198514162424"></a><a data-type="indexterm" data-primary="Symbol.hasInstance" id="idm46198514160760"></a> the <code>instanceof</code> operator was described in <a data-type="xref" href="ch04.html#instanceof">§4.9.4</a>, we said
        that the righthand side must be a constructor function and that the
        expression <code>o instanceof f</code> was evaluated by looking for the value
        <code>f.prototype</code> within the prototype chain of <code>o</code>. That is still true,
        but in ES6 and beyond, <code>Symbol.hasInstance</code> provides an
        alternative. In ES6, if the righthand side of <code>instanceof</code> is any
        object with a <code>[Symbol.hasInstance]</code> method, then that method is
        invoked with the lefthand side value as its argument, and the return
        value of the method, converted to a boolean, becomes the value of the
        <code>instanceof</code> operator. And, of course, if the value on the righthand
        side does not have a <code>[Symbol.hasInstance]</code> method but is a function,
        then the <code>instanceof</code> operator behaves in its ordinary way.</p>
        
        <p><code>Symbol.hasInstance</code> means that we can use the <code>instanceof</code> operator
        to do generic type checking with suitably defined pseudotype
        objects. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Define an object as a "type" we can use with instanceof</code>
        <code class="kd">let</code> <code class="nx">uint8</code> <code class="o">=</code> <code class="p">{</code>
            <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">hasInstance</code><code class="p">](</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&gt;=</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="nx">x</code> <code class="o">&lt;=</code> <code class="mi">255</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">};</code>
        <code class="mi">128</code> <code class="k">instanceof</code> <code class="nx">uint8</code>     <code class="c1">// =&gt; true</code>
        <code class="mi">256</code> <code class="k">instanceof</code> <code class="nx">uint8</code>     <code class="c1">// =&gt; false: too big</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="k">instanceof</code> <code class="nx">uint8</code> <code class="c1">// =&gt; false: not an integer</code></pre>
        
        <p>Note that this example is clever but confusing because it uses a
        nonclass object where a class would normally be expected. It would be
        just as easy—and clearer to readers of your code—to write a
        <code>isUint8()</code> function instead of relying on this <code>Symbol.hasInstance</code>
        behavior.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="14.4.3 Symbol.toStringTag"><div class="sect2" id="tostringtag">
        <h2>14.4.3 Symbol.toStringTag</h2>
        
        <p>If<a data-type="indexterm" data-primary="advanced features" data-secondary="well-known Symbols" data-tertiary="Symbol.toStringTag" id="idm46198514016424"></a><a data-type="indexterm" data-primary="Symbol.toStringTag" id="idm46198514015144"></a> you invoke the <code>toString()</code> method of a basic JavaScript object,
        you get the string “[object Object]”:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">{}.</code><code class="nx">toString</code><code class="p">()</code>  <code class="c1">// =&gt; "[object Object]"</code></pre>
        
        <p>If you invoke this same <code>Object.prototype.toString()</code> function as a
        method of instances of built-in types, you get some interesting
        results:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">([])</code>     <code class="c1">// =&gt; "[object Array]"</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="sr">/./</code><code class="p">)</code>    <code class="c1">// =&gt; "[object RegExp]"</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(()</code><code class="o">=&gt;</code><code class="p">{})</code> <code class="c1">// =&gt; "[object Function]"</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="s2">""</code><code class="p">)</code>     <code class="c1">// =&gt; "[object String]"</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>      <code class="c1">// =&gt; "[object Number]"</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="kc">false</code><code class="p">)</code>  <code class="c1">// =&gt; "[object Boolean]"</code></pre>
        
        <p>It turns out that you can use this
        <code>Object.prototype.toString().call()</code> technique with any JavaScript
        value to obtain the “class attribute” of an object that contains type
        information that is not otherwise available.  The following
        <code>classof()</code> function is arguably more useful than the <code>typeof</code>
        operator, which makes no distinction between types of objects:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">classof</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">o</code><code class="p">).</code><code class="nx">slice</code><code class="p">(</code><code class="mi">8</code><code class="p">,</code><code class="o">-</code><code class="mi">1</code><code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">classof</code><code class="p">(</code><code class="kc">null</code><code class="p">)</code>       <code class="c1">// =&gt; "Null"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="kc">undefined</code><code class="p">)</code>  <code class="c1">// =&gt; "Undefined"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>          <code class="c1">// =&gt; "Number"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="mi">10</code><code class="nx">n</code><code class="o">**</code><code class="mi">100</code><code class="nx">n</code><code class="p">)</code>  <code class="c1">// =&gt; "BigInt"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="s2">""</code><code class="p">)</code>         <code class="c1">// =&gt; "String"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="kc">false</code><code class="p">)</code>      <code class="c1">// =&gt; "Boolean"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="nx">Symbol</code><code class="p">())</code>   <code class="c1">// =&gt; "Symbol"</code>
        <code class="nx">classof</code><code class="p">({})</code>         <code class="c1">// =&gt; "Object"</code>
        <code class="nx">classof</code><code class="p">([])</code>         <code class="c1">// =&gt; "Array"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="sr">/./</code><code class="p">)</code>        <code class="c1">// =&gt; "RegExp"</code>
        <code class="nx">classof</code><code class="p">(()</code><code class="o">=&gt;</code><code class="p">{})</code>     <code class="c1">// =&gt; "Function"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="k">new</code> <code class="nx">Map</code><code class="p">())</code>  <code class="c1">// =&gt; "Map"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="k">new</code> <code class="nx">Set</code><code class="p">())</code>  <code class="c1">// =&gt; "Set"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">())</code> <code class="c1">// =&gt; "Date"</code></pre>
        
        <p>Prior to ES6, this special behavior of the
        <code>Object.prototype.toString()</code> method was available only to instances
        of built-in types, and if you called this <code>classof()</code> function on an
        instance of a class you had defined yourself, it would simply return
        “Object”. In ES6, however, <code>Object.prototype.toString()</code> looks for a
        property with the symbolic name <code>Symbol.toStringTag</code> on its argument,
        and if such a property exists, it uses the property value in its
        output. This means that if you define a class of your own, you can
        easily make it work with functions like <code>classof()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Range</code> <code class="p">{</code>
            <code class="nx">get</code> <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">toStringTag</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="s2">"Range"</code><code class="p">;</code> <code class="p">}</code>
            <code class="c1">// the rest of this class is omitted here</code>
        <code class="p">}</code>
        <code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Range</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">10</code><code class="p">);</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">toString</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code>   <code class="c1">// =&gt; "[object Range]"</code>
        <code class="nx">classof</code><code class="p">(</code><code class="nx">r</code><code class="p">)</code>                          <code class="c1">// =&gt; "Range"</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="14.4.4 Symbol.species"><div class="sect2" id="idm46198514017800">
        <h2>14.4.4 Symbol.species</h2>
        
        <p>Prior<a data-type="indexterm" data-primary="advanced features" data-secondary="well-known Symbols" data-tertiary="Symbol.species" id="AFwellspec14"></a><a data-type="indexterm" data-primary="Symbol.species" id="symbspec14"></a> to ES6, JavaScript did not provide any real way to create robust
        subclasses of built-in classes like Array. In ES6, however, you can
        extend any built-in class simply by using the <code>class</code> and <code>extends</code>
        keywords. <a data-type="xref" href="ch09.html#extendsandsuper">§9.5.2</a> demonstrated that with this simple
        subclass of Array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// A trivial Array subclass that adds getters for the first and last elements.</code>
        <code class="kr">class</code> <code class="nx">EZArray</code> <code class="kr">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="nx">get</code> <code class="nx">first</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code> <code class="p">}</code>
            <code class="nx">get</code> <code class="nx">last</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">];</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">e</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">EZArray</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">f</code> <code class="o">=</code> <code class="nx">e</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">);</code>
        <code class="nx">e</code><code class="p">.</code><code class="nx">last</code>  <code class="c1">// =&gt; 3: the last element of EZArray e</code>
        <code class="nx">f</code><code class="p">.</code><code class="nx">last</code>  <code class="c1">// =&gt; 9: f is also an EZArray with a last property</code></pre>
        
        <p>Array defines methods <code>concat()</code>, <code>filter()</code>, <code>map()</code>, <code>slice()</code>, and
        <code>splice()</code>, which return arrays. When we create an array subclass like
        EZArray that inherits these methods, should the inherited method
        return instances of Array or instances of EZArray? Good arguments can
        be made for either choice, but the ES6 specification says that (by
        default) the five array-returning methods will return instances of the
        subclass.</p>
        
        <p>Here’s how it works:</p>
        
        <ul>
        <li>
        <p>In ES6 and later, the <code>Array()</code> constructor has a property with the
        symbolic name <code>Symbol.species</code>. (Note that this Symbol is used as
        the name of a property of the constructor function. Most of the
        other well-known Symbols described here are used as the name of
        methods of a prototype object.)</p>
        </li>
        <li>
        <p>When we create a subclass with <code>extends</code>, the resulting subclass
        constructor inherits properties from the superclass
        constructor. (This is in addition to the normal kind of inheritance,
        where instances of the subclass inherit methods of the
        superclass.) This means that the constructor for every subclass of
        Array also has an inherited property with name
        <code>Symbol.species</code>. (Or a subclass can define its own property
        with this name, if it wants.)</p>
        </li>
        <li>
        <p>Methods like <code>map()</code> and <code>slice()</code> that create and return new arrays
        are tweaked slightly in ES6 and later. Instead of just creating a
        regular Array, they (in effect) invoke <code>new
        this.constructor[Symbol.species]()</code> to create the new array.</p>
        </li>
        </ul>
        
        <p>Now here’s the interesting part. Suppose that <code>Array[Symbol.species]</code>
        was just a regular data property, defined like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Array</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">]</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">;</code></pre>
        
        <p>In that case, then subclass constructors would inherit the <code>Array()</code>
        constructor as their “species,” and invoking <code>map()</code> on an array
        subclass would return an instance of the superclass rather than an
        instance of the subclass. That is not how ES6 actually behaves,
        however. The reason is that <code>Array[Symbol.species]</code> is a read-only
        accessor property whose getter function simply returns <code>this</code>. Subclass
        constructors inherit this getter function, which means that by default,
        every subclass constructor is its own “species.”</p>
        
        <p>Sometimes this default behavior is not what you want, however. If you
        wanted the array-returning methods of EZArray to return regular Array
        objects, you just need to set <code>EZArray[Symbol.species]</code> to
        <code>Array</code>. But since the inherited property is a read-only accessor, you
        can’t just set it with an assignment operator. You can use
        <code>defineProperty()</code>, however:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">EZArray</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">]</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">;</code> <code class="c1">// Attempt to set a read-only property fails</code>
        
        <code class="c1">// Instead we can use defineProperty():</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code><code class="nx">EZArray</code><code class="p">,</code> <code class="nx">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">,</code> <code class="p">{</code><code class="nx">value</code><code class="o">:</code> <code class="nb">Array</code><code class="p">});</code></pre>
        
        <p>The simplest option is probably to explicitly define your own
        <code>Symbol.species</code> getter when creating the subclass in the first place:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">EZArray</code> <code class="kr">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="kr">static</code> <code class="nx">get</code> <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Array</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">get</code> <code class="nx">first</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code> <code class="p">}</code>
            <code class="nx">get</code> <code class="nx">last</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">];</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">e</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">EZArray</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">f</code> <code class="o">=</code> <code class="nx">e</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code><code class="p">);</code>
        <code class="nx">e</code><code class="p">.</code><code class="nx">last</code>  <code class="c1">// =&gt; 3</code>
        <code class="nx">f</code><code class="p">.</code><code class="nx">last</code>  <code class="c1">// =&gt; undefined: f is a regular array with no last getter</code></pre>
        
        <p>Creating useful subclasses of Array was the primary use case that
        motivated the introduction of <code>Symbol.species</code>, but it is not the only
        place that this well-known Symbol is used. Typed array classes use the
        Symbol in the same way that the Array class does. Similarly, the
        <code>slice()</code> method of ArrayBuffer looks at the <code>Symbol.species</code> property
        of <code>this.constructor</code> instead of simply creating a new
        ArrayBuffer. And Promise methods like <code>then()</code> that return new Promise
        objects create those objects via this species protocol as
        well. Finally, if you find yourself subclassing Map (for example) and
        defining methods that return new Map objects, you might want to use
        <code>Symbol.species</code> yourself for the benefit of subclasses of your
        subclass.<a data-type="indexterm" data-primary="" data-startref="symbspec14" id="idm46198513334344"></a><a data-type="indexterm" data-primary="" data-startref="AFwellspec14" id="idm46198513333368"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="14.4.5 Symbol.isConcatSpreadable"><div class="sect2" id="idm46198513609464">
        <h2>14.4.5 Symbol.isConcatSpreadable</h2>
        
        <p>The<a data-type="indexterm" data-primary="advanced features" data-secondary="well-known Symbols" data-tertiary="Symbol.isConcatSpreadable" id="idm46198513330824"></a><a data-type="indexterm" data-primary="Symbol.isConcatSpreadable" id="idm46198513329576"></a> Array method <code>concat()</code> is one of the methods described in the previous section that
        uses <code>Symbol.species</code> to determine what constructor to use for the
        returned array. But <code>concat()</code> also uses <code>Symbol.isConcatSpreadable</code>.
        Recall from <a data-type="xref" href="ch07.html#arrayconcat">§7.8.3</a> that the <code>concat()</code> method of an array
        treats its <code>this</code> value and its array arguments differently than its
        nonarray arguments: nonarray arguments are simply appended to the
        new array, but the <code>this</code> array and any array arguments are flattened
        or “spread” so that the elements of the array are concatenated rather
        than the array argument itself.</p>
        
        <p>Before ES6, <code>concat()</code> just used <code>Array.isArray()</code> to determine
        whether to treat a value as an array or not. In ES6, the algorithm is
        changed slightly: if the argument (or the <code>this</code> value) to
        <code>concat()</code> is an object and has a property with the symbolic name
        <code>Symbol.isConcatSpreadable</code>, then the boolean value of that property
        is used to determine whether the argument should be “spread.” If no
        such property exists, then <code>Array.isArray()</code> is used as in previous
        versions of the language.</p>
        
        <p>There are two cases when you might want to use this Symbol:</p>
        
        <ul>
        <li>
        <p>If you create an Array-like (see <a data-type="xref" href="ch07.html#arraylike">§7.9</a>) object and want it
        to behave like a real array when passed to <code>concat()</code>, you can
        simply add the symbolic property to your object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">arraylike</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">length</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
            <code class="mi">0</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
            <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">isConcatSpreadable</code><code class="p">]</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">};</code>
        <code class="p">[].</code><code class="nx">concat</code><code class="p">(</code><code class="nx">arraylike</code><code class="p">)</code>  <code class="c1">// =&gt; [1]: (would be [[1]] if not spread)</code></pre>
        </li>
        <li>
        <p>Array subclasses are spreadable by default, so if you are defining an
        array subclass that you do not want to act like an array when used
        with <code>concat()</code>, then you can<sup><a data-type="noteref" id="idm46198513295640-marker" href="ch14.html#idm46198513295640">1</a></sup> add a getter like this to your subclass:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">NonSpreadableArray</code> <code class="kr">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="nx">get</code> <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">isConcatSpreadable</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">NonSpreadableArray</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">);</code>
        <code class="p">[].</code><code class="nx">concat</code><code class="p">(</code><code class="nx">a</code><code class="p">).</code><code class="nx">length</code> <code class="c1">// =&gt; 1; (would be 3 elements long if a was spread)</code></pre>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="14.4.6 Pattern-Matching Symbols"><div class="sect2" id="patternmatchingsymbols">
        <h2>14.4.6 Pattern-Matching Symbols</h2>
        
        <p><a data-type="xref" href="ch11.html#regexps-string-methods">§11.3.2</a> documented<a data-type="indexterm" data-primary="pattern matching" data-secondary="pattern-matching symbols" id="idm46198513196744"></a><a data-type="indexterm" data-primary="advanced features" data-secondary="well-known Symbols" data-tertiary="pattern-matching symbols" id="idm46198513195800"></a> the String methods that perform
        pattern-matching operations using a RegExp argument. In ES6 and later,
        these methods have been generalized to work with RegExp objects or any
        object that defines pattern-matching behavior via properties with
        symbolic names. For each of the string methods <code>match()</code>,
        <code>matchAll()</code>, <code>search()</code>, <code>replace()</code>, and <code>split()</code>, there is a
        corresponding well-known Symbol: <code>Symbol.match</code>, <code>Symbol.search</code>, and
        so on.</p>
        
        <p>RegExps are a general and very powerful way to describe textual
        patterns, but they can be complicated and not well suited to fuzzy
        matching. With the generalized string methods, you can define your own
        pattern classes using the well-known Symbol methods to provide custom
        matching. For example, you could perform string comparisons using
        Intl.Collator (see <a data-type="xref" href="ch11.html#collator">§11.7.3</a>) to ignore accents when matching. Or
        you could define a pattern class based on the <em>Soundex</em> algorithm to
        match words based on their approximate sounds or to loosely match
        strings up to a given Levenshtein <span class="keep-together">distance.</span></p>
        
        <p>In general, when you invoke one of these five String methods on a
        pattern object like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">string</code><code class="p">.</code><code class="nx">method</code><code class="p">(</code><code class="nx">pattern</code><code class="p">,</code> <code class="nx">arg</code><code class="p">)</code></pre>
        
        <p>that invocation turns into an invocation of a symbolically named
        method on your pattern object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">pattern</code><code class="p">[</code><code class="nx">symbol</code><code class="p">](</code><code class="nx">string</code><code class="p">,</code> <code class="nx">arg</code><code class="p">)</code></pre>
        
        <p>As an example, consider the pattern-matching class in the next example, which
        implements pattern matching using the simple <code>*</code> and <code>?</code>  wildcards that
        you are probably familar with from filesystems. This style of pattern
        matching dates back to the very early days of the Unix operating
        system, and the patterns are often called <em>globs</em>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Glob</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">glob</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">glob</code> <code class="o">=</code> <code class="nx">glob</code><code class="p">;</code>
        
                <code class="c1">// We implement glob matching using RegExp internally.</code>
                <code class="c1">// ? matches any one character except /, and * matches zero or more</code>
                <code class="c1">// of those characters. We use capturing groups around each.</code>
                <code class="kd">let</code> <code class="nx">regexpText</code> <code class="o">=</code> <code class="nx">glob</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"?"</code><code class="p">,</code> <code class="s2">"([^/])"</code><code class="p">).</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"*"</code><code class="p">,</code> <code class="s2">"([^/]*)"</code><code class="p">);</code>
        
                <code class="c1">// We use the u flag to get Unicode-aware matching.</code>
                <code class="c1">// Globs are intended to match entire strings, so we use the ^ and $</code>
                <code class="c1">// anchors and do not implement search() or matchAll() since they</code>
                <code class="c1">// are not useful with patterns like this.</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">regexp</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code><code class="sb">`^</code><code class="si">${</code><code class="nx">regexpText</code><code class="si">}</code><code class="sb">$`</code><code class="p">,</code> <code class="s2">"u"</code><code class="p">);</code>
            <code class="p">}</code>
        
            <code class="nx">toString</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">glob</code><code class="p">;</code> <code class="p">}</code>
        
            <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">search</code><code class="p">](</code><code class="nx">s</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">s</code><code class="p">.</code><code class="nx">search</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">regexp</code><code class="p">);</code> <code class="p">}</code>
            <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">match</code><code class="p">](</code><code class="nx">s</code><code class="p">)</code>  <code class="p">{</code> <code class="k">return</code> <code class="nx">s</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">regexp</code><code class="p">);</code> <code class="p">}</code>
            <code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">replace</code><code class="p">](</code><code class="nx">s</code><code class="p">,</code> <code class="nx">replacement</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nx">s</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">regexp</code><code class="p">,</code> <code class="nx">replacement</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">pattern</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Glob</code><code class="p">(</code><code class="s2">"docs/*.txt"</code><code class="p">);</code>
        <code class="s2">"docs/js.txt"</code><code class="p">.</code><code class="nx">search</code><code class="p">(</code><code class="nx">pattern</code><code class="p">)</code>   <code class="c1">// =&gt; 0: matches at character 0</code>
        <code class="s2">"docs/js.htm"</code><code class="p">.</code><code class="nx">search</code><code class="p">(</code><code class="nx">pattern</code><code class="p">)</code>   <code class="c1">// =&gt; -1: does not match</code>
        <code class="kd">let</code> <code class="nx">match</code> <code class="o">=</code> <code class="s2">"docs/js.txt"</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="nx">pattern</code><code class="p">);</code>
        <code class="nx">match</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>     <code class="c1">// =&gt; "docs/js.txt"</code>
        <code class="nx">match</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>     <code class="c1">// =&gt; "js"</code>
        <code class="nx">match</code><code class="p">.</code><code class="nx">index</code>  <code class="c1">// =&gt; 0</code>
        <code class="s2">"docs/js.txt"</code><code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="nx">pattern</code><code class="p">,</code> <code class="s2">"web/$1.htm"</code><code class="p">)</code>  <code class="c1">// =&gt; "web/js.htm"</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="14.4.7 Symbol.toPrimitive"><div class="sect2" id="toprimitive">
        <h2>14.4.7 Symbol.toPrimitive</h2>
        
        <p><a data-type="xref" href="ch03.html#objtoprim">§3.9.3</a> explained<a data-type="indexterm" data-primary="Symbol.toPrimitive" id="idm46198512884856"></a><a data-type="indexterm" data-primary="advanced features" data-secondary="well-known Symbols" data-tertiary="Symbol.toPrimitive" id="idm46198512884152"></a> that JavaScript has three slightly different
        algorithms for converting objects to primitive values. Loosely
        speaking, for
        conversions where a string value is expected or preferred, JavaScript
        invokes an object’s <code>toString()</code> method first and falls back on the
        <code>valueOf()</code> method if <code>toString()</code> is not defined or does not return a
        primitive value. For conversions where a numeric value is preferred,
        JavaScript tries the <code>valueOf()</code> method first and falls back on
        <code>toString()</code> if <code>valueOf()</code> is not defined or if it does not return a
        primitive value. And finally, in cases where there is no preference,
        it lets the class decide how to do the conversion. Date objects
        convert using <code>toString()</code> first, and all other types try <code>valueOf()</code>
        first.</p>
        
        <p>In ES6, the well-known Symbol <code>Symbol.toPrimitive</code> allows you to
        override this default object-to-primitive behavior and gives you
        complete control over how instances of your own classes will be
        converted to primitive values. To do this, define a method with this
        symbolic name. The method must return a primitive value that somehow
        represents the object. The method you define will be invoked with a
        single string argument that tells you what kind of conversion
        JavaScript is trying to do on your object:</p>
        
        <ul>
        <li>
        <p>If the argument is <code>"string"</code>, it means that JavaScript is doing the
        conversion in a context where it would expect or prefer (but not
        require) a string. This happens when you interpolate the object into
        a template literal, for example.</p>
        </li>
        <li>
        <p>If the argument is <code>"number"</code>, it means that JavaScript is doing the
        conversion in a context where it would expect or prefer (but not
        require) a numeric value. This happens when you use the object with
        a <code>&lt;</code> or <code>&gt;</code> operator or with arithmetic operators like <code>-</code> and
        <code>*</code>.</p>
        </li>
        <li>
        <p>If the argument is <code>"default"</code>, it means that JavaScript is
        converting your object in a context where either a numeric or string
        value could work. This happens with the <code>+</code>, <code>==</code>, and <code>!=</code>
        operators.</p>
        </li>
        </ul>
        
        <p>Many classes can ignore the argument and simply return the same
        primitive value in all cases. If you want instances of your class to
        be comparable and sortable with <code>&lt;</code> and <code>&gt;</code>, then that is a good
        reason to define a <code>[Symbol.toPrimitive]</code> method.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="14.4.8 Symbol.unscopables"><div class="sect2" id="idm46198512867656">
        <h2>14.4.8 Symbol.unscopables</h2>
        
        <p>The<a data-type="indexterm" data-primary="advanced features" data-secondary="well-known Symbols" data-tertiary="Symbol.unscopables" id="idm46198512866072"></a><a data-type="indexterm" data-primary="Symbol.unscopables" id="idm46198512864792"></a> final well-known Symbol that we’ll cover here is an obscure one
        that was introduced as a workaround for compatibility issues caused
        by the deprecated <code>with</code> statement. Recall that the <code>with</code> statement
        takes an object and executes its statement body as if it were in a
        scope where the properties of that object were variables. This caused
        compatibility problems when new methods were added to the Array class,
        and it broke some existing code. <code>Symbol.unscopables</code> is the result. In
        ES6 and later, the <code>with</code> statement has been slightly modified. When
        used with an object <code>o</code>, a <code>with</code> statement computes
        <code>Object.keys(o[Symbol.unscopables]||{})</code> and ignores properties whose
        names are in the resulting array when creating the simulated scope in
        which to execute its body. ES6 uses this to add new methods to
        <code>Array.prototype</code> without breaking existing code on the web. This
        means that you can find a list of the newest Array methods by
        evaluating:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">newArrayMethods</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nx">Symbol</code><code class="p">.</code><code class="nx">unscopables</code><code class="p">]);</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="14.5 Template Tags"><div class="sect1" id="templatetags">
        <h1>14.5 Template Tags</h1>
        
        <p>Strings<a data-type="indexterm" data-primary="template literals" id="idm46198512838600"></a><a data-type="indexterm" data-primary="literals" data-secondary="template literals" id="idm46198512837864"></a><a data-type="indexterm" data-primary="tagged template literals" id="idm46198512836920"></a><a data-type="indexterm" data-primary="advanced features" data-secondary="template tags" id="AFtemplatetags14"></a> within backticks are known as “template literals” and were
        covered in <a data-type="xref" href="ch03.html#templateliterals">§3.3.4</a>. When an expression whose value is a
        function is followed by a template literal, it turns into a function
        invocation, and we call it a “tagged template literal.” Defining a new
        tag function for use with tagged
        template literals can be thought of as metaprogramming, because tagged
        templates are often used to define DSLs—domain-specific languages—and
        defining a new tag function is like adding new syntax to JavaScript.
        Tagged template literals have been adopted by a number of frontend
        JavaScript packages. The GraphQL query language uses a <code>gql``</code> tag
        function to allow queries to be embedded within JavaScript code. And
        the Emotion library uses a <code>css``</code> tag function to enable CSS styles
        to be embedded in JavaScript. This section demonstrates how to write
        your own tag functions like these.</p>
        
        <p>There is nothing special about tag functions: they are ordinary
        JavaScript functions, and no special syntax is required to define
        them. When a function expression is followed by a template literal,
        the function is invoked. The first argument is an array of strings,
        and this is followed by zero or more additional arguments, which can
        have values of any type.</p>
        
        <p>The number of arguments depends on the number of values that are
        interpolated into the template literal. If the template literal is
        simply a constant string with no interpolations, then the tag function
        will be called with an array of that one string and no additional
        arguments. If the template literal includes one interpolated value,
        then the tag function is called with two arguments. The first is an
        array of two strings, and the second is the interpolated value. The
        strings in that initial array are the string to the left of the
        interpolated value and the string to its right, and either one of them
        may be the empty string. If the template literal includes two
        interpolated values, then the tag function is invoked with three
        arguments: an array of three strings and the two interpolated
        values. The three strings (any or all of which may be empty) are the
        text to the left of the first value, the text between the two values,
        and the text to the right of the second value. In the general case, if
        the template literal has <code>n</code> interpolated values, then the tag function
        will be invoked with <code>n+1</code> arguments. The first argument will be an
        array of <code>n+1</code> strings, and the remaining arguments are the <code>n</code>
        interpolated values, in the order that they appear in the template
        literal.</p>
        
        <p>The value of a template literal is always a string. But the value of a
        tagged template literal is whatever value the tag function
        returns. This may be a string, but when the tag function is used to
        implement a DSL, the return value is typically a non-string data
        structure that is a parsed representation of the string.</p>
        
        <p>As an example of a template tag function that returns a string,
        consider the following <code>html``</code> template, which is useful when you want to
        safely interpolate values into a string of HTML. The tag performs HTML
        escaping on each of the values before using it to build the final
        string:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">html</code><code class="p">(</code><code class="nx">strings</code><code class="p">,</code> <code class="p">...</code><code class="nx">values</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Convert each value to a string and escape special HTML characters</code>
            <code class="kd">let</code> <code class="nx">escaped</code> <code class="o">=</code> <code class="nx">values</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">v</code> <code class="o">=&gt;</code> <code class="nb">String</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code>
                                          <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"&amp;"</code><code class="p">,</code> <code class="s2">"&amp;amp;"</code><code class="p">)</code>
                                          <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"&lt;"</code><code class="p">,</code> <code class="s2">"&amp;lt;"</code><code class="p">)</code>
                                          <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"&gt;"</code><code class="p">,</code> <code class="s2">"&amp;gt;"</code><code class="p">)</code>
                                          <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s1">'"'</code><code class="p">,</code> <code class="s2">"&amp;quot;"</code><code class="p">)</code>
                                          <code class="p">.</code><code class="nx">replace</code><code class="p">(</code><code class="s2">"'"</code><code class="p">,</code> <code class="s2">"&amp;#39;"</code><code class="p">));</code>
        
            <code class="c1">// Return the concatenated strings and escaped values</code>
            <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">strings</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">escaped</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">result</code> <code class="o">+=</code> <code class="nx">escaped</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">+</code> <code class="nx">strings</code><code class="p">[</code><code class="nx">i</code><code class="o">+</code><code class="mi">1</code><code class="p">];</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">operator</code> <code class="o">=</code> <code class="s2">"&lt;"</code><code class="p">;</code>
        <code class="nx">html</code><code class="sb">`&lt;b&gt;x </code><code class="si">${</code><code class="nx">operator</code><code class="si">}</code><code class="sb"> y&lt;/b&gt;`</code>             <code class="c1">// =&gt; "&lt;b&gt;x &amp;lt; y&lt;/b&gt;"</code>
        
        <code class="kd">let</code> <code class="nx">kind</code> <code class="o">=</code> <code class="s2">"game"</code><code class="p">,</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"D&amp;D"</code><code class="p">;</code>
        <code class="nx">html</code><code class="sb">`&lt;div class="</code><code class="si">${</code><code class="nx">kind</code><code class="si">}</code><code class="sb">"&gt;</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">&lt;/div&gt;`</code> <code class="c1">// =&gt;'&lt;div class="game"&gt;D&amp;amp;D&lt;/div&gt;'</code></pre>
        
        <p>For an example of a tag function that does not return a string but
        instead a parsed representation of a string, think back to the Glob
        pattern class defined in <a data-type="xref" href="#patternmatchingsymbols">§14.4.6</a>. Since the
        <code>Glob()</code> constructor takes a single string argument, we can define a
        tag function for creating new Glob objects:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">glob</code><code class="p">(</code><code class="nx">strings</code><code class="p">,</code> <code class="p">...</code><code class="nx">values</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Assemble the strings and values into a single string</code>
            <code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="nx">strings</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">values</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">s</code> <code class="o">+=</code> <code class="nx">values</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">+</code> <code class="nx">strings</code><code class="p">[</code><code class="nx">i</code><code class="o">+</code><code class="mi">1</code><code class="p">];</code>
            <code class="p">}</code>
            <code class="c1">// Return a parsed representation of that string</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nx">Glob</code><code class="p">(</code><code class="nx">s</code><code class="p">);</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">root</code> <code class="o">=</code> <code class="s2">"/tmp"</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">filePattern</code> <code class="o">=</code> <code class="nx">glob</code><code class="sb">`</code><code class="si">${</code><code class="nx">root</code><code class="si">}</code><code class="sb">/*.html`</code><code class="p">;</code>  <code class="c1">// A RegExp alternative</code>
        <code class="s2">"/tmp/test.html"</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code><code class="nx">filePattern</code><code class="p">)[</code><code class="mi">1</code><code class="p">]</code>   <code class="c1">// =&gt; "test"</code></pre>
        
        <p>One of the features mentioned in passing in <a data-type="xref" href="ch03.html#templateliterals">§3.3.4</a> is the
        <code>String.raw``</code> tag function that returns a string in its “raw” form
        without interpreting any of the backslash escape sequences. This is
        implemented using a feature of tag function invocation that we have not
        discussed yet. When a tag function is invoked, we’ve seen that its
        first argument is an array of strings. But this array also has a
        property named <code>raw</code>, and the value of that property is another array
        of strings, with the same number of elements. The argument array
        includes strings that have had escape sequences interpreted as
        usual. And the raw array includes strings in which escape sequences
        are not interpreted. This obscure feature is important if you want to
        define a DSL with a grammar that uses backslashes. For example, if we
        wanted our <code>glob``</code> tag function to support pattern matching on
        Windows-style paths (which use backslashes instead of forward slashes)
        and we did not want users of the tag to have to double every
        backslash, we could rewrite that function to use <code>strings.raw[]</code>
        instead of <code>strings[]</code>. The downside, of course, would be that we
        could no longer use escapes like <code>\u</code> in our glob<a data-type="indexterm" data-primary="" data-startref="AFtemplatetags14" id="idm46198512582120"></a><a data-type="indexterm" data-primary="" data-startref="AFtemplatetags14" id="idm46198512581112"></a> <span class="keep-together">literals.</span></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="14.6 The Reflect API"><div class="sect1" id="reflectapi">
        <h1>14.6 The Reflect API</h1>
        
        <p>The<a data-type="indexterm" data-primary="advanced features" data-secondary="Reflect API" id="AFreflect14"></a><a data-type="indexterm" data-primary="Reflect API" id="reflect14"></a> Reflect object is not a class; like the Math object, its
        properties simply define a collection of related functions. These
        functions, added in ES6, define an API for “reflecting upon” objects
        and their properties. There is little new functionality here: the
        Reflect object defines a convenient set of functions, all in a single
        namespace, that mimic the behavior of core language syntax and
        duplicate the features of various pre-existing Object functions.</p>
        
        <p>Although the <code>Reflect</code> functions do not provide any new features, they
        do group the features together in one convenient API. And,
        importantly, the set of <code>Reflect</code> functions maps one-to-one with the set
        of Proxy handler methods that we’ll learn about in <a data-type="xref" href="#proxy">§14.7</a>.</p>
        
        <p>The Reflect API consists of the following functions:</p>
        <dl>
        <dt><code>Reflect.apply(f, o, args)</code></dt>
        <dd>
        <p>This function invokes the function <code>f</code>
        as a method of <code>o</code> (or invokes it as a function with no <code>this</code> value
        if <code>o</code> is <code>null</code>) and passes the values in the <code>args</code> array as
        arguments. It is equivalent to <code>f.apply(o, args)</code>.</p>
        </dd>
        <dt><code>Reflect.construct(c, args, newTarget)</code></dt>
        <dd>
        <p>This function invokes the
        constructor <code>c</code> as if the <code>new</code> keyword had been used and passes the
        elements of the array <code>args</code> as arguments. If the optional <code>newTarget</code>
        argument is specified, it is used as the value of <code>new.target</code> within
        the constructor invocation. If not specified, then the <code>new.target</code>
        value will be <code>c</code>.</p>
        </dd>
        <dt><code>Reflect.defineProperty(o, name, descriptor)</code></dt>
        <dd>
        <p>This function defines
        a property on the object <code>o</code>, using <code>name</code> (a string or symbol) as the
        name of the property. The Descriptor object should define the value
        (or getter and/or setter) and attributes of the
        property. <code>Reflect.defineProperty()</code> is very similar to
        <code>Object.defineProperty()</code> but returns <code>true</code> on success and <code>false</code>
        on failures. (<code>Object.defineProperty()</code> returns <code>o</code> on success and
        throws TypeError on failure.)</p>
        </dd>
        <dt><code>Reflect.deleteProperty(o, name)</code></dt>
        <dd>
        <p>This function deletes the property
        with the specified string or symbolic name from the object <code>o</code>,
        returning <code>true</code> if successful (or if no such property existed) and
        <code>false</code> if the property could not be deleted. Calling this function is
        similar to writing <code>delete o[name]</code>.</p>
        </dd>
        <dt><code>Reflect.get(o, name, receiver)</code></dt>
        <dd>
        <p>This function returns the value of
        the property of <code>o</code> with the specified name (a string or symbol). If the
        property is an accessor method with a getter, and if the optional
        <code>receiver</code> argument is specified, then the getter function is called as a
        method of <code>receiver</code> instead of as a method of <code>o</code>. Calling this
        function is similar to evaluating <code>o[name]</code>.</p>
        </dd>
        <dt><code>Reflect.getOwnPropertyDescriptor(o, name)</code></dt>
        <dd>
        <p>This function returns a
        property descriptor object that describes the attributes of the
        property named <code>name</code> of the object <code>o</code>, or returns <code>undefined</code> if no
        such property exists. This function is nearly identical to
        <code>Object.getOwnPropertyDescriptor()</code>, except that the Reflect API
        version of the function requires that the first argument be an object
        and throws TypeError if it is not.</p>
        </dd>
        <dt><code>Reflect.getPrototypeOf(o)</code></dt>
        <dd>
        <p>This function returns the prototype
        of object <code>o</code> or <code>null</code> if the object has no prototype. It throws a
        TypeError if <code>o</code> is a primitive value instead of an object. This
        function is almost identical to <code>Object.getPrototypeOf()</code> except that
        <code>Object.getPrototypeOf()</code> only throws a TypeError for <code>null</code> and
        <code>undefined</code> arguments and coerces other primitive values to their
        wrapper objects.</p>
        </dd>
        <dt><code>Reflect.has(o, name)</code></dt>
        <dd>
        <p>This function returns <code>true</code> if the object
        <code>o</code> has a property with the specified <code>name</code> (which must be a string or a
        symbol). Calling this function is similar to evaluating <code>name in o</code>.</p>
        </dd>
        <dt><code>Reflect.isExtensible(o)</code></dt>
        <dd>
        <p>This function returns <code>true</code> if the object
        <code>o</code> is extensible (<a data-type="xref" href="#extensibleattr">§14.2</a>) and <code>false</code> if it is not. It
        throws a TypeError if <code>o</code> is not an object. <code>Object.isExtensible()</code> is
        similar but simply returns <code>false</code> when passed an argument that is not
        an object.</p>
        </dd>
        <dt><code>Reflect.ownKeys(o)</code></dt>
        <dd>
        <p>This function returns an array of the names of
        the properties of the object <code>o</code> or throws a TypeError if <code>o</code> is not
        an object. The names in the returned array will be strings and/or
        symbols. Calling this function is similar to calling
        <code>Object.getOwnPropertyNames()</code> and <code>Object.getOwnPropertySymbols()</code>
        and combining their results.</p>
        </dd>
        <dt><code>Reflect.preventExtensions(o)</code></dt>
        <dd>
        <p>This function sets the <em>extensible</em>
        attribute (<a data-type="xref" href="#extensibleattr">§14.2</a>) of the object <code>o</code> to <code>false</code> and
        returns <code>true</code> to indicate success. It throws a TypeError if <code>o</code> is
        not an object. <code>Object.preventExtensions()</code> has the same effect but
        returns <code>o</code> instead of <code>true</code> and does not throw TypeError for
        nonobject arguments.</p>
        </dd>
        <dt><code>Reflect.set(o, name, value, receiver)</code></dt>
        <dd>
        <p>This function sets the
        property with the specified <code>name</code> of the object <code>o</code> to the specified
        <code>value</code>. It returns
        <code>true</code> on success and <code>false</code> on failure (which can happen if the
        property is read-only). It throws TypeError if <code>o</code> is not an
        object. If the specified property is an accessor property with a
        setter function, and if the optional <code>receiver</code> argument is passed, then
        the setter will be invoked as a method of <code>receiver</code> instead of being
        invoked as a method of <code>o</code>. Calling this function is usually the same
        as evaluating <code>o[name] = value</code>.</p>
        </dd>
        <dt><code>Reflect.setPrototypeOf(o, p)</code></dt>
        <dd>
        <p>This function sets the prototype of
        the object <code>o</code> to <code>p</code>, returning <code>true</code> on success and <code>false</code> on
        failure (which can occur if <code>o</code> is not extensible or if the operation
        would cause a circular prototype chain). It throws a TypeError if <code>o</code>
        is not an object or if <code>p</code> is neither an object nor
        <code>null</code>. <code>Object.setPrototypeOf()</code> is similar, but returns <code>o</code> on
        success and throws TypeError on failure. Remember that calling either
        of these functions is likely to make your code slower by disrupting
        JavaScript interpreter optimizations.<a data-type="indexterm" data-primary="" data-startref="AFreflect14" id="idm46198512511080"></a><a data-type="indexterm" data-primary="" data-startref="reflect14" id="idm46198512385464"></a></p>
        </dd>
        </dl>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="14.7 Proxy Objects"><div class="sect1" id="proxy">
        <h1>14.7 Proxy Objects</h1>
        
        <p>The<a data-type="indexterm" data-primary="Proxy objects" id="proxy14"></a><a data-type="indexterm" data-primary="advanced features" data-secondary="Proxy objects" id="AFproxy14"></a> Proxy class, available in ES6 and later, is JavaScript’s most
        powerful metaprogramming feature. It allows us to write code that
        alters the fundamental behavior of JavaScript objects.  The Reflect
        API described in <a data-type="xref" href="#reflectapi">§14.6</a> is a set of functions that gives us direct
        access to a set of fundamental operations on JavaScript objects. What
        the Proxy class does is allows us a way to implement those fundamental
        operations ourselves and create objects that behave in ways that are
        not possible for ordinary objects.</p>
        
        <p>When we create a Proxy object, we specify two other objects, the
        target object and the handlers object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">handlers</code><code class="p">);</code></pre>
        
        <p>The resulting Proxy object has no state or behavior of its
        own. Whenever you perform an operation on it (read a property, write a
        property, define a new property, look up the prototype, invoke it as a
        function), it dispatches those operations to the handlers object or to
        the target object.</p>
        
        <p>The operations supported by Proxy objects are the same as those
        defined by the Reflect API. Suppose that <code>p</code> is a Proxy object and you
        write <code>delete p.x</code>. The <code>Reflect.deleteProperty()</code> function has the
        same behavior as the <code>delete</code> operator. And when you use the <code>delete</code>
        operator to delete a property of a Proxy object, it looks for a
        <code>deleteProperty()</code> method on the handlers object. If such a method
        exists, it invokes it. And if no such method exists, then the Proxy
        object performs the property deletion on the target object instead.</p>
        
        <p>Proxies work this way for all of the fundamental operations: if an
        appropriate method exists on the handlers object, it invokes that
        method to perform the operation. (The method names and signatures are
        the same as those of the Reflect functions covered in
        <a data-type="xref" href="#reflectapi">§14.6</a>.) And if that method does not exist on the handlers
        object, then the Proxy performs the fundamental operation on the target
        object. This means that a Proxy can obtain its behavior from the
        target object or from the handlers object. If the handlers object is
        empty, then the proxy is essentially a transparent wrapper around the
        target object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">t</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code> <code class="p">};</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">t</code><code class="p">,</code> <code class="p">{});</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">x</code>          <code class="c1">// =&gt; 1</code>
        <code class="k">delete</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code>   <code class="c1">// =&gt; true: delete property y of the proxy</code>
        <code class="nx">t</code><code class="p">.</code><code class="nx">y</code>          <code class="c1">// =&gt; undefined: this deletes it in the target, too</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">z</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>     <code class="c1">// Defining a new property on the proxy</code>
        <code class="nx">t</code><code class="p">.</code><code class="nx">z</code>          <code class="c1">// =&gt; 3: defines the property on the target</code></pre>
        
        <p>This kind of transparent wrapper proxy is essentially equivalent to
        the underlying target object, which means that there really isn’t a
        reason to use it instead of the wrapped object. Transparent wrappers
        can be useful, however, when created as “revocable proxies.”
        Instead of creating a Proxy with the <code>Proxy()</code> constructor, you can
        use the <code>Proxy.revocable()</code> factory function. This function returns an
        object that includes <span class="keep-together">a Proxy</span> object and also a <code>revoke()</code>
        function. Once you call the <code>revoke()</code> function, the proxy immediately
        stops working:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">accessTheDatabase</code><code class="p">()</code> <code class="p">{</code> <code class="cm">/* implementation omitted */</code> <code class="k">return</code> <code class="mi">42</code><code class="p">;</code> <code class="p">}</code>
        <code class="kd">let</code> <code class="p">{</code><code class="nx">proxy</code><code class="p">,</code> <code class="nx">revoke</code><code class="p">}</code> <code class="o">=</code> <code class="nb">Proxy</code><code class="p">.</code><code class="nx">revocable</code><code class="p">(</code><code class="nx">accessTheDatabase</code><code class="p">,</code> <code class="p">{});</code>
        
        <code class="nx">proxy</code><code class="p">()</code>   <code class="c1">// =&gt; 42: The proxy gives access to the underlying target function</code>
        <code class="nx">revoke</code><code class="p">();</code> <code class="c1">// But that access can be turned off whenever we want</code>
        <code class="nx">proxy</code><code class="p">();</code>  <code class="c1">// !TypeError: we can no longer call this function</code></pre>
        
        <p>Note that in addition to demonstrating revocable proxies, the preceding code
        also demonstrates that proxies can work with target functions as
        well as target objects. But the main point here is that revocable
        proxies are a building block for a kind of code isolation, and you
        might use them when dealing with untrusted third-party libraries, for
        example. If you have to pass a function to a library that you don’t
        control, you can pass a revocable proxy instead and then revoke the
        proxy when you are finished with the library. This prevents the
        library from keeping a reference to your function and calling it at
        unexpected times. This kind of defensive programming is not typical in
        JavaScript programs, but the Proxy class at least makes it possible.</p>
        
        <p>If we pass a non-empty handlers object to the <code>Proxy()</code> constructor,
        then we are no longer defining a transparent wrapper object and are
        instead implementing custom behavior for our proxy. With the right set
        of handlers, the underlying target object essentially becomes
        irrelevant.</p>
        
        <p>In the following code, for example, is how we could implement an object
        that appears to have an infinite number of read-only properties, where
        the value of each property is the same as the name of the property:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// We use a Proxy to create an object that appears to have every</code>
        <code class="c1">// possible property, with the value of each property equal to its name</code>
        <code class="kd">let</code> <code class="nx">identity</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">({},</code> <code class="p">{</code>
            <code class="c1">// Every property has its own name as its value</code>
            <code class="nx">get</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">target</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">name</code><code class="p">;</code> <code class="p">},</code>
            <code class="c1">// Every property name is defined</code>
            <code class="nx">has</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">name</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">true</code><code class="p">;</code> <code class="p">},</code>
            <code class="c1">// There are too many properties to enumerate, so we just throw</code>
            <code class="nx">ownKeys</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nx">RangeError</code><code class="p">(</code><code class="s2">"Infinite number of properties"</code><code class="p">);</code> <code class="p">},</code>
            <code class="c1">// All properties exist and are not writable, configurable or enumerable.</code>
            <code class="nx">getOwnPropertyDescriptor</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="p">{</code>
                    <code class="nx">value</code><code class="o">:</code> <code class="nx">name</code><code class="p">,</code>
                    <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
                    <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
                    <code class="nx">configurable</code><code class="o">:</code> <code class="kc">false</code>
                <code class="p">};</code>
            <code class="p">},</code>
            <code class="c1">// All properties are read-only so they can't be set</code>
            <code class="nx">set</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">target</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code> <code class="p">},</code>
            <code class="c1">// All properties are non-configurable, so they can't be deleted</code>
            <code class="nx">deleteProperty</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">name</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code> <code class="p">},</code>
            <code class="c1">// All properties exist and are non-configurable so we can't define more</code>
            <code class="nx">defineProperty</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">desc</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code> <code class="p">},</code>
            <code class="c1">// In effect, this means that the object is not extensible</code>
            <code class="nx">isExtensible</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code> <code class="p">},</code>
            <code class="c1">// All properties are already defined on this object, so it couldn't</code>
            <code class="c1">// inherit anything even if it did have a prototype object.</code>
            <code class="nx">getPrototypeOf</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">null</code><code class="p">;</code> <code class="p">},</code>
            <code class="c1">// The object is not extensible, so we can't change the prototype</code>
            <code class="nx">setPrototypeOf</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">proto</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">false</code><code class="p">;</code> <code class="p">},</code>
        <code class="p">});</code>
        
        <code class="nx">identity</code><code class="p">.</code><code class="nx">x</code>                <code class="c1">// =&gt; "x"</code>
        <code class="nx">identity</code><code class="p">.</code><code class="nx">toString</code>         <code class="c1">// =&gt; "toString"</code>
        <code class="nx">identity</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code>               <code class="c1">// =&gt; "0"</code>
        <code class="nx">identity</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>           <code class="c1">// Setting properties has no effect</code>
        <code class="nx">identity</code><code class="p">.</code><code class="nx">x</code>                <code class="c1">// =&gt; "x"</code>
        <code class="k">delete</code> <code class="nx">identity</code><code class="p">.</code><code class="nx">x</code>         <code class="c1">// =&gt; false: can't delete properties either</code>
        <code class="nx">identity</code><code class="p">.</code><code class="nx">x</code>                <code class="c1">// =&gt; "x"</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">identity</code><code class="p">);</code>    <code class="c1">// !RangeError: can't list all the keys</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">p</code> <code class="k">of</code> <code class="nx">identity</code><code class="p">)</code> <code class="p">;</code>  <code class="c1">// !RangeError</code></pre>
        
        <p>Proxy objects can derive their behavior from the target object and
        from the handlers object, and the examples we have seen so far have
        used one object or the other. But it is typically more useful to
        define proxies that use both objects.</p>
        
        <p>The following code, for example, uses Proxy to create a read-only wrapper
        for a target object. When code tries to read values from the object,
        those reads are forwarded to the target object normally. But if any
        code tries to modify the object or its properties, methods of the
        handler object throw a TypeError. A proxy like this might be helpful
        for writing tests: suppose you’ve written a function that takes an
        object argument and want to ensure that your function does not make
        any attempt to modify the input argument. If your test passes in a
        read-only wrapper object, then any writes will throw exceptions that
        cause the test to fail:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">readOnlyProxy</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">function</code> <code class="nx">readonly</code><code class="p">()</code> <code class="p">{</code> <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s2">"Readonly"</code><code class="p">);</code> <code class="p">}</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="p">{</code>
                <code class="nx">set</code><code class="o">:</code> <code class="nx">readonly</code><code class="p">,</code>
                <code class="nx">defineProperty</code><code class="o">:</code> <code class="nx">readonly</code><code class="p">,</code>
                <code class="nx">deleteProperty</code><code class="o">:</code> <code class="nx">readonly</code><code class="p">,</code>
                <code class="nx">setPrototypeOf</code><code class="o">:</code> <code class="nx">readonly</code><code class="p">,</code>
            <code class="p">});</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code> <code class="p">};</code>    <code class="c1">// Normal writable object</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="nx">readOnlyProxy</code><code class="p">(</code><code class="nx">o</code><code class="p">);</code>  <code class="c1">// Readonly version of it</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">x</code>                        <code class="c1">// =&gt; 1: reading properties works</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>                   <code class="c1">// !TypeError: can't change properties</code>
        <code class="k">delete</code> <code class="nx">p</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>                <code class="c1">// !TypeError: can't delete properties</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">z</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>                   <code class="c1">// !TypeError: can't add properties</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">__proto__</code> <code class="o">=</code> <code class="p">{};</code>          <code class="c1">// !TypeError: can't change the prototype</code></pre>
        
        <p>Another technique when writing proxies is to define handler methods
        that intercept operations on an object but still delegate the
        operations to the target object. The functions of the Reflect API
        (<a data-type="xref" href="#reflectapi">§14.6</a>) have exactly the same signatures as the handler
        methods, so they make it easy to do that kind of delegation.</p>
        
        <p>Here, for
        example, is a proxy that delegates all operations to the target object
        but uses handler methods to log the operations:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="cm">/*</code>
        <code class="cm"> * Return a Proxy object that wraps o, delegating all operations to</code>
        <code class="cm"> * that object after logging each operation. objname is a string that</code>
        <code class="cm"> * will appear in the log messages to identify the object. If o has own</code>
        <code class="cm"> * properties whose values are objects or functions, then if you query</code>
        <code class="cm"> * the value of those properties, you'll get a loggingProxy back, so that</code>
        <code class="cm"> * logging behavior of this proxy is "contagious".</code>
        <code class="cm"> */</code>
        <code class="kd">function</code> <code class="nx">loggingProxy</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">objname</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Define handlers for our logging Proxy object.</code>
            <code class="c1">// Each handler logs a message and then delegates to the target object.</code>
            <code class="kr">const</code> <code class="nx">handlers</code> <code class="o">=</code> <code class="p">{</code>
                <code class="c1">// This handler is a special case because for own properties</code>
                <code class="c1">// whose value is an object or function, it returns a proxy rather</code>
                <code class="c1">// than returning the value itself.</code>
                <code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// Log the get operation</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Handler get(</code><code class="si">${</code><code class="nx">objname</code><code class="si">}</code><code class="sb">,</code><code class="si">${</code><code class="nx">property</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">)`</code><code class="p">);</code>
        
                    <code class="c1">// Use the Reflect API to get the property value</code>
                    <code class="kd">let</code> <code class="nx">value</code> <code class="o">=</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">property</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
        
                    <code class="c1">// If the property is an own property of the target and</code>
                    <code class="c1">// the value is an object or function then return a Proxy for it.</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">target</code><code class="p">).</code><code class="nx">includes</code><code class="p">(</code><code class="nx">property</code><code class="p">)</code> <code class="o">&amp;&amp;</code>
                        <code class="p">(</code><code class="k">typeof</code> <code class="nx">value</code> <code class="o">===</code> <code class="s2">"object"</code> <code class="o">||</code> <code class="k">typeof</code> <code class="nx">value</code> <code class="o">===</code> <code class="s2">"function"</code><code class="p">))</code> <code class="p">{</code>
                        <code class="k">return</code> <code class="nx">loggingProxy</code><code class="p">(</code><code class="nx">value</code><code class="p">,</code> <code class="sb">`</code><code class="si">${</code><code class="nx">objname</code><code class="si">}</code><code class="sb">.</code><code class="si">${</code><code class="nx">property</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
                    <code class="p">}</code>
        
                    <code class="c1">// Otherwise return the value unmodified.</code>
                    <code class="k">return</code> <code class="nx">value</code><code class="p">;</code>
                <code class="p">},</code>
        
                <code class="c1">// There is nothing special about the following three methods:</code>
                <code class="c1">// they log the operation and delegate to the target object.</code>
                <code class="c1">// They are a special case simply so we can avoid logging the</code>
                <code class="c1">// receiver object which can cause infinite recursion.</code>
                <code class="nx">set</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">prop</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Handler set(</code><code class="si">${</code><code class="nx">objname</code><code class="si">}</code><code class="sb">,</code><code class="si">${</code><code class="nx">prop</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code><code class="si">}</code><code class="sb">,</code><code class="si">${</code><code class="nx">value</code><code class="si">}</code><code class="sb">)`</code><code class="p">);</code>
                    <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">prop</code><code class="p">,</code> <code class="nx">value</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
                <code class="p">},</code>
                <code class="nx">apply</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">,</code> <code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Handler </code><code class="si">${</code><code class="nx">objname</code><code class="si">}</code><code class="sb">(</code><code class="si">${</code><code class="nx">args</code><code class="si">}</code><code class="sb">)`</code><code class="p">);</code>
                    <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
                <code class="p">},</code>
                <code class="nx">construct</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Handler </code><code class="si">${</code><code class="nx">objname</code><code class="si">}</code><code class="sb">(</code><code class="si">${</code><code class="nx">args</code><code class="si">}</code><code class="sb">)`</code><code class="p">);</code>
                    <code class="k">return</code> <code class="nx">Reflect</code><code class="p">.</code><code class="nx">construct</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="nx">args</code><code class="p">,</code> <code class="nx">receiver</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">};</code>
        
            <code class="c1">// We can automatically generate the rest of the handlers.</code>
            <code class="c1">// Metaprogramming FTW!</code>
            <code class="nx">Reflect</code><code class="p">.</code><code class="nx">ownKeys</code><code class="p">(</code><code class="nx">Reflect</code><code class="p">).</code><code class="nx">forEach</code><code class="p">(</code><code class="nx">handlerName</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">handlerName</code> <code class="k">in</code> <code class="nx">handlers</code><code class="p">))</code> <code class="p">{</code>
                    <code class="nx">handlers</code><code class="p">[</code><code class="nx">handlerName</code><code class="p">]</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
                        <code class="c1">// Log the operation</code>
                        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Handler </code><code class="si">${</code><code class="nx">handlerName</code><code class="si">}</code><code class="sb">(</code><code class="si">${</code><code class="nx">objname</code><code class="si">}</code><code class="sb">,</code><code class="si">${</code><code class="nx">args</code><code class="si">}</code><code class="sb">)`</code><code class="p">);</code>
                        <code class="c1">// Delegate the operation</code>
                        <code class="k">return</code> <code class="nx">Reflect</code><code class="p">[</code><code class="nx">handlerName</code><code class="p">](</code><code class="nx">target</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">);</code>
                    <code class="p">};</code>
                <code class="p">}</code>
            <code class="p">});</code>
        
            <code class="c1">// Return a proxy for the object using these logging handlers</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">handlers</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>The <code>loggingProxy()</code> function defined earlier creates proxies that log
        all of the ways they are used. If you are trying
        to understand how an undocumented function uses the objects you pass
        it, using a logging proxy can help.</p>
        
        <p>Consider the following examples, which result in some genuine insights about array <span class="keep-together">iteration:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Define an array of data and an object with a function property</code>
        <code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[</code><code class="mi">10</code><code class="p">,</code><code class="mi">20</code><code class="p">];</code>
        <code class="kd">let</code> <code class="nx">methods</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">square</code><code class="o">:</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code> <code class="p">};</code>
        
        <code class="c1">// Create logging proxies for the array and the object</code>
        <code class="kd">let</code> <code class="nx">proxyData</code> <code class="o">=</code> <code class="nx">loggingProxy</code><code class="p">(</code><code class="nx">data</code><code class="p">,</code> <code class="s2">"data"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">proxyMethods</code> <code class="o">=</code> <code class="nx">loggingProxy</code><code class="p">(</code><code class="nx">methods</code><code class="p">,</code> <code class="s2">"methods"</code><code class="p">);</code>
        
        <code class="c1">// Suppose we want to understand how the Array.map() method works</code>
        <code class="nx">data</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">methods</code><code class="p">.</code><code class="nx">square</code><code class="p">)</code>        <code class="c1">// =&gt; [100, 400]</code>
        
        <code class="c1">// First, let's try it with a logging Proxy array</code>
        <code class="nx">proxyData</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">methods</code><code class="p">.</code><code class="nx">square</code><code class="p">)</code>   <code class="c1">// =&gt; [100, 400]</code>
        <code class="c1">// It produces this output:</code>
        <code class="c1">// Handler get(data,map)</code>
        <code class="c1">// Handler get(data,length)</code>
        <code class="c1">// Handler get(data,constructor)</code>
        <code class="c1">// Handler has(data,0)</code>
        <code class="c1">// Handler get(data,0)</code>
        <code class="c1">// Handler has(data,1)</code>
        <code class="c1">// Handler get(data,1)</code>
        
        <code class="c1">// Now lets try with a proxy methods object</code>
        <code class="nx">data</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">proxyMethods</code><code class="p">.</code><code class="nx">square</code><code class="p">)</code>   <code class="c1">// =&gt; [100, 400]</code>
        <code class="c1">// Log output:</code>
        <code class="c1">// Handler get(methods,square)</code>
        <code class="c1">// Handler methods.square(10,0,10,20)</code>
        <code class="c1">// Handler methods.square(20,1,10,20)</code>
        
        <code class="c1">// Finally, let's use a logging proxy to learn about the iteration protocol</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="k">of</code> <code class="nx">proxyData</code><code class="p">)</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Datum"</code><code class="p">,</code> <code class="nx">x</code><code class="p">);</code>
        <code class="c1">// Log output:</code>
        <code class="c1">// Handler get(data,Symbol(Symbol.iterator))</code>
        <code class="c1">// Handler get(data,length)</code>
        <code class="c1">// Handler get(data,0)</code>
        <code class="c1">// Datum 10</code>
        <code class="c1">// Handler get(data,length)</code>
        <code class="c1">// Handler get(data,1)</code>
        <code class="c1">// Datum 20</code>
        <code class="c1">// Handler get(data,length)</code></pre>
        
        <p>From the first chunk of logging output, we learn that the
        <code>Array.map()</code> method explicitly checks for the existence of each array
        element (causing the <code>has()</code> handler to be invoked) before actually
        reading the element value (which triggers the <code>get()</code> handler). This
        is presumably so that it can distinguish nonexistent array elements
        from elements that exist but are undefined.</p>
        
        <p>The second chunk of logging output might remind us that the function
        we pass to <code>Array.map()</code> is invoked with three arguments: the
        element’s value, the element’s index, and the array itself. (There is
        a problem in our logging output: the <code>Array.toString()</code> method does
        not include square brackets in its output, and the log messages would
        be clearer if they were included in the argument list
        <code>(10,0,[10,20])</code>.)</p>
        
        <p>The third chunk of logging output shows us that the <code>for/of</code> loop
        works by looking for a method with symbolic name
        <code>[Symbol.iterator]</code>. It also demonstrates that the Array class’s
        implementation of this iterator method is careful to check the array
        length at every iteration and does not assume that the array length
        remains constant during the iteration.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="14.7.1 Proxy Invariants"><div class="sect2" id="idm46198511295912">
        <h2>14.7.1 Proxy Invariants</h2>
        
        <p>The<a data-type="indexterm" data-primary="proxy invariants" id="idm46198511294120"></a> <code>readOnlyProxy()</code> function defined earlier creates Proxy objects
        that are effectively frozen: any attempt to alter a property value or
        property attribute or to add or remove properties will throw an
        exception. But as long as the target object is not frozen, we’ll find
        that if we can query the proxy with <code>Reflect.isExtensible()</code> and
        <code>Reflect.getOwnPropertyDescriptor()</code>, and it will tell us that we
        should be able to set, add, and delete properties. So
        <code>readOnlyProxy()</code> creates objects in an inconsistent state. We could
        fix this by adding <code>isExtensible()</code> and <code>getOwnPropertyDescriptor()</code>
        handlers, or we can just live with this kind of minor inconsistency.</p>
        
        <p>The Proxy handler API allows us to define objects with major
        inconsistencies, however, and in this case, the Proxy class itself
        will prevent us from creating Proxy objects that are inconsistent in a
        bad way. At the start of this section, we described proxies as objects
        with no behavior of their own because they simply forward all
        operations to the handlers object and the target object. But this is
        not entirely true: after forwarding an operation, the Proxy class
        performs some sanity checks on the result to ensure important
        JavaScript invariants are not being violated. If it detects a
        violation, the proxy will throw a TypeError instead of letting the
        operation proceed.</p>
        
        <p>As an example, if you create a proxy for a non-extensible object, the
        proxy will throw a TypeError if the <code>isExtensible()</code> handler ever
        returns <code>true</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">target</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">preventExtensions</code><code class="p">({});</code>
        <code class="kd">let</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="p">{</code> <code class="nx">isExtensible</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="kc">true</code><code class="p">;</code> <code class="p">}});</code>
        <code class="nx">Reflect</code><code class="p">.</code><code class="nx">isExtensible</code><code class="p">(</code><code class="nx">proxy</code><code class="p">);</code>  <code class="c1">// !TypeError: invariant violation</code></pre>
        
        <p>Relatedly, proxy objects for non-extensible targets may not have a
        <code>getPrototypeOf()</code> handler that returns anything other than the real
        prototype object of the target. Also, if the target object has
        nonwritable, nonconfigurable properties, then the Proxy class will
        throw a TypeError if the <code>get()</code> handler returns anything other than
        the actual value:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">target</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">freeze</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">});</code>
        <code class="kd">let</code> <code class="nx">proxy</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Proxy</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="p">{</code> <code class="nx">get</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="mi">99</code><code class="p">;</code> <code class="p">}});</code>
        <code class="nx">proxy</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>         <code class="c1">// !TypeError: value returned by get() doesn't match target</code></pre>
        
        <p>Proxy enforces a number of additional invariants, almost all of them having <span class="keep-together">to do with non-extensible</span> target objects and nonconfigurable
        properties on the target object.<a data-type="indexterm" data-primary="" data-startref="AFproxy14" id="idm46198511197304"></a><a data-type="indexterm" data-primary="" data-startref="proxy14" id="idm46198511196456"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="14.8 Summary"><div class="sect1" id="idm46198512383736">
        <h1>14.8 Summary</h1>
        
        <p>In this chapter, you have learned:</p>
        
        <ul>
        <li>
        <p>JavaScript objects have an <em>extensible</em> attribute and object
        properties have <em>writable</em>, <em>enumerable</em>, and <em>configurable</em>
        attributes, as well as a value and a getter and/or setter
        attribute. You can use these attributes to “lock down” your objects
        in various ways, including creating “sealed” and “frozen” objects.</p>
        </li>
        <li>
        <p>JavaScript defines functions that allow you to traverse the
        prototype chain of an object and even to change the prototype of an
        object (though doing this can make your code slower).</p>
        </li>
        <li>
        <p>The properties of the <code>Symbol</code> object have values that are
        “well-known Symbols,” which you can use as property or method names
        for the objects and classes that you define. Doing so allows you to
        control how your object interacts with JavaScript language features
        and with the core library. For example, well-known Symbols allow you
        to make your classes iterable and control the string that is
        displayed when an instance is passed to
        <code>Object.prototype.toString()</code>. Prior to ES6, this kind of
        customization was available only to the native classes that were
        built in to an implementation.</p>
        </li>
        <li>
        <p>Tagged template literals are a function invocation syntax, and
        defining a new tag function is kind of like adding a new literal
        syntax to the language. Defining a tag function that parses its
        template string argument allows you to embed DSLs within JavaScript code. Tag functions also provide access to a
        raw, unescaped form of string literals where backslashes have no
        special meaning.</p>
        </li>
        <li>
        <p>The Proxy class and the related Reflect API allow low-level
        control over the fundamental behaviors of JavaScript objects. Proxy
        objects can be used as optionally revocable wrappers to improve code
        encapsulation, and they can also be used to implement nonstandard
        object behaviors (like some of the special case APIs defined by
        early web browsers).</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        <div data-type="footnotes"><p data-type="footnote" id="idm46198513295640"><sup><a href="ch14.html#idm46198513295640-marker">1</a></sup> A bug in the V8 JavaScript engine means that this code does not work correctly in Node 13.</p></div></div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->