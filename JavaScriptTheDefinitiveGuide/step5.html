<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Statements"><div class="chapter" id="statements">
<h1><span class="label">Chapter 5. </span>Statements</h1>


<p><a data-type="xref" href="ch04.html#expressions">Chapter&nbsp;4</a> described<a data-type="indexterm" data-primary="statements" data-secondary="overview of" id="idm46198556048712"></a> expressions as JavaScript phrases. By that
analogy, <em>statements</em> are JavaScript sentences or commands. Just as
English sentences are terminated and separated from one another with
periods, JavaScript statements are terminated with semicolons
(<a data-type="xref" href="ch02.html#optionalsemicolons">§2.6</a>). Expressions<a data-type="indexterm" data-primary="expressions" data-secondary="versus statements" data-secondary-sortas="statements" id="idm46198556046200"></a> are <em>evaluated</em> to produce a value, but statements are <em>executed</em> to make something happen.</p>

<p>One way to “make something happen” is to evaluate an expression that
has side effects. Expressions with side effects, such as assignments
and function invocations, can stand alone as statements, and when used
this way are known as <em>expression statements</em>. A similar
category of statements are the <em>declaration statements</em> that declare
new variables and define new functions.</p>

<p>JavaScript programs are nothing more than a sequence of statements to
execute. By default, the JavaScript interpreter executes these
statements one after another in the order they are written. Another way
to “make something happen” is to alter this default order of
execution, and JavaScript has a number of statements<a data-type="indexterm" data-primary="statements" data-secondary="control structures" id="idm46198556041672"></a><a data-type="indexterm" data-primary="control structures" id="idm46198556040696"></a> or <em>control
structures</em> that do just this:</p>
<dl>
<dt>Conditionals</dt>
<dd>
<p>Statements<a data-type="indexterm" data-primary="statements" data-secondary="conditional statements" id="idm46198556037720"></a><a data-type="indexterm" data-primary="conditional statements" id="idm46198556036712"></a> like <code>if</code> and <code>switch</code> that make the
JavaScript interpreter execute or skip other statements depending on
the value of an expression</p>
</dd>
<dt>Loops</dt>
<dd>
<p>Statements<a data-type="indexterm" data-primary="statements" data-secondary="loops" id="idm46198556033608"></a><a data-type="indexterm" data-primary="looping statements" data-secondary="purpose of" id="idm46198556032600"></a> like <code>while</code> and <code>for</code> that execute other
statements <span class="keep-together">repetitively</span></p>
</dd>
<dt>Jumps</dt>
<dd>
<p>Statements<a data-type="indexterm" data-primary="statements" data-secondary="jump statements" id="idm46198556028568"></a><a data-type="indexterm" data-primary="jump statements" id="idm46198556027560"></a><a data-type="indexterm" data-primary="jump statements" data-secondary="definition of term" id="idm46198556026888"></a> like <code>break</code>, <code>return</code>, and <code>throw</code> that cause
the interpreter to jump to another part of the program</p>
</dd>
</dl>

<p>The sections that follow describe the various statements in JavaScript
and explain their syntax. <a data-type="xref" href="#statementssummary">Table&nbsp;5-1</a>, at the end of the
chapter, summarizes the syntax. A JavaScript program is simply a
sequence of statements, separated from one another with <span class="keep-together">semicolons,</span> so
once you are familiar with the statements of JavaScript, you can begin
writing JavaScript programs.</p>






<section data-type="sect1" data-pdf-bookmark="5.1 Expression Statements"><div class="sect1" id="idm46198556022088">
<h1>5.1 Expression Statements</h1>

<p>The<a data-type="indexterm" data-primary="statements" data-secondary="expression statements" id="idm46198556020360"></a><a data-type="indexterm" data-primary="expression statements" id="idm46198556004600"></a> simplest kinds of statements in JavaScript are expressions that
have side effects. This sort of statement was shown in
<a data-type="xref" href="ch04.html#expressions">Chapter&nbsp;4</a>. Assignment statements are one major category of
expression statements. For example:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">greeting</code> <code class="o">=</code> <code class="s2">"Hello "</code> <code class="o">+</code> <code class="nx">name</code><code class="p">;</code>
<code class="nx">i</code> <code class="o">*=</code> <code class="mi">3</code><code class="p">;</code></pre>

<p>The increment and decrement operators, <code>++</code> and <code>--</code>, are related
to assignment statements. These have the side effect of changing a
variable value, just as if an assignment had been performed:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">counter</code><code class="o">++</code><code class="p">;</code></pre>

<p>The <code>delete</code> operator has the important side effect of deleting an
object property. Thus, it is almost always used as a statement, rather
than as part of a larger <span class="keep-together">expression:</span></p>

<pre data-type="programlisting" data-code-language="js"><code class="k">delete</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code></pre>

<p>Function calls are another major category of expression statements. For
example:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">debugMessage</code><code class="p">);</code>
<code class="nx">displaySpinner</code><code class="p">();</code> <code class="c1">// A hypothetical function to display a spinner in a web app.</code></pre>

<p>These function calls are expressions, but they have side effects
that affect the host environment or program state, and they are used here
as statements. If a function does not have any side effects, there is
no sense in calling it, unless it is part of a larger expression or an
assignment statement. For example, you wouldn’t just compute a cosine
and discard the result:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nb">Math</code><code class="p">.</code><code class="nx">cos</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code></pre>

<p>But you might well compute the value and assign it to a variable for
future use:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">cx</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">cos</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code></pre>

<p>Note that each line of code in each of these examples is terminated
with a semicolon.</p>
</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="5.2 Compound and Empty Statements"><div class="sect1" id="idm46198556021592">
<h1>5.2 Compound and Empty Statements</h1>

<p>Just<a data-type="indexterm" data-primary="statements" data-secondary="compound and empty statements" id="idm46198555857816"></a><a data-type="indexterm" data-primary="compound statements" id="idm46198555856840"></a><a data-type="indexterm" data-primary="empty statements" id="idm46198555856168"></a><a data-type="indexterm" data-primary="statement blocks" id="idm46198555863048"></a> as the comma operator (<a data-type="xref" href="ch04.html#commaoperator">§4.13.7</a>) combines multiple
expressions into a single expression, a <em>statement block</em> combines
multiple statements into a single <em>compound statement</em>. A statement
block is simply a sequence of statements enclosed within curly braces.
Thus, the following lines act as a single statement and can be used
anywhere that JavaScript expects a single statement:</p>

<pre data-type="programlisting" data-code-language="js"><code class="p">{</code>
    <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code><code class="p">;</code>
    <code class="nx">cx</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">cos</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"cos(π) = "</code> <code class="o">+</code> <code class="nx">cx</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>There are a few things to note about this statement block. First, it
does <em>not</em> end with a semicolon. The primitive statements within the
block end in semicolons, but the block itself does not. Second, the
lines inside the block are indented relative to the curly braces that
enclose them. This is optional, but it makes the code easier to read
and understand.</p>

<p>Just as expressions often contain subexpressions, many JavaScript
statements contain substatements. Formally, JavaScript syntax usually
allows a single substatement. For example, the <code>while</code> loop syntax
includes a single statement that serves as the body of the loop. Using
a statement block, you can place any number of statements within this
single allowed substatement.</p>

<p>A compound statement allows you to use multiple statements where
JavaScript syntax expects a single statement. The <em>empty statement</em>
is the opposite: it allows you to include no statements where one is
expected. The empty statement looks like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="p">;</code></pre>

<p>The JavaScript interpreter takes no action when it executes an empty
statement. The empty statement is occasionally useful when you want to
create a loop that has an empty body. Consider the following <code>for</code> loop
(<code>for</code> loops will be covered in <a data-type="xref" href="#forloop">§5.4.3</a>):</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Initialize an array a</code>
<code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="o">++</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">;</code></pre>

<p>In this loop, all the work is done by the expression <code>a[i++] = 0</code>,
and no loop body is necessary. JavaScript syntax requires a
statement as a loop body, however, so an empty statement—just a bare
semicolon—is used.</p>

<p>Note that the accidental inclusion of a semicolon after the right
parenthesis of a <code>for</code> loop, <code>while</code> loop, or <code>if</code> statement can cause
frustrating bugs that are difficult to detect. For example, the
following code probably does not do what the author intended:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">((</code><code class="nx">a</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="o">||</code> <code class="p">(</code><code class="nx">b</code> <code class="o">===</code> <code class="mi">0</code><code class="p">));</code>  <code class="c1">// Oops! This line does nothing...</code>
    <code class="nx">o</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>                 <code class="c1">// and this line is always executed.</code></pre>

<p>When you intentionally use the empty statement, it is a good idea to
comment your code in a way that makes it clear that you are doing it on
purpose. For example:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="o">++</code><code class="p">]</code> <code class="o">=</code> <code class="mi">0</code><code class="p">)</code> <code class="cm">/* empty */</code> <code class="p">;</code></pre>
</div></section>













<section data-type="sect1" data-pdf-bookmark="5.3 Conditionals"><div class="sect1" id="idm46198555715976">
<h1>5.3 Conditionals</h1>

<p>Conditional statements<a data-type="indexterm" data-primary="statements" data-secondary="conditional statements" id="Scond05"></a><a data-type="indexterm" data-primary="conditional statements" id="cond05"></a> execute or skip other statements depending on
the value of a specified expression. These statements are the decision
points of your code, and they are also sometimes known as “branches.”
If you imagine a JavaScript interpreter following a path through your
code, the conditional statements are the places where the code branches
into two or more paths and the interpreter must choose which path to
follow.</p>

<p>The following subsections explain JavaScript’s basic conditional, the
<code>if/else</code> statement, and also cover <code>switch</code>, a more complicated,
multiway branch statement.</p>








<section data-type="sect2" data-pdf-bookmark="5.3.1 if"><div class="sect2" id="ifstatement">
<h2>5.3.1 if</h2>

<p>The<a data-type="indexterm" data-primary="if statements" id="ifstat05"></a> <code>if</code> statement is the fundamental control statement that allows
JavaScript to make decisions, or, more precisely, to execute statements
conditionally. This statement has two forms. The first is:</p>
<pre data-type="programlisting" data-code-language="js">if (<em><code>expression</code></em>)
    <em><code>statement</code></em></pre>

<p>In this form, <em>expression</em> is evaluated. If the resulting value is
truthy, <em>statement</em> is executed. If <em>expression</em> is falsy,
<em>statement</em> is not executed. (See <a data-type="xref" href="ch03.html#booleans">§3.4</a> for a definition of
truthy and falsy values.) For example:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">username</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code>       <code class="c1">// If username is null or undefined,</code>
    <code class="nx">username</code> <code class="o">=</code> <code class="s2">"John Doe"</code><code class="p">;</code>  <code class="c1">// define it</code></pre>

<p>Or similarly:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// If username is null, undefined, false, 0, "", or NaN, give it a new value</code>
<code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">username</code><code class="p">)</code> <code class="nx">username</code> <code class="o">=</code> <code class="s2">"John Doe"</code><code class="p">;</code></pre>

<p>Note that the parentheses around the <em>expression</em> are a required part
of the syntax for the <code>if</code> statement.</p>

<p>JavaScript syntax requires a single statement after the <code>if</code> keyword
and parenthesized expression, but you can use a statement block to
combine multiple statements into one. So the <code>if</code> statement might also
look like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">address</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">address</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
    <code class="nx">message</code> <code class="o">=</code> <code class="s2">"Please specify a mailing address."</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>The second form of the <code>if</code> statement introduces an <code>else</code> clause that
is executed when <em>expression</em> is <code>false</code>. Its syntax is:</p>
<pre data-type="programlisting" data-code-language="js">if (<em><code>expression</code></em>)
    <em><code>statement1</code></em>
else
    <em><code>statement2</code></em></pre>

<p>This form of the statement executes <code>statement1</code> if <em>expression</em> is
truthy and executes <code>statement2</code> if <em>expression</em> is falsy. For
example:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"You have 1 new message."</code><code class="p">);</code>
<code class="k">else</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`You have </code><code class="si">${</code><code class="nx">n</code><code class="si">}</code><code class="sb"> new messages.`</code><code class="p">);</code></pre>

<p>When you have nested <code>if</code> statements with <code>else</code> clauses, some caution
is required to ensure that the <code>else</code> clause goes with the appropriate
<code>if</code> statement. Consider the following lines:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">i</code> <code class="o">=</code> <code class="nx">j</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
<code class="nx">k</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
<code class="k">if</code> <code class="p">(</code><code class="nx">i</code> <code class="o">===</code> <code class="nx">j</code><code class="p">)</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">j</code> <code class="o">===</code> <code class="nx">k</code><code class="p">)</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"i equals k"</code><code class="p">);</code>
<code class="k">else</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"i doesn't equal j"</code><code class="p">);</code>    <code class="c1">// WRONG!!</code></pre>

<p>In this example, the inner <code>if</code> statement forms the single statement
allowed by the syntax of the outer <code>if</code> statement. Unfortunately, it is
not clear (except from the hint given by the indentation) which <code>if</code>
the <code>else</code> goes with. And in this example, the indentation is wrong,
because a JavaScript interpreter actually interprets the previous
example as:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">i</code> <code class="o">===</code> <code class="nx">j</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">j</code> <code class="o">===</code> <code class="nx">k</code><code class="p">)</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"i equals k"</code><code class="p">);</code>
    <code class="k">else</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"i doesn't equal j"</code><code class="p">);</code>    <code class="c1">// OOPS!</code>
<code class="p">}</code></pre>

<p>The rule in JavaScript (as in most programming languages) is that by
default an <code>else</code> clause is part of the nearest <code>if</code> statement. To make
this example less ambiguous and easier to read, understand, maintain,
and debug, you should use curly braces:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">i</code> <code class="o">===</code> <code class="nx">j</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">j</code> <code class="o">===</code> <code class="nx">k</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"i equals k"</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>  <code class="c1">// What a difference the location of a curly brace makes!</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"i doesn't equal j"</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Many programmers make a habit of enclosing the bodies of <code>if</code> and
<code>else</code> statements (as well as other compound statements, such as
<code>while</code> loops) within curly braces, even when the body consists of
only a single statement. Doing so consistently can prevent the sort of
problem just shown, and I advise you to adopt this practice. In this
printed book, I place a premium on keeping example code vertically
compact, and I do not always follow my own advice on this matter.<a data-type="indexterm" data-primary="" data-startref="ifstat05" id="idm46198555271400"></a></p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.3.2 else if"><div class="sect2" id="idm46198555629864">
<h2>5.3.2 else if</h2>

<p>The<a data-type="indexterm" data-primary="else if statements" id="idm46198555269048"></a> <code>if/else</code> statement evaluates an expression and executes one
of two pieces of code, depending on the outcome. But what about when
you need to execute one of many pieces of code? One way to do this is
with an <code>else if</code> statement. <code>else if</code> is not really a JavaScript
statement, but simply a frequently used programming idiom that results
when repeated <code>if/else</code> statements are used:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Execute code block #1</code>
<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Execute code block #2</code>
<code class="p">}</code> <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">3</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Execute code block #3</code>
<code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
    <code class="c1">// If all else fails, execute block #4</code>
<code class="p">}</code></pre>

<p>There is nothing special about this code. It is just a series of <code>if</code>
statements, where each following <code>if</code> is part of the <code>else</code> clause of
the previous statement. Using the <code>else if</code> idiom is preferable to,
and more legible than, writing these statements out in their
syntactically equivalent, fully nested form:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Execute code block #1</code>
<code class="p">}</code>
<code class="k">else</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">2</code><code class="p">)</code> <code class="p">{</code>
        <code class="c1">// Execute code block #2</code>
    <code class="p">}</code>
    <code class="k">else</code> <code class="p">{</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">===</code> <code class="mi">3</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Execute code block #3</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="p">{</code>
            <code class="c1">// If all else fails, execute block #4</code>
        <code class="p">}</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.3.3 switch"><div class="sect2" id="switch">
<h2>5.3.3 switch</h2>

<p>An<a data-type="indexterm" data-primary="switch statements" id="switch05"></a> <code>if</code> statement causes a branch in the flow of a program’s execution,
and you can use the <code>else if</code> idiom to perform a multiway branch.
This is not the best solution, however, when all of the branches depend
on the value of the same expression. In this case, it is wasteful to
repeatedly evaluate that expression in multiple <code>if</code> statements.</p>

<p>The <code>switch</code> statement handles exactly this situation. The <code>switch</code>
keyword is followed by an expression in parentheses and a block of code
in curly braces:</p>
<pre data-type="programlisting" data-code-language="js">switch(<em><code>expression</code></em>) {
    <em><code>statements</code></em>
}</pre>

<p>However, the full syntax of a <code>switch</code> statement is more complex than
this. Various locations in the block of code are labeled with the
<code>case</code> keyword followed by an expression and a colon. When a <code>switch</code>
executes, it computes the value of <em>expression</em> and then looks for a
<code>case</code> label whose expression evaluates to the same value (where
sameness is determined by the <code>===</code> operator). If it finds one, it
starts executing the block of code at the statement labeled by the
<code>case</code>. If it does not find a <code>case</code> with a matching value, it looks
for a statement labeled <code>default:</code>. If there is no <code>default:</code> label,
the <code>switch</code> statement skips the block of code altogether.</p>

<p><code>switch</code> is a confusing statement to explain; its operation becomes
much clearer with an example. The following <code>switch</code> statement is
equivalent to the repeated <code>if/else</code> statements shown in the
previous section:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">switch</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
<code class="k">case</code> <code class="mi">1</code><code class="o">:</code>                        <code class="c1">// Start here if n === 1</code>
    <code class="c1">// Execute code block #1.</code>
    <code class="k">break</code><code class="p">;</code>                     <code class="c1">// Stop here</code>
<code class="k">case</code> <code class="mi">2</code><code class="o">:</code>                        <code class="c1">// Start here if n === 2</code>
    <code class="c1">// Execute code block #2.</code>
    <code class="k">break</code><code class="p">;</code>                     <code class="c1">// Stop here</code>
<code class="k">case</code> <code class="mi">3</code><code class="o">:</code>                        <code class="c1">// Start here if n === 3</code>
    <code class="c1">// Execute code block #3.</code>
    <code class="k">break</code><code class="p">;</code>                     <code class="c1">// Stop here</code>
<code class="k">default</code><code class="o">:</code>                       <code class="c1">// If all else fails...</code>
    <code class="c1">// Execute code block #4.</code>
    <code class="k">break</code><code class="p">;</code>                     <code class="c1">// Stop here</code>
<code class="p">}</code></pre>

<p>Note the <code>break</code> keyword used at the end of each <code>case</code> in this code. The <code>break</code> statement, described later in this chapter, causes
the interpreter to jump to the end (or “break out”) of the <code>switch</code>
statement and continue with the statement that follows it. The <code>case</code>
clauses in a <code>switch</code> statement specify only the <em>starting point</em> of
the desired code; they do not specify any ending point. In the absence
of <code>break</code> statements, a <code>switch</code> statement begins executing its block
of code at the <code>case</code> label that matches the value of its
<em>expression</em> and continues executing statements until it reaches the
end of the block. On rare occasions, it is useful to write code like
this that “falls through” from one <code>case</code> label to the next, but 99% of the time you should be careful to end every <code>case</code> with a
<code>break</code> statement. (When using <code>switch</code> inside a function, however, you
may use a <code>return</code> statement instead of a <code>break</code> statement. Both serve
to terminate the <code>switch</code> statement and prevent execution from falling
through to the next <code>case</code>.)</p>

<p>Here is a more realistic example of the <code>switch</code> statement; it converts
a value to a string in a way that depends on the type of the value:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">convert</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">switch</code><code class="p">(</code><code class="k">typeof</code> <code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">case</code> <code class="s2">"number"</code><code class="o">:</code>            <code class="c1">// Convert the number to a hexadecimal integer</code>
        <code class="k">return</code> <code class="nx">x</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code><code class="mi">16</code><code class="p">);</code>
    <code class="k">case</code> <code class="s2">"string"</code><code class="o">:</code>            <code class="c1">// Return the string enclosed in quotes</code>
        <code class="k">return</code> <code class="s1">'"'</code> <code class="o">+</code> <code class="nx">x</code> <code class="o">+</code> <code class="s1">'"'</code><code class="p">;</code>
    <code class="k">default</code><code class="o">:</code>                  <code class="c1">// Convert any other type in the usual way</code>
        <code class="k">return</code> <code class="nb">String</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>Note that in the two previous examples, the <code>case</code> keywords are
followed by number and string literals, respectively. This is how the
<code>switch</code> statement is most often used in practice, but note that the
ECMAScript standard allows each <code>case</code> to be followed by an arbitrary
expression.</p>

<p>The <code>switch</code> statement first evaluates the expression that follows the
<code>switch</code> keyword and then evaluates the <code>case</code> expressions, in the
order in which they appear, until it finds a value that
matches.<sup><a data-type="noteref" id="idm46198554953944-marker" href="ch05.html#idm46198554953944">1</a></sup> The matching
case is determined using the <code>===</code> identity operator, not the <code>==</code>
equality operator, so the expressions must match without any type
conversion.</p>

<p>Because not all of the <code>case</code> expressions are evaluated each time the
<code>switch</code> statement is executed, you should avoid using <code>case</code>
expressions that contain side effects such as function calls or
assignments. The safest course is simply to limit your <code>case</code>
expressions to constant expressions.</p>

<p>As explained earlier, if none of the <code>case</code> expressions match the
<code>switch</code> expression, the <code>switch</code> statement begins executing its body
at the statement labeled <code>default:</code>. If there is no <code>default:</code> label,
the <code>switch</code> statement skips its body altogether. Note that in the
examples shown, the <code>default:</code> label appears at the end of the <code>switch</code>
body, <span class="keep-together">following</span> all the <code>case</code> labels. This is a logical and common
place for it, but it can actually appear anywhere within the body of
the statement.<a data-type="indexterm" data-primary="" data-startref="Scond05" id="idm46198554941960"></a><a data-type="indexterm" data-primary="" data-startref="cond05" id="idm46198554940984"></a><a data-type="indexterm" data-primary="" data-startref="switch05" id="idm46198554940040"></a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="5.4 Loops"><div class="sect1" id="idm46198555131368">
<h1>5.4 Loops</h1>

<p>To<a data-type="indexterm" data-primary="statements" data-secondary="loops" id="Sloop05"></a> understand conditional statements, we imagined the JavaScript
interpreter following a branching path through your source code. The
<em>looping statements</em> are those that bend that path back upon itself to
repeat portions of your code. JavaScript has five looping statements:
<code>while</code>, <code>do/while</code>, <code>for</code>, <code>for/of</code> (and its <code>for/await</code> variant),
and <code>for/in</code>. The following subsections explain each in turn. One common
use for loops is to iterate over the elements of an
array. <a data-type="xref" href="ch07.html#iteratingarrays">§7.6</a> discusses this kind of loop in detail and
covers special looping methods defined by the Array class.</p>








<section data-type="sect2" data-pdf-bookmark="5.4.1 while"><div class="sect2" id="idm46198554931816">
<h2>5.4.1 while</h2>

<p>Just<a data-type="indexterm" data-primary="looping statements" data-secondary="while loops" id="idm46198554930280"></a><a data-type="indexterm" data-primary="while loops" id="idm46198554929272"></a> as the <code>if</code> statement is <span class="keep-together">JavaScript’s</span> basic conditional, the
<code>while</code> statement is JavaScript’s basic loop. It has the following
syntax:</p>
<pre data-type="programlisting" data-code-language="js">while (<em><code>expression</code></em>)
    <em><code>statement</code></em></pre>

<p>To execute a <code>while</code> statement, the interpreter first evaluates
<em>expression</em>. If the value of the expression is falsy, then the
interpreter skips over the <em>statement</em> that serves as the loop body
and moves on to the next statement in the program. If, on the other
hand, the <em>expression</em> is truthy, the interpreter executes the
<em>statement</em> and repeats, jumping back to the top of the loop and
evaluating <em>expression</em> again. Another way to say this is that the
interpreter executes <em>statement</em> repeatedly <em>while</em> the
<em>expression</em> is truthy. Note that you can create an infinite loop
with the syntax <code>while(true)</code>.</p>

<p>Usually, you do not want JavaScript to perform exactly the same
operation over and over again. In almost every loop, one or more
variables change with each <em>iteration</em> of the loop. Since the variables
change, the actions performed by executing <em>statement</em> may differ
each time through the loop. Furthermore, if the changing variable or
variables are involved in <em>expression</em>, the value of the expression
may be different each time through the loop. This is important;
otherwise, an expression that starts off truthy would never change, and
the loop would never end! Here is an example of a <code>while</code> loop that
prints the numbers from 0 to 9:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="k">while</code><code class="p">(</code><code class="nx">count</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">count</code><code class="p">);</code>
    <code class="nx">count</code><code class="o">++</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>As you can see, the variable <code>count</code> starts off at 0 and is incremented
each time the body of the loop runs. Once the loop has executed 10
times, the expression becomes <code>false</code> (i.e., the variable <code>count</code> is no
longer less than 10), the <code>while</code> statement finishes, and the
interpreter can move on to the next statement in the program. Many
loops have a counter variable like <code>count</code>. The variable names <code>i</code>,
<code>j</code>, and <code>k</code> are commonly used as loop counters, though you should use
more descriptive names if it makes your code easier to understand.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.4.2 do/while"><div class="sect2" id="idm46198554861256">
<h2>5.4.2 do/while</h2>

<p>The<a data-type="indexterm" data-primary="looping statements" data-secondary="do/while loops" id="idm46198554859848"></a><a data-type="indexterm" data-primary="do/while loops" id="idm46198554858840"></a> <code>do/while</code> loop is like a <code>while</code> loop, except that the loop
expression is tested at the bottom of the loop rather than at the top.
This means that the body of the loop is always executed at least once.
The syntax is:</p>
<pre data-type="programlisting" data-code-language="js">do
    <em><code>statement</code></em>
while (<em><code>expression</code></em>);</pre>

<p>The <code>do/while</code> loop is less commonly used than its <code>while</code>
cousin—in practice, it is somewhat uncommon to be certain that you want
a loop to execute at least once. Here’s an example of a
<code>do/while</code> loop:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">printArray</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code> <code class="p">{</code>
    <code class="kd">let</code> <code class="nx">len</code> <code class="o">=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">,</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">len</code> <code class="o">===</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="s2">"Empty Array"</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="k">do</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">]);</code>
        <code class="p">}</code> <code class="k">while</code><code class="p">(</code><code class="o">++</code><code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">len</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>There are a couple of syntactic differences between the
<code>do/while</code> loop and the ordinary <code>while</code> loop. First, the <code>do</code>
loop requires both the <code>do</code> keyword (to mark the beginning of the loop)
and the <code>while</code> keyword (to mark the end and introduce the loop
condition). Also, the <code>do</code> loop must always be terminated with a
semicolon. The <code>while</code> loop doesn’t need a semicolon if the loop body
is enclosed in curly braces.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.4.3 for"><div class="sect2" id="forloop">
<h2>5.4.3 for</h2>

<p>The<a data-type="indexterm" data-primary="looping statements" data-secondary="for loops" id="idm46198554770520"></a><a data-type="indexterm" data-primary="for loops" id="idm46198554769512"></a> <code>for</code> statement provides a looping construct that is often more
convenient than the <code>while</code> statement. The <code>for</code> statement simplifies
loops that follow a common pattern. Most loops have a counter variable
of some kind. This variable is initialized before the loop starts and
is tested before each iteration of the loop. Finally, the counter
variable is incremented or otherwise updated at the end of the loop
body, just before the variable is tested again. In this kind of loop,
the initialization, the test, and the update are the three crucial
manipulations of a loop variable. The <code>for</code> statement encodes each of
these three manipulations as an expression and makes those expressions
an explicit part of the loop syntax:</p>
<pre data-type="programlisting" data-code-language="js">for(<em><code>initialize</code></em> ; <em><code>test</code></em> ; <em><code>increment</code></em>)
    <em><code>statement</code></em></pre>

<p><em>initialize</em>, <em>test</em>, and <em>increment</em> are three expressions
(separated by semicolons) that are responsible for initializing,
testing, and incrementing the loop variable. Putting them all in the
first line of the loop makes it easy to understand what a <code>for</code> loop is
doing and prevents mistakes such as forgetting to initialize or
increment the loop variable.</p>

<p>The simplest way to explain how a <code>for</code> loop works is to show the
equivalent <code>while</code> loop:<sup><a data-type="noteref" id="idm46198554759768-marker" href="ch05.html#idm46198554759768">2</a></sup></p>
<pre data-type="programlisting" data-code-language="js"><em><code>initialize</code></em>;
while(<em><code>test</code></em>) {
    <em><code>statement</code></em>
    <em><code>increment</code></em>;
}</pre>

<p>In other words, the <em>initialize</em> expression is evaluated once, before
the loop begins. To be useful, this expression must have side effects
(usually an assignment). JavaScript also allows <em>initialize</em> to be a
variable declaration statement so that you can declare and
initialize a loop counter at the same time. The <em>test</em> expression is
evaluated before each iteration and controls whether the body of the
loop is executed. If <em>test</em> evaluates to a truthy value, the
<em>statement</em> that is the body of the loop is executed. Finally, the
<em>increment</em> expression is evaluated. Again, this must be an
expression with side effects in order to be useful. Generally, it is either an assignment expression, or it uses the <code>++</code> <span class="keep-together">or <code>--</code> operators.</span></p>

<p>We can print the numbers from 0 to 9 with a <code>for</code> loop like the
following. Contrast it with the equivalent <code>while</code> loop shown in the
previous section:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">count</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">count</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">count</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">count</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>Loops can become a lot more complex than this simple example, of
course, and sometimes multiple variables change with each iteration of
the loop. This situation is the only place that the comma operator is
commonly used in JavaScript; it provides a way to combine multiple
initialization and increment expressions into a single expression
suitable for use in a <code>for</code> loop:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">j</code><code class="p">,</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="k">for</code><code class="p">(</code><code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">j</code> <code class="o">=</code> <code class="mi">10</code> <code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code> <code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">,</code> <code class="nx">j</code><code class="o">--</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">i</code> <code class="o">*</code> <code class="nx">j</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>In all our loop examples so far, the loop variable has been numeric.
This is quite common but is not necessary. The following code uses a
<code>for</code> loop to traverse a linked list data structure and return the last
object in the list (i.e., the first object that does not have a <code>next</code>
property):</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">tail</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code>                          <code class="c1">// Return the tail of linked list o</code>
    <code class="k">for</code><code class="p">(;</code> <code class="nx">o</code><code class="p">.</code><code class="nx">next</code><code class="p">;</code> <code class="nx">o</code> <code class="o">=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">next</code><code class="p">)</code> <code class="cm">/* empty */</code> <code class="p">;</code> <code class="c1">// Traverse while o.next is truthy</code>
    <code class="k">return</code> <code class="nx">o</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>Note that this code has no <em>initialize</em> expression. Any of the
three expressions may be omitted from a <code>for</code> loop, but the two
semicolons are required. If you omit the <em>test</em> expression, the loop
repeats forever, and <code>for(;;)</code> is another way of writing an infinite
loop, like <code>while(true)</code>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.4.4 for/of"><div class="sect2" id="forofloop">
<h2>5.4.4 for/of</h2>

<p>ES6<a data-type="indexterm" data-primary="ES6" data-secondary="for/of loops" id="ESforof05"></a><a data-type="indexterm" data-primary="looping statements" data-secondary="for/of loops" id="LSforof05"></a><a data-type="indexterm" data-primary="for/of loops" id="forof05"></a> defines a new loop statement: <code>for/of</code>. This new kind of
loop uses the <code>for</code> keyword but is a completely different kind of loop
than the regular <code>for</code> loop. (It is also completely different than the
older <code>for/in</code> loop that we’ll describe in <a data-type="xref" href="#forinloop">§5.4.5</a>.)</p>

<p>The <code>for/of</code> loop works with <em>iterable</em> objects. We’ll explain
exactly what it means for an object to be iterable in <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>,
but for this chapter, it is enough to know that arrays, strings, sets,
and maps are iterable: they represent a sequence or set of elements
that you can loop or iterate through using a <code>for/of</code> loop.</p>

<p>Here, for example, is how we can use <code>for/of</code> to loop through the
elements of an array of numbers and compute their sum:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">,</code> <code class="mi">7</code><code class="p">,</code> <code class="mi">8</code><code class="p">,</code> <code class="mi">9</code><code class="p">],</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">data</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">element</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">sum</code>       <code class="c1">// =&gt; 45</code></pre>

<p>Superficially, the syntax looks like a regular <code>for</code> loop: the <code>for</code>
keyword is followed by parentheses that contain details about what the
loop should do. In this case, the parentheses contain a variable
declaration (or, for variables that have already been declared, simply
the name of the variable) followed by the <code>of</code> keyword and an
expression that evaluates to an iterable object, like the <code>data</code> array
in this case. As with all loops, the body of a <code>for/of</code> loop follows
the parentheses, typically within curly braces.</p>

<p>In the code just shown, the loop body runs once for each element of the
<code>data</code> array. Before each execution of the loop body, the next element
of the array is assigned to the element variable. Array elements are
iterated in order from first to last.</p>

<p>Arrays are iterated “live”—changes made during the iteration may
affect the outcome of the iteration. If we modify the preceding code by adding the line <code>data.push(sum);</code> inside the loop body, then we create
an infinite loop because the iteration can never reach the last
element of the array.</p>










<section data-type="sect3" data-pdf-bookmark="for/of with objects"><div class="sect3" id="idm46198554479896">
<h3>for/of with objects</h3>

<p>Objects are not (by default) iterable. Attempting to use <code>for/of</code> on a
regular object throws a TypeError at runtime:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="mi">3</code> <code class="p">};</code>
<code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// Throws TypeError because o is not iterable</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">element</code><code class="p">);</code>
<code class="p">}</code></pre>

<p>If<a data-type="indexterm" data-primary="Object.keys method" id="idm46198554457224"></a> you want to iterate through the properties of an object, you can
use the <code>for/in</code> loop (introduced in <a data-type="xref" href="#forinloop">§5.4.5</a>), or use <code>for/of</code>
with the <code>Object.keys()</code> method:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="mi">3</code> <code class="p">};</code>
<code class="kd">let</code> <code class="nx">keys</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
<code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">k</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">o</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">keys</code> <code class="o">+=</code> <code class="nx">k</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">keys</code>  <code class="c1">// =&gt; "xyz"</code></pre>

<p>This works because <code>Object.keys()</code> returns an array of property names
for an object, and arrays are iterable with <code>for/of</code>. Note also that
this iteration of the keys of an object is not live as the array
example above was—changes to the object <code>o</code> made in the loop body
will have no effect on the iteration. If you don’t care about the keys
of an object, you can also iterate through their corresponding values
like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">v</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">values</code><code class="p">(</code><code class="nx">o</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">v</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">sum</code> <code class="c1">// =&gt; 6</code></pre>

<p>And<a data-type="indexterm" data-primary="Object.entries() method" id="idm46198554312376"></a> if you are interested in both the keys and the values of an
object’s properties, you can use <code>for/of</code> with <code>Object.entries()</code> and
destructuring assignment:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">pairs</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
<code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="p">[</code><code class="nx">k</code><code class="p">,</code> <code class="nx">v</code><code class="p">]</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">entries</code><code class="p">(</code><code class="nx">o</code><code class="p">))</code> <code class="p">{</code>
    <code class="nx">pairs</code> <code class="o">+=</code> <code class="nx">k</code> <code class="o">+</code> <code class="nx">v</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">pairs</code>  <code class="c1">// =&gt; "x1y2z3"</code></pre>

<p><code>Object.entries()</code> returns an array of arrays, where each inner array
represents a key/value pair for one property of the object. We use
destructuring assignment in this code example to unpack those inner
arrays into two individual variables.</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="for/of with strings"><div class="sect3" id="idm46198554479400">
<h3>for/of with strings</h3>

<p>Strings are iterable character-by-character in ES6:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">frequency</code> <code class="o">=</code> <code class="p">{};</code>
<code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">letter</code> <code class="k">of</code> <code class="s2">"mississippi"</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">frequency</code><code class="p">[</code><code class="nx">letter</code><code class="p">])</code> <code class="p">{</code>
        <code class="nx">frequency</code><code class="p">[</code><code class="nx">letter</code><code class="p">]</code><code class="o">++</code><code class="p">;</code>
    <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
        <code class="nx">frequency</code><code class="p">[</code><code class="nx">letter</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code>
<code class="nx">frequency</code>   <code class="c1">// =&gt; {m: 1, i: 4, s: 4, p: 2}</code></pre>

<p>Note that strings are iterated by Unicode codepoint, not by UTF-16
character. The string “I ❤ <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/assets/cat.png" width="147" height="146">” has a <code>.length</code> of 5 (because the two
emoji characters each require two UTF-16 characters to represent). But
if you iterate that string with <code>for/of</code>, the loop body will run three
times, once for each of the three code points “I”, “❤”, and “<img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/assets/cat.png" width="147" height="146">.”</p>
</div></section>













<section data-type="sect3" data-pdf-bookmark="for/of with Set and Map"><div class="sect3" id="idm46198554150680">
<h3>for/of with Set and Map</h3>

<p>The<a data-type="indexterm" data-primary="ES6" data-secondary="Set and Map classes" id="idm46198554149112"></a><a data-type="indexterm" data-primary="Set class" id="idm46198554148104"></a><a data-type="indexterm" data-primary="Map class" id="idm46198554147432"></a> built-in ES6 Set and Map classes are iterable.  When you iterate a
Set with <code>for/of</code>, the loop body runs once for each element of the
set.  You could use code like this to print the unique words in a
string of text:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">text</code> <code class="o">=</code> <code class="s2">"Na na na na na na na na Batman!"</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">wordSet</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Set</code><code class="p">(</code><code class="nx">text</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">" "</code><code class="p">));</code>
<code class="kd">let</code> <code class="nx">unique</code> <code class="o">=</code> <code class="p">[];</code>
<code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">word</code> <code class="k">of</code> <code class="nx">wordSet</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">unique</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">word</code><code class="p">);</code>
<code class="p">}</code>
<code class="nx">unique</code> <code class="c1">// =&gt; ["Na", "na", "Batman!"]</code></pre>

<p>Maps are an interesting case because the iterator for a Map object
does not iterate the Map keys, or the Map values, but key/value
pairs. Each time through the iteration, the iterator returns an array
whose first element is a key and whose second element is the
corresponding value.  Given a Map <code>m</code>, you could iterate and destructure
its key/value pairs like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">m</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">([[</code><code class="mi">1</code><code class="p">,</code> <code class="s2">"one"</code><code class="p">]]);</code>
<code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="p">[</code><code class="nx">key</code><code class="p">,</code> <code class="nx">value</code><code class="p">]</code> <code class="k">of</code> <code class="nx">m</code><code class="p">)</code> <code class="p">{</code>
    <code class="nx">key</code>    <code class="c1">// =&gt; 1</code>
    <code class="nx">value</code>  <code class="c1">// =&gt; "one"</code>
<code class="p">}</code></pre>
</div></section>













<section data-type="sect3" data-pdf-bookmark="Asynchronous iteration with for/await"><div class="sect3" id="idm46198554081704">
<h3>Asynchronous iteration with for/await</h3>

<p>ES2018<a data-type="indexterm" data-primary="asynchronous programming" data-secondary="asynchronous iteration" data-tertiary="for/await loops" id="idm46198554057752"></a><a data-type="indexterm" data-primary="ES2018" data-secondary="asynchronous iterator" id="idm46198554056568"></a><a data-type="indexterm" data-primary="for/await loops" id="idm46198554055624"></a><a data-type="indexterm" data-primary="looping statements" data-secondary="for/await loops" id="idm46198554054952"></a> introduces a new kind of iterator, known as an
<em>asynchronous iterator</em>, and a variant on the <code>for/of</code> loop, known as
the <code>for/await</code> loop that works with asynchronous iterators.</p>

<p>You’ll need to read Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch12.html#itergene">12</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch13.html#async">13</a> in order to understand
the <code>for/await</code> loop, but here is how it looks in code:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Read chunks from an asynchronously iterable stream and print them out</code>
<code class="nx">async</code> <code class="kd">function</code> <code class="nx">printStream</code><code class="p">(</code><code class="nx">stream</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code> <code class="nx">await</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">chunk</code> <code class="k">of</code> <code class="nx">stream</code><code class="p">)</code> <code class="p">{</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">chunk</code><code class="p">);</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></section>



</div></section>













<section data-type="sect2" data-pdf-bookmark="5.4.5 for/in"><div class="sect2" id="forinloop">
<h2>5.4.5 for/in</h2>

<p>A<a data-type="indexterm" data-primary="" data-startref="forof05" id="idm46198553945304"></a><a data-type="indexterm" data-primary="" data-startref="ESforof05" id="idm46198553943912"></a><a data-type="indexterm" data-primary="" data-startref="LSforof05" id="idm46198553942968"></a><a data-type="indexterm" data-primary="looping statements" data-secondary="for/in loops" id="idm46198553942024"></a><a data-type="indexterm" data-primary="for/in loops" id="idm46198553941080"></a> <code>for/in</code> loop looks a lot like a <code>for/of</code> loop, with the <code>of</code>
keyword changed to <code>in</code>. While a <code>for/of</code> loop requires an iterable
object after the <code>of</code>, a <code>for/in</code> loop works with any object after the
<code>in</code>. The <code>for/of</code> loop is new in ES6, but <code>for/in</code> has been
part of JavaScript since the very beginning (which is why it has the
more natural sounding syntax).</p>

<p>The <code>for/in</code> statement loops through the property names of a specified
object. The syntax looks like this:</p>
<pre data-type="programlisting" data-code-language="js">for (<em><code>variable</code></em> in <em><code>object</code></em>)
    <em><code>statement</code></em></pre>

<p><em>variable</em> typically names a variable, but it may be a variable
declaration or anything suitable as the left-hand side of an
assignment expression. <em>object</em> is an expression that evaluates to
an object. As usual, <em>statement</em> is the statement or statement block
that serves as the body of the loop.</p>

<p>And you might use a <code>for/in</code> loop like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">p</code> <code class="k">in</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code>      <code class="c1">// Assign property names of o to variable p</code>
    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">o</code><code class="p">[</code><code class="nx">p</code><code class="p">]);</code> <code class="c1">// Print the value of each property</code>
<code class="p">}</code></pre>

<p>To execute a <code>for/in</code> statement, the JavaScript interpreter first
evaluates the <em>object</em> expression. If it evaluates to <code>null</code> or
<code>undefined</code>, the interpreter skips the loop and moves on to the next
statement. The interpreter now executes the body of the loop once for
each enumerable property of the object. Before each iteration,
however, the interpreter evaluates the <em>variable</em> expression and
assigns the name of the property (a string value) to it.</p>

<p>Note that the <em>variable</em> in the <code>for/in</code> loop may be an
arbitrary expression, as long as it evaluates to something suitable for
the left side of an assignment. This expression is evaluated each time
through the loop, which means that it may evaluate differently each
time. For example, you can use code like the following to copy the
names of all object properties into an array:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="mi">3</code> <code class="p">};</code>
<code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[],</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
<code class="k">for</code><code class="p">(</code><code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="o">++</code><code class="p">]</code> <code class="k">in</code> <code class="nx">o</code><code class="p">)</code> <code class="cm">/* empty */</code><code class="p">;</code></pre>

<p>JavaScript arrays are simply a specialized kind of object, and array
indexes are object properties that can be enumerated with a
<code>for/in</code> loop. For example, following the previous code with this
line enumerates the array indexes 0, 1, and 2:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="k">in</code> <code class="nx">a</code><code class="p">)</code> <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code></pre>

<p>I find that a common source of bugs in my own code is the accidental
use of <code>for/in</code> with arrays when I meant to use <code>for/of</code>. When working
with arrays, you almost always want to use <code>for/of</code> instead of
<code>for/in</code>.</p>

<p>The <code>for/in</code> loop does not actually enumerate all properties of an
object. It does not enumerate properties whose names are symbols. And
of the properties whose names are strings, it only loops over the
<em>enumerable</em> properties (see <a data-type="xref" href="ch14.html#propertydescriptors">§14.1</a>). The various
built-in methods defined by core JavaScript are not enumerable. All
objects have a <code>toString()</code> method, for example, but the <code>for/in</code> loop
does not enumerate this <code>toString</code> property. In addition to built-in
methods, many other properties of the built-in objects are
non-enumerable. All properties and methods defined by your code are
enumerable, by default. (You can make them non-enumerable using
techniques explained in <a data-type="xref" href="ch14.html#propertydescriptors">§14.1</a>.)</p>

<p>Enumerable inherited properties (see <a data-type="xref" href="ch06.html#inheritance">§6.3.2</a>) are also
enumerated by the <code>for/in</code> loop. This means that if you use
<code>for/in</code> loops and also use code that defines properties that are
inherited by all objects, then your loop may not behave in the way you
expect. For this reason, many programmers prefer to use a <code>for/of</code>
loop with <code>Object.keys()</code> instead of a <code>for/in</code> loop.</p>

<p>If the body of a <code>for/in</code> loop deletes a property that has not
yet been enumerated, that property will not be enumerated. If the body
of the loop defines new properties on the object, those properties may
or may not be enumerated. See <a data-type="xref" href="ch06.html#property-enumeration-order">§6.6.1</a> for more
information on the order in which <code>for/in</code> enumerates the properties
of an object.<a data-type="indexterm" data-primary="" data-startref="Sloop05" id="idm46198553799240"></a></p>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="5.5 Jumps"><div class="sect1" id="idm46198553946440">
<h1>5.5 Jumps</h1>

<p>Another<a data-type="indexterm" data-primary="jump statements" id="jumps05"></a><a data-type="indexterm" data-primary="jump statements" data-secondary="overview of" id="idm46198553795336"></a><a data-type="indexterm" data-primary="statements" data-secondary="jump statements" id="Sjump05"></a> category of JavaScript statements are <em>jump statements</em>. As
the name implies, these cause the JavaScript interpreter to jump to a
new location in the source code. The <code>break</code> statement makes the
interpreter jump to the end of a loop or other statement. <code>continue</code>
makes the interpreter skip the rest of the body of a loop and jump back
to the top of a loop to begin a new iteration. JavaScript allows
statements to be named, or <em>labeled</em>, and <code>break</code> and <code>continue</code>
can identify the target loop or other statement label.</p>

<p>The <code>return</code> statement makes the interpreter jump from a function
invocation back to the code that invoked it and also supplies the
value for the invocation. The <code>throw</code> statement is a kind of interim
return from a generator function. The <code>throw</code> statement raises, or
<em>throws</em>, an exception and is designed to work with the
<code>try/catch/finally</code> statement, which establishes a block of exception-handling code. This is a complicated kind of jump statement: when an
exception is thrown, the interpreter jumps to the nearest enclosing
exception handler, which may be in the same function or up the call
stack in an invoking function.</p>

<p>Details about each of these jump statements are in the sections that
follow.</p>








<section data-type="sect2" data-pdf-bookmark="5.5.1 Labeled Statements"><div class="sect2" id="labeledstatements">
<h2>5.5.1 Labeled Statements</h2>

<p>Any<a data-type="indexterm" data-primary="jump statements" data-secondary="labeled statements" id="idm46198553735336"></a><a data-type="indexterm" data-primary="labeled statements" id="idm46198553734488"></a> statement may be <em>labeled</em> by preceding it with an identifier and a
colon:</p>
<pre data-type="programlisting" data-code-language="js"><em><code>identifier</code></em>: <em><code>statement</code></em></pre>

<p>By labeling a statement, you give it a name that you can use to refer
to it elsewhere in your program. You can label any statement, although
it is only useful to label statements that have bodies, such as loops
and conditionals. By giving a loop a name, you can use <code>break</code> and
<code>continue</code> statements inside the body of the loop to exit the loop or
to jump directly to the top of the loop to begin the next iteration.
<code>break</code> and <code>continue</code> are the only JavaScript statements that use
statement labels; they are covered in the following subsections. Here is an
example of a labeled <code>while</code> loop and a <code>continue</code> statement that uses
the label.</p>

<pre data-type="programlisting" data-code-language="js"><code class="nx">mainloop</code><code class="o">:</code> <code class="k">while</code><code class="p">(</code><code class="nx">token</code> <code class="o">!==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Code omitted...</code>
    <code class="k">continue</code> <code class="nx">mainloop</code><code class="p">;</code>  <code class="c1">// Jump to the next iteration of the named loop</code>
    <code class="c1">// More code omitted...</code>
<code class="p">}</code></pre>

<p>The <em>identifier</em> you use to label a statement can be any legal
JavaScript identifier that is not a reserved word. The namespace for
labels is different than the namespace for variables and functions, so
you can use the same identifier as a statement label and as a variable
or function name. Statement labels are defined only within the
statement to which they apply (and within its substatements, of
course). A statement may not have the same label as a statement that
contains it, but two statements may have the same label as long as
neither one is nested within the other. Labeled statements may
themselves be labeled. Effectively, this means that any statement may
have multiple labels.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.5.2 break"><div class="sect2" id="idm46198553706184">
<h2>5.5.2 break</h2>

<p>The<a data-type="indexterm" data-primary="jump statements" data-secondary="break statements" id="idm46198553704584"></a><a data-type="indexterm" data-primary="break statements" id="idm46198553703576"></a> <code>break</code> statement, used alone, causes the innermost enclosing loop
or <code>switch</code> statement to exit immediately. Its syntax is simple:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">break</code><code class="p">;</code></pre>

<p>Because it causes a loop or <code>switch</code> to exit, this form of the <code>break</code>
statement is legal only if it appears inside one of these statements.</p>

<p>You’ve already seen examples of the <code>break</code> statement within a <code>switch</code>
statement. In loops, it is typically used to exit prematurely when, for
whatever reason, there is no longer any need to complete the loop. When
a loop has complex termination conditions, it is often easier to
implement some of these conditions with <code>break</code> statements rather than
trying to express them all in a single loop expression. The following
code searches the elements of an array for a particular value. The loop
terminates in the normal way when it reaches the end of the array; it
terminates with a <code>break</code> statement if it finds what it is looking for
in the array:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">a</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">===</code> <code class="nx">target</code><code class="p">)</code> <code class="k">break</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>JavaScript also allows the <code>break</code> keyword to be followed by a
statement label (just the identifier, with no colon):</p>
<pre data-type="programlisting" data-code-language="js">break <em><code>labelname</code></em>;</pre>

<p>When <code>break</code> is used with a label, it jumps to the end of, or
terminates, the enclosing statement that has the specified label. It is
a syntax error to use <code>break</code> in this form if there is no enclosing
statement with the specified label. With this form of the <code>break</code>
statement, the named statement need not be a loop or <code>switch</code>: <code>break</code>
can “break out of” any enclosing statement. This statement can even
be a statement block grouped within curly braces for the sole purpose
of naming the block with a label.</p>

<p>A newline is not allowed between the <code>break</code> keyword and the
<em>labelname</em>. This is a result of JavaScript’s automatic insertion of
omitted semicolons: if you put a line terminator between the <code>break</code>
keyword and the label that follows, JavaScript assumes you meant to use
the simple, unlabeled form of the statement and treats the line
terminator as a semicolon. (See <a data-type="xref" href="ch02.html#optionalsemicolons">§2.6</a>.)</p>

<p>You need the labeled form of the <code>break</code> statement when you want to
break out of a statement that is not the nearest enclosing loop or a
<code>switch</code>. The following code <span class="keep-together">demonstrates:</span></p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">matrix</code> <code class="o">=</code> <code class="nx">getData</code><code class="p">();</code>  <code class="c1">// Get a 2D array of numbers from somewhere</code>
<code class="c1">// Now sum all the numbers in the matrix.</code>
<code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">success</code> <code class="o">=</code> <code class="kc">false</code><code class="p">;</code>
<code class="c1">// Start with a labeled statement that we can break out of if errors occur</code>
<code class="nx">computeSum</code><code class="o">:</code> <code class="k">if</code> <code class="p">(</code><code class="nx">matrix</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">x</code> <code class="o">&lt;</code> <code class="nx">matrix</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">x</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="kd">let</code> <code class="nx">row</code> <code class="o">=</code> <code class="nx">matrix</code><code class="p">[</code><code class="nx">x</code><code class="p">];</code>
        <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">row</code><code class="p">)</code> <code class="k">break</code> <code class="nx">computeSum</code><code class="p">;</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">y</code> <code class="o">&lt;</code> <code class="nx">row</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">y</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">cell</code> <code class="o">=</code> <code class="nx">row</code><code class="p">[</code><code class="nx">y</code><code class="p">];</code>
            <code class="k">if</code> <code class="p">(</code><code class="nb">isNaN</code><code class="p">(</code><code class="nx">cell</code><code class="p">))</code> <code class="k">break</code> <code class="nx">computeSum</code><code class="p">;</code>
            <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">cell</code><code class="p">;</code>
        <code class="p">}</code>
    <code class="p">}</code>
    <code class="nx">success</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
<code class="p">}</code>
<code class="c1">// The break statements jump here. If we arrive here with success == false</code>
<code class="c1">// then there was something wrong with the matrix we were given.</code>
<code class="c1">// Otherwise, sum contains the sum of all cells of the matrix.</code></pre>

<p>Finally, note that a <code>break</code> statement, with or without a label, can
not transfer control across function boundaries. You cannot label a
function definition statement, for example, and then use that label
inside the function.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.5.3 continue"><div class="sect2" id="continue">
<h2>5.5.3 continue</h2>

<p>The<a data-type="indexterm" data-primary="jump statements" data-secondary="continue statements" id="idm46198553456872"></a><a data-type="indexterm" data-primary="continue statements" id="idm46198553455976"></a> <code>continue</code> statement is similar to the <code>break</code> statement. Instead
of exiting a loop, however, <code>continue</code> restarts a loop at the next
iteration. The <code>continue</code> statement’s syntax is just as simple as the
<code>break</code> statement’s:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">continue</code><code class="p">;</code></pre>

<p>The <code>continue</code> statement can also be used with a label:</p>
<pre data-type="programlisting" data-code-language="js">continue <em><code>labelname</code></em>;</pre>

<p>The <code>continue</code> statement, in both its labeled and unlabeled forms, can
be used only within the body of a loop. Using it anywhere else causes a
syntax error.</p>

<p>When the <code>continue</code> statement is executed, the current iteration of the
enclosing loop is terminated, and the next iteration begins. This means
different things for different types of loops:</p>

<ul>
<li>
<p>In a <code>while</code> loop, the specified <em>expression</em> at the beginning of
the loop is tested again, and if it’s <code>true</code>, the loop body is executed
starting from the top.</p>
</li>
<li>
<p>In a <code>do/while</code> loop, execution skips to the bottom of the
loop, where the loop condition is tested again before restarting the
loop at the top.</p>
</li>
<li>
<p>In a <code>for</code> loop, the <em>increment</em> expression is evaluated, and the
<em>test</em> expression is tested again to determine if another iteration
should be done.</p>
</li>
<li>
<p>In a <code>for/of</code> or <code>for/in</code> loop, the loop starts over with the next
iterated value or next property name being assigned to the specified
variable.</p>
</li>
</ul>

<p>Note the difference in behavior of the <code>continue</code> statement in the
<code>while</code> and <code>for</code> loops: a <code>while</code> loop returns directly to its
condition, but a <code>for</code> loop first evaluates its <em>increment</em>
expression and then returns to its condition. Earlier, we considered the
behavior of the <code>for</code> loop in terms of an “equivalent” <code>while</code> loop.
Because the <code>continue</code> statement behaves differently for these two
loops, however, it is not actually possible to perfectly simulate a
<code>for</code> loop with a <code>while</code> loop alone.</p>

<p>The following example shows an unlabeled <code>continue</code> statement being
used to skip the rest of the current iteration of a loop when an error
occurs:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">data</code><code class="p">[</code><code class="nx">i</code><code class="p">])</code> <code class="k">continue</code><code class="p">;</code>  <code class="c1">// Can't proceed with undefined data</code>
    <code class="nx">total</code> <code class="o">+=</code> <code class="nx">data</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
<code class="p">}</code></pre>

<p>Like the <code>break</code> statement, the <code>continue</code> statement can be used in its
labeled form within nested loops when the loop to be restarted is not
the immediately enclosing loop. Also, as with the <code>break</code> statement, line
breaks are not allowed between the <code>continue</code> statement and its <em>labelname</em>.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.5.4 return"><div class="sect2" id="return">
<h2>5.5.4 return</h2>

<p>Recall<a data-type="indexterm" data-primary="jump statements" data-secondary="return statements" id="idm46198553337352"></a><a data-type="indexterm" data-primary="return statements" id="idm46198553336344"></a> that function invocations are expressions and that all
expressions have values. A <code>return</code> statement within a function
specifies the value of invocations of that function. Here’s the syntax
of the <code>return</code> statement:</p>
<pre data-type="programlisting" data-code-language="js">return <em><code>expression</code></em>;</pre>

<p>A <code>return</code> statement may appear only within the body of a function. It
is a syntax error for it to appear anywhere else. When the <code>return</code>
statement is executed, the function that contains it returns the value
of <em>expression</em> to its caller. For example:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;</code> <code class="p">}</code> <code class="c1">// A function that has a return statement</code>
<code class="nx">square</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>                          <code class="c1">// =&gt; 4</code></pre>

<p>With no <code>return</code> statement, a function invocation simply executes each
of the statements in the function body in turn until it reaches the end
of the function and then returns to its caller. In this case, the
invocation expression evaluates to <code>undefined</code>. The <code>return</code> statement
often appears as the last statement in a function, but it need not be
last: a function returns to its caller when a <code>return</code> statement is
executed, even if there are other statements remaining in the function
body.</p>

<p>The <code>return</code> statement can also be used without an <em>expression</em> to
make the function return <code>undefined</code> to its caller. For example:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">displayObject</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// Return immediately if the argument is null or undefined.</code>
    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">o</code><code class="p">)</code> <code class="k">return</code><code class="p">;</code>
    <code class="c1">// Rest of function goes here...</code>
<code class="p">}</code></pre>

<p>Because of JavaScript’s automatic semicolon insertion
(<a data-type="xref" href="ch02.html#optionalsemicolons">§2.6</a>), you cannot include a line break between the
<code>return</code> keyword and the expression that follows it.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.5.5 yield"><div class="sect2" id="idm46198553338920">
<h2>5.5.5 yield</h2>

<p>The<a data-type="indexterm" data-primary="statements" data-secondary="yield statements" id="idm46198553270936"></a><a data-type="indexterm" data-primary="yield statements" id="idm46198553269928"></a> <code>yield</code> statement is much like the <code>return</code> statement but is used
only in ES6 generator functions (see <a data-type="xref" href="ch12.html#generators">§12.3</a>) to produce the next
value in the generated sequence of values without actually returning:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// A generator function that yields a range of integers</code>
<code class="kd">function</code><code class="o">*</code> <code class="nx">range</code><code class="p">(</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">from</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="nx">to</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
        <code class="k">yield</code> <code class="nx">i</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>

<p>In order to understand <code>yield</code>, you must understand iterators and
generators, which will not be covered until <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>. <code>yield</code> is
included here for completeness, however. (Technically, though, <code>yield</code>
is an operator rather than a statement, as explained in
<a data-type="xref" href="ch12.html#yieldexpression">§12.4.2</a>.)</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.5.6 throw"><div class="sect2" id="idm46198553174808">
<h2>5.5.6 throw</h2>

<p>An<a data-type="indexterm" data-primary="statements" data-secondary="throw statements" id="idm46198553173016"></a><a data-type="indexterm" data-primary="throw statements" id="idm46198553172008"></a><a data-type="indexterm" data-primary="exceptions, throwing and catching" id="idm46198553171336"></a> <em>exception</em> is a signal that indicates that some sort of exceptional
condition or error has occurred. To <em>throw</em> an exception is to signal
such an error or exceptional condition. To <em>catch</em> an exception is to
handle it—to take whatever actions are necessary or appropriate to
recover from the exception. In JavaScript, exceptions are thrown
whenever a runtime error occurs and whenever the program explicitly
throws one using the <code>throw</code> statement. Exceptions are caught with the
<code>try/catch/finally</code> statement, which is described in the next
section.</p>

<p>The <code>throw</code> statement has the following syntax:</p>
<pre data-type="programlisting" data-code-language="js">throw <em><code>expression</code></em>;</pre>

<p><em>expression</em> may evaluate to a value of any type. You might throw a
number that represents an error code or a string that contains a
human-readable error message. The Error class and its subclasses are
used when the JavaScript interpreter itself throws an error, and you
can use them as well. An Error object has a <code>name</code> property that
specifies the type of error and a <code>message</code> property that holds the
string passed to the constructor function. Here is an example function
that throws an Error object when invoked with an invalid argument:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// If the input argument is invalid, throw an exception!</code>
    <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">0</code><code class="p">)</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"x must not be negative"</code><code class="p">);</code>
    <code class="c1">// Otherwise, compute a value and return normally</code>
    <code class="kd">let</code> <code class="nx">f</code><code class="p">;</code>
    <code class="k">for</code><code class="p">(</code><code class="nx">f</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">x</code> <code class="o">&gt;</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">f</code> <code class="o">*=</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">x</code><code class="o">--</code><code class="p">)</code> <code class="cm">/* empty */</code> <code class="p">;</code>
    <code class="k">return</code> <code class="nx">f</code><code class="p">;</code>
<code class="p">}</code>
<code class="nx">factorial</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>   <code class="c1">// =&gt; 24</code></pre>

<p>When an exception is thrown, the JavaScript interpreter immediately
stops normal program execution and jumps to the nearest exception
handler. Exception handlers are written using the <code>catch</code> clause of the
<code>try/catch/finally</code> statement, which is described in the next
section. If the block of code in which the exception was thrown does
not have an associated <code>catch</code> clause, the interpreter checks the next-highest enclosing block of code to see if it has an exception handler
associated with it. This continues until a handler is found. If an
exception is thrown in a function that does not contain a
<code>try/catch/finally</code> statement to handle it, the exception
propagates up to the code that invoked the function. In this way,
exceptions propagate up through the lexical structure of JavaScript
methods and up the call stack. If no exception handler is ever found,
the exception is treated as an error and is reported to the user.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.5.7 try/catch/finally"><div class="sect2" id="idm46198553088056">
<h2>5.5.7 try/catch/finally</h2>

<p>The<a data-type="indexterm" data-primary="statements" data-secondary="try/catch/finally statements" id="Stry05"></a><a data-type="indexterm" data-primary="try/catch/finally statements" id="try05"></a><a data-type="indexterm" data-primary="catch clauses" id="catch05"></a> <code>try/catch/finally</code> statement is JavaScript’s exception
handling mechanism. The <code>try</code> clause of this statement simply defines
the block of code whose exceptions are to be handled. The <code>try</code> block
is followed by a <code>catch</code> clause, which is a block of statements that
are invoked when an exception occurs anywhere within the <code>try</code> block.
The <code>catch</code> clause is followed by a <code>finally</code> block containing cleanup
code that is guaranteed to be executed, regardless of what happens in
the <code>try</code> block. Both the <code>catch</code> and <code>finally</code> blocks are optional,
but a <code>try</code> block must be accompanied by at least one of these blocks.
The <code>try</code>, <code>catch</code>, and <code>finally</code> blocks all begin and end with curly
braces. These braces are a required part of the syntax and cannot be
omitted, even if a clause contains only a single statement.</p>

<p>The following code illustrates the syntax and purpose of the
<code>try/catch/finally</code> statement:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">try</code> <code class="p">{</code>
    <code class="c1">// Normally, this code runs from the top of the block to the bottom</code>
    <code class="c1">// without problems. But it can sometimes throw an exception,</code>
    <code class="c1">// either directly, with a throw statement, or indirectly, by calling</code>
    <code class="c1">// a method that throws an exception.</code>
<code class="p">}</code>
<code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
    <code class="c1">// The statements in this block are executed if, and only if, the try</code>
    <code class="c1">// block throws an exception. These statements can use the local variable</code>
    <code class="c1">// e to refer to the Error object or other value that was thrown.</code>
    <code class="c1">// This block may handle the exception somehow, may ignore the</code>
    <code class="c1">// exception by doing nothing, or may rethrow the exception with throw.</code>
<code class="p">}</code>
<code class="k">finally</code> <code class="p">{</code>
    <code class="c1">// This block contains statements that are always executed, regardless of</code>
    <code class="c1">// what happens in the try block. They are executed whether the try</code>
    <code class="c1">// block terminates:</code>
    <code class="c1">//   1) normally, after reaching the bottom of the block</code>
    <code class="c1">//   2) because of a break, continue, or return statement</code>
    <code class="c1">//   3) with an exception that is handled by a catch clause above</code>
    <code class="c1">//   4) with an uncaught exception that is still propagating</code>
<code class="p">}</code></pre>

<p>Note that the <code>catch</code> keyword is generally followed by an identifier in
parentheses. This identifier is like a function parameter. When an
exception is caught, the value associated with the exception (an Error
object, for example) is assigned to this parameter. The identifier
associated with a <code>catch</code> clause has block
scope—it is only defined within the <code>catch</code> block.</p>

<p>Here is a realistic example of the <code>try/catch</code> statement. It uses
the <code>factorial()</code> method defined in the previous section and the
client-side JavaScript methods <code>prompt()</code> and <code>alert()</code> for input and
output:</p>

<pre data-type="programlisting" data-code-language="js"><code class="k">try</code> <code class="p">{</code>
    <code class="c1">// Ask the user to enter a number</code>
    <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="nb">Number</code><code class="p">(</code><code class="nx">prompt</code><code class="p">(</code><code class="s2">"Please enter a positive integer"</code><code class="p">,</code> <code class="s2">""</code><code class="p">));</code>
    <code class="c1">// Compute the factorial of the number, assuming the input is valid</code>
    <code class="kd">let</code> <code class="nx">f</code> <code class="o">=</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">n</code><code class="p">);</code>
    <code class="c1">// Display the result</code>
    <code class="nx">alert</code><code class="p">(</code><code class="nx">n</code> <code class="o">+</code> <code class="s2">"! = "</code> <code class="o">+</code> <code class="nx">f</code><code class="p">);</code>
<code class="p">}</code>
<code class="k">catch</code><code class="p">(</code><code class="nx">ex</code><code class="p">)</code> <code class="p">{</code>     <code class="c1">// If the user's input was not valid, we end up here</code>
    <code class="nx">alert</code><code class="p">(</code><code class="nx">ex</code><code class="p">);</code>  <code class="c1">// Tell the user what the error is</code>
<code class="p">}</code></pre>

<p>This example is a <code>try/catch</code> statement with no <code>finally</code> clause.
Although <code>finally</code> is not used as often as <code>catch</code>, it can be useful.
However, its behavior requires additional explanation. The <code>finally</code>
clause is guaranteed to be executed if any portion of the <code>try</code> block
is executed, regardless of how the code in the <code>try</code> block completes.
It is generally used to clean up after the code in the <code>try</code> clause.</p>

<p>In the normal case, the JavaScript interpreter reaches the end of the
<code>try</code> block and then proceeds to the <code>finally</code> block, which performs
any necessary cleanup. If the interpreter left the <code>try</code> block because
of a <code>return</code>, <code>continue</code>, or <code>break</code> statement, the <code>finally</code> block is
executed before the interpreter jumps to its new destination.</p>

<p>If an exception occurs in the <code>try</code> block and there is an associated
<code>catch</code> block to handle the exception, the interpreter first executes
the <code>catch</code> block and then the <code>finally</code> block. If there is no local
<code>catch</code> block to handle the exception, the interpreter first executes
the <code>finally</code> block and then jumps to the nearest containing <code>catch</code>
clause.</p>

<p>If a <code>finally</code> block itself causes a jump with a <code>return</code>, <code>continue</code>,
<code>break</code>, or <code>throw</code> statement, or by calling a method that throws an
exception, the interpreter abandons whatever jump was pending and
performs the new jump. For example, if a <code>finally</code> clause throws an
exception, that exception replaces any exception that was in the
process of being thrown. If a <code>finally</code> clause issues a <code>return</code>
statement, the method returns normally, even if an exception has been
thrown and has not yet been handled.</p>

<p><code>try</code> and <code>finally</code> can be used together without a <code>catch</code> clause. In
this case, the <code>finally</code> block is simply cleanup code that is
guaranteed to be executed, regardless of what happens in the <code>try</code>
block. Recall that we can’t completely simulate a <code>for</code> loop with a
<code>while</code> loop because the <code>continue</code> statement behaves differently for
the two loops. If we add a <code>try/finally</code> statement, we can write
a <code>while</code> loop that works like a <code>for</code> loop and that handles <code>continue</code>
statements correctly:</p>
<pre data-type="programlisting" data-code-language="js">// Simulate for(<em><code>initialize</code></em> ; <em><code>test</code></em> ;<em><code>increment</code></em> ) body;
<em><code>initialize</code></em> ;
while( <em><code>test</code></em> ) {
    try { <em><code>body</code></em> ; }
    finally { <em><code>increment</code></em> ; }
}</pre>

<p>Note, however, that a <em>body</em> that contains a <code>break</code> statement
behaves slightly differently (causing an extra increment before
exiting) in the <code>while</code> loop than it does in the <code>for</code> loop, so even
with the <code>finally</code> clause, it is not possible to completely simulate
the <code>for</code> loop with <code>while</code>.<a data-type="indexterm" data-primary="" data-startref="Sjump05" id="idm46198552895032"></a><a data-type="indexterm" data-primary="" data-startref="jumps05" id="idm46198552894024"></a><a data-type="indexterm" data-primary="" data-startref="try05" id="idm46198552893080"></a><a data-type="indexterm" data-primary="" data-startref="Stry05" id="idm46198552892136"></a></p>
<aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198552891192">
<h5>Bare Catch Clauses</h5>
<p>Occasionally<a data-type="indexterm" data-primary="bare catch clauses" id="idm46198552889896"></a> you may find yourself using a <code>catch</code> clause solely to
detect and stop the propagation of an exception, even though you do not
care about the type or the value of the exception. In<a data-type="indexterm" data-primary="ES2019" data-secondary="bare catch clauses" id="idm46198552888488"></a> ES2019 and later,
you can omit the parentheses and the identifier and use the <code>catch</code>
keyword bare in this case. Here is an example:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// Like JSON.parse(), but return undefined instead of throwing an error</code>
<code class="kd">function</code> <code class="nx">parseJSON</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">try</code> <code class="p">{</code>
        <code class="k">return</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">s</code><code class="p">);</code>
    <code class="p">}</code> <code class="k">catch</code> <code class="p">{</code>
        <code class="c1">// Something went wrong but we don't care what it was</code>
        <code class="k">return</code> <code class="kc">undefined</code><code class="p">;</code>
    <code class="p">}</code>
<code class="p">}</code></pre>
</div></aside>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="5.6 Miscellaneous Statements"><div class="sect1" id="idm46198553087432">
<h1>5.6 Miscellaneous Statements</h1>

<p>This<a data-type="indexterm" data-primary="" data-startref="catch05" id="idm46198552840904"></a><a data-type="indexterm" data-primary="statements" data-secondary="miscellaneous statements" data-tertiary="with statements" id="idm46198552839928"></a><a data-type="indexterm" data-primary="with statements" id="idm46198552838744"></a> section describes the remaining three JavaScript
statements—<code>with</code>, <code>debugger</code>, and <code>"use strict"</code>.</p>








<section data-type="sect2" data-pdf-bookmark="5.6.1 with"><div class="sect2" id="withstatement">
<h2>5.6.1 with</h2>

<p>The <code>with</code> statement runs a block of code as if the properties of
a specified object were variables in scope for that code. It has the
following syntax:</p>
<pre data-type="programlisting" data-code-language="js">with (<em><code>object</code></em>)
    <em><code>statement</code></em></pre>

<p>This statement creates a temporary scope with the properties of
<em>object</em> as variables and then executes <em>statement</em> within that
scope.</p>

<p>The<a data-type="indexterm" data-primary="strict mode" data-secondary="with statement and" id="idm46198552830120"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="with statement and" id="idm46198552829112"></a> <code>with</code> statement is forbidden in strict mode (see
<a data-type="xref" href="#strictmode">§5.6.3</a>) and should be considered deprecated in non-strict
mode: avoid using it whenever possible. JavaScript code that uses
<code>with</code> is difficult to optimize and is likely to run significantly
more slowly than the equivalent code written without the <code>with</code>
statement.</p>

<p>The common use of the <code>with</code> statement is to make it easier to work
with deeply nested object hierarchies. In client-side JavaScript, for
example, you may have to type expressions like this one to access
elements of an HTML form:</p>

<pre data-type="programlisting" data-code-language="js"><code class="nb">document</code><code class="p">.</code><code class="nx">forms</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">address</code><code class="p">.</code><code class="nx">value</code></pre>

<p>If you need to write expressions like this a number of times, you can
use the <code>with</code> statement to treat the properties of the form object
like variables:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">with</code><code class="p">(</code><code class="nb">document</code><code class="p">.</code><code class="nx">forms</code><code class="p">[</code><code class="mi">0</code><code class="p">])</code> <code class="p">{</code>
    <code class="c1">// Access form elements directly here. For example:</code>
    <code class="nx">name</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
    <code class="nx">address</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
    <code class="nx">email</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>This reduces the amount of typing you have to do: you no longer need
to prefix each form property name with <code>document.forms[0]</code>. It is
just as simple, of course, to avoid the <code>with</code> statement and write
the preceding code like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">f</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">forms</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>
<code class="nx">f</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
<code class="nx">f</code><code class="p">.</code><code class="nx">address</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
<code class="nx">f</code><code class="p">.</code><code class="nx">email</code><code class="p">.</code><code class="nx">value</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code></pre>

<p>Note that if you use <code>const</code> or <code>let</code> or <code>var</code> to declare a variable
or constant within the body of a <code>with</code> statement, it creates an
ordinary variable and does not define a new property within the
specified object.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.6.2 debugger"><div class="sect2" id="idm46198552836008">
<h2>5.6.2 debugger</h2>

<p>The<a data-type="indexterm" data-primary="statements" data-secondary="miscellaneous statements" data-tertiary="debugger statements" id="idm46198552712792"></a><a data-type="indexterm" data-primary="debugger statements" id="idm46198552711544"></a> <code>debugger</code> statement normally does nothing. If, however, a debugger
program is available and is running, then an implementation may (but is
not required to) perform some kind of debugging action. In practice,
this statement acts like a breakpoint: execution of JavaScript code
stops, and you can use the debugger to print variables’ values, examine
the call stack, and so on. Suppose, for example, that you are getting
an exception in your function <code>f()</code> because it is being called with an
undefined argument, and you can’t figure out where this call is coming
from. To help you in debugging this problem, you might alter <code>f()</code> so
that it begins like this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
  <code class="k">if</code> <code class="p">(</code><code class="nx">o</code> <code class="o">===</code> <code class="kc">undefined</code><code class="p">)</code> <code class="kr">debugger</code><code class="p">;</code>  <code class="c1">// Temporary line for debugging purposes</code>
  <code class="p">...</code>                             <code class="c1">// The rest of the function goes here.</code>
<code class="p">}</code></pre>

<p>Now, when <code>f()</code> is called with no argument, execution will stop, and
you can use the debugger to inspect the call stack and find out where
this incorrect call is coming from.</p>

<p>Note that it is not enough to have a debugger available: the
<code>debugger</code> statement won’t start the debugger for you. If you’re using
a web browser and have the developer tools console open, however, this
statement will cause a breakpoint.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.6.3 “use strict”"><div class="sect2" id="strictmode">
<h2>5.6.3 “use strict”</h2>

<p><code>"use strict"</code> is<a data-type="indexterm" data-primary="statements" data-secondary="miscellaneous statements" data-tertiary="use strict directive" id="idm46198552650536"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="strict versus non-strict mode" id="USDnon05"></a><a data-type="indexterm" data-primary="strict mode" data-secondary="versus non-strict mode" data-secondary-sortas="non-strict mode" id="SMnon05"></a> a <em>directive</em> introduced in ES5.
Directives are not statements (but are close enough that <code>"use
strict"</code> is documented here). There are two important differences
between the <code>"use strict"</code> directive and regular statements:</p>

<ul>
<li>
<p>It does not include any language keywords: the directive is just an
expression statement that consists of a special string literal (in
single or double quotes).</p>
</li>
<li>
<p>It can appear only at the start of a script or at the start of a
function body, before any real statements have appeared.</p>
</li>
</ul>

<p>The purpose of a <code>"use strict"</code> directive is to indicate that the code
that follows (in the script or function) is <em>strict code</em>. The
top-level (nonfunction) code of a script is strict code if the script
has a <code>"use strict"</code> directive. A function body is strict code if it
is defined within strict code or if it has a <code>"use strict"</code>
directive. Code passed to the <code>eval()</code> method is strict code if
<code>eval()</code> is called from strict code or if the string of code includes
a <code>"use strict"</code> directive. In addition to code explicitly declared to
be strict, any code in a <code>class</code> body (<a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>) or in an ES6
module (<a data-type="xref" href="ch10.html#es6modules">§10.3</a>) is automatically strict code. This means that
if all of your JavaScript code is written as modules, then it is all
automatically strict, and you will never need to use an explicit <code>"use
strict"</code> directive.</p>

<p>Strict code is executed in <em>strict mode</em>. Strict mode is a restricted
subset of the language that fixes important language deficiencies and
provides stronger error checking and increased security. Because
strict mode is not the default, old JavaScript code that still uses
the deficient legacy features of the language will continue to run
correctly. The differences between strict mode and non-strict mode are
the following (the first three are particularly important):</p>

<ul>
<li>
<p>The <code>with</code> statement is not allowed in strict mode.</p>
</li>
<li>
<p>In strict mode, all variables must be declared: a ReferenceError is
thrown if you assign a value to an identifier that is not a declared
variable, function, function parameter, <code>catch</code> clause parameter, or
property of the global object. (In non-strict mode, this implicitly
declares a global variable by adding a new property to the global
object.)</p>
</li>
<li>
<p>In strict mode, functions invoked as functions (rather than as
methods) have a <code>this</code> value of <code>undefined</code>. (In non-strict mode,
functions invoked as functions are always passed the global object as
their <code>this</code> value.) Also, in strict mode, when a function is invoked
with <code>call()</code> or <code>apply()</code> (<a data-type="xref" href="ch08.html#applyandcall">§8.7.4</a>), the <code>this</code> value is
exactly the value passed as the first argument to <code>call()</code> or
<code>apply()</code>. (In non-strict mode, <code>null</code> and <code>undefined</code> values are
replaced with the global object and nonobject values are converted to
objects.)</p>
</li>
<li>
<p>In strict mode, assignments to nonwritable properties and attempts to
create new properties on non-extensible objects throw a TypeError. (In
non-strict mode, these attempts fail silently.)</p>
</li>
<li>
<p>In strict mode, code passed to <code>eval()</code> cannot declare variables or
define functions in the caller’s scope as it can in non-strict mode.
Instead, variable and function definitions live in a new scope created
for the <code>eval()</code>. This scope is discarded when the <code>eval()</code> returns.</p>
</li>
<li>
<p>In strict mode, the Arguments object (<a data-type="xref" href="ch08.html#argumentsobject">§8.3.3</a>) in a
function holds a static copy of the values passed to the function. In
non-strict mode, the Arguments object has “magical” behavior in
which elements of the array and named function parameters both refer to
the same value.</p>
</li>
<li>
<p>In strict mode, a SyntaxError is thrown if the <code>delete</code> operator is
followed by an unqualified identifier such as a variable, function, or
function parameter. (In nonstrict mode, such a <code>delete</code> expression
does nothing and evaluates to <code>false</code>.)</p>
</li>
<li>
<p>In strict mode, an attempt to delete a nonconfigurable property
throws a TypeError. (In non-strict mode, the attempt fails and the
<code>delete</code> expression evaluates to <code>false</code>.)</p>
</li>
<li>
<p>In strict mode, it is a syntax error for an object literal to define
two or more properties by the same name. (In non-strict mode, no error
occurs.)</p>
</li>
<li>
<p>In strict mode, it is a syntax error for a function declaration to
have two or more parameters with the same name. (In non-strict mode, no
error occurs.)</p>
</li>
<li>
<p>In strict mode, octal integer literals (beginning with a 0 that is
not followed by an x) are not allowed. (In non-strict mode, some
implementations allow octal <span class="keep-together">literals.)</span></p>
</li>
<li>
<p>In strict mode, the identifiers <code>eval</code> and <code>arguments</code> are treated
like keywords, and you are not allowed to change their value. You
cannot assign a value to these identifiers, declare them as variables,
use them as function names, use them as function parameter names, or
use them as the identifier of a <code>catch</code> block.</p>
</li>
<li>
<p>In strict mode, the ability to examine the call stack is restricted.
<code>arguments.caller</code> and <code>arguments.callee</code> both throw a TypeError within
a strict mode function. Strict mode functions also have <code>caller</code> and
<code>arguments</code> properties that throw TypeError when read. (Some
implementations define these nonstandard properties on non-strict
functions.)<a data-type="indexterm" data-primary="" data-startref="USDnon05" id="idm46198552546968"></a><a data-type="indexterm" data-primary="" data-startref="SMnon05" id="idm46198552545992"></a></p>
</li>
</ul>
</div></section>





</div></section>













<section data-type="sect1" data-pdf-bookmark="5.7 Declarations"><div class="sect1" id="idm46198552593592">
<h1>5.7 Declarations</h1>

<p>The<a data-type="indexterm" data-primary="declarations" data-secondary="overview of" id="idm46198552543448"></a><a data-type="indexterm" data-primary="statements" data-see="also declarations" id="idm46198552542440"></a> keywords <code>const</code>, <code>let</code>, <code>var</code>, <code>function</code>, <code>class</code>, <code>import</code>, and
<code>export</code> are not technically statements, but they look a lot like
statements, and this book refers informally to them as statements, so
they deserve a mention in this chapter.</p>

<p>These keywords are more accurately described as <em>declarations</em> rather
than statements. We said at the start of this chapter that statements
“make something happen.” Declarations serve to define new values and
give them names that we can use to refer to those values. They don’t
make much happen themselves, but by providing names for values they,
in an important sense, define the meaning of the other statements in
your program.</p>

<p>When a program runs, it is the program’s expressions that are being
evaluated and the program’s statements that are being executed. The
declarations in a program don’t “run” in the same way: instead, they
define the structure of the program itself. Loosely, you can think of
declarations as the parts of the program that are processed before the
code starts running.</p>

<p>JavaScript declarations are used to define constants, variables,
functions, and classes and for importing and exporting values between
modules. The next subsections give examples of all of these
declarations. They are all covered in much more detail elsewhere in
this book.</p>








<section data-type="sect2" data-pdf-bookmark="5.7.1 const, let, and var"><div class="sect2" id="idm46198552535288">
<h2>5.7.1 const, let, and var</h2>

<p>The<a data-type="indexterm" data-primary="var keyword" id="idm46198552533960"></a><a data-type="indexterm" data-primary="keywords" data-secondary="var keyword" id="idm46198552532840"></a><a data-type="indexterm" data-primary="let keyword" id="idm46198552531896"></a><a data-type="indexterm" data-primary="keywords" data-secondary="let keyword" id="idm46198552531224"></a><a data-type="indexterm" data-primary="constants" data-secondary="declaring" id="idm46198552530280"></a><a data-type="indexterm" data-primary="declarations" data-secondary="const, let, and var" id="idm46198552529336"></a> <code>const</code>, <code>let</code>, and <code>var</code> declarations are covered in
<a data-type="xref" href="ch03.html#variabledeclaration">§3.10</a>.  In ES6 and later, <code>const</code> declares constants,
and <code>let</code> declares variables. Prior to ES6, the <code>var</code> keyword was the only way
to declare variables and there was no way to declare
constants. Variables declared with <code>var</code> are scoped to the containing
function rather than the containing block. This can be a source of
bugs, and in modern JavaScript there is really no reason to use <code>var</code>
instead of <code>let</code>.</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">TAU</code> <code class="o">=</code> <code class="mi">2</code><code class="o">*</code><code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code><code class="p">;</code>
<code class="kd">let</code> <code class="nx">radius</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
<code class="kd">var</code> <code class="nx">circumference</code> <code class="o">=</code> <code class="nx">TAU</code> <code class="o">*</code> <code class="nx">radius</code><code class="p">;</code></pre>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.7.2 function"><div class="sect2" id="idm46198552504008">
<h2>5.7.2 function</h2>

<p>The<a data-type="indexterm" data-primary="declarations" data-secondary="function" id="idm46198552498792"></a><a data-type="indexterm" data-primary="function declaration" id="idm46198552497784"></a> <code>function</code> declaration is used to define functions, which are
covered in detail in <a data-type="xref" href="ch08.html#functions">Chapter&nbsp;8</a>. (We also saw <code>function</code> in
<a data-type="xref" href="ch04.html#functionexprs">§4.3</a>, where it was used as part of a function expression
rather than a function declaration.) A function declaration looks like
this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">area</code><code class="p">(</code><code class="nx">radius</code><code class="p">)</code> <code class="p">{</code>
    <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="nx">radius</code> <code class="o">*</code> <code class="nx">radius</code><code class="p">;</code>
<code class="p">}</code></pre>

<p>A function declaration creates a function object and assigns it to the
specified name—<code>area</code> in this example. Elsewhere in our program,
we can refer to the function—and run the code inside it—by using this
name. The function declarations in any block of JavaScript code are
processed before that code runs, and the function names are bound to
the function objects throughout the block. We say that function
declarations are “hoisted” because it is as if they had all been moved
up to the top of whatever scope they are defined within. The upshot is
that code that invokes a function can exist in your program before the
code that declares the function.</p>

<p><a data-type="xref" href="ch12.html#generators">§12.3</a> describes a special kind of function known as a
<em>generator</em>. Generator declarations use the <code>function</code> keyword but
follow it with an asterisk. <a data-type="xref" href="ch13.html#async-await">§13.3</a> describes asynchronous
functions, which are also declared using the <code>function</code> keyword but
are prefixed with the <code>async</code> keyword.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.7.3 class"><div class="sect2" id="idm46198552445240">
<h2>5.7.3 class</h2>

<p>In<a data-type="indexterm" data-primary="ES6" data-secondary="class declaration" id="idm46198552443880"></a><a data-type="indexterm" data-primary="declarations" data-secondary="class" id="idm46198552442872"></a><a data-type="indexterm" data-primary="class declaration" id="idm46198552441928"></a> ES6 and later, the <code>class</code> declaration creates a new class and
gives it a name that we can use to refer to it. Classes are described
in detail in <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>. A simple class declaration might look like
this:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">class</code> <code class="nx">Circle</code> <code class="p">{</code>
    <code class="nx">constructor</code><code class="p">(</code><code class="nx">radius</code><code class="p">)</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">=</code> <code class="nx">radius</code><code class="p">;</code> <code class="p">}</code>
    <code class="nx">area</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">r</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="p">;</code> <code class="p">}</code>
    <code class="nx">circumference</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="mi">2</code> <code class="o">*</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">r</code><code class="p">;</code> <code class="p">}</code>
<code class="p">}</code></pre>

<p>Unlike functions, class declarations are not hoisted, and you cannot
use a class declared this way in code that appears before the
declaration.</p>
</div></section>













<section data-type="sect2" data-pdf-bookmark="5.7.4 import and export"><div class="sect2" id="idm46198552364648">
<h2>5.7.4 import and export</h2>

<p>The<a data-type="indexterm" data-primary="declarations" data-secondary="import and export" id="idm46198552363368"></a><a data-type="indexterm" data-primary="import declaration" id="idm46198552361976"></a><a data-type="indexterm" data-primary="export declaration" id="idm46198552361304"></a> <code>import</code> and <code>export</code> declarations are used together to make
values defined in one module of JavaScript code available in another
module. A module is a file of JavaScript code with its own global
namespace, completely independent of all other modules. The only way
that a value (such as function or class) defined in one module can be
used in another module is if the defining module exports it with
<code>export</code> and the using module imports it with <code>import</code>. Modules are
the subject of <a data-type="xref" href="ch10.html#modules">Chapter&nbsp;10</a>, and <code>import</code> and <code>export</code> are covered in
detail in <a data-type="xref" href="ch10.html#es6modules">§10.3</a>.</p>

<p><code>import</code> directives are used to import one or more values from another
file of JavaScript code and give them names within the current
module. <code>import</code> directives come in a few different forms. Here are
some examples:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">import</code> <code class="nx">Circle</code> <code class="nx">from</code> <code class="s1">'./geometry/circle.js'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">PI</code><code class="p">,</code> <code class="nx">TAU</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./geometry/constants.js'</code><code class="p">;</code>
<code class="kr">import</code> <code class="p">{</code> <code class="nx">magnitude</code> <code class="nx">as</code> <code class="nx">hypotenuse</code> <code class="p">}</code> <code class="nx">from</code> <code class="s1">'./vectors/utils.js'</code><code class="p">;</code></pre>

<p>Values within a JavaScript module are private and cannot be imported
into other modules unless they have been explicitly exported. The
<code>export</code> directive does this: it declares that one or more values
defined in the current module are exported and therefore available for
import by other modules. The <code>export</code> directive has more variants than
the <code>import</code> directive does. Here is one of them:</p>

<pre data-type="programlisting" data-code-language="js"><code class="c1">// geometry/constants.js</code>
<code class="kr">const</code> <code class="nx">PI</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code><code class="p">;</code>
<code class="kr">const</code> <code class="nx">TAU</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">*</code> <code class="nx">PI</code><code class="p">;</code>
<code class="kr">export</code> <code class="p">{</code> <code class="nx">PI</code><code class="p">,</code> <code class="nx">TAU</code> <code class="p">};</code></pre>

<p>The <code>export</code> keyword is sometimes used as a modifier on other
declarations, resulting in a kind of compound declaration that defines
a constant, variable, function, or class and exports it at the same
time. And when a module exports only a single value, this is typically
done with the special form <code>export default</code>:</p>

<pre data-type="programlisting" data-code-language="js"><code class="kr">export</code> <code class="kr">const</code> <code class="nx">TAU</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">*</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">PI</code><code class="p">;</code>
<code class="kr">export</code> <code class="kd">function</code> <code class="nx">magnitude</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">x</code><code class="o">*</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="o">*</code><code class="nx">y</code><code class="p">);</code> <code class="p">}</code>
<code class="kr">export</code> <code class="k">default</code> <code class="kr">class</code> <code class="nx">Circle</code> <code class="p">{</code> <code class="cm">/* class definition omitted here */</code> <code class="p">}</code></pre>
</div></section>





</div></section>













<section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="5.8 Summary of JavaScript Statements"><div class="sect1" id="idm46198552201080">
<h1>5.8 Summary of JavaScript Statements</h1>

<p>This<a data-type="indexterm" data-primary="statements" data-secondary="list of" id="idm46198552183016"></a> chapter introduced each of the JavaScript language’s statements, which are summarized in <a data-type="xref" href="#statementssummary">Table&nbsp;5-1</a>.</p>
<table id="statementssummary">
<caption><span class="label">Table 5-1. </span>JavaScript statement syntax</caption>
<thead>
<tr>
<th>Statement</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td><p>break</p></td>
<td><p>Exit from the innermost loop or <code>switch</code> or from named enclosing statement</p></td>
</tr>
<tr>
<td><p>case</p></td>
<td><p>Label a statement within a <code>switch</code></p></td>
</tr>
<tr>
<td><p>class</p></td>
<td><p>Declare a class</p></td>
</tr>
<tr>
<td><p>const</p></td>
<td><p>Declare and initialize one or more constants</p></td>
</tr>
<tr>
<td><p>continue</p></td>
<td><p>Begin next iteration of the innermost loop or the named loop</p></td>
</tr>
<tr>
<td><p>debugger</p></td>
<td><p>Debugger breakpoint</p></td>
</tr>
<tr>
<td><p>default</p></td>
<td><p>Label the default statement within a <code>switch</code></p></td>
</tr>
<tr>
<td><p>do/while</p></td>
<td><p>An alternative to the <code>while</code> loop</p></td>
</tr>
<tr>
<td><p>export</p></td>
<td><p>Declare values that can be imported into other modules</p></td>
</tr>
<tr>
<td><p>for</p></td>
<td><p>An easy-to-use loop</p></td>
</tr>
<tr>
<td><p>for/await</p></td>
<td><p>Asynchronously iterate the values of an async iterator</p></td>
</tr>
<tr>
<td><p>for/in</p></td>
<td><p>Enumerate the property names of an object</p></td>
</tr>
<tr>
<td><p>for/of</p></td>
<td><p>Enumerate the values of an iterable object such as an array</p></td>
</tr>
<tr>
<td><p>function</p></td>
<td><p>Declare a function</p></td>
</tr>
<tr>
<td><p>if/else</p></td>
<td><p>Execute one statement or another depending on a condition</p></td>
</tr>
<tr>
<td><p>import</p></td>
<td><p>Declare names for values defined in other modules</p></td>
</tr>
<tr>
<td><p>label</p></td>
<td><p>Give statement a name for use with <code>break</code> and <code>continue</code></p></td>
</tr>
<tr>
<td><p>let</p></td>
<td><p>Declare and initialize one or more block-scoped variables (new syntax)</p></td>
</tr>
<tr>
<td><p>return</p></td>
<td><p>Return a value from a function</p></td>
</tr>
<tr>
<td><p>switch</p></td>
<td><p>Multiway branch to <code>case</code> or <code>default:</code> labels</p></td>
</tr>
<tr>
<td><p>throw</p></td>
<td><p>Throw an exception</p></td>
</tr>
<tr>
<td><p>try/catch/finally</p></td>
<td><p>Handle exceptions and code cleanup</p></td>
</tr>
<tr>
<td><p>“use strict”</p></td>
<td><p>Apply strict mode restrictions to script or function</p></td>
</tr>
<tr>
<td><p>var</p></td>
<td><p>Declare and initialize one or more variables (old syntax)</p></td>
</tr>
<tr>
<td><p>while</p></td>
<td><p>A basic loop construct</p></td>
</tr>
<tr>
<td><p>with</p></td>
<td><p>Extend the scope chain (deprecated and forbidden in strict mode)</p></td>
</tr>
<tr>
<td><p>yield</p></td>
<td><p>Provide a value to be iterated; only used in generator functions</p></td>
</tr>
</tbody>
</table>
</div></section>







<div data-type="footnotes"><p data-type="footnote" id="idm46198554953944"><sup><a href="ch05.html#idm46198554953944-marker">1</a></sup> The fact that the <code>case</code> expressions are evaluated at runtime makes the JavaScript <code>switch</code> statement much different from (and less efficient than) the <code>switch</code> statement of C, C++, and Java. In those languages, the <code>case</code> expressions must be compile-time constants of the same type, and <code>switch</code> statements can often compile down to highly efficient <em>jump tables</em>.</p><p data-type="footnote" id="idm46198554759768"><sup><a href="ch05.html#idm46198554759768-marker">2</a></sup> When we consider the <code>continue</code> statement in <a data-type="xref" href="#continue">§5.5.3</a>, we’ll see that this <code>while</code> loop is not an exact equivalent of the <code>for</code> loop.</p></div></div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->