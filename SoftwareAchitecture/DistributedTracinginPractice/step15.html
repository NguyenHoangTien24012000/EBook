<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="appendix" epub:type="appendix" data-pdf-bookmark="Appendix A. The State of Distributed Tracing Circa 2020"><div class="appendix" id="appendix_a_distributed_tracing_refs">
        <h1><span class="label">Appendix A. </span>The State of Distributed Tracing Circa 2020</h1>
        
        
        <p>One of the biggest challenges in writing this book has been figuring out what merits inclusion. We’ve attempted to provide a broad, and somewhat timeless, overview of the fundamental concepts and techniques underpinning the technology as it exists today. For everything we touched on, however, there’s more that we left out. This appendix will attempt to give you a snapshot of popular tools for distributed tracing, both open source and commercial, that you might find useful.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Open Source Tracers and Trace Analysis"><div class="sect1" id="idm45356997510712">
        <h1>Open Source Tracers and Trace Analysis</h1>
        
        <p><a data-type="indexterm" data-primary="tracers" data-secondary="open source" id="idm45356997509304"></a><a data-type="indexterm" data-primary="open source tracers and trace analyzers" id="idm45356997508328"></a><a data-type="indexterm" data-primary="data analysis" data-secondary="open source trace analyzers" id="idm45356997507688"></a><a data-type="indexterm" data-primary="URLs" data-secondary="open source tracers and trace analyzers" id="idm45356997506728"></a>These are some popular open source tracers and trace analyzers:</p>
        <dl>
        <dt><a data-type="indexterm" data-primary="Zipkin (Twitter)" data-secondary="OpenZipkin" id="idm45356997474776"></a><a data-type="indexterm" data-primary="URLs" data-secondary="Zipkin" id="idm45356997473928"></a><a data-type="indexterm" data-primary="OpenZipkin" id="idm45356997473080"></a><a href="https://zipkin.io">Zipkin</a></dt>
        <dd>
        <p>One of the most mature open source tracing tools available today. We discuss it in more depth in <a data-type="xref" href="ch03.html#ch4_zipkin">“Zipkin”</a>. It provides, in addition to a trace analyzer, a number of instrumentation libraries for popular frameworks such as ASP.NET Core, a variety of Java frameworks (such as Jersey, JAXRS2, Apache HttpClient, and Spring Cloud), and more.</p>
        </dd>
        <dt><a data-type="indexterm" data-primary="URLs" data-secondary="Jaeger" id="idm45356997469624"></a><a data-type="indexterm" data-primary="Jaeger" data-secondary="as open source" data-secondary-sortas="open source" id="idm45356997468648"></a><a data-type="indexterm" data-primary="open source instrumentation" data-secondary="Jaeger as" id="idm45356997467432"></a><a data-type="indexterm" data-primary="Jaeger" data-secondary="distributed tracing" id="idm45356997466520"></a><a href="https://www.jaegertracing.io">Jaeger</a></dt>
        <dd>
        <p>A newer open source tracing tool and a <a data-type="indexterm" data-primary="Cloud Native Computing Foundation (CNCF)" id="idm45356997464344"></a>Cloud Native Computing Foundation (CNCF) project. The more lightweight nature of Jaeger has made it extremely popular for cloud-native developers, and it is the default trace analyzer for the popular service mesh Istio. Jaeger also fully supports the OpenTracing API, making it compatible with hundreds of integrations into existing frameworks and libraries.</p>
        </dd>
        <dt><a data-type="indexterm" data-primary="SkyWalking (Apache Foundation)" id="idm45356997462664"></a><a href="https://skywalking.apache.org">SkyWalking</a></dt>
        <dd>
        <p>An Apache Foundation project that has found a great deal of popularity in China. Its goal is to be an all-in-one application performance management tool. It <span class="keep-together">supports</span> not just distributed traces but also metrics, and can ingest data from a variety of tracing formats.</p>
        </dd>
        <dt><a data-type="indexterm" data-primary="Haystack (Expedia)" id="idm45356997459224"></a><a href="https://expediadotcom.github.io/haystack">Haystack</a></dt>
        <dd>
        <p>A distributed tracing analysis system built by Expedia. It supports OpenTracing, allowing you to make use of hundreds of existing integrations. It supports trace analysis and allows you to create custom alerts based on performance data.</p>
        </dd>
        <dt><a data-type="indexterm" data-primary="Pinpoint" id="idm45356997456552"></a><a href="https://naver.github.io/pinpoint">Pinpoint</a></dt>
        <dd>
        <p>An APM tool that supports monitoring of Java- and PHP-based distributed systems. One unique characteristic of Pinpoint is that it exclusively instruments your code through agents and plug-ins, which means you can’t do explicit instrumentation of your source code and are required to run the agent.</p>
        </dd>
        <dt><a data-type="indexterm" data-primary="AppDash" id="idm45356997453832"></a><a href="https://github.com/sourcegraph/appdash">Appdash</a></dt>
        <dd>
        <p>An application tracing system for Go that is based on Google’s Dapper. It’s primarily intended for instrumenting Go-based applications, but offers support for the OpenTracing API and has clients in Python and Ruby as well.</p>
        </dd>
        </dl>
        
        <p>In general, Jaeger and Zipkin are the two most popular and mature open source tracing tools. They have large user and contributor communities, and offer a fairly straightforward setup and installation process.</p>
        
        <p><a data-type="indexterm" data-primary="OpenTelemetry" data-secondary="current status" id="idm45356997450744"></a><a data-type="indexterm" data-primary="OpenTelemetry" data-secondary="instrumentation plug-in" id="idm45356997449736"></a>At the time of this writing, OpenTelemetry is still in alpha, but by the time this book is printed it’s anticipated to be in beta or moving toward a 1.0 release. One of the design goals of OpenTelemetry, in addition to providing a standard API and SDK for instrumentation, is to provide high-quality automatic instrumentation for popular frameworks and libraries both through wrappers around that code and also through agents. We anticipate that this movement toward instrumentation as a focus of the open source world will lead to distributed tracing being a built-in feature of RPC frameworks, libraries, and other software products.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Commercial Tracers and Trace Analyzers"><div class="sect1" id="idm45356997447880">
        <h1>Commercial Tracers and Trace Analyzers</h1>
        
        <p><a data-type="indexterm" data-primary="URLs" data-secondary="commercial tracers and trace analyzers" id="idm45356997446776"></a><a data-type="indexterm" data-primary="tracers" data-secondary="commercial" id="idm45356997445784"></a><a data-type="indexterm" data-primary="vendor URLs" id="idm45356997444840"></a>There’s a huge variety of commercial performance monitoring and distributed tracing vendors. In an effort to be impartial, we’ll simply list the most notable ones here. In general, these are all SaaS products that do the heavy lifting in terms of storing, analyzing, indexing, and alerting based on your trace data. Some of them offer proprietary agents and other tools to ease instrumentation. Many, if not most, support open source instrumentation standards such as OpenTracing, OpenCensus, and <span class="keep-together">OpenTelemetry</span>:</p>
        
        <ul>
        <li>
        <p><a href="https://www.appdynamics.com">AppDynamics</a></p>
        </li>
        <li>
        <p><a href="https://www.datadog.com">Datadog</a></p>
        </li>
        <li>
        <p><a href="https://www.dynatrace.com">Dynatrace</a></p>
        </li>
        <li>
        <p><a href="https://www.elastic.co">Elastic</a></p>
        </li>
        <li>
        <p><a href="https://www.epsagon.com">Epsagon</a></p>
        </li>
        <li>
        <p><a href="https://www.honeycomb.io">Honeycomb</a></p>
        </li>
        <li>
        <p><a href="https://www.instana.com">Instana</a></p>
        </li>
        <li>
        <p><a href="https://www.lightstep.com">Lightstep</a></p>
        </li>
        <li>
        <p><a href="https://www.newrelic.com">New Relic</a></p>
        </li>
        <li>
        <p><a href="https://www.splunk.com">Splunk</a></p>
        </li>
        <li>
        <p><a href="https://www.wavefront.com">Wavefront</a></p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Language-Specific Tracing Features"><div class="sect1" id="idm45356997427704">
        <h1>Language-Specific Tracing Features</h1>
        
        <p><a data-type="indexterm" data-primary="language-specific tracing features" id="idm45356997426424"></a><a data-type="indexterm" data-primary="plug-ins by language" id="idm45356997425656"></a>Not every language is created equal when it comes to distributed tracing. Some languages offer tools, features, and projects that you may wish to employ in instrumenting your code. We’ll look at a few of them here.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Java and C#"><div class="sect2" id="idm45356997424488">
        <h2>Java and C#</h2>
        
        <p><a data-type="indexterm" data-primary="Java" data-secondary="Java tracing features" id="idm45356997423144"></a><a data-type="indexterm" data-primary="C/C#/C++ tracing features" id="idm45356997422168"></a>As two of the most common languages in use around the world, it’s no surprise that Java and C# have wide support for distributed tracing. A variety of proprietary and open source agents and automatic instrumentation plug-ins exist for most popular service and RPC frameworks, including:</p>
        
        <ul>
        <li>
        <p>Spring</p>
        </li>
        <li>
        <p>Akka</p>
        </li>
        <li>
        <p>JAX-RS</p>
        </li>
        <li>
        <p>JDBI</p>
        </li>
        <li>
        <p>JDBC</p>
        </li>
        <li>
        <p>Apache HttpClient</p>
        </li>
        <li>
        <p>Netty</p>
        </li>
        <li>
        <p>OkHTTP</p>
        </li>
        <li>
        <p>Java Flight Recorder (JFR)</p>
        </li>
        <li>
        <p>Web Servlet Filter</p>
        </li>
        <li>
        <p>gRPC</p>
        </li>
        </ul>
        
        <p>C# also supports a wide variety of instrumentation plug-ins, such as:</p>
        
        <ul>
        <li>
        <p>ASP.NET MVC</p>
        </li>
        <li>
        <p>ASP.NET WebAPI</p>
        </li>
        <li>
        <p>ASP.NET Core MVC</p>
        </li>
        <li>
        <p>Entity Framework Core</p>
        </li>
        <li>
        <p>gRPC</p>
        </li>
        </ul>
        
        <p>In addition, both of these languages feature a variety of automatic instrumentation tools that operate on the bytecode of compiled software, such as the <a data-type="indexterm" data-primary="Java" data-secondary="Special Agent" id="idm45356997404712"></a>Java Special Agent or C#’s Fody plug-in. It’s also possible to use a variety of aspect-oriented programming frameworks (such as C#’s PostSharp) to write tracing plug-ins that allow you to easily decorate method declarations in order to trace them.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Go, Rust, and C++"><div class="sect2" id="idm45356997403208">
        <h2>Go, Rust, and C++</h2>
        
        <p><a data-type="indexterm" data-primary="Go tracing features" id="idm45356997401832"></a><a data-type="indexterm" data-primary="Rust tracing features" id="idm45356997401128"></a>Go, Rust, C++, and C are somewhat more challenging to instrument because they lack some of the niceties available to us in managed runtimes like the JVM or CLR. However, their popularity as microservice languages means that there are a great many instrumentation tools available for them.</p>
        
        <p>Go supports automatic instrumentation primarily by wrapping existing libraries with tracing code. Generally, you use these by modifying your import path to point to a traced version of the library, but there are other implementations that provide function wrappers—such as the ones used earlier in this text, in the MicroCalc example code.</p>
        
        <p>Rust supports tracing as a first-class citizen through its <code>tracing</code> crate (package, in Rust parlance), which was formerly known as <code>tokio-trace</code>. This crate provides an interface to popular OSS tracing APIs such as OpenTracing and OpenTelemetry. This package is becoming widely supported throughout the Rust ecosystem, and provides helpful methods for tracing at the local function level in addition to distributed requests.</p>
        
        <p><a data-type="indexterm" data-primary="OpenTracing" data-secondary="API" id="idm45356997397448"></a><a data-type="indexterm" data-primary="OpenTelemetry" data-secondary="API component" id="idm45356997396472"></a>C++ is supported by the OpenTracing API, as well as OpenTelemetry. There’s little in the way of automatic instrumentation or tracing agents for C++, but tracers exist for most commercial and OSS tracing systems that support <a data-type="indexterm" data-primary="Envoy" data-secondary="C++ support" id="idm45356997395160"></a><a data-type="indexterm" data-primary="NGINX" data-secondary="C++ support" id="idm45356997394216"></a>C++ as it is part of service mesh tracing (through its integration into tools like Envoy and Nginx).</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Python, JavaScript, and Other Dynamic Languages"><div class="sect2" id="idm45356997392904">
        <h2>Python, JavaScript, and Other Dynamic Languages</h2>
        
        <p><a data-type="indexterm" data-primary="dynamic languages tracing support" id="idm45356997391624"></a><a data-type="indexterm" data-primary="JavaScript tracing support" id="idm45356997390952"></a>Dynamic languages tend to have excellent support for distributed tracing instrumentation, through either plug-ins or agents. We’ll focus just on JavaScript and Python, but much of this is generally applicable to other similar languages (for example, most of what we write about JavaScript applies to TypeScript and other languages that run on V8 or other JS runtimes).</p>
        
        <p><a data-type="indexterm" data-primary="instrumentation" data-secondary="JavaScript" id="idm45356997389544"></a><a data-type="indexterm" data-primary="HTTP" data-secondary="JavaScript instrumentation" id="idm45356997388344"></a><a data-type="indexterm" data-primary="web clients" data-secondary="JavaScript instrumentation" id="idm45356997387432"></a><a data-type="indexterm" data-primary="web clients" data-secondary="browser tracing" id="idm45356997386520"></a><a data-type="indexterm" data-primary="browser tracing" id="idm45356997385576"></a><a data-type="indexterm" data-primary="instrumentation" data-secondary="dynamic instrumentation" id="idm45356997384904"></a>JavaScript instrumentation can be thought of in two major groups—browser- and Node.JS-based. Browser instrumentation is primarily interested in instrumenting HTTP libraries, such as the <code>XMLHttpRequest</code> or <code>fetch</code> libraries. These plug-ins tend to be fairly straightforward, just importing the libraries and going from there. Since JavaScript makes it easy to add hooks to existing functions, quite a bit of browser instrumentation falls into this category. There are also packages, like <a data-type="indexterm" data-primary="OpenCensus" data-secondary="Web" id="idm45356997382504"></a>OpenCensus Web, which hook into the underlying browser API to trace page load timings and user interactions in the browser.</p>
        
        <p>For Node.JS, instrumentation plug-ins and middleware exist for many popular and widely used libraries and frameworks, such as the following:</p>
        
        <ul>
        <li>
        <p>Express</p>
        </li>
        <li>
        <p>Connect</p>
        </li>
        <li>
        <p>gRPC</p>
        </li>
        <li>
        <p>Restify</p>
        </li>
        <li>
        <p>Native modules (dns, http, net, etc.)</p>
        </li>
        <li>
        <p>MySQL and MySQL2</p>
        </li>
        <li>
        <p>pg (Postgres)</p>
        </li>
        <li>
        <p>Redis</p>
        </li>
        <li>
        <p>MongoDB</p>
        </li>
        </ul>
        
        <p>This isn’t an exhaustive list, but it’s representative of the breadth of integrations <span class="keep-together">available</span>.</p>
        
        <p><a data-type="indexterm" data-primary="Python tracing support" id="idm45356997370760"></a><a data-type="indexterm" data-primary="dynamic instrumentation" data-secondary="Python" id="idm45356997370056"></a>Python, similarly, allows for dynamic instrumentation by simply importing a tracing library into your application code, as method signatures can be intercepted and rewritten by imported code. Some of the frameworks and libraries that are instrumented for Python are:</p>
        
        <ul>
        <li>
        <p>Django</p>
        </li>
        <li>
        <p>Flask</p>
        </li>
        <li>
        <p>Tornado</p>
        </li>
        <li>
        <p>Cassandra</p>
        </li>
        <li>
        <p>Memcached</p>
        </li>
        <li>
        <p>MongoDB</p>
        </li>
        <li>
        <p>MySQL</p>
        </li>
        <li>
        <p>Postgres</p>
        </li>
        <li>
        <p>Redis</p>
        </li>
        <li>
        <p>gRPC</p>
        </li>
        <li>
        <p>Requests</p>
        </li>
        <li>
        <p>gevent</p>
        </li>
        </ul>
        
        <p>The best way to discover these and other integrations for your language is to browse the various tracing registries available at <a href="https://opentracing.io/registry">OpenTracing</a> and <a href="https://opentelemetry.io/registry">OpenTelemetry</a>, as they tend to be somewhat exhaustive.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492056621/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com