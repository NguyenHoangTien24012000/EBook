<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" class="pagenumrestart" data-pdf-bookmark="Chapter 1. The Problem with Distributed Tracing"><div class="chapter" id="chapter_2">
        <h1><span class="label">Chapter 1. </span>The Problem with Distributed Tracing</h1>
        
        <blockquote data-type="epigraph" epub:type="epigraph">
        <p>I HAVE NO TOOLS BECAUSE I’VE DESTROYED MY TOOLS WITH MY TOOLS.</p>
        <p data-type="attribution">James Mickens<sup><a data-type="noteref" id="idm45357015165928-marker" href="ch01.html#idm45357015165928">1</a></sup></p>
        </blockquote>
        
        <p>The concept of tracing the execution of a computer program is not a new one in any sense. Being able to understand the <a data-type="indexterm" data-primary="stack traces" data-secondary="debugging ubiquity of" id="idm45357015163992"></a>call stack of a program is fairly critical, you might say, to all manner of profiling, debugging, and monitoring tasks. Indeed, stack traces are likely to be the second most utilized debugging tool in the world, right behind <code>print</code> statements liberally scattered throughout a codebase. Our tools, processes, and technologies have improved over the past two decades and demand new methodologies and patterns of thinking, though. As we recalled in the <a href="preface01.html#chapter_1">Introduction</a>, modern architectures such as microservices have fundamentally broken these classic methods of profiling, debugging, and monitoring. Distributed tracing stands ready to alleviate these issues to fix the holes in our tools that we have destroyed with our tools.</p>
        
        <p><a data-type="indexterm" data-primary="distributed tracing" data-secondary="challenges of" id="idm45357015160776"></a>There’s just one problem—distributed tracing can be hard. Why is this the case? Three fundamental problems generally occur when you’re trying to get started with distributed tracing.</p>
        
        <p>First, <a data-type="indexterm" data-primary="data collection" data-secondary="challenge of distributed tracing" id="idm45357015159080"></a><a data-type="indexterm" data-primary="data generation" data-secondary="challenge of distributed tracing" id="idm45357015158008"></a>you need to be able to generate trace data. Support for distributed tracing as a first-class citizen in your runtime may be spotty or nonexistent. Your software might not be structured to easily accept the instrumentation code required to emit tracing data. You may use patterns that are antithetical to the request-based style of most distributed tracing platforms. Often, distributed tracing initiatives are dead on arrival due to the challenges of instrumenting an existing codebase.</p>
        
        <p><a data-type="indexterm" data-primary="data aggregation" data-secondary="challenge of distributed tracing" id="idm45357015156168"></a>Another problem is how you collect and store the trace data generated by your software. Imagine hundreds or thousands of services, each emitting small chunks of trace data for each request, potentially millions of times per second. How do you capture that data and store it for analysis and retrieval? How do you decide what to keep, and how long to keep it? How do you scale the collection of your data in time with requests to your services?</p>
        
        <p>Finally, <a data-type="indexterm" data-primary="data analysis" data-secondary="challenge of distributed tracing" id="idm45357015154200"></a>once you’ve got all of this data, how do you actually derive value from it? How do you translate the raw trace data that you’re receiving into actionable insights and actions? How do you use trace data to provide context to other service telemetry, reducing the time required to diagnose issues? Can you turn your trace data into value for other parts of the business, outside of just engineers? These questions, and more, stymie and confuse many who are trying to get started with distributed tracing.</p>
        
        <p><a data-type="indexterm" data-primary="deep systems" data-secondary="distributed tracing managing" id="idm45357015152264"></a><a data-type="indexterm" data-primary="distributed tracing" data-secondary="deep systems management" id="idm45357015151272"></a><a data-type="indexterm" data-primary="distributed applications" data-secondary="as deep system" id="idm45357015150328"></a>The result of a distributed tracing deployment is a tool that grants you visibility into your deep system and the ability to easily understand how individual services in a request contribute to the overall performance of each request. The trace data you’ll generate can be used not only to display the overall shape of your distributed system (see <a data-type="xref" href="#ch2_map">Figure&nbsp;1-1</a>), but also to view individual service performance inside a single request.</p>
        
        <figure><div id="ch2_map" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492056621/files/assets/dtip_0101.png" alt="dtip 0101" width="1395" height="614">
        <h6><span class="label">Figure 1-1. </span>A service map generated from distributed trace data.</h6>
        </div></figure>
        
        <p><a data-type="indexterm" data-primary="requests" data-secondary="as RPCs to be traced" data-secondary-sortas="RPCs to be traced" id="idm45357015145848"></a>As <a data-type="xref" href="#ch2_trace">Figure&nbsp;1-2</a> shows, you’ll be able to inspect requests as they move from frontend clients into backend services and understand how—and why—latency or errors are occurring, and what impact they’re having on the entire request. These traces provide a wealth of information that you’ll find invaluable when troubleshooting problems in production, such as metadata that indicates which host or region a particular service is running on. You’ll have the ability to search, sort, filter, group, and generally slice and dice this trace data how you please in order to quickly troubleshoot problems or understand how different dimensions are impacting your service performance.</p>
        
        <figure><div id="ch2_trace" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492056621/files/assets/dtip_0102.png" alt="dtip 0102" width="1440" height="1296">
        <h6><span class="label">Figure 1-2. </span>A sample trace demonstrating a request initiated by a frontend web client.</h6>
        </div></figure>
        
        <p>So, how do you get from here to there? What do you need to build a successful distributed tracing deployment?</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="The Pieces of a Distributed Tracing Deployment"><div class="sect1" id="idm45357015140344">
        <h1>The Pieces of a Distributed Tracing Deployment</h1>
        
        <p>To answer these questions and help you organize your thinking about the subject, we’ve broken down distributed tracing deployments into three main areas of focus, which is also how we’ve organized the book. These three pieces build off of each other, but may be generally useful to different people at different times—by no means do you need to be an expert on all three! Inside each section you’ll find helpful explanations, lessons, and examples of how to build and deliver a distributed tracing deployment at your organization that should help in building confidence in your systems and software.</p>
        <dl>
        <dt>Instrumentation, <a data-type="xref" href="ch02.html#Chapter3">Chapter&nbsp;2</a></dt>
        <dd>
        <p><a data-type="indexterm" data-primary="deployment of distributed tracing" data-secondary="instrumentation" id="idm45357015136088"></a><a data-type="indexterm" data-primary="instrumentation" data-secondary="deployment" id="idm45357015134920"></a><a data-type="indexterm" data-primary="data generation" data-secondary="instrumentation for" data-seealso="instrumentation" id="idm45357015133976"></a>Distributed tracing requires traces. Trace data can be generated through <a data-type="indexterm" data-primary="instrumentation" data-secondary="about" id="idm45357015132632"></a><em>instrumentation</em> of your service processes or by transforming existing telemetry data into trace data. In this section, you’ll learn about <em>spans</em>, the building blocks of request-based distributed traces, and how they may be generated by your services. We’ll discuss the state of the art in <em>instrumentation frameworks</em> such as OpenTelemetry, a widely supported open source project that offers an instrumentation API (and more) that allows for easy bootstrapping of distributed tracing into your software. In addition, we’ll discuss the best practices for instrumenting legacy code as well as greenfield development.</p>
        </dd>
        <dt>Deployment, <a data-type="xref" href="ch05.html#chapter_6">Chapter&nbsp;5</a></dt>
        <dd>
        <p><a data-type="indexterm" data-primary="deployment of distributed tracing" data-secondary="information required for" id="idm45357015128056"></a>Once you’re generating trace data, you need to send it somewhere. Deploying tracing for your organization requires an understanding of where your software runs—for end users and their clients, as well as on servers—and how it’s operated. You’ll need to understand the security, privacy, and compliance implications of collecting and storing trace data. You may encounter trade-offs in overhead relating to how much data is kept, and how much is discarded through a process known as <em>sampling</em>. We’ll discuss best practices around all of these topics and help you figure out how to quickly deploy tracing infrastructure for your <span class="keep-together">system</span>.</p>
        </dd>
        <dt>Delivering value, <a data-type="xref" href="ch07.html#chapter_9">Chapter&nbsp;7</a></dt>
        <dd>
        <p><a data-type="indexterm" data-primary="deployment of distributed tracing" data-secondary="delivering value" id="idm45357015123240"></a><a data-type="indexterm" data-primary="data analysis" data-secondary="delivering value" id="idm45357015122248"></a><a data-type="indexterm" data-primary="data analysis" data-secondary="statistics" data-see="statistics" id="idm45357015121304"></a><a data-type="indexterm" data-primary="data analysis" data-secondary="histograms" data-see="histograms" id="idm45357015120088"></a>Once your services are generating trace data and you’ve deployed the necessary infrastructure to collect it, the real fun begins! How do you combine traces with your other observability tools and techniques such as metrics and logs? How do you measure what matters—and how do you define what matters to begin with? Distributed tracing provides the tools you’ll need to answer these questions, and we’ll help you figure it out in this section. You’ll learn how to use traces to improve your baseline performance, as well as how tracing assists you in getting back to that baseline when things catch on fire.</p>
        </dd>
        </dl>
        
        <p>All that said, there’s still an open question here: how does distributed tracing relate to microservices, and distributed architectures more generally? We touched on this in <a data-type="xref" href="preface01.html#chapter_1">Introduction: What Is Distributed Tracing?</a>, but let’s digress for a moment to review the relationship between these things.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Distributed Tracing, Microservices, Serverless, Oh My!"><div class="sect1" id="idm45357015116312">
        <h1>Distributed Tracing, Microservices, Serverless, Oh My!</h1>
        
        <p><a data-type="indexterm" data-primary="microservices" data-secondary="considerations for adopting" id="idm45357015114936"></a>There’s a certain line of thinking about microservices, now that we’re several years past them being the “hot thing” in every analyst’s portfolio of “Top Trends for 20XX”—namely, that the battle has been won. The exploding popularity of cloud computing, Kubernetes, containerization, and other development tools which enable rapid provisioning and deployment of hardware (or hardware-like abstractions) has <span class="keep-together">transformed</span> the industry, undoubtedly. These factors can make it feel like asking the question “Should I use microservices?” would be to out oneself as a fool or charlatan.</p>
        
        <p><a data-type="indexterm" data-primary="containerization" data-secondary="limited use of" id="idm45357015112312"></a>Take a step back here and we’ll look at some real-world data. First and foremost, there’s some evidence that containers aren’t exactly as popular in production as the hype may make them seem: only 25% of developers use them in production.<sup><a data-type="noteref" id="idm45357010214552-marker" href="ch01.html#idm45357010214552">2</a></sup> Quite a few engineering organizations are still using traditional monoliths for a lot of their work. Why? One reason may be, ironically enough, the <em>lack</em> of accessible distributed tracing tools.</p>
        
        <p><a data-type="indexterm" data-primary="Fowler, Martin" id="idm45357010212456"></a>Developer and author Martin Fowler identifies three primary considerations for those adopting microservices: the ability to rapidly provision hardware, the ability to rapidly deploy software, and a monitoring regime that can detect serious problems quickly.<sup><a data-type="noteref" id="idm45357010211352-marker" href="ch01.html#idm45357010211352">3</a></sup> The things we love about microservices (independence, idempotence, etc.) are also the things that make them difficult to understand, especially when things go wrong. <a data-type="indexterm" data-primary="serverless technologies" data-secondary="challenges of" id="idm45357010209944"></a>Serverless technologies add further confusion to this equation by giving you less visibility into the runtime environment of a particular function and often being stubbornly resistant to monitoring through your favorite tools.</p>
        
        <p><a data-type="indexterm" data-primary="microservices" data-secondary="distributed tracing relationship to" id="idm45357010208408"></a><a data-type="indexterm" data-primary="monitoring" data-secondary="distributed tracing overview" id="idm45357010207416"></a>How, then, should we consider distributed tracing arrayed against these questions? First, distributed tracing solves the monitoring question raised by Fowler by providing visibility into the operation of your microservice architecture. It allows you to gain critical insights into the performance and status of individual services as part of a chain of requests in a way that would be difficult or time-consuming to do otherwise. Distributed tracing gives you the ability to understand exactly what a <em>particular, individual service</em> is doing as part of the whole, enabling you to ask and answer questions about the performance of your services and your distributed system.</p>
        
        <p>Traditional metrics and logging alone simply can’t compare to the additional context provided by distributed tracing. <a data-type="indexterm" data-primary="metrics" data-secondary="distributed tracing versus" id="idm45357010204744"></a>Metrics, for example, will allow you to get an aggregate understanding of what’s happening to all instances of a given service, and even allow you to narrow your query to specific groups of services, but fail to account for infinite <a data-type="indexterm" data-primary="cardinality" data-secondary="definition" id="idm45357010203320"></a><a data-type="indexterm" data-primary="metrics" data-secondary="cardinality" id="idm45357010202376"></a>cardinality.<sup><a data-type="noteref" id="idm45357010201304-marker" href="ch01.html#idm45357010201304">4</a></sup></p>
        
        <p><a data-type="indexterm" data-primary="logs" data-secondary="distributed tracing versus" id="idm45357010199928"></a><a data-type="indexterm" data-primary="trace context" data-secondary="distributed tracing overview" id="idm45357010198936"></a><a data-type="indexterm" data-primary="distributed tracing" data-secondary="context" data-see="trace context" id="idm45357010197976"></a><a data-type="indexterm" data-primary="context" data-see="trace context" id="idm45357010196760"></a>Logs, on the other hand, provide extremely fine-grained detail on a given service, but have no built-in way to provide that detail in the context of a request. While you can use metrics and logs to discover and address problems in your distributed system, distributed tracing provides context that helps you narrow down the search space required to discover the root cause of an incident while it’s occurring (when every moment counts).</p>
        
        <p>As we mentioned in <a href="preface01.html#ch1_section_deepsystems">the Introduction</a>, trying to manage and understand a complex, microservice-based distributed architecture can lead to stress and burnout. If you’re thinking about migrating to microservices, are in the middle of a transition from a monolith to microservices, or are already tasked with wrangling an immense microservice architecture, then you might be experiencing this stress too, when considering how to understand the health and performance of your software. Distributed tracing might not be a panacea, but as part of a larger observability strategy, it can become a critical component of how you operate reliable distributed systems.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="The Benefits of Tracing"><div class="sect1" id="idm45357010193352">
        <h1>The Benefits of Tracing</h1>
        
        <p><a data-type="indexterm" data-primary="distributed tracing" data-secondary="benefits of" id="idm45357010192152"></a>What are the specific benefits you can achieve with distributed tracing? We’ll talk about this throughout the rest of the book, but let’s review the high-level quick wins first:</p>
        
        <ul>
        <li>
        <p>Distributed tracing can transform the way that you develop and deliver software, no doubt about it. It has benefits not only for software quality, but for your organization’s health.</p>
        </li>
        <li>
        <p>Distributed tracing can improve developer productivity and your development output. It is the best and easiest way for developers to understand the behavior of distributed systems in production. You will spend less time troubleshooting and debugging a distributed system by using distributed tracing than you would without it, and you’ll discover problems you wouldn’t otherwise realize you had.</p>
        </li>
        <li>
        <p><a data-type="indexterm" data-primary="agnostic nature of distributed tracing" id="idm45357010187512"></a><a data-type="indexterm" data-primary="distributed tracing" data-secondary="agnostic nature of" id="idm45357010186840"></a>Distributed tracing supports modern polyglot development. Since distributed tracing is agnostic to your programming language, monitoring vendor, and runtime environment, you can propagate a single trace from an iOS-native client through a C++ high-performance proxy through a Java or C# backend to a web-scale database and back, all visualized in a single place, using a single tool. No other set of tools allows you this freedom and flexibility.</p>
        </li>
        <li>
        <p>Distributed tracing reduces the overhead required for deployments and rollbacks by quickly giving you visibility into changes. This not only reduces the mean time to resolution of incidents, but decreases the time to market for new features and the mean time to detection of performance regressions. This also improves communication and collaboration across teams because your developers aren’t siloed into a particular monitoring stack for their slice of the pie—everyone, from frontend developers to database nerds, can look at the same data to understand how changes impact the overall system.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Setting the Table"><div class="sect1" id="idm45357010183336">
        <h1>Setting the Table</h1>
        
        <p>After all that, we hope that we have your attention! Let’s recap:</p>
        
        <ul>
        <li>
        <p>Distributed tracing is a tool that allows for profiling and monitoring distributed systems by way of <em>traces</em>, data that represents requests as they flow through a <span class="keep-together">system</span>.</p>
        </li>
        <li>
        <p>Distributed tracing is agnostic to your programming language, runtime, or deployment environment and can be used with almost every type of application or service.</p>
        </li>
        <li>
        <p>Distributed tracing improves teamwork and coordination, and reduces time to detect and resolve performance issues with your application.</p>
        </li>
        </ul>
        
        <p>To realize these benefits, first you’ll need some trace data. Then you’ll need to collect it, and finally you’ll have to analyze it. Let’s start at the beginning, then, and talk about instrumenting your code for distributed tracing.</p>
        </div></section>
        
        
        
        
        
        
        
        <div data-type="footnotes"><p data-type="footnote" id="idm45357015165928"><sup><a href="ch01.html#idm45357015165928-marker">1</a></sup> <a data-type="xref" href="bibliography01.html#Mic13">[Mic13]</a></p><p data-type="footnote" id="idm45357010214552"><sup><a href="ch01.html#idm45357010214552-marker">2</a></sup> <a data-type="xref" href="bibliography01.html#Sta19">[Sta19]</a></p><p data-type="footnote" id="idm45357010211352"><sup><a href="ch01.html#idm45357010211352-marker">3</a></sup> <a data-type="xref" href="bibliography01.html#Fow14">[Fow14]</a></p><p data-type="footnote" id="idm45357010201304"><sup><a href="ch01.html#idm45357010201304-marker">4</a></sup> <em>Cardinality</em> is a mathematical term that refers to the number of elements in a set or group. In the context of metrics, it’s the number of unique combinations of metric names and key/value attributes attached to those names. We’ll discuss this more in later chapters.</p></div></div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492056621/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com