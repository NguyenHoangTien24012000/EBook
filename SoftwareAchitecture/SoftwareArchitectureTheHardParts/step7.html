<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 7. Service Granularity"><div class="chapter" id="ch07-service-granularity">
        <h1><span class="label">Chapter 7. </span>Service Granularity</h1>
        
        
        <p><code>Thursday, October 14, 13:33</code></p>
        <div class="story">
        
        <p>As the migration effort got underway, both Addison and Austen<a data-type="indexterm" data-primary="granularity" data-secondary="Sysops Squad saga" id="idm45978844609088"></a><a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="granularity" id="idm45978844608112"></a><a data-type="indexterm" data-primary="service granularity" data-see="granularity" id="idm45978844606928"></a><a data-type="indexterm" data-primary="services" data-secondary="granularity" data-see="granularity" id="idm45978844605984"></a> started getting overwhelmed with all of the decisions involved with breaking apart the domain services previously identified. The development team also had its own opinions, which made decision making for service granularity even more difficult.</p>
        
        <p>“I’m still not sure what to do with the core ticketing functionality,” said Addison. “I can’t decide whether ticket creation, completion, expert assignment, and expert routing should be one, two, three, or even four services. Taylen is insisting on making everything fine-grained, but I’m not sure that’s the right approach.”</p>
        
        <p>“Me neither,” said Austen. “And I’ve got my own issues trying to figure out if the customer registration, profile management, and billing functionality should even be broken apart. And on top of all that, I’ve got another game this evening.”</p>
        
        <p>“You’ve always got a game to go to,” said Addison. “Speaking of customer functionality, did you ever figure out if the customer login functionality is going to be a separate service?”</p>
        
        <p>“No,” said Austen, “I’m still working on that as well. Skyler says it should be separate, but won’t give me a reason other than to say it’s separate functionality.”</p>
        
        <p>“This is hard stuff,” said Addison. “Do you think Logan can shed any light on this?”</p>
        
        <p>“Good idea,” said Austen, “This seat-of-the-pants analysis is really slowing things down.”</p>
        
        <p>Addison and Austen invited Taylen, the Sysops Squad tech lead, to the meeting with Logan so that all of them could be on the same page with regard to the service granularity issues they were facing.</p>
        
        <p class="pagebreak-before">“I’m telling you,” said Taylen, “we need to break up the domain services into smaller services. They are simply too coarse-grained for microservices. From what I remember, <em>micro</em> means small. We are, after all, moving to microservices. What Addison and Austen are suggesting simply doesn’t fit with the microservices model.”</p>
        
        <p>“Not every portion of an application has to be microservices,” said Logan. “That’s one of the biggest pitfalls of the microservices architecture style.”</p>
        
        <p>“If that’s the case, then how do you determine what services should and shouldn’t be broken apart?” asked Taylen.</p>
        
        <p>“Let me ask you something, Taylen,” said Logan. “What is your reason for wanting to make all of the services so small?”<a data-type="indexterm" data-primary="microservices" data-secondary="single responsibility principle and granularity" id="idm45978844598080"></a><a data-type="indexterm" data-primary="granularity" data-secondary="microservice single responsibility" id="idm45978844597136"></a><a data-type="indexterm" data-primary="single responsibility principle" data-secondary="granularity and" id="idm45978844461680"></a></p>
        
        <p>“Single-responsibility principle,” answered Taylen. “Look it up. That’s what microservices is based on.”</p>
        
        <p>“I know what the single-responsibility principle is,” said Logan. “And I also know how subjective it can be. Let’s take our customer notification service as an example. We can notify our customers through SMS, email, and we even send out postal letters. So tell me everyone, one service or three services?”</p>
        
        <p>“Three,” immediately answered Taylen. “Each notification method is its own thing. That’s what microservices is all about.”</p>
        
        <p>“One,” answered Addison. “Notification itself is clearly a single responsibility.”</p>
        
        <p>“I’m not sure,” answered Austen. “I can see it both ways. Should we just toss a coin?”</p>
        
        <p>“This is exactly why we need help,” sighed Addison.</p>
        
        <p>“The key to getting service granularity right,” said Logan, “is to remove opinion and gut feeling, and use granularity disintegrators and integrators to objectively analyze the trade-offs and form solid justifications for whether or not to break apart a service.”</p>
        
        <p>“What are granularity disintegrators and integrators?” asked Austen.</p>
        
        <p>“Let me show you,” said Logan.</p>
        <hr>
        </div>
        
        <p>Architects and developers frequently confuse the terms <em>modularity</em> and <em>granularity</em>, <a data-type="indexterm" data-primary="granularity" data-secondary="modularity versus" id="idm45978844455568"></a><a data-type="indexterm" data-primary="modularity" data-secondary="granularity versus" id="idm45978844454592"></a>and in some cases even treat them to mean the same thing. Consider the following dictionary definitions of each of these terms:</p>
        <dl>
        <dt>Modularity</dt>
        <dd>
        <p>Constructed with standardized units or dimensions for flexibility and variety in use.</p>
        </dd>
        <dt>Granularity</dt>
        <dd>
        <p>Consisting of or appearing to consist of one of numerous particles forming a larger unit.</p>
        </dd>
        </dl>
        
        <p>It’s no wonder so much confusion exists between these terms! Although the terms have similar dictionary definitions, we want to distinguish between them because they mean different things within the context of software architecture. In our usage, <em>modularity</em> concerns breaking up systems into separate parts (see <a data-type="xref" href="ch03.html#ch03-architectural-modularity">Chapter&nbsp;3</a>), whereas <em>granularity</em> deals with the <em>size</em> of those separate parts. Interestingly enough, most issues and challenges within distributed systems are typically not related to modularity, but rather granularity.</p>
        
        <p>Determining the right level of granularity—the size of a service—is one of the many hard parts of software architecture that architects and development teams continually struggle with. Granularity is not defined by the number of classes or lines of code in a service, but rather what the service does—hence why it is so hard to get service granularity right.</p>
        
        <p>Architects can leverage metrics to monitor and measure various aspects of a service to determine the appropriate level of service granularity. <a data-type="indexterm" data-primary="granularity" data-secondary="metrics" id="idm45978844446752"></a><a data-type="indexterm" data-primary="statements counted" id="idm45978844445776"></a>One such metric used to objectively measure the size of a service is to calculate the number of statements in a service. Every developer has a different coding style and technique, which is why the number of classes and number of lines of code are poor metrics to use to measure granularity. The number of statements, on the other hand, at least allows an architect or development team to objectively measure <em>what</em> the service is doing. Recall from <a data-type="xref" href="ch04.html#ch04-architectural-decomposition">Chapter&nbsp;4</a> that a <em>statement</em> is a single complete action performed in the source code, usually terminated by a special character (such as a semicolon in languages such as Java, C, C++, C#, Go, JavaScript; or a newline in languages such as F#, Python, and Ruby).</p>
        
        <p>Another metric to determine service granularity is to measure and track the number of <em>public</em> interfaces or operations exposed by a service. Granted, while there is still a bit of subjectiveness and variability with these two metrics, it’s the closest thing we’ve come up with so far to objectively measure and assess service granularity.</p>
        
        <p>Two opposing forces for service granularity are granularity disintegrators and granularity integrators. <a data-type="indexterm" data-primary="granularity" data-secondary="integrators of granularity" data-tertiary="about" id="idm45978844441680"></a><a data-type="indexterm" data-primary="granularity" data-secondary="disintegrators of granularity" data-tertiary="about" id="idm45978844440416"></a>These opposing forces are illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-balance">Figure 7-1</a>. <em>Granularity disintegrators</em> address the question “When should I consider breaking apart a service into smaller parts?”, whereas <em>Granularity integrators</em> address the question “When should I consider putting services back together?” One common mistake many development teams make is focusing too much on granularity disintegrators while ignoring granularity integrators. The secret of arriving at the appropriate level of granularity for a service is achieving an equilibrium between these two opposing forces.</p>
        
        <figure class="width-75"><div id="fig-modularity-vs-granularity-balance" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0701.png" alt="Granularity Disintegrators and Integrators" width="600" height="494">
        <h6><span class="label">Figure 7-1. </span>Service granularity depends on a balance of disintegrators and integrators</h6>
        </div></figure>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Granularity Disintegrators"><div class="sect1" id="sec-granularity-disintegrators">
        <h1>Granularity Disintegrators</h1>
        
        <p>Granularity disintegrators provide guidance and justification for when to break a service into smaller pieces.<a data-type="indexterm" data-primary="granularity" data-secondary="disintegrators of granularity" data-tertiary="about" id="idm45978844432336"></a> While the justification for breaking up a service may involve only a single driver, in most cases the justification will be based on multiple drivers. The six main drivers for granularity disintegration are as follows:</p>
        <dl>
        <dt>Service scope and function</dt>
        <dd>
        <p>Is the service doing too many unrelated things?</p>
        </dd>
        <dt>Code volatility</dt>
        <dd>
        <p>Are changes isolated to only one part of the service?</p>
        </dd>
        <dt>Scalability and throughput</dt>
        <dd>
        <p>Do parts of the service need to scale differently?</p>
        </dd>
        <dt>Fault tolerance</dt>
        <dd>
        <p>Are there errors that cause critical functions to fail within the service?</p>
        </dd>
        <dt>Security</dt>
        <dd>
        <p>Do some parts of the service need higher security levels than others?</p>
        </dd>
        <dt>Extensibility</dt>
        <dd>
        <p>Is the service always expanding to add new contexts?</p>
        </dd>
        </dl>
        
        <p>The following sections detail each of these granularity disintegration drivers.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Service Scope and Function"><div class="sect2" id="idm45978844421840">
        <h2>Service Scope and Function</h2>
        
        <p>The service scope and function is the first and most common driver for breaking<a data-type="indexterm" data-primary="granularity" data-secondary="disintegrators of granularity" data-tertiary="service scope and function" id="idm45978844420192"></a><a data-type="indexterm" data-primary="cohesion" data-secondary="service granularity" id="idm45978844418768"></a><a data-type="indexterm" data-primary="components" data-secondary="size determination" data-tertiary="size and granularity" id="idm45978844417824"></a> up a single service into smaller ones, particularly with regard to microservices. There are two dimensions to consider when analyzing the service scope and function. The first dimension is <em>cohesion</em>: the degree and manner to which the operations of a particular service interrelate. The second dimension is the overall <em>size</em> of a component, measured usually in terms of the total number of statements summed from the classes that make up that service, the number of public entrypoints into the service, or both.</p>
        
        <p>Consider a typical Notification Service that does three things: notifies a customer through <a data-type="indexterm" data-primary="SMS information link" id="idm45978844414912"></a>SMS (<a href="https://oreil.ly/caVCG">Short Message Service</a>), email, or a printed postal letter that is mailed to the customer. Although it is very tempting to break this service into three separate single-purpose services (one for SMS, one for email, and one for postal letters) as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-scope-notification">Figure 7-2</a>, this alone is not enough to justify breaking the service apart because it already has relatively strong cohesion—all of these functions relate to one thing, notifying the customer. Because “single purpose” is left for individual opinion and interpretation, it is difficult to know whether to break apart this service or not.</p>
        
        <figure><div id="fig-modularity-vs-granularity-scope-notification" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0702.png" alt="Notification Service Scope" width="600" height="559">
        <h6><span class="label">Figure 7-2. </span>A service with relatively strong cohesion is not a good candidate for disintegration based on functionality alone</h6>
        </div></figure>
        
        <p>Now consider a single service that manages the customer profile information, customer preferences, and also customer comments made on the website. Unlike the previous Notification Service example, this service has relatively weak cohesion because these three functions relate to a broader scope—customer. This service is possibly doing too much, and hence should probably be broken into three separate services, as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-scope-customer">Figure 7-3</a>.</p>
        
        <figure><div id="fig-modularity-vs-granularity-scope-customer" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0703.png" alt="Customer Service Scope" width="600" height="554">
        <h6><span class="label">Figure 7-3. </span>A service with relatively weak cohesion is a good candidate for disintegration</h6>
        </div></figure>
        
        <p>This granularity disintegrator is related to the<a data-type="indexterm" data-primary="microservices" data-secondary="single responsibility principle and granularity" id="idm45978844406048"></a><a data-type="indexterm" data-primary="granularity" data-secondary="microservice single responsibility" id="idm45978844404976"></a><a data-type="indexterm" data-primary="single responsibility principle" data-secondary="granularity and" id="idm45978844404016"></a><a data-type="indexterm" data-primary="single responsibility principle" id="idm45978844403056"></a><a data-type="indexterm" data-primary="Martin, Robert C." id="idm45978844402368"></a><a data-type="indexterm" data-primary="SOLID principles (Martin)" id="idm45978844401696"></a> <a href="https://oreil.ly/JZpcT">single-responsibility principle</a> coined by Robert C. Martin as part of his <a href="https://oreil.ly/r64Yw">SOLID principles</a>, which states, “every class should have responsibility over a single part of that program’s functionality, which it should encapsulate. All of that module, class or function’s services should be narrowly aligned with that responsibility.” While the single-responsibility principle was originally scoped within the context of classes, in later years it has expanded to include components and services.</p>
        
        <p class="pagebreak-before">Within the microservices architecture style, a <em>microservice</em> is <a data-type="indexterm" data-primary="microservices" data-secondary="definition" id="idm45978844398016"></a>defined as a single-purpose, separately deployed unit of software that does <em>one thing</em> really well. No wonder developers are so tempted to make services as small as possible without considering why they are doing so! The subjectiveness related to what is and isn’t a single responsibility is where most developers get into trouble with regard to service granularity. <a data-type="indexterm" data-primary="cohesion" data-secondary="metrics information link" id="idm45978844396400"></a><a data-type="indexterm" data-primary="resources online" data-secondary="cohesion metrics information" id="idm45978844395360"></a>While there are some metrics (such as <a href="https://oreil.ly/qOtdg">LCOM</a>) to measure cohesion, it is nevertheless highly subjective when it comes to services—is notifying the customer one single thing, or is notifying via email one single thing? For this reason, it is vital to understand other granularity disintegrators to determine the appropriate level of granularity.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Code Volatility"><div class="sect2" id="idm45978844393296">
        <h2>Code Volatility</h2>
        
        <p><em>Code volatility</em>--the rate at which the source code changes—is another <a data-type="indexterm" data-primary="granularity" data-secondary="disintegrators of granularity" data-tertiary="code volatility" id="idm45978844391280"></a><a data-type="indexterm" data-primary="code volatility as granularity driver" id="idm45978844390064"></a><a data-type="indexterm" data-primary="architectural decomposition" data-secondary="volatility-based decomposition" id="idm45978844389424"></a><a data-type="indexterm" data-primary="volatility-based decomposition" id="idm45978844388448"></a>good driver for breaking a service into smaller ones. This is also known as <em>volatility-based decomposition</em>. <a data-type="indexterm" data-primary="version control systems" data-secondary="code change frequency metric" id="idm45978844387152"></a>Objectively measuring the frequency of code changes in a service (easily done through standard facilities in any source code version-control system) can sometimes lead to a good justification for breaking apart a service. Consider the notification service example again from the prior section. Service scope (cohesion) alone was not enough to justify breaking the service apart. However, by applying change metrics, relevant information is revealed about the service:</p>
        
        <ul>
        <li>
        <p>SMS notification functionality rate of change: every six months (avg)</p>
        </li>
        <li>
        <p>Email notification functionality rate of change: every six months (avg)</p>
        </li>
        <li>
        <p>Postal letter notification functionality rate of change: weekly (avg)</p>
        </li>
        </ul>
        
        <p>Notice that the postal letter functionality changes weekly (on average), whereas the SMS and email functionality rarely changes. As a single service, any change to the postal letter code would require the developer to test and redeploy the entire service, including SMS and email functionality. Depending on the deployment environment, this also might mean SMS and email functionality would not be available when the postal letter changes are deployed. Thus, as a single service, testing scope is increased and deployment risk is high. However, by breaking this service into two separate services (Electronic Notification and Postal Letter Notification), as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-volatility">Figure 7-4</a>, frequent changes are now isolated into a single, smaller service. This in turn means that the testing scope is significantly reduced, deployment risk is lower, and SMS and email functionality is not disrupted during a deployment of postal letter changes.</p>
        
        <figure><div id="fig-modularity-vs-granularity-volatility" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0704.png" alt="Code volatility" width="600" height="422">
        <h6><span class="label">Figure 7-4. </span>An area of high code change in a service is a good candidate for 
        <span class="keep-together">disintegration</span></h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Scalability and Throughput"><div class="sect2" id="idm45978844378400">
        <h2>Scalability and Throughput</h2>
        
        <p>Another driver for breaking up a service into separate smaller ones is <em>scalability</em> and <em>throughput</em>.<a data-type="indexterm" data-primary="granularity" data-secondary="disintegrators of granularity" data-tertiary="scalability and throughput" id="idm45978844375984"></a><a data-type="indexterm" data-primary="scalability" data-secondary="granularity disintegration driver" id="idm45978844374720"></a> The scalability demands of different functions of a service can be objectively measured to qualify whether a service should be broken apart. Consider once again the Notification Service example, where a single service notifies customers through SMS, email, and printed postal letter. Measuring the scalability demands of this single service reveals the following information:</p>
        
        <ul>
        <li>
        <p>SMS notification: 220,000/minute</p>
        </li>
        <li>
        <p>Email notification: 500/minute</p>
        </li>
        <li>
        <p>Postal letter notification: 1/minute</p>
        </li>
        </ul>
        
        <p>Notice the extreme variation between sending out SMS notifications and postal letter notifications. As a single service, email and postal letter functionality must unnecessarily scale to meet the demands of SMS notifications, impacting cost and also elasticity in terms of mean time to startup (MTTS). Breaking the Notification Service into three separate services (SMS, Email, and Letter), as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-scalability">Figure 7-5</a>, allows each of these services to scale independently to meet their varying demands of throughput.</p>
        
        <figure><div id="fig-modularity-vs-granularity-scalability" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0705.png" alt="Scalability and Throughput" width="600" height="495">
        <h6><span class="label">Figure 7-5. </span>Differing scalability and throughput needs is a good disintegration driver</h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Fault Tolerance"><div class="sect2" id="idm45978844366576">
        <h2>Fault Tolerance</h2>
        
        <p><em>Fault tolerance</em> describes the ability of an application or functionality<a data-type="indexterm" data-primary="fault tolerance" data-secondary="definition" id="idm45978844364624"></a><a data-type="indexterm" data-primary="fault tolerance" data-secondary="granularity disintegration driver" id="idm45978844363568"></a><a data-type="indexterm" data-primary="granularity" data-secondary="disintegrators of granularity" data-tertiary="fault tolerance" id="idm45978844362656"></a> within a particular domain to continue to operate, even though a fatal crash occurs (such as an out-of-memory condition). Fault Tolerance is another good driver for granularity disintegration.</p>
        
        <p>Consider the same consolidated Notification Service example that notifies customers through SMS, email, and postal letter (<a data-type="xref" href="#fig-modularity-vs-granularity-ft">Figure 7-6</a>). If the email functionality continues to have problems with out-of-memory conditions and fatally crashes, the entire service comes down, including SMS and postal letter processing.</p>
        
        <p>Separating this single consolidated Notification Service into three separate services provides a level of fault tolerance for the domain of customer notification. Now, a fatal error in the functionality of the email service doesn’t impact SMS or postal 
        <span class="keep-together">letters</span>.</p>
        
        <p>Notice in this example that the Notification Service is split into three separate services (SMS, Email, and Postal Letter), even though email functionality is the only issue with regard to frequent crashes (the other two are very stable). Since email functionality is the only issue, why not combine the SMS and postal letter functionality into a single service?</p>
        
        <p>Consider the code volatility example from the prior section. In this case Postal Letter changes constantly, whereas the other two (SMS and Email) do not. Splitting this 
        <span class="keep-together">service</span> into only two services made sense because Postal Letter was the offending functionality, but Email and SMS are <em>related</em>—they both have to do with <em>electronically</em> notifying the customer. Now consider the fault-tolerance example. What do SMS notification and Postal Letter notification have in common other than a notification means to the customer? What would be an appropriate self-descriptive name of that combined service?</p>
        
        <figure><div id="fig-modularity-vs-granularity-ft" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0706.png" alt="Fault Tolerance" width="600" height="495">
        <h6><span class="label">Figure 7-6. </span>Fault tolerance and service availability are good disintegration drivers</h6>
        </div></figure>
        
        <p>Moving the email functionality to a separate service disrupts the overall <em>domain cohesion</em> <a data-type="indexterm" data-primary="cohesion" data-secondary="service granularity" id="idm45978844351968"></a><a data-type="indexterm" data-primary="domain services" data-secondary="domain cohesion and granularity" id="idm45978844350960"></a>because the resulting cohesion between SMS and postal letter functionality is weak. Consider what the likely service names would be: Email Service and…Other Notification Service? Email Service and…SMS-Letter Notification Service? Email Service and…Non-Email Service? This naming problem relates back to the service scope and function granularity disintegrator—if a service is too hard to name because it’s doing multiple things, then consider breaking apart the service. The following disintegrations help in visualizing this important point:</p>
        
        <ul>
        <li>
        <p>Notification Service → Email Service, Other Notification Service (poor name)</p>
        </li>
        <li>
        <p>Notification Service → Email Service, Non-Email Service (poor name)</p>
        </li>
        <li>
        <p>Notification Service → Email Service, SMS-Letter Service (poor name)</p>
        </li>
        <li>
        <p>Notification Service → Email Service, SMS Service, Letter Service (good names)</p>
        </li>
        </ul>
        
        <p>In this example, only the last disintegration makes sense, particularly considering the addition of another social media notification—where would that go? Whenever breaking apart a service, regardless of the disintegration driver, always check to see if strong cohesion can be formed with the “leftover” functionality.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Security"><div class="sect2" id="idm45978844344976">
        <h2>Security</h2>
        
        <p>A common pitfall when securing sensitive data is to think only in<a data-type="indexterm" data-primary="security" data-secondary="granularity disintegration driver" id="idm45978844343248"></a><a data-type="indexterm" data-primary="granularity" data-secondary="disintegrators of granularity" data-tertiary="security" id="idm45978844342224"></a><a data-type="indexterm" data-primary="data" data-secondary="security" data-tertiary="granularity driver" id="idm45978844340992"></a><a data-type="indexterm" data-primary="PCI (Payment Card Industry) data" data-secondary="security and granularity" id="idm45978844339776"></a><a data-type="indexterm" data-primary="credit card data" data-see="PCI (Payment Card Industry) data" id="idm45978844338800"></a><a data-type="indexterm" data-primary="data" data-secondary="security" data-tertiary="credit card data" id="idm45978844337840"></a> terms of the storage of that data. For example, securing PCI (<a href="https://oreil.ly/Z5QRV">Payment Card Industry</a>) data from non-PCI data might be addressed through separate schemas or databases residing in different secure regions. What is sometimes missing from this practice, however, is also securing <em>how</em> that data is accessed.</p>
        
        <p>Consider the example illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-sec">Figure 7-7</a> that describes a Customer Profile Service containing two main functions: customer profile maintenance for adding, changing, or deleting basic profile information (name, address, and so on); and customer credit card maintenance for adding, removing, and updating credit card information.</p>
        
        <figure><div id="fig-modularity-vs-granularity-sec" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0707.png" alt="Security" width="600" height="413">
        <h6><span class="label">Figure 7-7. </span>Security and data access are good disintegration drivers</h6>
        </div></figure>
        
        <p>While the credit card <em>data</em> may be protected, <em>access</em> to that data is at risk because the credit card functionality is joined together with the basic customer profile functionality. Although the API entry points into the consolidated customer profile service may differ, nevertheless there is risk that someone entering into the service to retrieve the customer name might also have access to credit card functionality. By breaking this service into two separate services, access to the <em>functionality</em> used to maintain credit card information can be made more secure because the set of credit card operations is going into only a single-purpose service.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Extensibility"><div class="sect2" id="idm45978844329856">
        <h2>Extensibility</h2>
        
        <p>Another primary driver for granularity disintegration<a data-type="indexterm" data-primary="granularity" data-secondary="disintegrators of granularity" data-tertiary="extensibility" id="idm45978844328352"></a><a data-type="indexterm" data-primary="extensibility as granularity driver" id="idm45978844327088"></a><a data-type="indexterm" data-primary="services" data-secondary="extensibility" id="idm45978844326400"></a> is <em>extensibility</em>—the ability to add additional functionality as the service context grows. Consider a payment service that manages payments and refunds through multiple payment methods, including credit cards, gift cards, and PayPal transactions. Suppose the company wants to start supporting other managed payment methods, such as reward points, store credit from returns; and other third-party payment services, such as ApplePay, SamsungPay, and so on. How easy is it to extend the payment service to add these additional payment methods?</p>
        
        <p>These additional payment methods could certainly be added to a single consolidated payment service. However, every time a new payment method is added, the entire payment service would need to be tested (including other payment types), and the functionality for all other payment methods unnecessarily redeployed into production. Thus, with the single consolidated payment service, the testing scope is increased and deployment risk is higher, making it more difficult to add additional payment types.</p>
        
        <p>Now consider breaking up the existing consolidated service into three separate services (Credit Card Processing, Gift Card Processing, and PayPal Transaction Processing), as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-extensibility">Figure 7-8</a>.</p>
        
        <p>Now that the single payment service is broken into separate services by payment methods, adding another payment method (such as reward points) is only a matter of developing, testing, and deploying a single service separate from the others. As a result, development is faster, testing scope is reduced, and deployment risk is lower.</p>
        
        <p>Our advice is to apply this driver only if it is known ahead of time that additional consolidated contextual functionality is planned, desired, or part of the normal domain. For example, with notification, it is doubtful the means of notification would continually expand beyond the basic notification means (SMS, email, or letter). However, with payment processing, it is highly likely that additional payment types would be added in the future, and therefore separate services for each payment type would be warranted. Since it is often difficult to sometimes “guess” whether (and when) contextual functionality might expand (such as additional payment methods), our advice is to wait on this driver as a primary means of justifying a granularly disintegration until a pattern can be established or confirmation of continued extensibility can be confirmed.</p>
        
        <figure><div id="fig-modularity-vs-granularity-extensibility" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0708.png" alt="Extensibility" width="600" height="636">
        <h6><span class="label">Figure 7-8. </span>Planned extensibility is a good disintegration driver</h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Granularity Integrators"><div class="sect1" id="sec-granularity-integrators">
        <h1>Granularity Integrators</h1>
        
        <p>Whereas granularity disintegrators provide guidance and<a data-type="indexterm" data-primary="granularity" data-secondary="integrators of granularity" data-tertiary="about" id="idm45978844318576"></a> justification for when to break a service into smaller pieces, granularity integrators work in the opposite way—they provide guidance and justification for putting services back together (or not breaking apart a service in the first place). Analyzing the trade-offs between disintegration drivers and integration drivers is the secret to getting service granularity right. The four main drivers for granularity integration are as follows:</p>
        <dl>
        <dt>Database transactions</dt>
        <dd>
        <p>Is an ACID transaction required between separate services?</p>
        </dd>
        <dt>Workflow and choreography</dt>
        <dd>
        <p>Do services need to talk to one another?</p>
        </dd>
        <dt>Shared code</dt>
        <dd>
        <p>Do services need to share code among one another?</p>
        </dd>
        <dt>Database relationships</dt>
        <dd>
        <p>Although a service can be broken apart, can the data it uses be broken apart as well?</p>
        </dd>
        </dl>
        
        <p>The following sections detail each of these granularity integration drivers.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Database Transactions"><div class="sect2" id="idm45978844310736">
        <h2>Database Transactions</h2>
        
        <p>Most monolithic systems and course-grained domain services using<a data-type="indexterm" data-primary="granularity" data-secondary="integrators of granularity" data-tertiary="database transactions" id="idm45978844308880"></a><a data-type="indexterm" data-primary="database transactions and granularity" id="idm45978844307584"></a><a data-type="indexterm" data-primary="transactions" data-secondary="database transactions and granularity" id="idm45978844306944"></a><a data-type="indexterm" data-primary="relational databases (RDBMS)" data-secondary="transactions and service granularity" id="idm45978844305984"></a> relational databases rely on single-unit-of-work database transactions to maintain data integrity and consistency; see <a data-type="xref" href="ch09.html#sec-acid-vs-base">“Distributed Transactions”</a> for the details of ACID (database) transactions and how they differ from BASE (distributed) transactions. To understand how database transactions impact service granularity, consider the situation illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-transactions-atomic">Figure 7-9</a> where customer functionality has been split into a Customer Profile Service that maintains customer profile information and a Password Service that maintains password and other security-related information and 
        <span class="keep-together">functionality</span>.</p>
        
        <p>Notice that having two separate services provides a good level of security access control to password information since access is at a service level rather than at a request level. Access to operations such as changing a password, resetting a password, and accessing a customer’s password for sign-in can all be restricted to a single service (and hence the access can be restricted to that single service). However, while this may be a good disintegration driver, consider the operation of registering a new customer, as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-transactions-no-acid">Figure 7-10</a>.</p>
        
        <figure><div id="fig-modularity-vs-granularity-transactions-atomic" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0709.png" alt="Atomic operations" width="600" height="475">
        <h6><span class="label">Figure 7-9. </span>Separate services with atomic operations have better security access control</h6>
        </div></figure>
        
        <figure><div id="fig-modularity-vs-granularity-transactions-no-acid" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0710.png" alt="No ACID Transaction" width="600" height="519">
        <h6><span class="label">Figure 7-10. </span>Separate services with combined operations do not support database (ACID) transactions</h6>
        </div></figure>
        
        <p>When registering a new customer, both profile and encrypted password information is passed into the Profile Service from a user interface screen. The Profile Service inserts the profile information into its corresponding database table, commits that work, and then passes the encrypted password information to the Password Service, which in turn inserts the password information into its corresponding database table and commits its own work.</p>
        
        <p>While separating the services provides better security access control to the password information, the trade-off is that there is no ACID transaction for actions such as registering a new customer or unsubscribing (deleting) a customer from the system. If the password service fails during either of these operations, data is left in an inconsistent state, resulting in complex error handling (which is also error prone) to reverse the original profile insert or take other corrective action (see <a data-type="xref" href="ch12.html#sec-transactional-sagas">“Transactional Saga Patterns”</a> for the details of eventual consistency and error handling within distributed transactions). Thus, if having a single-unit-of-work ACID transaction is required from a business perspective, these services should be consolidated into a single service, as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-transactions-acid">Figure 7-11</a>.</p>
        
        <figure><div id="fig-modularity-vs-granularity-transactions-acid" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0711.png" alt="ACID Transaction" width="600" height="751">
        <h6><span class="label">Figure 7-11. </span>A single service supports database (ACID) transactions</h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Workflow and Choreography"><div class="sect2" id="idm45978844291584">
        <h2>Workflow and Choreography</h2>
        
        <p>Another common granularity integrator is <em>workflow</em> and<a data-type="indexterm" data-primary="granularity" data-secondary="integrators of granularity" data-tertiary="workflow and choreography" id="ch07-granw"></a><a data-type="indexterm" data-primary="workflow and service granularity" data-seealso="distributed workflows" id="ch07-granw2"></a><a data-type="indexterm" data-primary="choreographed coordination" data-secondary="service granularity and" id="ch07-granw3"></a><a data-type="indexterm" data-primary="communication" data-secondary="interservice communication" id="ch07-granw4"></a><a data-type="indexterm" data-primary="interservice communication" id="ch07-granw6"></a><a data-type="indexterm" data-primary="communication" data-secondary="east-west communication" id="ch07-granw5"></a><a data-type="indexterm" data-primary="east-west communication" id="ch07-granw7"></a><a data-type="indexterm" data-primary="synchronous communication" data-secondary="granularity and" id="ch07-granw8"></a><a data-type="indexterm" data-primary="fault tolerance" data-secondary="granularity integration driver" id="ch07-granw9"></a><a data-type="indexterm" data-primary="distributed workflows" data-secondary="service granularity and workflow" id="ch07-granwa"></a> <em>choreography</em>--services talking to one another (also sometimes referred to as <em>interservice</em> communication or <em>east-west</em> communications). Communication between services is fairly common and in many cases necessary in highly distributed architectures like microservices. However, as services move toward a finer level of granularity based on the disintegration factors outlined in the previous section, service communication can increase to a point where negative impacts start to occur.</p>
        
        <p>Issues with overall fault tolerance is the first impact of too much synchronous inter-service communication. Consider the diagram in <a data-type="xref" href="#fig-modularity-vs-granularity-workflow-ft">Figure 7-12</a>: Service A communicates with services B and C, Service B communicates with Service C, Service D communicates with Service E, and finally Service E communicates with Service C. In this case, if Service C goes down, all other services become nonoperational because of a transitive dependency with Service C, creating an issue with overall fault tolerance, availability, and reliability.</p>
        
        <figure><div id="fig-modularity-vs-granularity-workflow-ft" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0712.png" alt="Workflow Fault Tolerance" width="600" height="306">
        <h6><span class="label">Figure 7-12. </span>Too much workflow impacts fault tolerance</h6>
        </div></figure>
        
        <p>Interestingly enough, fault tolerance is one of the granularity disintegration drivers from the previous section—yet when those services need to talk to one another, nothing is really gained from a fault-tolerance perspective. When breaking apart services, always check to see if the functionalities are tightly coupled and dependent on one another. If it is, then overall fault tolerance from a business request standpoint won’t be achieved, and it might be best to consider keeping the services together.</p>
        
        <p>Overall performance and responsiveness is another driver for granularity integration (putting services back together). Consider the scenario in <a data-type="xref" href="#fig-modularity-vs-granularity-workflow-perf">Figure 7-13</a>: a large customer service is split into five separate services (services A through E). While each of these services has its own collection of cohesive atomic requests, retrieving all of the customer information collectively from a single API request into a single user interface screen involves five separate hops when using choreography (see <a data-type="xref" href="ch11.html#ch11-managing-workflows">Chapter&nbsp;11</a> for an alternative solution to this problem using orchestration). Assuming 300 ms in network and security latency per request, this single request would incur an additional 1500 ms just in latency alone! Consolidating all of these services into a single service would remove the latency, therefore increasing overall performance and 
        <span class="keep-together">responsiveness</span>.</p>
        
        <figure><div id="fig-modularity-vs-granularity-workflow-perf" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0713.png" alt="Workflow Performance" width="600" height="344">
        <h6><span class="label">Figure 7-13. </span>Too much workflow impacts overall performance and responsiveness</h6>
        </div></figure>
        
        <p>In terms of overall performance, the trade-off for this integration driver is balancing the need to break apart a service with the corresponding performance loss if those services need to communicate with one another. A good rule of thumb is to take into consideration the number of requests that require multiple services to communicate with one another, also taking into account the criticality of those requests requiring interservice communication. For example, if 30% of the requests require a workflow between services to complete the request and 70% are purely atomic (dedicated to only one service without the need for any additional communication), then it might be OK to keep the services separate. However, if the percentages are reversed, then consider putting them back together again. This assumes, of course, that overall performance matters. There’s more leeway in the case of backend functionality where an end user isn’t waiting for the request to complete.</p>
        
        <p>The other performance consideration is with regard to the criticality of the request requiring workflow. Consider the previous example, where 30% of the requests require a workflow between services to complete the request, and 70% are purely atomic. If a critical request that requires extremely fast response time is part of that 30%, then it might be wise to put the services back together, even though 70% of the requests are purely atomic.</p>
        
        <p>Overall reliability and data integrity are also impacted with increased service communication. Consider the example in <a data-type="xref" href="#fig-modularity-vs-granularity-workflow-reliability">Figure 7-14</a>: customer information is separated into five separate customer services. In this case, adding a new customer to the system involves the coordination of all five customer services. However, as explained in a previous section, each of these services has its own database transaction. Notice in <a data-type="xref" href="#fig-modularity-vs-granularity-workflow-reliability">Figure 7-14</a> that services <code>A</code>, <code>B</code>, and <code>C</code> have all committed part of the customer data, but Service D fails.</p>
        
        <figure><div id="fig-modularity-vs-granularity-workflow-reliability" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0714.png" alt="Workflow Reliability" width="600" height="323">
        <h6><span class="label">Figure 7-14. </span>Too much workflow impacts reliability and data integrity</h6>
        </div></figure>
        
        <p>This creates a data consistency and data integrity issue because part of the customer data has already been committed, and may have already been acted upon through a retrieval of that information from another process or even a message sent out from one of those services broadcasting an action based on that data. In either case, that data would either have to be rolled back through compensating transactions or marked with a specific state to know where the transaction left off in order to restart it. This is very messy situation, one we describe in detail in <a data-type="xref" href="ch12.html#sec-transactional-sagas">“Transactional Saga Patterns”</a>. If data integrity and data consistency are important or critical to an operation, it might be wise to consider putting those services back together.<a data-type="indexterm" data-startref="ch07-granw" id="idm45978844257584"></a><a data-type="indexterm" data-startref="ch07-granw2" id="idm45978844256912"></a><a data-type="indexterm" data-startref="ch07-granw3" id="idm45978844256240"></a><a data-type="indexterm" data-startref="ch07-granw4" id="idm45978844255568"></a><a data-type="indexterm" data-startref="ch07-granw5" id="idm45978844254896"></a><a data-type="indexterm" data-startref="ch07-granw6" id="idm45978844254224"></a><a data-type="indexterm" data-startref="ch07-granw7" id="idm45978844253552"></a><a data-type="indexterm" data-startref="ch07-granw8" id="idm45978844252880"></a><a data-type="indexterm" data-startref="ch07-granw9" id="idm45978844252208"></a><a data-type="indexterm" data-startref="ch07-granwa" id="idm45978844251536"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Shared Code"><div class="sect2" id="idm45978844290992">
        <h2>Shared Code</h2>
        
        <p>Shared source code is a common (and necessary) practice in<a data-type="indexterm" data-primary="granularity" data-secondary="integrators of granularity" data-tertiary="shared code" id="ch07-intg"></a><a data-type="indexterm" data-primary="shared code and granularity" data-seealso="code reuse patterns" id="ch07-intg2"></a><a data-type="indexterm" data-primary="code reuse patterns" data-secondary="granularity and shared code" id="ch07-intg3"></a> software development. Functions like logging, security, utilities, formatters, converters, extractors, and so on are all good examples of shared code. However, things can get complicated when dealing with shared code in a distributed architecture and can sometimes influence service granularity.</p>
        
        <p>Shared code is often contained in a shared library, such as a JAR file in the Java Ecosystem, a GEM in the Ruby environment, or a DLL in the .NET environment, and is typically bound to a service at compile time. While we dive into code reuse patterns in detail in <a data-type="xref" href="ch08.html#ch08-reuse-patterns">Chapter&nbsp;8</a>, here we illustrate only how shared code can sometimes 
        <span class="keep-together">influence</span> service granularity and can become a granularity integrator (putting services back together).</p>
        
        <p>Consider the set of five services shown in <a data-type="xref" href="#fig-modularity-vs-granularity-commoncode">Figure 7-15</a>. While there may have been a good disintegrator driver for breaking apart these services, they all share a common codebase of domain functionality (as opposed to common utilities or infrastructure functionality). If a change occurs in the shared library, <a data-type="indexterm" data-primary="version control systems" data-secondary="shared code libraries" data-tertiary="granularity and" id="idm45978844241232"></a>this would eventually necessitate a change in the corresponding services using that shared library. We say <em>eventually</em> because versioning can sometimes be used with shared libraries to provide agility and backward compatibility (see <a data-type="xref" href="ch08.html#ch08-reuse-patterns">Chapter&nbsp;8</a>). As such, all of these separately deployed services would have to be changed, tested, and deployed together. In these cases, it might be wise to consolidate these five services into a single service to avoid multiple deployments, as well as having the service functionality be out of sync based on the use of different versions of a library.</p>
        
        <figure><div id="fig-modularity-vs-granularity-commoncode" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0715.png" alt="Common Code" width="600" height="290">
        <h6><span class="label">Figure 7-15. </span>A change in shared code requires a coordinated change to all services</h6>
        </div></figure>
        
        <p>Not all uses of shared code drive granularity integration. For example, infrastructure-related cross-cutting functionality such as logging, auditing, authentication, authorization, and monitoring that all services use is <em>not</em> a good driver for putting services back together or even moving back to a monolithic architecture. Some of the guidelines for considering shared code as a granularity integrator are as follows:</p>
        <dl>
        <dt>Specific shared domain functionality</dt>
        <dd>
        <p>Shared domain functionality is shared code that contains business logic<a data-type="indexterm" data-primary="domain partitioned architecture" data-secondary="granularity and shared domain functionality" id="idm45978844233280"></a><a data-type="indexterm" data-primary="shared domain functionality" data-secondary="granularity and" id="idm45978844232176"></a> (as opposed to infrastructure-related cross-cutting functionality). Our recommendation is to consider this factor as a possible granularity integrator if the percentage of shared domain code is relatively high. For example, suppose the common (shared) code for a group of customer-related functionality (profile maintenance, preference maintenance, and adding or removing comments) makes up over 40% of the collective codebase. Breaking up the collective functionality into separate services would mean that almost half of the source code is in a shared library used only by those three services. In this example it might be wise to consider keeping the collective customer-related functionality in a single consolidated service along with the shared code (particularly if the shared code changes frequently, as discussed next).</p>
        </dd>
        <dt>Frequent shared code changes</dt>
        <dd>
        <p>Regardless of the size of the shared library, frequent changes to shared functionality require frequent coordinated changes to the services using that shared domain functionality. <a data-type="indexterm" data-primary="version control systems" data-secondary="shared code libraries" data-tertiary="granularity and" id="idm45978844229648"></a>While versioning can sometimes be used to help mitigate coordinated changes, eventually services using that shared functionality will need to adopt the latest version. If the shared code changes frequently, it might be wise to consider consolidating the services using that shared code to help mitigate the complex change coordination of multiple deployment units.</p>
        </dd>
        <dt>Defects that cannot be versioned</dt>
        <dd>
        <p>While versioning can help mitigate coordinated changes and allow for backward compatibility and agility (the ability to respond quickly to change), at times certain business functionality must be applied to all services at the same time (such as a defect or a change in business rules). If this happens frequently, it might be time to consider putting services back together to simplify the changes.<a data-type="indexterm" data-startref="ch07-intg" id="idm45978844226592"></a><a data-type="indexterm" data-startref="ch07-intg2" id="idm45978844225888"></a><a data-type="indexterm" data-startref="ch07-intg3" id="idm45978844225216"></a></p>
        </dd>
        </dl>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Data Relationships"><div class="sect2" id="idm45978844224288">
        <h2>Data Relationships</h2>
        
        <p>Another trade-off in the balance between granularity disintegrators and integrators<a data-type="indexterm" data-primary="granularity" data-secondary="integrators of granularity" data-tertiary="data relationships" id="ch07-drgr"></a><a data-type="indexterm" data-primary="data" data-secondary="granularity and data relationships" id="ch07-drgr2"></a> is the relationship between the data that a single consolidated service uses as opposed to the data that separate services would use. This integrator driver assumes that the data resulting from breaking apart a service is not shared, but rather formed into tight bounded contexts within each service to facilitate change control and support overall availability and reliability.</p>
        
        <p>Consider the example in <a data-type="xref" href="#fig-modularity-vs-granularity-db-consolidated">Figure 7-16</a>: a single consolidated service has three functions (A, B, and C) and corresponding data table relationships. The solid lines pointing to the tables represent writes to the tables (hence data ownership), and the dotted lines pointing away from the tables represent read-only access to the table. Performing a mapping operation between the functions and the tables reveals the results shown in <a data-type="xref" href="#table-data-associations">Table&nbsp;7-1</a>, where <em>owner</em> implies writes (and corresponding reads) and <em>access</em> implies read-only access to a table not owned by that function.</p>
        
        <figure><div id="fig-modularity-vs-granularity-db-consolidated" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0716.png" alt="Database Relationships Consolidated" width="600" height="447">
        <h6><span class="label">Figure 7-16. </span>The database table relationships of a consolidated service</h6>
        </div></figure>
        <table id="table-data-associations">
        <caption><span class="label">Table 7-1. </span>Function-to-table mapping</caption>
        <thead>
        <tr>
        <th>Function</th>
        <th>Table 1</th>
        <th>Table 2</th>
        <th>Table 3</th>
        <th>Table 4</th>
        <th>Table 5</th>
        <th>Table 6</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>A</p></td>
        <td><p>owner</p></td>
        <td><p>owner</p></td>
        <td></td>
        <td><p>owner</p></td>
        <td></td>
        <td><p>owner</p></td>
        </tr>
        <tr>
        <td><p>B</p></td>
        <td></td>
        <td></td>
        <td><p>owner</p></td>
        <td></td>
        <td><p>access</p></td>
        <td></td>
        </tr>
        <tr>
        <td><p>C</p></td>
        <td></td>
        <td></td>
        <td><p>access</p></td>
        <td></td>
        <td><p>owner</p></td>
        <td></td>
        </tr>
        </tbody>
        </table>
        
        <p>Assume that based on some of the disintegration drivers outlined in the prior section,<a data-type="indexterm" data-primary="bounded context in microservices" data-secondary="granularity and" id="idm45978844197056"></a><a data-type="indexterm" data-primary="microservices" data-secondary="bounded context" data-tertiary="granularity and" id="idm45978844196112"></a> this service was broken into three separate services (one for each of the functions in the consolidated service); see <a data-type="xref" href="#fig-modularity-vs-granularity-db-separated">Figure 7-17</a>. However, breaking apart the single consolidated service into three separate services now requires the corresponding data tables to be associated with each service in a bounded context.</p>
        
        <p>Notice at the top of  <a data-type="xref" href="#fig-modularity-vs-granularity-db-separated">Figure 7-17</a> that Service A owns tables 1, 2, 4, and 6 as part of its bounded context; Service B owns table 3; and Service C owns table 5. However, notice in the diagram that every operation in Service B requires access to data in table 5 (owned by Service C), and every operation in Service C requires access to data in table 3 (owned by Service B). Because of the bounded context, Service B cannot simply reach out and directly query table 5, nor can Service C directly query table 3.</p>
        
        <p>To better understand the bounded context and why Service C cannot simply access table 3, <a data-type="indexterm" data-primary="interservice communication" data-secondary="bounded context data" id="idm45978844191792"></a><a data-type="indexterm" data-primary="communication" data-secondary="interservice communication" data-tertiary="bounded context data" id="idm45978844190848"></a>say Service B (which owns table 3) decides to make a change to its business rules that requires a column to be removed from table 3. Doing so would break Service C and any other services using table 3. This is why the bounded context concept is so important in highly distributed architectures like microservices. To resolve this issue, Service B would have to <em>ask</em> Service C for its data, and Service C would have to ask Service B for its data, resulting in back-and-forth interservice communication between these services, as illustrated at the bottom of <a data-type="xref" href="#fig-modularity-vs-granularity-db-separated">Figure 7-17</a>.</p>
        
        <figure><div id="fig-modularity-vs-granularity-db-separated" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0717.png" alt="Database Relationships Separated" width="600" height="576">
        <h6><span class="label">Figure 7-17. </span>Database table relationships impact service granularity</h6>
        </div></figure>
        
        <p>Based on the dependency of the data between services B and C, it would be wise to consolidate those services into a single service to avoid the latency, fault tolerance, and scalability issues associated with the interservice communication between these services, demonstrating that relationships between tables can influence service granularity. We’ve saved this granularity integration driver for last because it is the one granularity integration driver with the fewest number of trade-offs. While occasionally a migration from a monolithic system requires a refactoring of the way data is organized, in most cases it isn’t feasible to reorganize database table entity relationships for the sake of breaking apart a service. We dive into the details about breaking apart data in <a data-type="xref" href="ch06.html#ch06-decomposing-operational-data">Chapter&nbsp;6</a>.<a data-type="indexterm" data-startref="ch07-drgr" id="idm45978844184512"></a><a data-type="indexterm" data-startref="ch07-drgr2" id="idm45978844183808"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Finding the Right Balance"><div class="sect1" id="idm45978844223696">
        <h1>Finding the Right Balance</h1>
        
        <p>Finding the right level of service granularity is hard. The secret to getting granularity<a data-type="indexterm" data-primary="granularity" data-secondary="balancing trade-offs" id="idm45978844181216"></a><a data-type="indexterm" data-primary="trade-off analysis" data-secondary="granularity" id="idm45978844180240"></a> right is understanding both granularity disintegrators (when to break apart a service) and granularity integrators (when to put them back together), and analyze the corresponding trade-offs between the two. As illustrated in the previous scenarios, this requires an architect to not only identify the trade-offs, but also to collaborate closely with business stakeholders to analyze those trade-offs and arrive at the appropriate solution for service granularity.</p>
        
        <p>Tables <a href="#table-disintegrators">7-2</a> and <a href="#table-integrators">7-3</a> summarize the drivers for disintegrators and integrators.</p>
        <table id="table-disintegrators">
        <caption><span class="label">Table 7-2. </span>Disintegrator drivers (breaking apart a service)</caption>
        <thead>
        <tr>
        <th>Disintegrator driver</th>
        <th>Reason for applying driver</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Service scope</p></td>
        <td><p>Single-purpose services with tight cohesion</p></td>
        </tr>
        <tr>
        <td><p>Code volatility</p></td>
        <td><p>Agility (reduced testing scope and deployment risk)</p></td>
        </tr>
        <tr>
        <td><p>Scalability</p></td>
        <td><p>Lower costs and faster responsiveness</p></td>
        </tr>
        <tr>
        <td><p>Fault tolerance</p></td>
        <td><p>Better overall uptime</p></td>
        </tr>
        <tr>
        <td><p>Security access</p></td>
        <td><p>Better security access control to certain functions</p></td>
        </tr>
        <tr>
        <td><p>Extensibility</p></td>
        <td><p>Agility (ease of adding new functionality)</p></td>
        </tr>
        </tbody>
        </table>
        <table id="table-integrators">
        <caption><span class="label">Table 7-3. </span>Integrator drivers (putting services back together)</caption>
        <thead>
        <tr>
        <th>Integrator driver</th>
        <th>Reason for applying driver</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Database transactions</p></td>
        <td><p>Data integrity and consistency</p></td>
        </tr>
        <tr>
        <td><p>Workflow</p></td>
        <td><p>Fault tolerance, performance, and reliability</p></td>
        </tr>
        <tr>
        <td><p>Shared code</p></td>
        <td><p>Maintainability</p></td>
        </tr>
        <tr>
        <td><p>Data relationships</p></td>
        <td><p>Data integrity and correctness</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Architects can use the drivers in these tables to form trade-off statements that can then be discussed and resolved by collaborating with a product owner or business sponsor.</p>
        
        <p>Example 1:</p>
        <blockquote>
        <p><strong>Architect</strong>: “We want to break apart our service to isolate frequent code changes, but in doing so we won’t be able to maintain a database transaction. Which is more important based on our business needs—better <em>overall agility</em> (maintainability, testability, and deployability), which translates to faster time-to-market, or stronger <em>data integrity and consistency</em>?”<br></p>
        
        <p><strong>Project Sponsor</strong>: “Based on our business needs, I’d rather sacrifice a little bit slower time-to-market to have better data integrity and consistency, so let’s leave it as a single service for right now.”</p></blockquote>
        
        <p>Example 2:</p>
        <blockquote>
        <p><strong>Architect</strong>: “We need to keep the service together to support a database transaction between two operations to ensure data consistency, but that means sensitive functionality in the combined single service will be less secure. Which is more important based on our business needs—better <em>data consistency</em> or better <em>security</em>?”<br></p>
        
        <p><strong>Project Sponsor</strong>: “Our CIO has been through some rough situations with regard to security and protecting sensitive data, and it’s on the forefront of their mind and part of almost every discussion. In this case, it’s more important to secure sensitive data, so let’s keep the services separate and work out how we can mitigate some of the issues with data consistency.”</p></blockquote>
        
        <p>Example 3:</p>
        <blockquote>
        <p><strong>Architect</strong>: “We need to break apart our payment service to provide better extensibility for adding new payment methods, but that means we will have increased workflow that will impact the responsiveness when multiple payment types are used for an order (which happens frequently). Which is more important based on our business needs—better extensibility within the payment processing, hence better <em>agility and overall time-to-market</em>, or better <em>responsiveness</em> for making a payment?”<br></p>
        
        <p><strong>Project Sponsor</strong>: “Given that I see us adding only two, maybe three more payment types over the next couple of years, I’d rather have us focus on the overall responsiveness since the customer must wait for payment processing to be complete before the order ID is issued.”</p></blockquote>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Sysops Squad Saga: Ticket Assignment Granularity"><div class="sect1" id="idm45978844182544">
        <h1>Sysops Squad Saga: Ticket Assignment Granularity</h1>
        
        <p><code>Monday, October 25 11:08</code></p>
        <div class="story">
        
        <p>Once a trouble ticket has been created by a customer and accepted by the system,<a data-type="indexterm" data-primary="granularity" data-secondary="Sysops Squad saga" id="ch07-ssotg"></a><a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="granularity" id="ch07-ssotg2"></a> it must be assigned to a Sysops Squad expert based on their skill set, location, and availability. Ticket assignment involves two main components—a Ticket Assignment component that determines which consultant should be assigned the job, and the Ticket Routing component that locates the Sysops Squad expert, forwards the ticket to the expert’s mobile device (via a custom Sysops Squad mobile app), and notifies the expert via an SMS text message that a new ticket has been assigned.</p>
        
        <p>The Sysops Squad development team was having trouble deciding whether these two components (assignment and routing) should be implemented as a single consolidated service or two separate services, as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-ticket-assign-options">Figure 7-18</a>. The development team consulted with Addison (one of the Sysops Squad architects) to help decide which option it should go with.</p>
        
        <figure><div id="fig-modularity-vs-granularity-ticket-assign-options" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0718.png" alt="Ticket Assignment Options" width="600" height="620">
        <h6><span class="label">Figure 7-18. </span>Options for ticket assignment and routing</h6>
        </div></figure>
        
        <p>“So you see,” said Taylen, “the ticket assignment algorithms are very complex, and therefore should be isolated from the ticket routing functionality. That way, when those algorithms change, I don’t have to worry about all of the routing functionality.”</p>
        
        <p>“Yes, but how much change is there to those assignment algorithms?” asked Addison. “And how much change do we anticipate in the future?”</p>
        
        <p>“I apply changes to those algorithms at least two to three times a month. I read about volatility-based decomposition, and this situation fits it perfectly,” said Taylen.</p>
        
        <p>“But if we separated the assignment and routing functionality into two services, there would need to be constant communication between them,” said Skyler. “Furthermore, assignment and routing are really one function, not two.”</p>
        
        <p>“No,” said Taylen, “they are two separate functions.”</p>
        
        <p>“Hold on,” said Addison. “I see what Skyler means. Think about it a minute. Once an expert is found that is available within a certain period of time, the ticket is immediately routed to that expert. If no expert is available, the ticket goes back in the queue and waits until an expert can be found.”</p>
        
        <p>“Yes, that’s right,” said Taylen.</p>
        
        <p>“See,” said Skyler, “you cannot make a ticket assignment without routing it to the expert. So the two functions are one.”</p>
        
        <p>“No, no, no,” said Taylen. “You don’t understand. If an expert is seen to be available within a certain amount of time, then that expert is assigned. Period. Routing is just a transport thing.”</p>
        
        <p>“What happens in the current functionality if a ticket can’t be routed to the expert?” asked Addison.</p>
        
        <p>“Then another expert is selected,” said Taylen.</p>
        
        <p>“OK, so think about it a minute, Taylen,” said Addison. “If assignment and routing are two separate services, then the routing service would have to then communicate back to the assignment service, letting it know that the expert cannot be located and to pick another one. That’s a lot of coordination between the two services.”</p>
        
        <p>“Yes, but they are still <em>two</em> separate functions, not one as Skyler is suggesting,” said Taylen.</p>
        
        <p>“I have an idea,” said Addison. “Can we all agree that the assignment and routing are two separate activities, but are tightly bound synchronously to each other? Meaning, one function cannot exist without the other?”</p>
        
        <p>“Yes,” both Taylen and Skyler replied.</p>
        
        <p>“In that case,” said Addison, “let’s analyze the trade-offs. Which is more important—isolating the assignment functionality for change control purposes, or combining assignment and routing into a single service for better performance, error handling, and workflow control?”</p>
        
        <p>“Well,” said Taylen, “when you put it that way, obviously the single service. But I still want to isolate the assignment code.”</p>
        
        <p>“OK,” said Addison, “in that case, how about we make three distinct architectural components in the single service. We can delineate assignment, routing, and shared code with separate namespaces in the code. Would that help?”</p>
        
        <p>“Yeah,” said Taylen, “that would work. OK, you both win. Let’s go with a single service then.”</p>
        
        <p>“Taylen,” said Addison, “it’s not about winning, it’s about analyzing the trade-offs to arrive at the most appropriate solution; that’s all.”</p>
        
        <p>With everyone agreeing to a single service for assignment and routing, Addison wrote the following architecture decision record (ADR) for this decision:</p>
        <blockquote>
        <p class="adr" id="adr_5"><em>ADR: Consolidated Service for Ticket Assignment and Routing</em><br></p>
        
        <p><em>Context</em><br>
        Once a ticket is created and accepted by the system, it must be assigned to an expert and then routed to that expert’s mobile device. This can be done through a single consolidated ticket assignment service or separate services for ticket assignment and ticket routing.<br></p>
        
        <p><em>Decision</em><br>
        We will create a single consolidated ticket assignment service for the assignment and routing functions of the ticket.<br></p>
        
        <p>Tickets are immediately routed to the Sysops Squad expert once they are assigned, so these two operations are tightly bound and dependent each other.<br></p>
        
        <p>Both functions must scale the same, so there are no throughput differences between these services, <a data-type="indexterm" data-primary="backpressure information link" id="idm45978844114736"></a>nor is <a href="https://oreil.ly/Vhjmv">back-pressure</a> needed between these 
        <span class="keep-together">functions</span>.<br></p>
        
        <p>Since both functions are fully dependent on each other, fault tolerance is not a driver for breaking these functions apart.<br></p>
        
        <p>Making these functions separate services would require workflow between them, resulting in performance, fault tolerance, and possible reliability issues.<br></p>
        
        <p><em>Consequences</em><br>
        Changes to the assignment algorithm (which occur on a regular basis) and changes to the routing mechanism (infrequent change) would require testing and deployment of both functions, resulting in increased testing scope and deployment risk.</p></blockquote>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Sysops Squad Saga: Customer Registration Granularity"><div class="sect1" id="idm45978844139696">
        <h1>Sysops Squad Saga: Customer Registration Granularity</h1>
        
        <p><code>Friday January 14, 13:15</code></p>
        <div class="story">
        
        <p>Customers must register with the system to gain access to the Sysops Squad support plan. <a data-type="indexterm" data-primary="PCI (Payment Card Industry) data" data-secondary="security and granularity" data-tertiary="Sysops Squad saga" id="ch07-ssotg3"></a><a data-type="indexterm" data-primary="security" data-secondary="PCI data Sysops Squad saga" id="ch07-ssotg4"></a><a data-type="indexterm" data-primary="transactionality" data-secondary="security versus" id="ch07-ssotg5"></a>During registration, customers must provide profile information (name, address, business name if applicable, and so on), credit card information (which is billed on a monthly basis), password and security question information, and a list of products purchased they would like to have covered under the Sysops Squad support plan.</p>
        
        <p>Some members of the development team insisted that this should be a single consolidated Customer Service containing all of the customer information, yet other members of the team disagreed and thought that there should be a separate service for each of these functions (a Profile service, Credit Card service, Password service, and a Supported Product service). Skyler, having prior experience in PCI and PII data, thought that the credit card and password information should be a separate service from the rest, and hence only two services (a Profile service containing profile and product information and a separate Customer Secure service containing credit card and password information). These three options are illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-registration-options">Figure 7-19</a>.</p>
        
        <figure><div id="fig-modularity-vs-granularity-registration-options" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0719.png" alt="Registration Options" width="600" height="686">
        <h6><span class="label">Figure 7-19. </span>Options for customer registration</h6>
        </div></figure>
        
        <p>Because Addison was busy with the core ticketing functionality, the development team asked for Austen’s help in resolving this granularity issue. Anticipating this will not be an easy decision, particularly since it involved security, Austen scheduled a meeting with Parker, (the product owner), and Sam, the Penultimate Electronics security expert to discuss these options.</p>
        
        <p>“OK, so what can we do for you?” asked Parker.</p>
        
        <p>“Well,” said Austen, “we are struggling with how many services to create for registering customers and maintaining customer-related information, You see, there are four main pieces of data we are dealing with here: profile info, credit card info, password info, and purchased product info.”</p>
        
        <p>“Whoa, hold on now,” interrupted Sam. “You know that credit card and password information <em>must</em> be secure, right?”</p>
        
        <p>“Of course we know it has to be secure,” said Austen. “What we’re struggling with is the fact that there’s a single customer registration API to the backend, so if we have separate services they all have to be coordinated together when registering a customer, which would require a distributed transaction.”</p>
        
        <p>“What do you mean by that?” asked Parker.</p>
        
        <p>“Well,” said Austen, “we wouldn’t be able to synchronize all of the data together as one atomic unit of work.”</p>
        
        <p>“That’s not an option,” said Parker. “All of the customer information is either saved in the database, or it’s not. Let me put it another way. We absolutely <em>cannot</em> have the situation where we have a customer record without a corresponding credit card or password record. <em>Ever</em>.”</p>
        
        <p>“OK, but what about securing the credit card and password information?” asked Sam. “Seems to me, having separate services would allow much better security control access to that type of sensitive information.”</p>
        
        <p>“I think I may have an idea.” said Austen. “The credit card information is tokenized in the database, right?”</p>
        
        <p>“Tokenized <em>and</em> encrypted,” said Sam.</p>
        
        <p>“Great. And the password information?” asked Austen.</p>
        
        <p>“The same,” said Sam.</p>
        
        <p>“OK,” said Austen, “so it seems to me that what we really need to focus on here is controlling access to the password and credit card information separate from the other customer-related requests—you know, like getting and updating profile information, and so on.”</p>
        
        <p>“I think I see where you are coming from with your problem,” said Parker. “You’re telling me that if you separate all of this functionality into separate services, you can better secure access to sensitive data, but you cannot guarantee my all-or-nothing requirement. Am I right?”</p>
        
        <p>“Exactly. That’s the trade-off,” said Austen.</p>
        
        <p>“Hold on,” said Sam. “Are you using the Tortoise security libraries to secure the API calls?”</p>
        
        <p>“Yes. We use those libraries not only at the API layer, but also within each service to control access through the service mesh. So essentially it’s a double-check,” said Austen.</p>
        
        <p>“Hmmm,” said Sam. “OK, I’m good with a single service providing you use the Tortoise security framework.”</p>
        
        <p>“Me too, providing we can still have the all-or-nothing customer registration process,” said Parker.</p>
        
        <p>“Then I think we are all in agreement that the all-or-nothing customer registration is an absolute requirement and we will maintain multilevel security access using Tortoise,” said Austen.</p>
        
        <p>“Agreed,” said Parker.</p>
        
        <p>“Agreed,” said Sam.</p>
        
        <p>Parker noticed how Austen handled the meeting by facilitating the conversation rather than controlling it. This was an important lesson as an architect in identifying, understanding, and negotiating trade-offs. <a data-type="indexterm" data-primary="design" data-secondary="architecture versus" data-tertiary="security controlled through design" id="idm45978844084192"></a><a data-type="indexterm" data-primary="architecture" data-secondary="design versus" data-tertiary="security controlled through design" id="idm45978844082880"></a>Parker also better understood the difference between design versus architecture in that security can be controlled through <em>design</em> (use of a custom library with special encryption) rather than <em>architecture</em> (breaking up functionality into separate deployment units).</p>
        
        <p>Based on the conversation with Parker and Sam, Austen made the decision that customer-related functionality would be managed through a single consolidated domain service (rather than separately deployed services) and wrote the following ADR for this decision:</p>
        <blockquote>
        <p class="adr" id="adr_7"><em>ADR: Consolidated Service for Customer-Related Functionality</em></p>
        
        <p><em>Context</em><br>
        Customers must register with the system to gain access to the Sysops Squad support plan. During registration, customers must provide profile information, credit card information, password information, and products purchased. This can be done through a single consolidated customer service, a separate service for each of these functions, or a separate service for sensitive and nonsensitive data.</p>
        
        <p><em>Decision</em><br>
        We will create a single consolidated customer service for profile, credit card, password, and products supported.</p>
        
        <p>Customer registration and unsubscribe functionality <em>requires</em> a single atomic unit of work. A single service would support ACID transactions to meet this requirement, whereas separate services would not.</p>
        
        <p>Use of the Tortoise security libraries in the API layer and the service mesh will mitigate security access risk to sensitive information.</p>
        
        <p><em>Consequences</em><br>
        We will require the Tortoise security library to ensure security access in both the API gateway and the service mesh.</p>
        
        <p>Because it’s a single service, changes to source code for profile info, credit card, password, or products purchased will increase testing scope and increase deployment risk.</p>
        
        <p>The combined functionality (profile, credit card, password, and products purchased) will have to scale as one unit.</p>
        
        <p>The trade-off discussed in a meeting with the product owner and security expert is <em>transactionality</em> versus <em>security</em>. Breaking the customer functionality into separate services 
        <span class="keep-together">provides</span> better security access, but doesn’t support the “all-or-nothing” database transaction required for customer registration or unsubscribing. However, the security concerns are mitigated through the use the custom Tortoise security library.<a data-type="indexterm" data-startref="ch07-ssotg" id="idm45978844069696"></a><a data-type="indexterm" data-startref="ch07-ssotg2" id="idm45978844068992"></a><a data-type="indexterm" data-startref="ch07-ssotg3" id="idm45978844068320"></a><a data-type="indexterm" data-startref="ch07-ssotg4" id="idm45978844067648"></a><a data-type="indexterm" data-startref="ch07-ssotg5" id="idm45978844066976"></a></p></blockquote>
        </div>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492086888/files/epub.css" crossorigin="anonymous"><script src="https://learning.oreilly.comhttps://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-svg.js"></script></div></div></section>
</div>

https://learning.oreilly.com