<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Discerning Coupling in 
        Software Architecture"><div class="chapter" id="ch02-discerning">
        <h1><span class="label">Chapter 2. </span>Discerning Coupling in 
        <span class="keep-together">Software Architecture</span></h1>
        
        
        <p><code>Wednesday, November 3, 13:00</code></p>
        <div class="story">
        
        <p>Logan, the lead architect for Penultimate Electronics, interrupted a small group of architects in the cafeteria, discussing distributed architectures. “Austen, are you wearing a cast <em>again</em>?”</p>
        
        <p>“No, it’s just a splint,” replied Austen. “I sprained my wrist playing extreme disc golf over the weekend—it’s almost healed.”</p>
        
        <p>“What is…never mind. What is this impassioned conversation I barged in on?”</p>
        
        <p>“Why wouldn’t someone always choose the <em>saga pattern</em> in microservices to wire together transactions?” asked Austen. “That way, architects can make the services as small as they want.”</p>
        
        <p>“But don’t you have to use <em>orchestration</em> with sagas?” asked Addison. “What about times when we need asynchronous communication? And, how complex will the transactions get? If we break things down too much, can we really guarantee data fidelity?”</p>
        
        <p>“You know,” said Austen, “if we use an <em>enterprise service bus</em>, we can get it to manage most of that stuff for us.”</p>
        
        <p>“I thought no one used ESBs anymore—shouldn’t we use Kafka for stuff like that?”</p>
        
        <p>“They aren’t even the same thing!” said Austen.</p>
        
        <p>Logan interrupted the increasingly heated conversation. “It is an apples-to-oranges comparison, but none of these tools or approaches is a silver bullet. Distributed architectures like microservices are difficult, especially if architects cannot untangle all the forces at play. What we need is an approach or framework that helps us figure out the hard problems in our architecture.”</p>
        
        <p>“Well,” said Addison, “whatever we do, it has to be as decoupled as possible—everything I’ve read says that architects should embrace decoupling as much as possible.”</p>
        
        <p>“If you follow that advice,” said Logan, “Everything will be so decoupled that nothing can communicate with anything else—it’s hard to build software that way! Like a lot of things, coupling isn’t inherently bad; architects just have to know how to apply it appropriately. In fact, I remember a famous quote about that from a philosopher….”</p>
        <hr>
        </div>
        <blockquote>
        <p>All things are poison, and nothing is without poison; the dosage alone makes it so a thing is not a poison.</p>
        <p data-type="attribution">Paracelsus</p>
        </blockquote>
        
        <p>One of the most difficult tasks an architect will face is untangling the various forces and trade-offs at play in distributed architectures. <a data-type="indexterm" data-primary="coupling" data-secondary="trade-off analysis" id="ch02-toa3"></a><a data-type="indexterm" data-primary="decision making" data-seealso="trade-off analysis" id="ch02-toa2"></a><a data-type="indexterm" data-primary="trade-off analysis" id="ch02-toa"></a><a data-type="indexterm" data-primary="trade-off analysis" data-secondary="coupling" id="ch02-toa4"></a>People who provide advice constantly extol the benefits of “loosely coupled” systems, but how can architects design systems where nothing connects to anything else? Architects design fine-grained microservices to achieve decoupling, but then orchestration, transactionality, and asynchronicity become huge problems. Generic advice says “decouple,” but provides no guidelines for <em>how</em> to achieve that goal while still constructing useful systems.</p>
        
        <p>Architects struggle with granularity and communication decisions because there are no clear universal guides for making decisions—no best practices exist that can apply to real-world complex systems. Until now, architects lacked the correct perspective and terminology to allow a careful analysis that could determine the best (or least worst) set of trade-offs on a case-by-case basis.</p>
        
        <p>Why have architects struggled with decisions in distributed architectures? After all, we’ve been building distributed systems since the last century, using many of the same mechanisms (message queues, events, and so on). Why has the complexity ramped up so much with microservices?</p>
        
        <p>The answer lies with the fundamental philosophy of microservices, inspired by the idea of a <em>bounded context</em>. <a data-type="indexterm" data-primary="microservices" data-secondary="bounded context" id="idm45978857623888"></a><a data-type="indexterm" data-primary="bounded context in microservices" id="idm45978857622880"></a><a data-type="indexterm" data-primary="distributed architectures" data-secondary="bounded context in microservices" data-seealso="bounded context" id="idm45978857622192"></a>Building services that model bounded contexts required a subtle but important change to the way architects designed distributed systems because now transactionality is a first-class architectural concern. In many of the distributed systems architects designed prior to microservices, event handlers typically connected to a single relational database, allowing it to handle details such as integrity and transactions. Moving the database within the service boundary moves data concerns into architecture concerns.</p>
        
        <p>As we’ve said before, <em>“Software architecture” is the stuff you can’t Google answers for</em>. A skill that modern architects must build is the ability to do trade-off analysis. While several frameworks have existed for decades (such as Architecture Trade-off Analysis Method, or <a href="https://oreil.ly/okbuO">ATAM</a>), they lack focus on real problems architects face on a daily basis.</p>
        
        <p>This book focuses on how architects can perform trade-off analysis for any number of scenarios unique to their situation. As in many things in architecture, the advice is simple; the hard parts lie in the details, particularly how difficult parts become entangled, making it difficult to see and understand the individual parts, as illustrated in <a data-type="xref" href="#fig-discerning-complect">Figure 2-1</a>.</p>
        
        <figure><div id="fig-discerning-complect" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0201.png" alt="Instructions for braiding hair" width="600" height="241">
        <h6><span class="label">Figure 2-1. </span>A braid entangles hair, making the individual strands hard to identify</h6>
        </div></figure>
        
        <p>When architects look at entangled problems, they struggle with performing trade-off analysis because of the difficulties separating the concerns, so that they may consider them independently. Thus, the first step in trade-off analysis is untangle the dimensions of the problem, analyzing what parts are coupled to one another and what impact that coupling has on change. For this purpose, we use the simplest definition of the word <em>coupling</em>:</p>
        <dl>
        <dt>Coupling</dt>
        <dd>
        <p>Two parts of a software system are coupled if a change in one might cause a change in the other.<a data-type="indexterm" data-primary="coupling" data-secondary="definition" id="idm45978857613488"></a></p>
        </dd>
        </dl>
        
        <p>Often, software architecture creates multidimensional problems, where multiple forces all interact in interdependent ways. To analyze trade-offs, an architect must first determine what forces need to trade off with each other.</p>
        
        <p>Thus, here’s our advice for modern trade-off analysis in software architecture:</p>
        <ol>
        <li>
        <p>Find what parts are entangled together.</p>
        </li>
        <li>
        <p>Analyze how they are coupled to one another.</p>
        </li>
        <li>
        <p>Assess trade-offs by determining the impact of change on interdependent 
        <span class="keep-together">systems</span>.</p>
        </li>
        
        </ol>
        
        <p>While the steps are simple, the hard parts lurk in the details. Thus, to illustrate this framework in practice, we take one of the most difficult (and probably the closest to generic) problems in distributed architectures, which is related to microservices:</p>
        <dl>
        <dt>How do architects determine the size and communication styles for microservices?</dt>
        <dd>
        <p>Determining the proper size for microservices seems a pervasive problem—too-small services create transactional and orchestration issues, and too-large services create scale and distribution issues.</p>
        </dd>
        </dl>
        
        <p>To that end, the remainder of this book untangles the many aspects to consider when answering the preceding question. We provide new terminology to differentiate similar but distinct patterns and show practical examples of applying these and other 
        <span class="keep-together">patterns</span>.</p>
        
        <p>However, the overarching goal of this book is to provide you with example-driven techniques to learn how to construct your own trade-off analysis for the unique problems within your realm. We start with our first great untangling of forces in distributed architectures: defining architecture quantum along with the two types of coupling, static and dynamic.<a data-type="indexterm" data-startref="ch02-toa" id="idm45978857603648"></a><a data-type="indexterm" data-startref="ch02-toa2" id="idm45978857602944"></a><a data-type="indexterm" data-startref="ch02-toa3" id="idm45978857602272"></a><a data-type="indexterm" data-startref="ch02-toa4" id="idm45978857601600"></a></p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Architecture (Quantum | Quanta)"><div class="sect1" id="idm45978857600800">
        <h1>Architecture (Quantum | Quanta)</h1>
        
        <p>The term <em>quantum</em> is, of course, used heavily in the field of physics known as <em>quantum mechanics</em>. <a data-type="indexterm" data-primary="quanta" data-seealso="architecture quantum" id="idm45978857598000"></a><a data-type="indexterm" data-primary="architecture quantum" data-secondary="about" id="idm45978857596992"></a><a data-type="indexterm" data-primary="architecture" data-secondary="architecture quantum" data-seealso="architecture quantum" id="idm45978857596048"></a>However, the authors chose the word for the same reasons physicists did. <em>Quantum</em> originated from the Latin word <em>quantus</em>,  meaning “how great” or “how many.” Before physics co-opted it, the legal profession used it to represent the “required or allowed amount” (for example, in damages paid). The term also appears in the mathematics field of topology, concerning the properties of families of shapes. Because of its Latin roots, the singular is <em>quantum</em>, and the plural is <em>quanta</em>, similar to the datum/data symmetry.</p>
        
        <p>An architecture quantum measures several aspects of both topology and behavior in software architecture related to how parts connect and communicate with one another:</p>
        <dl>
        <dt>Architecture quantum</dt>
        <dd>
        <p>An architecture quantum is an independently deployable artifact with high functional cohesion, <a data-type="indexterm" data-primary="coupling" data-secondary="architecture quantum" id="idm45978857590736"></a><a data-type="indexterm" data-primary="microservices" data-secondary="architecture quantum" id="idm45978857589760"></a><a data-type="indexterm" data-primary="architecture quantum" data-secondary="coupling, static versus dynamic" id="idm45978857588816"></a>high static coupling, and synchronous dynamic coupling. A common example of an architecture quantum is a well-formed microservice within a workflow.</p>
        </dd>
        <dt>Static coupling</dt>
        <dd>
        <p>Represents how static dependencies resolve within the architecture via<a data-type="indexterm" data-primary="coupling" data-secondary="about static versus dynamic" data-tertiary="static coupling" id="idm45978857586288"></a><a data-type="indexterm" data-primary="static coupling" id="idm45978857585024"></a><a data-type="indexterm" data-primary="static coupling" data-secondary="operational dependencies as" id="idm45978857584352"></a><a data-type="indexterm" data-primary="dependencies" data-secondary="static coupling as operational dependencies" id="idm45978857583392"></a> contracts. These dependencies include operating system, frameworks, and/or libraries delivered via transitive dependency management, and any other operational requirement to allow the quantum to operate.</p>
        </dd>
        <dt>Dynamic coupling</dt>
        <dd>
        <p>Represents how quanta communicate at runtime, either synchronously<a data-type="indexterm" data-primary="communication" data-secondary="dynamic coupling as" id="idm45978857581008"></a><a data-type="indexterm" data-primary="coupling" data-secondary="about static versus dynamic" data-tertiary="dynamic coupling" id="idm45978857580032"></a><a data-type="indexterm" data-primary="dynamic coupling" id="idm45978857578800"></a><a data-type="indexterm" data-primary="fitness functions for governance" data-secondary="dynamic coupling monitored" id="idm45978857578128"></a> or asynchronously. Thus, fitness functions for these characteristics must be <em>continuous</em>, typically utilizing monitors.</p>
        </dd>
        </dl>
        
        <p>Even though both static and dynamic coupling seem similar, architects must <a data-type="indexterm" data-primary="dynamic coupling" data-secondary="static versus" id="idm45978857575680"></a><a data-type="indexterm" data-primary="static coupling" data-secondary="dynamic versus" id="idm45978857574704"></a><a data-type="indexterm" data-primary="coupling" data-secondary="about static versus dynamic" id="idm45978857573760"></a>distinguish two important differences. An easy way to think about the difference is that <em>static coupling</em> describes how services are <em>wired</em> together, whereas <em>dynamic coupling</em> describes how services <em>call</em> one another at runtime.  For example, in a microservices architecture, a service must contain dependent components such as a database, representing static coupling—the service isn’t operational without the necessary data. That service may call other services during the course of a workflow, which represents dynamic coupling. Neither service requires the other to be present to function, except for this runtime workflow. <a data-type="indexterm" data-primary="communication" data-secondary="dynamic coupling as" data-tertiary="communication dependencies" id="idm45978857570896"></a><a data-type="indexterm" data-primary="dependencies" data-secondary="dynamic coupling as communication dependencies" id="idm45978857569584"></a>Thus, static coupling analyzes operational dependencies, and dynamic coupling analyzes communication dependencies.</p>
        
        <p>These definitions include important characteristics; let’s cover each in detail as they inform most of the examples in the book.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Independently Deployable"><div class="sect2" id="independently_deployable_quantum_criteria">
        <h2>Independently Deployable</h2>
        
        <p><em>Independently deployable</em> implies several aspects of an<a data-type="indexterm" data-primary="architecture quantum" data-secondary="independently deployable" id="idm45978857565712"></a><a data-type="indexterm" data-primary="independent deployability" id="idm45978857564704"></a><a data-type="indexterm" data-primary="deployment" data-secondary="independent deployability" id="idm45978857564016"></a> architecture quantum—each quantum represents a separate deployable unit within a particular architecture. <a data-type="indexterm" data-primary="monolithic architectures" data-secondary="single architecture quantum" id="idm45978857562800"></a>Thus, a monolithic architecture—one that is deployed as a single unit—is by definition a single architecture quantum. <a data-type="indexterm" data-primary="microservices" data-secondary="architecture quantum" id="idm45978857561552"></a>Within a distributed architecture such as microservices, developers tend toward the ability to deploy services independently, often in a highly automated way. Thus, from an independently deployable standpoint, a service within a microservices architecture represents an architecture quantum (contingent on coupling—as discussed next).</p>
        
        <p>Making each architecture quantum represent a deployable asset within the architecture serves several useful purposes. First, the boundary represented by an architecture quantum serves as a useful common language among architects, developers, and operations. Each understands the common scope under question: architects understand the coupling characteristics, developers understand the scope of behavior, and the operations team understands the deployable characteristics.</p>
        
        <p>Second, the architecture quantum represents one of the forces (static coupling) architects<a data-type="indexterm" data-primary="coupling" data-secondary="architecture quantum" data-tertiary="independently deployable" id="idm45978857559568"></a><a data-type="indexterm" data-primary="static coupling" data-secondary="architecture quantum" data-tertiary="independently deployable" id="idm45978857558304"></a> must consider when striving for proper granularity of services within a distributed architecture. Often, in microservices architectures, developers face the difficult question of what service granularity offers the optimum set of trade-offs. Some of those trade-offs revolve around deployability: what release cadence does this service require, what other services might be affected, what engineering practices are involved, and so on. Architects benefit from a firm understanding of exactly where deployment boundaries lie in distributed architectures. We discuss service granularity and its attendant trade-offs in <a data-type="xref" href="ch07.html#ch07-service-granularity">Chapter&nbsp;7</a>.</p>
        
        <p>Third, <em>independent deployability</em> forces the architecture quantum to include common coupling points such as databases. Most discussions about architecture conveniently ignore issues such as databases and user interfaces, but real-world systems must commonly deal with those problems. Thus, any system that uses a shared database fails the architecture quantum criteria for independent deployment unless the database deployment is in lockstep with the application. Many distributed systems that would otherwise qualify for multiple quanta fail the independently deployable part if they share a common database that has its own deployment cadence. Thus, merely considering the deployment boundaries doesn’t solely provide a useful measure. Architects should also consider the second criteria for an architecture quantum, high functional cohesion, to limit the architecture quantum to a useful scope.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="High Functional Cohesion"><div class="sect2" id="idm45978857555136">
        <h2>High Functional Cohesion</h2>
        
        <p><em>High functional cohesion</em> refers structurally to the proximity<a data-type="indexterm" data-primary="architecture quantum" data-secondary="high functional cohesion" id="idm45978857553344"></a><a data-type="indexterm" data-primary="high functional cohesion" id="idm45978857552304"></a><a data-type="indexterm" data-primary="cohesion" data-secondary="high functional cohesion" id="idm45978857551616"></a> of related elements: classes, components, services, and so on. Throughout history, computer scientists defined a variety of cohesion types, scoped in this case to the generic <em>module</em>, which may be represented as <em>classes</em> or <em>components</em>, depending on platform. <a data-type="indexterm" data-primary="bounded context in microservices" data-secondary="high functional cohesion" id="idm45978857549040"></a><a data-type="indexterm" data-primary="microservices" data-secondary="bounded context" data-tertiary="high functional cohesion" id="idm45978857547984"></a><a data-type="indexterm" data-primary="Domain-Driven Design (DDD)" data-secondary="bounded context" data-tertiary="high functional cohesion and" id="idm45978857546752"></a>From a domain standpoint, the technical definition of <em>high functional cohesion</em> overlaps with the goals of the <em>bounded context</em> in domain-driven design: behavior and data that implements a particular domain workflow.</p>
        
        <p>From a purely independent deployability standpoint, a giant monolithic architecture qualifies as an architecture quantum. <a data-type="indexterm" data-primary="monolithic architectures" data-secondary="single architecture quantum" data-tertiary="functional cohesion" id="idm45978857544016"></a>However, it almost certainly isn’t highly functionally cohesive, but rather includes the functionality of the entire system. The larger the monolith, the less likely it is singularly functionally cohesive.</p>
        
        <p>Ideally, in a microservices architecture, each service models a single domain<a data-type="indexterm" data-primary="microservices" data-secondary="architecture quantum" data-tertiary="high functional cohesion" id="idm45978857542224"></a> or workflow, and therefore exhibits high functional cohesion. Cohesion in this context isn’t about how services interact to perform work, but rather how independent and coupled one service is to another service.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="High Static Coupling"><div class="sect2" id="idm45978857540256">
        <h2>High Static Coupling</h2>
        
        <p><em>High static coupling</em> implies that the elements inside the architecture<a data-type="indexterm" data-primary="architecture quantum" data-secondary="coupling, static versus dynamic" data-tertiary="high static coupling" id="ch02-hsc"></a><a data-type="indexterm" data-primary="coupling" data-secondary="architecture quantum" data-tertiary="high static coupling" id="ch02-hsc2"></a><a data-type="indexterm" data-primary="static coupling" data-secondary="architecture quantum" data-tertiary="high static coupling" id="ch02-hsc3"></a><a data-type="indexterm" data-primary="contracts" data-secondary="high static coupling" id="idm45978852128944"></a> quantum are tightly wired together, which is really an aspect of contracts. Architects recognize things like REST or SOAP as contract formats, but method signatures and operational dependencies (via coupling points such as IP addresses or URLs) also represent contracts. Thus, contracts are an <em>architecture hard part</em>; we cover coupling issues involving all types of contracts, including how to choose appropriate ones, in <span class="keep-together"><a data-type="xref" href="ch13.html#ch13-contracts">Chapter&nbsp;13</a></span>.</p>
        
        <p>An architecture quantum is, in part, a measure of static coupling, and the measure is quite simple for most architecture topologies. For example, the following diagrams show the architecture styles featured in <em>Fundamentals of Software Architecture</em>, with the architecture quantum static coupling illustrated.</p>
        
        <p>Any of the monolithic architecture styles will necessarily have a <a data-type="indexterm" data-primary="monolithic architectures" data-secondary="single architecture quantum" data-tertiary="static coupling" id="idm45978852124576"></a>quantum of one, as illustrated in <a data-type="xref" href="#fig-arch-vs-design-single-quantum-1">Figure 2-2</a>.</p>
        
        <figure><div id="fig-arch-vs-design-single-quantum-1" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0202.png" alt="architecture topologies with a quantum of one" width="600" height="769">
        <h6><span class="label">Figure 2-2. </span>Monolithic architectures always have a quantum of one</h6>
        </div></figure>
        
        <p>As you can see, any architecture that deploys as a single unit and utilizes a single database will always have a single quantum. The architecture quantum measure of static coupling includes the database, and a system that relies on a single database cannot have more than a single quantum. Thus, the static coupling measure of an architecture quantum helps identify coupling points in architecture, not just within the software components under development. Most monolithic architectures contain a single coupling point (typically, a database) that makes its quantum measure one.</p>
        
        <p>Distributed architectures often feature decoupling at the component level;<a data-type="indexterm" data-primary="distributed architectures" data-secondary="static coupling" id="idm45978852119376"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="static coupling" id="idm45978852118384"></a> consider the next set of architecture styles, starting with the service-based architecture shown in <a data-type="xref" href="#fig-arch-vs-design-single-quantum-SB-arch">Figure 2-3</a>.</p>
        
        <figure><div id="fig-arch-vs-design-single-quantum-SB-arch" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0203.png" alt="A service-based architecture has a single quantum" width="600" height="406">
        <h6><span class="label">Figure 2-3. </span>Architecture quantum for a service-based architecture</h6>
        </div></figure>
        
        <p>While this individual services model shows the isolation common in microservices, the architecture still utilizes a single relational database, rendering its architecture quantum score to one.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45978852113616">
        <h5>Service-Based Architecture</h5>
        <p>When we refer to <em>service-based architecture</em>, we don’t mean a generic architecture based on services, <a data-type="indexterm" data-primary="service-based architecture" data-secondary="about" id="idm45978852111728"></a>but rather a specific hybrid architecture style  that follows a distributed macro-layered structure consisting of a separately deployed user interface, separately deployed remote coarse-grained services, and a monolithic database. This architecture addresses one of the complexities of microservices—separation at the database level. Services in a service-based architecture follow the same principles as microservices (based on domain-driven design’s bounded context) but rely on a single relational database because the architects didn’t see value in separation (or saw too many negative trade-offs).</p>
        
        <p>Service-based architectures are common targets when restructuring monolithic architectures, allowing for decomposition without disrupting existing database schemas and integration points. We cover decomposition patterns in <a data-type="xref" href="ch05.html#ch05-decomposition-patterns">Chapter&nbsp;5</a>.</p>
        </div></aside>
        
        <p>So far, the static coupling measurement of architecture quantum has evaluated all the topologies to <em>one</em>. However, distributed architectures create the possibility of multiple quanta but don’t necessarily guarantee it. <a data-type="indexterm" data-primary="distributed architectures" data-secondary="static coupling" data-tertiary="single quantum" id="idm45978852108080"></a><a data-type="indexterm" data-primary="event-driven architecture (EDA)" data-secondary="single architecture quantum" data-tertiary="mediator style as" id="idm45978852106816"></a><a data-type="indexterm" data-primary="mediator style event-driven architecture quantum" id="idm45978852105568"></a>For example, the mediator style of event-driven architecture will always be evaluated to an single architecture quantum, as illustrated in <a data-type="xref" href="#fig-arch-vs-design-mediator-quantum">Figure 2-4</a>.</p>
        
        <p>Even though this style represents a distributed architecture, two coupling points push it toward a single architecture quantum: the database, as common with the previous monolithic architectures, but also the <code>Request Orchestrator</code> itself—any holistic coupling point necessary for the architecture to function forms an architecture quantum around it.</p>
        
        <figure><div id="fig-arch-vs-design-mediator-quantum" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0204.png" alt="user interface and database both represent coupling points in architecture" width="600" height="295">
        <h6><span class="label">Figure 2-4. </span>A mediated EDA has a single architecture quantum</h6>
        </div></figure>
        
        <p>Broker event-driven architectures (without a central mediator) are less coupled, <a data-type="indexterm" data-primary="event-driven architecture (EDA)" data-secondary="single architecture quantum" data-tertiary="broker style as" id="idm45978852100128"></a><a data-type="indexterm" data-primary="broker style event-driven architecture quantum" id="idm45978852098848"></a>but that doesn’t guarantee complete decoupling. Consider the event-driven architecture illustrated in <a data-type="xref" href="#fig-arch-vs-design-single-quantum-EDA">Figure 2-5</a>.</p>
        
        <p>This broker-style event driven architecture (without a central mediator) is nevertheless a single architecture quantum because all the services utilize a single relational database, which acts as a common coupling point. The question answered by the static analysis for an architecture quantum is, “Is this dependent of the architecture necessary to bootstrap this service?” Even in the case of an event-driven architecture where some of the services don’t access the database, if they rely on services that <em>do</em> access the database, then they become part of the static coupling of the architecture quantum.</p>
        
        <figure><div id="fig-arch-vs-design-single-quantum-EDA" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0205.png" alt="A broker EDA can still be a single architecture quantum because of a common coupling point" width="600" height="371">
        <h6><span class="label">Figure 2-5. </span>Even a distributed architecture such as broker-style event-driven architecture can be a single quantum</h6>
        </div></figure>
        
        <p>However, what about situations in distributed architectures where common coupling points don’t exist? <a data-type="indexterm" data-primary="distributed architectures" data-secondary="static coupling" data-tertiary="multiple quanta" id="idm45978852093248"></a><a data-type="indexterm" data-primary="event-driven architecture (EDA)" data-secondary="multiple architecture quanta" id="idm45978852091984"></a>Consider the event-driven architecture illustrated in <a data-type="xref" href="#fig-discerning-multi-quanta-EDA">Figure 2-6</a>.</p>
        
        <p>The architects designed this event-driven system<a data-type="indexterm" data-primary="data" data-secondary="coupling" data-tertiary="multiple quanta event-driven architecture" id="idm45978852089584"></a> with two data stores, and no static dependencies between the sets of services. Note that either architecture quantum can run in a production-like ecosystem. It may not be able to participate in all workflows required by the system, but it runs successfully and operates—sends requests and receives them within the architecture.</p>
        
        <p>The static coupling measure of an architecture quantum<a data-type="indexterm" data-primary="static coupling" data-secondary="architecture quantum" id="idm45978852087728"></a><a data-type="indexterm" data-primary="coupling" data-secondary="architecture quantum" id="idm45978852086752"></a> assesses the coupling dependencies between architectural and operational components. Thus, the operating system, data store, message broker, container orchestration, and all other operational dependencies form the static coupling points of an architecture quantum, using the strictest possible contracts, operational dependencies (more about the role of contracts in architecture quanta in <a data-type="xref" href="ch13.html#ch13-contracts">Chapter&nbsp;13</a>).</p>
        
        <figure><div id="fig-discerning-multi-quanta-EDA" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0206.png" alt="An EDA with multiple quanta because of a lack of single coupling point" width="600" height="430">
        <h6><span class="label">Figure 2-6. </span>An event-driven architecture with multiple quanta</h6>
        </div></figure>
        
        <p>The microservices architecture style features <a data-type="indexterm" data-primary="microservices" data-secondary="architecture quantum" data-tertiary="decoupled services" id="idm45978852082304"></a><a data-type="indexterm" data-primary="data" data-secondary="coupling" data-tertiary="microservices" id="idm45978852081056"></a><a data-type="indexterm" data-primary="bounded context in microservices" data-secondary="architecture quanta" id="idm45978852079840"></a><a data-type="indexterm" data-primary="microservices" data-secondary="bounded context" data-tertiary="architecture quanta" id="idm45978852078880"></a>highly decoupled services, including data dependencies. Architects in these architectures favor high degrees of decoupling and take care not to create coupling points between services, allowing each individual service to each form its own quanta, as shown in <a data-type="xref" href="#fig-discerning-microservice-api-quanta">Figure 2-7</a>.</p>
        
        <figure><div id="fig-discerning-microservice-api-quanta" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0207.png" alt="microservices are highly decoupled and can therefore form individual quanta" width="600" height="250">
        <h6><span class="label">Figure 2-7. </span>Microservices may form their own quanta</h6>
        </div></figure>
        
        <p class="pagebreak-before">Each service (acting as a bounded context) may have its own set of architecture characteristics—one service might have higher levels of scalability or security than another. This granular level of architecture characteristics scoping represents one of the advantages of the microservices architecture style. High degrees of decoupling allow teams working on a service to move as quickly as possible, without worrying about breaking other dependencies.</p>
        
        <p>However, if the system is tightly coupled to a user interface, <a data-type="indexterm" data-primary="microservices" data-secondary="architecture quantum" data-tertiary="user interface coupling" id="idm45978852073568"></a><a data-type="indexterm" data-primary="user interface quantum" id="idm45978852072240"></a><a data-type="indexterm" data-primary="coupling" data-secondary="architecture quantum" data-tertiary="user interface" id="idm45978852071568"></a><a data-type="indexterm" data-primary="architecture quantum" data-secondary="coupling, static versus dynamic" data-tertiary="user interface" id="idm45978852070352"></a>the architecture forms a single architecture quantum, as illustrated in <a data-type="xref" href="#fig-discerning-mono-ui-quantum">Figure 2-8</a>.</p>
        
        <figure><div id="fig-discerning-mono-ui-quantum" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0208.png" alt="Tightly coupling a user interface reduces the quantum to one" width="600" height="371">
        <h6><span class="label">Figure 2-8. </span>A tightly coupled user interface can reduce a microservices architecture quantum to one</h6>
        </div></figure>
        
        <p>User interfaces create coupling points between the front and back end, and most user interfaces won’t operate if portions of the backend aren’t available.</p>
        
        <p>Additionally, it will be difficult for an architect to design different levels of operational architecture characteristics (performance, scale, elasticity, reliability, and so on) for each service if they all must cooperate together in a single user interface (particularly in the case of synchronous calls, covered in <a data-type="xref" href="#sec-dynamic-coupling">“Dynamic Quantum Coupling”</a>).</p>
        
        <p>Architects design user interfaces utilizing asynchronicity that doesn’t create coupling between front and back. A trend on many microservices projects is to use a <em>micro frontend</em> framework for user interface elements in a microservices architecture. In such an architecture, the user interface elements that interact on behalf of the services are emitted from the services themselves. The user interface surface acts as a canvas where the user interface elements can appear, and also facilitates loosely coupled communication between components, typically using events. Such an architecture is illustrated in <a data-type="xref" href="#fig-discerning-microFE-quanta">Figure 2-9</a>.</p>
        
        <figure><div id="fig-discerning-microFE-quanta" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0209.png" alt="Micro-frontends allow for services + user interfaces to form a single architecture quantum" width="600" height="377">
        <h6><span class="label">Figure 2-9. </span>In a micro-frontend architecture, each service + user interface component forms an architecture quantum</h6>
        </div></figure>
        
        <p>In this example, the four tinted services along with their corresponding micro-frontends form architecture quanta: each of these services may have different architecture characteristics.</p>
        
        <p>Any coupling point in an architecture can create static coupling points from a quantum standpoint. Consider the impact of a shared database between two systems, as illustrated in <a data-type="xref" href="#fig-discerning-aq-shared-db">Figure 2-10</a>.</p>
        
        <p>The static coupling of a system provides valuable insight, even in complex systems involving integration architecture. Increasingly, a common architect technique for understanding legacy architecture involves creating a static quantum diagram of how things are “wired” together, which helps determine what systems will be impacted by change and offers a way of understanding (and potentially decoupling) the 
        <span class="keep-together">architecture</span>.<a data-type="indexterm" data-startref="ch02-hsc" id="idm45978852057408"></a><a data-type="indexterm" data-startref="ch02-hsc2" id="idm45978852056672"></a><a data-type="indexterm" data-startref="ch02-hsc3" id="idm45978852056000"></a></p>
        
        <p>Static coupling is only one-half of the forces at play in distributed architectures. The other is dynamic coupling.</p>
        
        <figure><div id="fig-discerning-aq-shared-db" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0210.png" alt="an integration database coupling two systems" width="600" height="458">
        <h6><span class="label">Figure 2-10. </span>A shared database forms a coupling point between two systems, creating a single quantum</h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Dynamic Quantum Coupling"><div class="sect2" id="sec-dynamic-coupling">
        <h2>Dynamic Quantum Coupling</h2>
        
        <p>The last portion of the architecture quantum definition <a data-type="indexterm" data-primary="coupling" data-secondary="architecture quantum" data-tertiary="dynamic quantum coupling" id="ch02-dqc"></a><a data-type="indexterm" data-primary="architecture quantum" data-secondary="coupling, static versus dynamic" data-tertiary="dynamic quantum coupling" id="ch02-dqc2"></a>concerns synchronous coupling at runtime—in other words, the behavior of architecture quanta as they interact with one another to form workflows within a distributed architecture.</p>
        
        <p>The nature of <em>how</em> services call one another creates difficult trade-off decisions because it represents a multidimensional decision space, influenced by three interlocking forces:</p>
        <dl>
        <dt>Communication</dt>
        <dd>
        <p>Refers to the type of connection synchronicity used: synchronous or 
        <span class="keep-together">asynchronous</span>.</p>
        </dd>
        </dl>
        <dl>
        <dt>Consistency</dt>
        <dd>
        <p>Describes whether the workflow communication requires atomicity or can utilize eventual consistency.</p>
        </dd>
        </dl>
        <dl>
        <dt>Coordination</dt>
        <dd>
        <p>Describes whether the workflow utilizes an orchestrator or whether the services communicate via choreography.</p>
        </dd>
        </dl>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Communication"><div class="sect3" id="idm45978857397344">
        <h3>Communication</h3>
        
        <p>When two services communicate with each other, <a data-type="indexterm" data-primary="communication" data-secondary="about synchronous versus asynchronous" id="idm45978857395664"></a><a data-type="indexterm" data-primary="synchronous communication" data-secondary="asynchronous versus" id="idm45978857394672"></a><a data-type="indexterm" data-primary="asynchronous communication" data-secondary="synchronous versus" id="idm45978857393712"></a><a data-type="indexterm" data-primary="dynamic coupling" data-secondary="communication" id="idm45978857392752"></a>one of the fundamental questions for an architect is whether that communication should be synchronous or asynchronous.</p>
        
        <p><em>Synchronous</em> communication requires the requestor to wait for the response from the receiver, as shown in <a data-type="xref" href="#fig-discern-sync-base">Figure 2-11</a>.</p>
        
        <figure><div id="fig-discern-sync-base" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0211.png" alt="synchronous call waits for return from receiver" width="600" height="178">
        <h6><span class="label">Figure 2-11. </span>A synchronous call waits for a result from the receiver</h6>
        </div></figure>
        
        <p>The calling service makes a call (using one of a number of protocols that support synchronous calls, such as gRPC) and <em>blocks</em> (does no further processing) until the receiver returns a value (or status indicating a state change or error condition).</p>
        
        <p><em>Asynchronous</em> communication occurs between two services when the caller posts a message to the receiver (usually via a mechanism such as a message queue) and, once the caller gets acknowledgment that the message will be processed, it returns to work. If the request required a response value, the receiver can use a reply queue to (asynchronously) notify the caller of the result, which is illustrated in <a data-type="xref" href="#fig-discern-async-base">Figure 2-12</a>.</p>
        
        <figure><div id="fig-discern-async-base" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0212.png" alt="Asynchronous communication allows parallel behavior" width="600" height="499">
        <h6><span class="label">Figure 2-12. </span>Asynchronous communication allows parallel processing</h6>
        </div></figure>
        
        <p>The caller posts a message to a message queue and continues processing until notified by the receiver that the requested information is available via return call. Generally, architects use message queues (illustrated via the gray cylindrical tube in the top diagram in <a data-type="xref" href="#fig-discern-async-base">Figure 2-12</a>) to implement asynchronous communication, but queues are common and create noise on diagrams, so many architects leave them off, as shown in the lower diagram. And, of course, architects can implement asynchronous communication without message queues by using a variety of libraries or frameworks. Each diagram variety implies asynchronous messaging; the second provides visual shorthand and less implementation detail.</p>
        
        <p>Architects must consider significant trade-offs when choosing how services will communicate. Decisions around communication affect synchronization, error handling, transactionality, scalability, and performance. The remainder of this book delves into many of these issues.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Consistency"><div class="sect3" id="idm45978857381280">
        <h3>Consistency</h3>
        
        <p><em>Consistency</em> refers to the strictness of transactional integrity <a data-type="indexterm" data-primary="dynamic coupling" data-secondary="consistency" id="idm45978857379376"></a><a data-type="indexterm" data-primary="consistency" data-secondary="about" id="idm45978857378400"></a><a data-type="indexterm" data-primary="atomic workflow" data-secondary="consistency" id="idm45978857377456"></a><a data-type="indexterm" data-primary="atomic workflow" data-secondary="eventual consistency versus" id="idm45978857376512"></a><a data-type="indexterm" data-primary="consistency" data-secondary="eventual consistency" data-tertiary="atomic workflow versus" id="idm45978857375600"></a><a data-type="indexterm" data-primary="eventual consistency" data-secondary="about consistency" id="idm45978857374384"></a><a data-type="indexterm" data-primary="eventual consistency" data-secondary="atomic workflow versus" id="idm45978857373440"></a>that communication calls must adhere to. Atomic transactions (all-or-nothing transactions requiring consistency <em>during</em> the processing of a request) lie on one side of the spectrum, whereas different degrees of eventual consistency lie on the other side.</p>
        
        <p>Transactionality—having several services participate in an all-or-nothing transaction—is <a data-type="indexterm" data-primary="distributed architectures" data-secondary="transactionality challenges" id="idm45978857371088"></a><a data-type="indexterm" data-primary="transactionality" data-secondary="distributed architecture challenge" id="idm45978857370176"></a>one of the most difficult problems to model in distributed architectures, resulting in the general advice to try to avoid cross-service transactions. We discuss consistency and the intersection of data and architecture in Chapters <a href="ch06.html#ch06-decomposing-operational-data">6</a>, <a href="ch09.html#ch09-data-update">9</a>, <a href="ch10.html#ch10-data-access">10</a>, and <a href="ch12.html#ch12-transactional-sagas">12</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Coordination"><div class="sect3" id="idm45978857366112">
        <h3>Coordination</h3>
        
        <p><em>Coordination</em> refers to how much coordination the workflow<a data-type="indexterm" data-primary="dynamic coupling" data-secondary="coordination" id="idm45978857363504"></a><a data-type="indexterm" data-primary="coordination of workflow" data-secondary="about" id="idm45978857362528"></a><a data-type="indexterm" data-primary="communication" data-secondary="coordination required" id="idm45978857361616"></a><a data-type="indexterm" data-primary="microservices" data-secondary="coordination" data-seealso="coordination" id="idm45978857360672"></a><a data-type="indexterm" data-primary="orchestrated coordination" data-secondary="about coordination" id="idm45978857359456"></a><a data-type="indexterm" data-primary="choreographed coordination" data-secondary="about coordination" id="idm45978857358544"></a><a data-type="indexterm" data-primary="distributed workflows" data-secondary="about coordination" id="idm45978857357584"></a> modeled by the communication requires. The two common generic patterns for microservices are orchestration and choreography, which we describe in <a data-type="xref" href="ch11.html#ch11-managing-workflows">Chapter&nbsp;11</a>. Simple workflows—a single service replying to a request—don’t require special consideration from this dimension. However, as the complexity of the workflow grows, the greater the need for coordination.</p>
        
        <p>These three factors—communication, consistency, and coordination—all inform the important decision an architect must make. Critically, however, architects cannot make these choices in isolation; each option has a gravitation effect on the others. For example, transactionality is easier in synchronous architectures with mediation, whereas higher levels of scale are possible with eventually consistent asynchronous choreographed systems.</p>
        
        <p>Thinking about these forces as related to each other forms a three-dimensional space, illustrated in<a data-type="indexterm" data-primary="dynamic coupling" data-secondary="relationships among factors" data-seealso="sagas" id="idm45978857354528"></a><a data-type="indexterm" data-primary="consistency" data-secondary="dynamic coupling relationship matrix" id="idm45978857353312"></a><a data-type="indexterm" data-primary="coordination of workflow" data-secondary="dynamic coupling relationship matrix" id="idm45978857352352"></a> <a data-type="xref" href="#fig-discern-aq-dyn-dimensions">Figure 2-13</a>.</p>
        
        <p>Each force in play during service communication appears as a dimension. For a particular decision, an architect could graph the position in space representing the strength of these forces.</p>
        
        <figure><div id="fig-discern-aq-dyn-dimensions" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0213.png" alt="Dimensions of dynamic quantum coupling" width="600" height="592">
        <h6><span class="label">Figure 2-13. </span>The dimensions of dynamic quantum coupling</h6>
        </div></figure>
        
        <p>When an architect can build a clear understanding of forces at play within a given situation,<a data-type="indexterm" data-primary="trade-off analysis" data-secondary="coupling" data-tertiary="dynamic quantum coupling factors" id="idm45978857347184"></a><a data-type="indexterm" data-primary="distributed architectures" data-secondary="dynamic coupling matrix" id="idm45978857345920"></a><a data-type="indexterm" data-primary="sagas" data-secondary="dynamic coupling matrix" id="idm45978857344960"></a><a data-type="indexterm" data-primary="transactional saga patterns" data-secondary="about" data-tertiary="pattern matrix" id="idm45978857344016"></a><a data-type="indexterm" data-primary="communication" data-secondary="dynamic coupling as" data-tertiary="saga pattern matrix" id="idm45978857342784"></a><a data-type="indexterm" data-primary="sagas" data-secondary="transactional saga patterns" data-tertiary="about" id="idm45978857341568"></a> it creates criteria for trade-off analysis. In the case of dynamic coupling, <a data-type="xref" href="#tbl-aq-coupling-matrix">Table&nbsp;2-1</a> shows a framework for identifying fundamental pattern names based on the eight possible combinations.</p>
        <table id="tbl-aq-coupling-matrix" style="width: 90%">
        <caption><span class="label">Table 2-1. </span>The matrix of dimensional intersections for distributed architectures</caption>
        <thead>
        <tr>
        <th>Pattern name</th>
        <th>Communication</th>
        <th>Consistency</th>
        <th>Coordination</th>
        <th>Coupling</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Epic Saga<sup>(sao)</sup></p></td>
        <td><p>synchronous</p></td>
        <td><p>atomic</p></td>
        <td><p>orchestrated</p></td>
        <td><p>very high</p></td>
        </tr>
        <tr>
        <td><p>Phone Tag Saga<sup>(sac)</sup></p></td>
        <td><p>synchronous</p></td>
        <td><p>atomic</p></td>
        <td><p>choreographed</p></td>
        <td><p>high</p></td>
        </tr>
        <tr>
        <td><p>Fairy Tale Saga<sup>(seo)</sup></p></td>
        <td><p>synchronous</p></td>
        <td><p>eventual</p></td>
        <td><p>orchestrated</p></td>
        <td><p>high</p></td>
        </tr>
        <tr>
        <td><p>Time Travel Saga<sup>(sec)</sup></p></td>
        <td><p>synchronous</p></td>
        <td><p>eventual</p></td>
        <td><p>choreographed</p></td>
        <td><p>medium</p></td>
        </tr>
        <tr>
        <td><p>Fantasy Fiction Saga<sup>(aao)</sup></p></td>
        <td><p>asynchronous</p></td>
        <td><p>atomic</p></td>
        <td><p>orchestrated</p></td>
        <td><p>high</p></td>
        </tr>
        <tr>
        <td><p>Horror Story<sup>(aac)</sup></p></td>
        <td><p>asynchronous</p></td>
        <td><p>atomic</p></td>
        <td><p>choreographed</p></td>
        <td><p>medium</p></td>
        </tr>
        <tr>
        <td><p>Parallel Saga<sup>(aeo)</sup></p></td>
        <td><p>asynchronous</p></td>
        <td><p>eventual</p></td>
        <td><p>orchestrated</p></td>
        <td><p>low</p></td>
        </tr>
        <tr>
        <td><p>Anthology Saga<sup>(aec)</sup></p></td>
        <td><p>asynchronous</p></td>
        <td><p>eventual</p></td>
        <td><p>choreographed</p></td>
        <td><p>very low</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>To fully understand this matrix, we must first investigate each of the dimensions individually. Therefore, the following chapters help you build context to understand the individual trade-offs for communication, consistency, and coordination, then entangle them back together in <a data-type="xref" href="ch12.html#ch12-transactional-sagas">Chapter&nbsp;12</a>.<a data-type="indexterm" data-startref="ch02-dqc" id="idm45978857138368"></a><a data-type="indexterm" data-startref="ch02-dqc2" id="idm45978857137664"></a></p>
        
        <p>In the remaining chapters in <a data-type="xref" href="part01.html#part1-pulling-things-apart">Part&nbsp;I</a>, we focus on static coupling and understanding the various dimensions at play in distributed architectures, including data ownership,  transactionality, and service granularity. In <a data-type="xref" data-xrefstyle="chap-num-title" href="part02.html#part2-putting-things-back-together">Part&nbsp;II, “Putting Things Back Together”</a>, we focus on dynamic coupling and understanding communication patterns in 
        <span class="keep-together">microservices</span>.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Sysops Squad Saga: Understanding Quanta"><div class="sect1" id="idm45978852052480">
        <h1>Sysops Squad Saga: Understanding Quanta</h1>
        
        <p><code>Tuesday, November 23, 14:32</code></p>
        <div class="story">
        
        <p>Austen came to Addison’s office wearing an uncharacteristic cross expression.<a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="architecture quantum" id="idm45978857130624"></a><a data-type="indexterm" data-primary="architecture quantum" data-secondary="Sysops Squad saga" id="idm45978857129648"></a><a data-type="indexterm" data-primary="coupling" data-secondary="architecture quantum" data-tertiary="Sysops Squad saga" id="idm45978857128704"></a> “Hey, Addison, can I bother you for a minute?”</p>
        
        <p>“Sure, what’s up?”</p>
        
        <p>“I’ve been reading about this architecture quantum stuff, and I just…don’t…get…it!”</p>
        
        <p>Addison laughed, “I know what you mean. I struggled with it when it was purely abstract, but when you ground it in practical things, it turns out to be a useful set of 
        <span class="keep-together">perspectives</span>.”</p>
        
        <p>“What do you mean?”</p>
        
        <p>“Well,” said Addison, “the architecture quantum basically defines a DDD <a data-type="indexterm" data-primary="DDD" data-see="Domain-Driven Design" id="idm45978857124208"></a><a data-type="indexterm" data-primary="Domain-Driven Design (DDD)" data-secondary="bounded context" data-tertiary="architecture quantum" id="idm45978857123232"></a><a data-type="indexterm" data-primary="bounded context in microservices" data-secondary="architecture quantum versus" id="idm45978857121952"></a><a data-type="indexterm" data-primary="microservices" data-secondary="bounded context" data-tertiary="architecture quantum versus" id="idm45978857120976"></a>bounded context in architectural terms.”</p>
        
        <p>“Why not just use bounded context, then?” asked Austen.</p>
        
        <p>“Bounded context has a specific definition in DDD, and overloading it with stuff about architecture just makes people constantly have to differentiate. They are similar, but not the same thing. The first part about <em>functional cohesion</em> and <em>independent deployment</em> certainly matches a service based on bounded context. <a data-type="indexterm" data-primary="coupling" data-secondary="about static versus dynamic" data-tertiary="Sysops Squad saga" id="idm45978857117584"></a><a data-type="indexterm" data-primary="static coupling" data-secondary="architecture quantum" data-tertiary="Sysops Squad saga" id="idm45978857116368"></a><a data-type="indexterm" data-primary="dynamic coupling" data-secondary="static versus" data-tertiary="Sysops Squad saga" id="idm45978857115152"></a><a data-type="indexterm" data-primary="static coupling" data-secondary="dynamic versus" data-tertiary="Sysops Squad saga" id="idm45978857113936"></a>But the architecture quantum definition goes further by identifying types of coupling—that’s where the <em>static</em> and <em>dynamic</em> stuff comes in.”</p>
        
        <p>“What is that all about? Isn’t <em>coupling</em> just <em>coupling</em>? Why make the distinction?”</p>
        
        <p>“It turns out that a bunch of different concerns revolve around the different types,” said Addison. “Let’s take the <em>static</em> one first, which I like to think of as how things are wired together. Another way to think about it: consider one of the services we’re building in our target architecture. What is all the wiring required to bootstrap that service?”</p>
        
        <p>“Well, it’s written in Java, using a Postgres database, and running in Docker—that’s it, right?”</p>
        
        <p>“You’re missing a lot.” said Addison. “What if you had to build that service from scratch, assuming we had nothing in place? It’s Java, but also using SpringBoot and, what, about 15 or 20 different frameworks and libraries?”</p>
        
        <p>“That’s right, we can look in the Maven POM file to figure out all those dependencies. What else?”</p>
        
        <p>“The idea behind <em>static quantum coupling</em> is the wiring required to function. <a data-type="indexterm" data-primary="broker style event-driven architecture quantum" id="idm45978857107056"></a><a data-type="indexterm" data-primary="event-driven architecture (EDA)" data-secondary="single architecture quantum" data-tertiary="broker style as" id="idm45978857106256"></a>We’re using events to communicate between services—what about the event broker?”</p>
        
        <p>“But isn’t that the dynamic part?”</p>
        
        <p>“Not the <em>presence</em> of the broker. If the service (or, more broadly, architecture quantum) I want to bootstrap utilizes a message broker to function, the broker must be present. When the service <em>calls</em> another service via the broker, we get into the dynamic side.”</p>
        
        <p>“OK, that makes sense,” said Austen. “If I think about what it would take to bootstrap it from scratch, that’s the static quantum coupling.”</p>
        
        <p>“That’s right. And just that information is super useful. We recently built a diagram of the static quantum coupling for each of our services defensively.”</p>
        
        <p>Austen laughed. “Defensively? What do you…”</p>
        
        <p>“We were performing a reliability analysis to determine if I change this <em>thing</em>, what might break, where <em>thing</em> could be anything in our architecture or operations. They’re trying to do risk mitigation—if we change a service, they want to know what must be tested.”</p>
        
        <p>“I see—that’s the static quantum coupling. I can see how that’s a useful view. It also shows how teams might impact one another. That seems really useful. Is there a tool we can download that figures that out for us?”</p>
        
        <p>“Wouldn’t that be nice!” laughed Addison. “Unfortunately, no one with our unique mix of architecture has built and open sourced exactly the tool we want. However, some of the platform team is working on a tool to automate it, necessarily customized to our architecture. They’re using the container manifests, POM files, NPM dependencies, and other dependency tools to build and maintain a list of build dependencies. We have also instituted observability for all our services, so we now have consistent log files about what systems call each other, when, and how often. They’re using that to build a call graph to see how things are connected.”</p>
        
        <p>“OK, so static coupling is how things are wired together. What about <em>dynamic</em> coupling?”</p>
        
        <p>“Dynamic coupling concerns how quanta <em>communicate</em> with each other,<a data-type="indexterm" data-primary="dynamic coupling" data-secondary="communication" id="idm45978857097264"></a><a data-type="indexterm" data-primary="communication" data-secondary="about synchronous versus asynchronous" id="idm45978857096256"></a><a data-type="indexterm" data-primary="synchronous communication" data-secondary="asynchronous versus" id="idm45978857095248"></a><a data-type="indexterm" data-primary="asynchronous communication" data-secondary="synchronous versus" id="idm45978857094288"></a> particularly synchronous versus asynchronous calls and their impact on operational architecture characteristics—things like performance, scale, elasticity, reliability, and so on. Consider <em>elasticity</em> for a moment—remember the difference between scalability and elasticity?”</p>
        
        <p>Austen smirked. “I didn’t know there was going to be a test. <a data-type="indexterm" data-primary="elasticity" data-secondary="scalability versus" id="idm45978857092192"></a><a data-type="indexterm" data-primary="scalability" data-secondary="elasticity versus" id="idm45978857091136"></a>Let’s see…<em>scalability</em> is the ability to support a large number of concurrent users; <em>elasticity</em> is the ability to support a burst of user requests in a short time frame.”</p>
        
        <p>“Correct! Gold star for you. OK, let’s think about <em>elasticity</em>. Suppose<a data-type="indexterm" data-primary="elasticity" data-secondary="coupling" id="idm45978857088256"></a> in our future state architecture we have two services like Ticketing and Assignment, and the two types of calls. We carefully designed our services to be highly statically decoupled from one another, so that they can be independently elastic. That’s the other side effect of static coupling, by the way—it identifies the scope of things like operational architecture characteristics. Let’s say that Ticketing is operating at 10 times the elastic scale of Assignment, and we need to make a call between them. If we make a synchronous call, the whole workflow will bog down, as the caller waits for the slower service to process and return. If on the other hand we make an asynchronous call, using the message queue as a buffer, we can allow the two services to execute operationally independently, allowing the caller to add messages to the queue and continue working, receiving notification when the workflow is complete.”</p>
        
        <p>“Oh, I see, I see! The architecture quantum defines the scope of architecture characteristics—it’s obvious how the static coupling can affect that. But I see now that, depending on the type of call you make, you might temporarily couple two services together.”</p>
        
        <p>“That’s right,” said Addison. “The architecture quanta can entangle one another temporarily, during the course of a call, if the nature of the call ties things like performance, responsiveness, scale, and a bunch of others.”</p>
        
        <p>“OK, I think I understand what an architecture quantum is, and how the coupling definitions work. But I’m never going to get that quantum/quanta thing straight!”</p>
        
        <p>“Same for datum/data, but no one ever uses datum!” laughed Addison. “You’ll see a lot more of the impact of dynamic coupling on workflows and transactional sagas as you keep digging into our architecture.”</p>
        
        <p>“I can’t wait!”</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492086888/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com