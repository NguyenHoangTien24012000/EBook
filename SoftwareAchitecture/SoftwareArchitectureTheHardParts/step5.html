<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 5. Component-Based Decomposition Patterns"><div class="chapter" id="ch05-decomposition-patterns">
        <h1><span class="label">Chapter 5. </span>Component-Based Decomposition Patterns</h1>
        
        
        <p id="ss-decomp-patterns-intro"><code>Monday, November 1, 11:53</code></p>
        <div class="story">
        
        <p>Addison and Austen chose to use the component-based decomposition approach, <a data-type="indexterm" data-primary="Identify and Size Components pattern" data-secondary="Sysops Squad saga" id="idm45978853579424"></a><a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="decomposition pattern" id="idm45978853578384"></a>but were unsure about the details of each decomposition pattern. They tried to research this approach, but did not find much on the internet about it. Once again, they met with Logan in the conference room for advice on what these patterns are all about and how to use them.</p>
        
        <p>“Listen, Logan,” said Addison, “I want to start out by saying we both really appreciate the amount of time you have been spending with us to get this migration process started. I know you’re super busy on your own firefights.”</p>
        
        <p>“No problem,” said Logan. “Us firefighters have to stick together. I’ve been in your shoes before, so I know what it’s like flying blind on these sort of things. Besides, this is a highly visible migration effort, and it’s important you both get this thing right the first time. Because there won’t be a second time.”</p>
        
        <p>“Thanks, Logan,” said Austen. “I’ve got a game in about two hours, so we’ll try to make this short. You talked earlier about component-based decomposition, and we chose that approach, but we aren’t able to find much about it on the internet.”</p>
        
        <p>“I’m not surprised,” said Logan. “Not much has been written about them yet, but I know a book is coming out describing these patterns in detail sometime later this year. I first learned about these decomposition patterns at a conference about four years ago in a session with an experienced software architect. I was really impressed with the iterative and methodical approach to safely move from a monolithic architecture to a distributed one like service-based architecture and microservices. Since then I’ve been using these patterns with quite a bit of success.”</p>
        
        <p>“Can you show us how these patterns work?” asked Addison.</p>
        
        <p>“Sure,” said Logan. “Let’s take it one pattern at a time.”</p>
        <hr>
        </div>
        
        <p>Component-based decomposition (introduced in <a data-type="xref" href="ch04.html#ch04-architectural-decomposition">Chapter&nbsp;4</a>) is a <a data-type="indexterm" data-primary="component-based decomposition" data-secondary="about" id="idm45978853571696"></a><a data-type="indexterm" data-primary="architectural decomposition" data-secondary="component-based" data-tertiary="about" id="idm45978853570704"></a><a data-type="indexterm" data-primary="architectural decomposition" data-secondary="component-based" data-tertiary="about patterns" id="idm45978853569472"></a><a data-type="indexterm" data-primary="component-based decomposition" data-secondary="patterns" data-tertiary="about" id="idm45978853568240"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="patterns for migration to service-based" data-tertiary="about" id="idm45978853567008"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="monolithic migration to" data-tertiary="about" id="idm45978853565760"></a>highly effective technique for breaking apart a monolithic application when the codebase is somewhat structured and grouped by namespaces (or directories). This chapter introduces a set of patterns, known as <em>component-based decomposition patterns</em>, that describe the refactoring of monolithic source code to arrive at a set of well-defined components that can eventually become services. These decomposition patterns significantly ease the effort of migrating monolithic applications to distributed architectures.</p>
        
        <p><a data-type="xref" href="#fig-decomposition-patterns-roadmap-alt">Figure 5-1</a> shows the road map for the component-based decomposition patterns described in this chapter and how they are used together to break apart a monolithic application. Initially, these patterns are used together in sequence when moving a monolithic application to a distributed one, and then individually as maintenance is applied to the monolithic application during migration. These decomposition patterns are summarized as follows:</p>
        <dl>
        <dt><a data-type="xref" href="#sec-pattern-identify-size">“Identify and Size Components Pattern”</a></dt>
        <dd>
        <p>Typically the first pattern applied when breaking apart a monolithic application. This pattern is used to identify, manage, and properly size components.</p>
        </dd>
        <dt><a data-type="xref" href="#sec-pattern-gather-common">“Gather Common Domain Components Pattern”</a></dt>
        <dd>
        <p>Used to consolidate common business domain logic that might be duplicated across the application, reducing the number of potentially duplicate services in the resulting distributed architecture.</p>
        </dd>
        <dt><a data-type="xref" href="#sec-pattern-flatten">“Flatten Components Pattern”</a></dt>
        <dd>
        <p>Used to collapse or expand domains, subdomains, and components, thus ensuring that source code files reside only within well-defined components.</p>
        </dd>
        <dt><a data-type="xref" href="#sec-pattern-dependencies">“Determine Component Dependencies Pattern”</a></dt>
        <dd>
        <p>Used to identify component dependencies, refine those dependencies, and determine the feasibility and overall level of effort for a migration from a monolithic architecture to a distributed one.</p>
        </dd>
        <dt><a data-type="xref" href="#sec-pattern-create-domains">“Create Component Domains Pattern”</a></dt>
        <dd>
        <p>Used to group components into logical domains within the application and to refactor component namespaces and/or directories to align with a particular domain.</p>
        </dd>
        <dt><a data-type="xref" href="#sec-pattern-domain-services">“Create Domain Services Pattern”</a></dt>
        <dd>
        <p>Used to physically break apart a monolithic architecture by moving logical domains within the monolithic application to separately deployed domain 
        <span class="keep-together">services</span>.</p>
        </dd>
        </dl>
        
        <figure><div id="fig-decomposition-patterns-roadmap-alt" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0501.png" alt="Decomposition Pattern Flow" width="600" height="626">
        <h6><span class="label">Figure 5-1. </span>Component-based decomposition pattern flow and usage</h6>
        </div></figure>
        
        <p>Each pattern described in this chapter is divided into three sections. The first section, “Pattern Description,” describes how the pattern works, why the pattern is important, and what the outcome is of applying the pattern. Knowing that most systems are moving targets during a migration, the second section, “Fitness Functions for Governance,” describes the automated governance that can be used after applying the pattern to continually analyze and verify the correctness of the codebase during ongoing maintenance. The third section uses the real-world Sysops Squad application (see <a data-type="xref" href="ch01.html#sec-sysops-squad">“Introducing the Sysops Squad Saga”</a>) to illustrate the use of the pattern and illustrate the transformations of the application after the pattern has been applied.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar-architecture-stories">
        <h5>Architecture Stories</h5>
        <p>Throughout this chapter, we will be using architecture stories as a <a data-type="indexterm" data-primary="architectural decomposition" data-secondary="component-based" data-tertiary="architecture stories" id="idm45978853543936"></a><a data-type="indexterm" data-primary="component-based decomposition" data-secondary="patterns" data-tertiary="architecture stories" id="idm45978853542592"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="patterns for migration to service-based" data-tertiary="architecture stories" id="idm45978851655568"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="monolithic migration to" data-tertiary="architecture stories" id="idm45978851654320"></a><a data-type="indexterm" data-primary="architecture stories" id="idm45978851653088"></a>way of recording and describing code refactoring that impacts the structural aspect of the application for each of the Sysops Squad sagas. Unlike <em>user stories</em>, which describe a feature that needs to be implemented or changed, an <em>architecture story</em> describes particular code refactoring that impacts the overall structure of an application and satisfies some sort of business driver (such as increased scalability, better time-to-market, etc.). For example, if an architect sees the need to break apart a payment service to support better overall extensibility for adding additional payment types, a new architecture story would be created and read as follows:</p>
        
        <p><em>As an architect, I need to decouple the payment service to support better extensibility and agility when adding additional payment types</em>.</p>
        
        <p>We view architecture stories as separate from <em>technical debt</em> stories. Technical debt stories usually capture things a developer needs to do in a later iteration to “clean up the code,” whereas an architecture story captures something that needs to change quickly to support a particular architectural characteristic or business need.</p>
        </div></aside>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Identify and Size Components Pattern"><div class="sect1" id="sec-pattern-identify-size">
        <h1>Identify and Size Components Pattern</h1>
        
        <p>The first step in any monolithic migration is to apply the <em>Identify and Size Components</em> pattern.<a data-type="indexterm" data-primary="components" data-secondary="Identify and Size Components pattern" id="ch05-idsz7"></a><a data-type="indexterm" data-primary="Identify and Size Components pattern" id="ch05-idsz"></a><a data-type="indexterm" data-primary="architectural decomposition" data-secondary="component-based" data-tertiary="identify and size components" id="ch05-idsz2"></a><a data-type="indexterm" data-primary="component-based decomposition" data-secondary="patterns" data-tertiary="identify and size components" id="ch05-idsz3"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="patterns for migration to service-based" data-tertiary="identify and size components" id="ch05-idsz5"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="monolithic migration to" data-tertiary="identify and size components" id="ch05-idsz6"></a> The purpose of this pattern is to identify and catalog the architectural components (logical building blocks) of the application and then properly size the components.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Pattern Description"><div class="sect2" id="idm45978851637568">
        <h2>Pattern Description</h2>
        
        <p>Because services are built from components, it is critical to not only identify the components within an application, but to properly size them as well. This pattern is used to identify components that are either too big (doing too much) or too small (not doing enough). Components that are too large relative to other components are generally more coupled to other components, are harder to break into separate services, and lead to a less modular architecture.</p>
        
        <p>Unfortunately, it is difficult to determine the size of a component. The number of source files, classes, and total lines of code are not good metrics because every programmer designs classes, methods, and functions differently. <a data-type="indexterm" data-primary="statements counted" id="idm45978851635376"></a><a data-type="indexterm" data-primary="components" data-secondary="size determination" id="idm45978851634672"></a>One metric we’ve found useful for component sizing is calculating the total number of statements within a given component (the sum of statements within all source files contained within a namespace or directory). A <em>statement</em> is a single complete action performed in the source code, usually terminated by a special character (such as a semicolon in languages such as Java, C, C++, C#, Go, and JavaScript; or a newline in languages such as F#, Python, and Ruby). While not a perfect metric, at least it’s a good indicator of how much the component is doing and how complex the component is.</p>
        
        <p>Having a relatively consistent component size within an application is important. Generally speaking, the size of components in an application should fall between one to two standard deviations from the average (or mean) component size. In addition, the percentage of code represented by each component should be somewhat evenly distributed between application components and not vary significantly.</p>
        
        <p>While many <a href="https://oreil.ly/XyIgr">static code analysis tools</a> <a data-type="indexterm" data-primary="resources online" data-secondary="static code analysis tools" id="idm45978851631424"></a><a data-type="indexterm" data-primary="static code analysis tools resource" id="idm45978851630384"></a><a data-type="indexterm" data-primary="tools" data-secondary="static code analysis" id="idm45978851629696"></a> can show the number of statements within a source file, many of them don’t accumulate total statement by <em>component</em>. Because of this, the architect usually must perform manual or automated post-processing to accumulate total statements by component and then calculate the percentage of code that component represents.</p>
        
        <p>Regardless of the tools or algorithms used, the important information and metrics to gather and calculate for this pattern are shown in <a data-type="xref" href="#table-ss-defs">Table&nbsp;5-1</a> and are defined in the following list.</p>
        <table id="table-ss-defs" style="width: 90%">
        <caption><span class="label">Table 5-1. </span>Component inventory and component size analysis example</caption>
        <thead>
        <tr>
        <th>Component name</th>
        <th>Component namespace</th>
        <th>Percent</th>
        <th>Statements</th>
        <th>Files</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Billing Payment</p></td>
        <td><p><code>ss.billing.payment</code></p></td>
        <td><p>5</p></td>
        <td><p>4,312</p></td>
        <td><p>23</p></td>
        </tr>
        <tr>
        <td><p>Billing History</p></td>
        <td><p><code>ss.billing.history</code></p></td>
        <td><p>4</p></td>
        <td><p>3,209</p></td>
        <td><p>17</p></td>
        </tr>
        <tr>
        <td><p>Customer Notification</p></td>
        <td><p><code>ss.customer.notification</code></p></td>
        <td><p>2</p></td>
        <td><p>1,433</p></td>
        <td><p>7</p></td>
        </tr>
        </tbody>
        </table>
        <dl>
        <dt>Component name</dt>
        <dd>
        <p>A descriptive name and identifier of the component that is<a data-type="indexterm" data-primary="components" data-secondary="names" id="idm45978851608640"></a> consistent throughout application diagrams and documentation. The component name should be clear enough to be as self-describing as possible. For example, the component Billing History shown in <a data-type="xref" href="#table-ss-defs">Table&nbsp;5-1</a> is clearly a component that contains source code files used to manage a customer’s billing history. If the distinct role and responsibility of the component isn’t immediately identifiable, consider changing the component (and potentially the corresponding namespace) to a more descriptive one. For example, a component named Ticket Manager leaves too many unanswered questions about its role and responsibility in the system, and should be renamed to better describe its role.</p>
        </dd>
        <dt>Component namespace</dt>
        <dd>
        <p>The physical (or logical) identification of the component representing where the <a data-type="indexterm" data-primary="components" data-secondary="namespaces" id="idm45978851604944"></a><a data-type="indexterm" data-primary="namespaces" data-secondary="components" id="idm45978851603968"></a>source code files implementing that component are grouped and stored. This identifier is usually denoted through a namespace, package structure (Java), or directory structure. When a directory structure is used to denote the component, we usually convert the file separator to a dot (.) and create a corresponding 
        <span class="keep-together">logical</span> namespace. For example, the component namespace for source code files in the <em>ss/customer/notification</em> directory structure would have the namespace value <code>ss.customer.notification</code>. Some languages require that the namespace match the directory structure (such as Java with a <em>package</em>), whereas other languages (such as C# with a <em>namespace</em>) do not enforce this constraint. Whatever namespace identifier is used, make sure the type of identifier is consistent across all of the components in the application.</p>
        </dd>
        <dt>Percent</dt>
        <dd>
        <p>The relative size of the component based on its percentage of the overall source code containing that component. The percent metric is helpful in identifying components that appear too large or too small in the overall application. This metric is calculated by taking the total number of statements within the source code files representing that component and dividing that number by the total number of statements in the entire codebase of the application. For example, the percent value of 5 for the <code>ss.billing.payment</code> component in <a data-type="xref" href="#table-ss-defs">Table&nbsp;5-1</a> means that this component constitutes 5% of the overall codebase.</p>
        </dd>
        <dt>Statements</dt>
        <dd>
        <p>The sum of the total number of source code statements in all source files contained within that component. This metric is useful for determining not only the relative size of the components within an application, but also for determining the overall complexity of the component. For example, a seemingly simple single-purpose component named Customer Wishlist might have a total of 12,000 statements, indicating that the processing of wish list items is perhaps more complex than it looks. This metric is also necessary for calculating the percent metric previously described.</p>
        </dd>
        <dt>Files</dt>
        <dd>
        <p>The total number of source code files (such as classes, interfaces, types, and so on) that are contained within the component. While this metric has little to do with the size of a component, it does provide additional information about the component from a class structure standpoint. For example, a component with 18,409 statements and only 2 files is a good candidate for refactoring into smaller, more contextual classes.</p>
        </dd>
        </dl>
        
        <p>When resizing a large component, we recommend using a functional decomposition approach or a domain-driven approach to identify subdomains that might exist within the large component. For example, assume the Sysops Squad application has a Trouble Ticket component containing 22% of the codebase that is responsible for ticket creation, assignment, routing, and completion. In this case, it might make sense to break the single Trouble Ticket component into four separate components (Ticket Creation, Ticket Assignment, Ticket Routing, and Ticket Completion), reducing the percentage of code each component represents, therefore creating a more modular application. If no clear subdomains exist within a large component, then leave the component as is.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Fitness Functions for Governance"><div class="sect2" id="idm45978851594336">
        <h2>Fitness Functions for Governance</h2>
        
        <p>Once this decomposition pattern has been applied and components<a data-type="indexterm" data-primary="components" data-secondary="Identify and Size Components pattern" data-tertiary="fitness functions" id="ch05-pff14"></a><a data-type="indexterm" data-primary="Identify and Size Components pattern" data-secondary="fitness functions" id="ch05-pff13"></a><a data-type="indexterm" data-primary="fitness functions for governance" data-secondary="patterns for component-based decomposition" data-tertiary="identify and size components" id="ch05-pff12"></a> have been identified and sized correctly, it’s important to apply some sort of automated governance to identify new components and to ensure components don’t get too large during normal application maintenance and create unwanted or unintended dependencies. Automated holistic fitness functions can be triggered during deployment to alert the architect if specified constraints are exceeded (such as the percent metric discussed previously or use of standard deviations to identify outliers).</p>
        
        <p>Fitness functions can be implemented through custom-written code or through the use of open source or COTS tools as part of a CI/CD pipeline. Some of the automated fitness functions that can be used to help govern this decomposition pattern are as follows.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: Maintain component inventory"><div class="sect3" id="idm45978851587536">
        <h3>Fitness function: Maintain component inventory</h3>
        
        <p>This automated holistic fitness function, usually triggered on deployment through a CI/CD pipeline, helps keep the inventory of components current. It’s used to alert an architect of components that might have been added or removed by the development team. Identifying new or removed components is not only critical for this pattern, but for the other decomposition patterns as well. <a data-type="xref" href="#source-ff-inventory">Example&nbsp;5-1</a> shows the pseudocode and algorithm for one possible implementation of this fitness function.</p>
        <div id="source-ff-inventory" data-type="example">
        <h5><span class="label">Example 5-1. </span>Pseudocode for maintaining component inventory</h5>
        
        <pre data-type="programlisting" data-code-language="perl"><code class="c1"># Get prior component namespaces that are stored in a datastore</code>
        <code class="n">LIST</code> <code class="n">prior_list</code> <code class="o">=</code> <code class="n">read_from_datastore</code><code class="p">()</code>
        
        <code class="c1"># Walk the directory structure, creating namespaces for each complete path</code>
        <code class="n">LIST</code> <code class="n">current_list</code> <code class="o">=</code> <code class="n">identify_components</code><code class="p">(</code><code class="n">root_directory</code><code class="p">)</code>
        
        <code class="c1"># Send an alert if new or removed components are identified</code>
        <code class="n">LIST</code> <code class="n">added_list</code> <code class="o">=</code> <code class="n">find_added</code><code class="p">(</code><code class="n">current_list</code><code class="p">,</code> <code class="n">prior_list</code><code class="p">)</code>
        <code class="n">LIST</code> <code class="n">removed_list</code> <code class="o">=</code> <code class="n">find_removed</code><code class="p">(</code><code class="n">current_list</code><code class="p">,</code> <code class="n">prior_list</code><code class="p">)</code>
        <code class="n">IF</code> <code class="n">added_list</code> <code class="n">NOT</code> <code class="n">EMPTY</code> <code class="p">{</code>
          <code class="n">add_to_datastore</code><code class="p">(</code><code class="n">added_list</code><code class="p">)</code>
          <code class="n">send_alert</code><code class="p">(</code><code class="n">added_list</code><code class="p">)</code>
        <code class="p">}</code>
        <code class="n">IF</code> <code class="n">removed_list</code> <code class="n">NOT</code> <code class="n">EMPTY</code> <code class="p">{</code>
          <code class="n">remove_from_datastore</code><code class="p">(</code><code class="n">removed_list</code><code class="p">)</code>
          <code class="n">send_alert</code><code class="p">(</code><code class="n">removed_list</code><code class="p">)</code>
        <code class="p">}</code></pre></div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: No component shall exceed <some percent> of the overall codebase"><div class="sect3" id="idm45978855011936">
        <h3>Fitness function: No component shall exceed &lt;some percent&gt; of the overall codebase</h3>
        
        <p>This automated holistic fitness function, usually triggered on deployment through a CI/CD pipeline, identifies components that exceed a given threshold in terms of the percentage of overall source code represented by that component, and alerts the architect if any component exceeds that threshold. As mentioned earlier in this chapter, the threshold percentage value will vary depending on the size of the application, but should be set so as to identify significant outliers. For example, for a relatively small application with only 10 components, setting the percentage threshold to something like 30% would sufficiently identify a component that is too large, whereas for a large application with 50 components, a threshold of 10% would be more appropriate. <a data-type="xref" href="#source-ff-percent">Example&nbsp;5-2</a> shows the pseudocode and algorithm for one possible implementation of this fitness function.</p>
        <div id="source-ff-percent" data-type="example">
        <h5><span class="label">Example 5-2. </span>Pseudocode for maintaining component size based on percent of code</h5>
        
        <pre data-type="programlisting" data-code-language="perl"><code class="c1"># Walk the directory structure, creating namespaces for each complete path</code>
        <code class="n">LIST</code> <code class="n">component_list</code> <code class="o">=</code> <code class="n">identify_components</code><code class="p">(</code><code class="n">root_directory</code><code class="p">)</code>
        
        <code class="c1"># Walk through all of the source code to accumulate total statements</code>
        <code class="n">total_statements</code> <code class="o">=</code> <code class="n">accumulate_statements</code><code class="p">(</code><code class="n">root_directory</code><code class="p">)</code>
        
        <code class="c1"># Walk through the source code for each component, accumulating statements</code>
        <code class="c1"># and calculating the percentage of code each component represents. Send</code>
        <code class="c1"># an alert if greater than 10%</code>
        <code class="n">FOREACH</code> <code class="n">component</code> <code class="n">IN</code> <code class="n">component_list</code> <code class="p">{</code>
          <code class="n">component_statements</code> <code class="o">=</code> <code class="n">accumulate_statements</code><code class="p">(</code><code class="n">component</code><code class="p">)</code>
          <code class="n">percent</code> <code class="o">=</code> <code class="n">component_statements</code> <code class="o">/</code> <code class="n">total_statements</code>
          <code class="n">IF</code> <code class="n">percent</code> <code class="o">&gt;</code> <code class="mf">.10</code> <code class="p">{</code>
            <code class="n">send_alert</code><code class="p">(</code><code class="n">component</code><code class="p">,</code> <code class="n">percent</code><code class="p">)</code>
          <code class="p">}</code>
        <code class="p">}</code></pre></div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: No component shall exceed <some number of standard deviations> from the mean component size"><div class="sect3" id="idm45978848472832">
        <h3>Fitness function: No component shall exceed &lt;some number of standard deviations&gt; from the mean component size</h3>
        
        <p>This automated holistic fitness function, usually triggered on deployment through a CI/CD pipeline, identifies components that exceed a given threshold in terms of the number of standard deviations from the mean of all component sizes (based on the total number of statements in the component), and alerts the architect if any component exceeds that threshold.</p>
        
        <p>Standard deviation is a useful means of determining outliers in terms of component size.<a data-type="indexterm" data-primary="standard deviation calculation" id="idm45978848378336"></a> Standard deviation is calculated as follows:</p>
        <div data-type="equation">
        <mjx-container class="MathJax CtxtMenu_Attached_0" jax="SVG" display="true" tabindex="0" ctxtmenu_counter="11" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="28.997ex" height="5.566ex" role="img" focusable="false" viewBox="0 -1662.3 12816.7 2460" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -1.805ex;"><defs><path id="MJX-12-TEX-I-1D460" d="M131 289Q131 321 147 354T203 415T300 442Q362 442 390 415T419 355Q419 323 402 308T364 292Q351 292 340 300T328 326Q328 342 337 354T354 372T367 378Q368 378 368 379Q368 382 361 388T336 399T297 405Q249 405 227 379T204 326Q204 301 223 291T278 274T330 259Q396 230 396 163Q396 135 385 107T352 51T289 7T195 -10Q118 -10 86 19T53 87Q53 126 74 143T118 160Q133 160 146 151T160 120Q160 94 142 76T111 58Q109 57 108 57T107 55Q108 52 115 47T146 34T201 27Q237 27 263 38T301 66T318 97T323 122Q323 150 302 164T254 181T195 196T148 231Q131 256 131 289Z"></path><path id="MJX-12-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-12-TEX-S3-221A" d="M424 -948Q422 -947 313 -434T202 80L170 31Q165 24 157 10Q137 -21 137 -21Q131 -16 124 -8L111 5L264 248L473 -720Q473 -717 727 359T983 1440Q989 1450 1001 1450Q1007 1450 1013 1445T1020 1433Q1020 1425 742 244T460 -941Q458 -950 439 -950H436Q424 -950 424 -948Z"></path><path id="MJX-12-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-12-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-12-TEX-N-2212" d="M84 237T84 250T98 270H679Q694 262 694 250T679 230H98Q84 237 84 250Z"></path><path id="MJX-12-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-12-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-12-TEX-N-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path><path id="MJX-12-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-12-TEX-S4-AF" d="M69 544V590H430V544H69Z"></path><path id="MJX-12-TEX-N-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path><path id="MJX-12-TEX-N-32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mi"><use data-c="1D460" xlink:href="#MJX-12-TEX-I-1D460"></use></g><g data-mml-node="mo" transform="translate(746.8,0)"><use data-c="3D" xlink:href="#MJX-12-TEX-N-3D"></use></g><g data-mml-node="msqrt" transform="translate(1802.6,0)"><g transform="translate(1020,0)"><g data-mml-node="mrow"><g data-mml-node="mfrac"><g data-mml-node="mn" transform="translate(1275.2,676)"><use data-c="31" xlink:href="#MJX-12-TEX-N-31"></use></g><g data-mml-node="mrow" transform="translate(220,-686)"><g data-mml-node="mi"><use data-c="1D441" xlink:href="#MJX-12-TEX-I-1D441"></use></g><g data-mml-node="mo" transform="translate(1110.2,0)"><use data-c="2212" xlink:href="#MJX-12-TEX-N-2212"></use></g><g data-mml-node="mn" transform="translate(2110.4,0)"><use data-c="31" xlink:href="#MJX-12-TEX-N-31"></use></g></g><rect width="2810.4" height="60" x="120" y="220"></rect></g><g data-mml-node="msubsup" transform="translate(3217.1,0)"><g data-mml-node="mo"><use data-c="2211" xlink:href="#MJX-12-TEX-LO-2211"></use></g><g data-mml-node="mi" transform="translate(1477,677.1) scale(0.707)"><use data-c="1D441" xlink:href="#MJX-12-TEX-I-1D441"></use></g><g data-mml-node="mrow" transform="translate(1477,-485.4) scale(0.707)"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-12-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="3D" xlink:href="#MJX-12-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123,0)"><use data-c="31" xlink:href="#MJX-12-TEX-N-31"></use></g></g></g><g data-mml-node="msup" transform="translate(6058.4,0)"><g data-mml-node="mrow"><g data-mml-node="mo"><use data-c="28" xlink:href="#MJX-12-TEX-N-28"></use></g><g data-mml-node="msub" transform="translate(389,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-12-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-12-TEX-I-1D456"></use></g></g><g data-mml-node="mo" transform="translate(1510.2,0)"><use data-c="2212" xlink:href="#MJX-12-TEX-N-2212"></use></g><g data-mml-node="mover" transform="translate(2510.4,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-12-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(27.8,3)"><svg width="572" height="246" x="0" y="444" viewBox="143 444 572 246"><use data-c="AF" xlink:href="#MJX-12-TEX-S4-AF" transform="scale(1.716,1)"></use></svg></g></g><g data-mml-node="mo" transform="translate(3110.2,0)"><use data-c="29" xlink:href="#MJX-12-TEX-N-29"></use></g></g><g data-mml-node="mn" transform="translate(3532.2,477.1) scale(0.707)"><use data-c="32" xlink:href="#MJX-12-TEX-N-32"></use></g></g></g></g><g data-mml-node="mo" transform="translate(0,152.3)"><use data-c="221A" xlink:href="#MJX-12-TEX-S3-221A"></use></g><rect width="9994.2" height="60" x="1020" y="1542.3"></rect></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="s equals StartRoot StartFraction 1 Over upper N minus 1 EndFraction sigma-summation Underscript i equals 1 Overscript upper N Endscripts left-parenthesis x Subscript i Baseline minus x overbar right-parenthesis squared EndRoot" display="block"><mrow><mi>s</mi><mo>=</mo><msqrt><mrow><mfrac><mn>1</mn><mrow><mi>N</mi><mo>-</mo><mn>1</mn></mrow></mfrac><msubsup><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><msup><mrow><mo>(</mo><msub><mi>x</mi><mi>i</mi></msub><mo>-</mo><mover accent="true"><mi>x</mi><mo>¯</mo></mover><mo>)</mo></mrow><mn>2</mn></msup></mrow></msqrt></mrow></math></mjx-assistive-mml></mjx-container>
        </div>
        
        <p>where <em>N</em> is the number of observed values, <mjx-container class="MathJax CtxtMenu_Attached_0" jax="SVG" tabindex="0" ctxtmenu_counter="12" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="2.034ex" height="1.357ex" role="img" focusable="false" viewBox="0 -442 899 599.8" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.357ex;"><defs><path id="MJX-13-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-13-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-13-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-13-TEX-I-1D456"></use></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="x Subscript i"><msub><mi>x</mi><mi>i</mi></msub></math></mjx-assistive-mml></mjx-container> is the observed values, and <mjx-container class="MathJax CtxtMenu_Attached_0" jax="SVG" tabindex="0" ctxtmenu_counter="13" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.593ex" role="img" focusable="false" viewBox="0 -693 599.8 704" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.025ex;"><defs><path id="MJX-14-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-14-TEX-S4-AF" d="M69 544V590H430V544H69Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-14-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(27.8,3)"><svg width="572" height="246" x="0" y="444" viewBox="143 444 572 246"><use data-c="AF" xlink:href="#MJX-14-TEX-S4-AF" transform="scale(1.716,1)"></use></svg></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="x overbar"><mover accent="true"><mi>x</mi><mo>¯</mo></mover></math></mjx-assistive-mml></mjx-container> is the mean of the observed values. The mean of observed values (<mjx-container class="MathJax CtxtMenu_Attached_0" jax="SVG" tabindex="0" ctxtmenu_counter="14" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="1.357ex" height="1.593ex" role="img" focusable="false" viewBox="0 -693 599.8 704" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -0.025ex;"><defs><path id="MJX-15-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-15-TEX-S4-AF" d="M69 544V590H430V544H69Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mover"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-15-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(27.8,3)"><svg width="572" height="246" x="0" y="444" viewBox="143 444 572 246"><use data-c="AF" xlink:href="#MJX-15-TEX-S4-AF" transform="scale(1.716,1)"></use></svg></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="inline"><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="x overbar"><mover accent="true"><mi>x</mi><mo>¯</mo></mover></math></mjx-assistive-mml></mjx-container>) is calculated as follows:</p>
        <div data-type="equation">
        <mjx-container class="MathJax CtxtMenu_Attached_0" jax="SVG" display="true" tabindex="0" ctxtmenu_counter="15" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="13.434ex" height="6.74ex" role="img" focusable="false" viewBox="0 -1733 5937.6 2978.9" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -2.819ex;"><defs><path id="MJX-16-TEX-I-1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path><path id="MJX-16-TEX-S4-AF" d="M69 544V590H430V544H69Z"></path><path id="MJX-16-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-16-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-16-TEX-I-1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path><path id="MJX-16-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-16-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mover"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-16-TEX-I-1D465"></use></g><g data-mml-node="mo" transform="translate(27.8,3)"><svg width="572" height="246" x="0" y="444" viewBox="143 444 572 246"><use data-c="AF" xlink:href="#MJX-16-TEX-S4-AF" transform="scale(1.716,1)"></use></svg></g></g><g data-mml-node="mo" transform="translate(877.6,0)"><use data-c="3D" xlink:href="#MJX-16-TEX-N-3D"></use></g><g data-mml-node="mfrac" transform="translate(1933.4,0)"><g data-mml-node="mn" transform="translate(414,676)"><use data-c="31" xlink:href="#MJX-16-TEX-N-31"></use></g><g data-mml-node="mi" transform="translate(220,-686)"><use data-c="1D441" xlink:href="#MJX-16-TEX-I-1D441"></use></g><rect width="1088" height="60" x="120" y="220"></rect></g><g data-mml-node="munderover" transform="translate(3428,0)"><g data-mml-node="mo"><use data-c="2211" xlink:href="#MJX-16-TEX-LO-2211"></use></g><g data-mml-node="mrow" transform="translate(148.2,-1087.9) scale(0.707)"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-16-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="3D" xlink:href="#MJX-16-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123,0)"><use data-c="31" xlink:href="#MJX-16-TEX-N-31"></use></g></g><g data-mml-node="mi" transform="translate(408,1150) scale(0.707)"><use data-c="1D441" xlink:href="#MJX-16-TEX-I-1D441"></use></g></g><g data-mml-node="msub" transform="translate(5038.7,0)"><g data-mml-node="mi"><use data-c="1D465" xlink:href="#MJX-16-TEX-I-1D465"></use></g><g data-mml-node="mi" transform="translate(605,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-16-TEX-I-1D456"></use></g></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="x overbar equals StartFraction 1 Over upper N EndFraction sigma-summation Underscript i equals 1 Overscript upper N Endscripts x Subscript i" display="block"><mrow><mover accent="true"><mi>x</mi><mo>¯</mo></mover><mo>=</mo><mfrac><mn>1</mn><mi>N</mi></mfrac><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></munderover><msub><mi>x</mi><mi>i</mi></msub></mrow></math></mjx-assistive-mml></mjx-container>
        </div>
        
        <p>The standard deviation can then be used along with the difference from the mean to determine the number of standard deviations the component size is from the mean. <a data-type="xref" href="#source-ff-stddev">Example&nbsp;5-3</a> shows the pseudocode for this fitness function, using three standard deviations from the mean as a threshold.<a data-type="indexterm" data-startref="ch05-pff12" id="idm45978848289920"></a><a data-type="indexterm" data-startref="ch05-pff13" id="idm45978848289312"></a><a data-type="indexterm" data-startref="ch05-pff14" id="idm45978848288704"></a></p>
        <div id="source-ff-stddev" data-type="example">
        <h5><span class="label">Example 5-3. </span>Pseudocode for maintaining component size based on number of standard deviations</h5>
        
        <pre data-type="programlisting" data-code-language="perl"><code class="c1"># Walk the directory structure, creating namespaces for each complete path</code>
        <code class="n">LIST</code> <code class="n">component_list</code> <code class="o">=</code> <code class="n">identify_components</code><code class="p">(</code><code class="n">root_directory</code><code class="p">)</code>
        
        <code class="c1"># Walk through all of the source code to accumulate total statements and number</code>
        <code class="c1"># of statements per component</code>
        <code class="n">SET</code> <code class="n">total_statements</code> <code class="n">TO</code> <code class="mi">0</code>
        <code class="n">MAP</code> <code class="n">component_size_map</code>
        <code class="n">FOREACH</code> <code class="n">component</code> <code class="n">IN</code> <code class="n">component_list</code> <code class="p">{</code>
          <code class="n">num_statements</code> <code class="o">=</code> <code class="n">accumulate_statements</code><code class="p">(</code><code class="n">component</code><code class="p">)</code>
          <code class="n">ADD</code> <code class="n">num_statements</code> <code class="n">TO</code> <code class="n">total_statements</code>
          <code class="n">ADD</code> <code class="n">component</code><code class="p">,</code><code class="n">num_statements</code> <code class="n">TO</code> <code class="n">component_size_map</code>
        <code class="p">}</code>
        
        <code class="c1"># Calculate the standard deviation</code>
        <code class="n">SET</code> <code class="n">square_diff_sum</code> <code class="n">TO</code> <code class="mi">0</code>
        <code class="n">num_components</code> <code class="o">=</code> <code class="n">get_num_entries</code><code class="p">(</code><code class="n">component_list</code><code class="p">)</code>
        <code class="n">mean</code> <code class="o">=</code> <code class="n">total_statements</code> <code class="o">/</code> <code class="n">num_components</code>
        <code class="n">FOREACH</code> <code class="n">component</code><code class="p">,</code><code class="n">size</code> <code class="n">IN</code> <code class="n">component_size_map</code> <code class="p">{</code>
          <code class="n">diff</code> <code class="o">=</code> <code class="n">size</code> <code class="o">-</code> <code class="n">mean</code>
          <code class="n">ADD</code> <code class="n">square</code><code class="p">(</code><code class="n">diff</code><code class="p">)</code> <code class="n">TO</code> <code class="n">square_diff_sum</code>
        <code class="p">}</code>
        <code class="n">std_dev</code> <code class="o">=</code> <code class="n">square_root</code><code class="p">(</code><code class="n">square_diff_sum</code> <code class="o">/</code> <code class="p">(</code><code class="n">num_components</code> <code class="o">-</code> <code class="mi">1</code><code class="p">))</code>
        
        <code class="c1"># For each component calculate the number of standard deviations from the</code>
        <code class="c1"># mean. Send an alert if greater than 3</code>
        <code class="n">FOREACH</code> <code class="n">component</code><code class="p">,</code><code class="n">size</code> <code class="n">IN</code> <code class="n">component_size_map</code> <code class="p">{</code>
          <code class="n">diff_from_mean</code> <code class="o">=</code> <code class="n">absolute_value</code><code class="p">(</code><code class="n">size</code> <code class="o">-</code> <code class="n">mean</code><code class="p">);</code>
          <code class="n">num_std_devs</code> <code class="o">=</code> <code class="n">diff_from_mean</code> <code class="o">/</code> <code class="n">std_dev</code>
          <code class="n">IF</code> <code class="n">num_std_devs</code> <code class="o">&gt;</code> <code class="mi">3</code> <code class="p">{</code>
            <code class="n">send_alert</code><code class="p">(</code><code class="n">component</code><code class="p">,</code> <code class="n">num_std_devs</code><code class="p">)</code>
          <code class="p">}</code>
        <code class="p">}</code></pre></div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Sysops Squad Saga: Sizing Components"><div class="sect2" id="idm45978848107280">
        <h2>Sysops Squad Saga: Sizing Components</h2>
        
        <p><code>Tuesday, November 2, 09:12</code></p>
        <div class="story">
        
        <p>After the discussion with Logan (the lead architect) about <a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="identify and size components" id="ch05-sss1"></a>component-based decomposition patterns, Addison decided to apply the Identify and Size Components pattern to identify all of the components in the Sysops Squad ticketing application and calculate the size of each component based on the total number of statements in each 
        <span class="keep-together">component</span>.</p>
        
        <p>Addison gathered all the necessary component information and put this information into <a data-type="xref" href="#table-ss-before-size">Table&nbsp;5-2</a>, calculating the percentage of code for each component based on the total number of statements in the entire application (in this case, 82,931 statements).</p>
        <table id="table-ss-before-size" style="width: 90%">
        <caption><span class="label">Table 5-2. </span>Component size analysis for the Sysops Squad application</caption>
        <thead>
        <tr>
        <th>Component name</th>
        <th>Component namespace</th>
        <th>Percent</th>
        <th>Statements</th>
        <th>Files</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Login</p></td>
        <td><p><code>ss.login</code></p></td>
        <td><p>2</p></td>
        <td><p>1865</p></td>
        <td><p>3</p></td>
        </tr>
        <tr>
        <td><p>Billing Payment</p></td>
        <td><p><code>ss.billing.payment</code></p></td>
        <td><p>5</p></td>
        <td><p>4,312</p></td>
        <td><p>23</p></td>
        </tr>
        <tr>
        <td><p>Billing History</p></td>
        <td><p><code>ss.billing.history</code></p></td>
        <td><p>4</p></td>
        <td><p>3,209</p></td>
        <td><p>17</p></td>
        </tr>
        <tr>
        <td><p>Customer Notification</p></td>
        <td><p><code>ss.customer.notification</code></p></td>
        <td><p>2</p></td>
        <td><p>1,433</p></td>
        <td><p>7</p></td>
        </tr>
        <tr>
        <td><p>Customer Profile</p></td>
        <td><p><code>ss.customer.profile</code></p></td>
        <td><p>5</p></td>
        <td><p>4,012</p></td>
        <td><p>16</p></td>
        </tr>
        <tr>
        <td><p>Expert Profile</p></td>
        <td><p><code>ss.expert.profile</code></p></td>
        <td><p>6</p></td>
        <td><p>5,099</p></td>
        <td><p>32</p></td>
        </tr>
        <tr>
        <td><p>KB Maint</p></td>
        <td><p><code>ss.kb.maintenance</code></p></td>
        <td><p>2</p></td>
        <td><p>1,701</p></td>
        <td><p>14</p></td>
        </tr>
        <tr>
        <td><p>KB Search</p></td>
        <td><p><code>ss.kb.search</code></p></td>
        <td><p>3</p></td>
        <td><p>2,871</p></td>
        <td><p>4</p></td>
        </tr>
        <tr>
        <td><p><strong>Reporting</strong></p></td>
        <td><p><code>ss.reporting</code></p></td>
        <td><p><strong>33</strong></p></td>
        <td><p><strong>27,765</strong></p></td>
        <td><p><strong>162</strong></p></td>
        </tr>
        <tr>
        <td><p>Ticket</p></td>
        <td><p><code>ss.ticket</code></p></td>
        <td><p>8</p></td>
        <td><p>7,009</p></td>
        <td><p>45</p></td>
        </tr>
        <tr>
        <td><p>Ticket Assign</p></td>
        <td><p><code>ss.ticket.assign</code></p></td>
        <td><p>9</p></td>
        <td><p>7,845</p></td>
        <td><p>14</p></td>
        </tr>
        <tr>
        <td><p>Ticket Notify</p></td>
        <td><p><code>ss.ticket.notify</code></p></td>
        <td><p>2</p></td>
        <td><p>1,765</p></td>
        <td><p>3</p></td>
        </tr>
        <tr>
        <td><p>Ticket Route</p></td>
        <td><p><code>ss.ticket.route</code></p></td>
        <td><p>2</p></td>
        <td><p>1,468</p></td>
        <td><p>4</p></td>
        </tr>
        <tr>
        <td><p>Support Contract</p></td>
        <td><p><code>ss.supportcontract</code></p></td>
        <td><p>5</p></td>
        <td><p>4,104</p></td>
        <td><p>24</p></td>
        </tr>
        <tr>
        <td><p>Survey</p></td>
        <td><p><code>ss.survey</code></p></td>
        <td><p>3</p></td>
        <td><p>2,204</p></td>
        <td><p>5</p></td>
        </tr>
        <tr>
        <td><p>Survey Notify</p></td>
        <td><p><code>ss.survey.notify</code></p></td>
        <td><p>2</p></td>
        <td><p>1,299</p></td>
        <td><p>3</p></td>
        </tr>
        <tr>
        <td><p>Survey Templates</p></td>
        <td><p><code>ss.survey.templates</code></p></td>
        <td><p>2</p></td>
        <td><p>1,672</p></td>
        <td><p>7</p></td>
        </tr>
        <tr>
        <td><p>User Maintenance</p></td>
        <td><p><code>ss.users</code></p></td>
        <td><p>4</p></td>
        <td><p>3,298</p></td>
        <td><p>12</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Addison noticed that most of the components listed in <a data-type="xref" href="#table-ss-before-size">Table&nbsp;5-2</a> are about the same size, with the exception of the Reporting component (<code>ss.reporting</code>) which consisted of 33% of the codebase. Since the Reporting component was significantly larger than the other components (illustrated in <a data-type="xref" href="#fig-decomposition-patterns-ss-components-size-before">Figure 5-2</a>), Addison chose to break this component apart to reduce its overall size.</p>
        
        <figure class="width-75"><div id="fig-decomposition-patterns-ss-components-size-before" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0502.png" alt="Before Size Refactoring" width="600" height="791">
        <h6><span class="label">Figure 5-2. </span>The Reporting component is too big and should be broken apart</h6>
        </div></figure>
        
        <p>After doing some analysis, Addison found that the reporting component contained source code that implemented three categories of reports:</p>
        
        <ul>
        <li>
        <p>Ticketing reports (ticket demographics reports, tickets per day/week/month reports, ticket resolution time reports, and so on)</p>
        </li>
        <li>
        <p>Expert reports (expert utilization reports, expert distribution reports, and so on)</p>
        </li>
        <li>
        <p>Financial reports (repair cost reports, expert cost reports, profit reports, and so on)</p>
        </li>
        </ul>
        
        <p>Addison also identified common (shared) code that all reporting categories used, such as common utilities, calculators, shared data queries, report distribution, and shared data formatters. Addison created an architecture story (see <a data-type="xref" href="#sidebar-architecture-stories">“Architecture Stories”</a>) for this refactoring and explained it to the development team. Sydney, one of the Sysops Squad developers assigned the architecture story, refactored the code to break apart the single Reporting component into four separate components—a Reporting Shared component containing the common code and three other components (Ticket Reports, Expert Reports, and Financial Reports), each representing a functional reporting area, as illustrated in <a data-type="xref" href="#fig-decomposition-patterns-ss-components-size-after">Figure 5-3</a>.</p>
        
        <figure class="width-75"><div id="fig-decomposition-patterns-ss-components-size-after" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0503.png" alt="After Size Refactoring" width="600" height="791">
        <h6><span class="label">Figure 5-3. </span>The large Reporting component broken into smaller reporting components</h6>
        </div></figure>
        
        <p>After Sydney committed the changes, Addison reanalyzed the code and verified that all of the components were now fairly equally distributed in size. Addison recorded the results of applying this decomposition pattern in <a data-type="xref" href="#table-ss-after-size">Table&nbsp;5-3</a>.</p>
        <table id="table-ss-after-size" style="width: 90%">
        <caption><span class="label">Table 5-3. </span>Component size after applying the Identify and Size Components pattern</caption>
        <thead>
        <tr>
        <th>Component name</th>
        <th>Component namespace</th>
        <th>Percent</th>
        <th>Statements</th>
        <th>Files</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Login</p></td>
        <td><p><code>ss.login</code></p></td>
        <td><p>2</p></td>
        <td><p>1865</p></td>
        <td><p>3</p></td>
        </tr>
        <tr>
        <td><p>Billing Payment</p></td>
        <td><p><code>ss.billing.payment</code></p></td>
        <td><p>5</p></td>
        <td><p>4,312</p></td>
        <td><p>23</p></td>
        </tr>
        <tr>
        <td><p>Billing History</p></td>
        <td><p><code>ss.billing.history</code></p></td>
        <td><p>4</p></td>
        <td><p>3,209</p></td>
        <td><p>17</p></td>
        </tr>
        <tr>
        <td><p>Customer Notification</p></td>
        <td><p><code>ss.customer.notification</code></p></td>
        <td><p>2</p></td>
        <td><p>1,433</p></td>
        <td><p>7</p></td>
        </tr>
        <tr>
        <td><p>Customer Profile</p></td>
        <td><p><code>ss.customer.profile</code></p></td>
        <td><p>5</p></td>
        <td><p>4,012</p></td>
        <td><p>16</p></td>
        </tr>
        <tr>
        <td><p>Expert Profile</p></td>
        <td><p><code>ss.expert.profile</code></p></td>
        <td><p>6</p></td>
        <td><p>5,099</p></td>
        <td><p>32</p></td>
        </tr>
        <tr>
        <td><p>KB Maint</p></td>
        <td><p><code>ss.kb.maintenance</code></p></td>
        <td><p>2</p></td>
        <td><p>1,701</p></td>
        <td><p>14</p></td>
        </tr>
        <tr>
        <td><p>KB Search</p></td>
        <td><p><code>ss.kb.search</code></p></td>
        <td><p>3</p></td>
        <td><p>2,871</p></td>
        <td><p>4</p></td>
        </tr>
        <tr>
        <td><p><strong>Reporting Shared</strong></p></td>
        <td><p><code>ss.reporting.shared</code></p></td>
        <td><p><strong>7</strong></p></td>
        <td><p><strong>5,309</strong></p></td>
        <td><p><strong>20</strong></p></td>
        </tr>
        <tr>
        <td><p><strong>Ticket Reports</strong></p></td>
        <td><p><code>ss.reporting.tickets</code></p></td>
        <td><p><strong>8</strong></p></td>
        <td><p><strong>6,955</strong></p></td>
        <td><p><strong>58</strong></p></td>
        </tr>
        <tr>
        <td><p><strong>Expert Reports</strong></p></td>
        <td><p><code>ss.reporting.experts</code></p></td>
        <td><p><strong>9</strong></p></td>
        <td><p><strong>7,734</strong></p></td>
        <td><p><strong>48</strong></p></td>
        </tr>
        <tr>
        <td><p><strong>Financial Reports</strong></p></td>
        <td><p><code>ss.reporting.financial</code></p></td>
        <td><p><strong>9</strong></p></td>
        <td><p><strong>7,767</strong></p></td>
        <td><p><strong>36</strong></p></td>
        </tr>
        <tr>
        <td><p>Ticket</p></td>
        <td><p><code>ss.ticket</code></p></td>
        <td><p>8</p></td>
        <td><p>7,009</p></td>
        <td><p>45</p></td>
        </tr>
        <tr>
        <td><p>Ticket Assign</p></td>
        <td><p><code>ss.ticket.assign</code></p></td>
        <td><p>9</p></td>
        <td><p>7,845</p></td>
        <td><p>14</p></td>
        </tr>
        <tr>
        <td><p>Ticket Notify</p></td>
        <td><p><code>ss.ticket.notify</code></p></td>
        <td><p>2</p></td>
        <td><p>1,765</p></td>
        <td><p>3</p></td>
        </tr>
        <tr>
        <td><p>Ticket Route</p></td>
        <td><p><code>ss.ticket.route</code></p></td>
        <td><p>2</p></td>
        <td><p>1,468</p></td>
        <td><p>4</p></td>
        </tr>
        <tr>
        <td><p>Support Contract</p></td>
        <td><p><code>ss.supportcontract</code></p></td>
        <td><p>5</p></td>
        <td><p>4,104</p></td>
        <td><p>24</p></td>
        </tr>
        <tr>
        <td><p>Survey</p></td>
        <td><p><code>ss.survey</code></p></td>
        <td><p>3</p></td>
        <td><p>2,204</p></td>
        <td><p>5</p></td>
        </tr>
        <tr>
        <td><p>Survey Notify</p></td>
        <td><p><code>ss.survey.notify</code></p></td>
        <td><p>2</p></td>
        <td><p>1,299</p></td>
        <td><p>3</p></td>
        </tr>
        <tr>
        <td><p>Survey Templates</p></td>
        <td><p><code>ss.survey.templates</code></p></td>
        <td><p>2</p></td>
        <td><p>1,672</p></td>
        <td><p>7</p></td>
        </tr>
        <tr>
        <td><p>User Maintenance</p></td>
        <td><p><code>ss.users</code></p></td>
        <td><p>4</p></td>
        <td><p>3,298</p></td>
        <td><p>12</p></td>
        </tr>
        </tbody>
        </table>
        </div>
        
        <p>Notice in the preceding Sysops Squad Saga that Reporting no longer exists as a component in <a data-type="xref" href="#table-ss-after-size">Table&nbsp;5-3</a> or <a data-type="xref" href="#fig-decomposition-patterns-ss-components-size-after">Figure 5-3</a>. Although the <em>namespace</em> still exists (<code>ss.reporting</code>), it is no longer considered a component, but rather a subdomain. <a data-type="indexterm" data-startref="ch05-sss1" id="idm45978847925328"></a>The refactored components listed in <a data-type="xref" href="#table-ss-after-size">Table&nbsp;5-3</a> will be used when applying the next decomposition pattern, Gather Common Domain Components.<a data-type="indexterm" data-startref="ch05-idsz" id="idm45978847923504"></a><a data-type="indexterm" data-startref="ch05-idsz2" id="idm45978847922832"></a><a data-type="indexterm" data-startref="ch05-idsz3" id="idm45978847922160"></a><a data-type="indexterm" data-startref="ch05-idsz5" id="idm45978847921488"></a><a data-type="indexterm" data-startref="ch05-idsz6" id="idm45978847920816"></a><a data-type="indexterm" data-startref="ch05-idsz7" id="idm45978847920144"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Gather Common Domain Components Pattern"><div class="sect1" id="sec-pattern-gather-common">
        <h1>Gather Common Domain Components Pattern</h1>
        
        <p>When moving from a monolithic architecture to a distributed one, it is <a data-type="indexterm" data-primary="Gather Common Domain Components pattern" id="ch05-ddp26"></a><a data-type="indexterm" data-primary="architectural decomposition" data-secondary="component-based" data-tertiary="gather common domain components" id="ch05-ddp2"></a><a data-type="indexterm" data-primary="component-based decomposition" data-secondary="patterns" data-tertiary="gather common domain components" id="ch05-ddp22"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="patterns for migration to service-based" data-tertiary="gather common domain components" id="ch05-ddp24"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="monolithic migration to" data-tertiary="gather common domain components" id="ch05-ddp25"></a>often beneficial to identify and consolidate common domain functionality to make common services easier to identify and create. The <em>Gather Common Domain Components</em> pattern is used to identify and collect common domain logic and centralize it into a single component.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Pattern Description"><div class="sect2" id="idm45978847910256">
        <h2>Pattern Description</h2>
        
        <p>Shared <em>domain</em> functionality is distinguished from shared <em>infrastructure</em> functionality<a data-type="indexterm" data-primary="shared domain functionality" data-secondary="shared infrastructure functionality versus" id="idm45978847907920"></a><a data-type="indexterm" data-primary="domain versus infrastructure shared functionality" id="idm45978847906848"></a><a data-type="indexterm" data-primary="infrastructure versus domain shared functionality" id="idm45978847906144"></a> in that domain functionality is part of the business processing logic of an application (such as notification, data formatting, and data validation) and is common to only some processes, whereas infrastructure functionality is operational in nature (such as logging, metrics gathering, and security) and is common to all processes.</p>
        
        <p>Consolidating common domain functionality helps eliminate duplicate services when breaking apart a monolithic system. Often there are only very subtle differences among common domain functionality that is duplicated throughout the application, and these differences can be easily resolved within a single common service (or shared library).</p>
        
        <p>Finding common domain functionality is mostly a manual process, but some automation can be used to assist in this effort (see <a data-type="xref" href="#sec-ff-gather">“Fitness Functions for Governance”</a>). One hint that common domain processing exists in the application is the use of shared classes across components or a common inheritance structure used by multiple components. Take, for example, a class file named <em>SMTPConnection</em> in a large codebase that is used by five classes, all contained within different namespaces (components). This scenario is a good indication that common email notification functionality is spread throughout the application and might be a good candidate for consolidation.</p>
        
        <p>Another way of identifying common domain functionality is through the name of a logical component or its corresponding namespace. Consider the following components (represented as namespaces) in a large codebase:</p>
        
        <ul>
        <li>
        <p>Ticket Auditing (<code>penultimate.ss.ticket.audit</code>)</p>
        </li>
        <li>
        <p>Billing Auditing (<code>penultimate.ss.billing.audit</code>)</p>
        </li>
        <li>
        <p>Survey Auditing (<code>penultimate.ss.survey.audit</code>)</p>
        </li>
        </ul>
        
        <p class="pagebreak-before">Notice how each of these components (Ticket Auditing, Billing Auditing, and Survey Auditing) all have the same thing in common—writing the action performed and the user requesting the action to an audit table. While the context may be different, the final outcome is the same—inserting a row in an audit table. This common domain functionality can be consolidated into a new component called <code>penultimate.ss.shared.audit</code>, resulting in less duplication of code and also fewer services in the resulting distributed architecture.</p>
        
        <p>Not all common domain functionality necessarily becomes a shared service. Alternatively, common code could be gathered into a <em>shared library</em> that is bound to the code during compile time. The pros and cons of using a shared service rather than a shared library are discussed in detail in <a data-type="xref" href="ch08.html#ch08-reuse-patterns">Chapter&nbsp;8</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Fitness Functions for Governance"><div class="sect2" id="sec-ff-gather">
        <h2>Fitness Functions for Governance</h2>
        
        <p>Automating the governance of shared domain functionality<a data-type="indexterm" data-primary="Gather Common Domain Components pattern" data-secondary="fitness functions" id="idm45978847894368"></a><a data-type="indexterm" data-primary="fitness functions for governance" data-secondary="patterns for component-based decomposition" data-tertiary="gather common domain components" id="idm45978847893344"></a> is rather difficult because of the subjectiveness of identifying shared functionality and classifying it as domain functionality versus infrastructure functionality. For the most part, the fitness functions used to govern this pattern are therefore somewhat manual. That said, there are some ways to automate the governance to assist in the manual interpretation of common domain functionality. The following fitness functions can assist in finding common domain functionality.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: Find common names in leaf nodes of component namespace"><div class="sect3" id="sec-ff-common-namespace">
        <h3>Fitness function: Find common names in leaf nodes of component namespace</h3>
        
        <p>This automated holistic fitness function can be triggered on deployment through a CI/CD pipeline to locate common names within the namespace of a component. When a common ending namespace node name is found between two or more components, the architect is alerted and can analyze the functionality to determine if it is common domain logic. So that the same alert isn’t continuously sent as a “false positive,” an exclusion file can be used to store those namespaces that have common ending node names but are not deemed common domain logic (such as multiple namespaces ending in <code>.calculate</code> or <code>.validate</code>). <a data-type="xref" href="#source-ff-common-namespace">Example&nbsp;5-4</a> shows the pseudocode for this fitness function.</p>
        <div id="source-ff-common-namespace" data-type="example">
        <h5><span class="label">Example 5-4. </span>Pseudocode for finding common namespace leaf node names</h5>
        
        <pre data-type="programlisting" data-code-language="perl"><code class="c1"># Walk the directory structure, creating namespaces for each complete path</code>
        <code class="n">LIST</code> <code class="n">component_list</code> <code class="o">=</code> <code class="n">identify_components</code><code class="p">(</code><code class="n">root_directory</code><code class="p">)</code>
        
        <code class="c1"># Locate possible duplicate component node names that are not in the exclusion</code>
        <code class="c1"># list stored in a datastore</code>
        <code class="n">LIST</code> <code class="n">excluded_leaf_node_list</code> <code class="o">=</code> <code class="n">read_datastore</code><code class="p">()</code>
        <code class="n">LIST</code> <code class="n">leaf_node_list</code>
        <code class="n">LIST</code> <code class="n">common_component_list</code>
        <code class="n">FOREACH</code> <code class="n">component</code> <code class="n">IN</code> <code class="n">component_list</code> <code class="p">{</code>
          <code class="n">leaf_name</code> <code class="o">=</code> <code class="n">get_last_node</code><code class="p">(</code><code class="n">component</code><code class="p">)</code>
          <code class="n">IF</code> <code class="n">leaf_name</code> <code class="n">IN</code> <code class="n">leaf_node_list</code> <code class="n">AND</code>
             <code class="n">leaf_name</code> <code class="n">NOT</code> <code class="n">IN</code> <code class="n">excluded_leaf_node_list</code> <code class="p">{</code>
            <code class="n">ADD</code> <code class="n">component</code> <code class="n">TO</code> <code class="n">common_component_list</code>
          <code class="p">}</code> <code class="n">ELSE</code> <code class="p">{</code>
            <code class="n">ADD</code> <code class="n">leaf_name</code> <code class="n">TO</code> <code class="n">leaf_node_list</code>
          <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1"># Send an alert if any possible common components were found</code>
        <code class="n">IF</code> <code class="n">common_component_list</code> <code class="n">NOT</code> <code class="n">EMPTY</code> <code class="p">{</code>
          <code class="n">send_alert</code><code class="p">(</code><code class="n">common_component_list</code><code class="p">)</code>
        <code class="p">}</code></pre></div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: Find common code across components"><div class="sect3" id="sec-ff-common-code">
        <h3>Fitness function: Find common code across components</h3>
        
        <p>This automated holistic fitness function can be triggered on deployment through a CI/CD pipeline to locate common classes used between namespaces. While not always accurate, it does help in alerting an architect of possible duplicate domain functionality. Like the previous fitness function, an exclusion file is used to reduce the number of “false positives” for known common code that is not considered duplicate domain logic. <a data-type="xref" href="#source-ff-common-code">Example&nbsp;5-5</a> shows the pseudocode for this fitness function.<a data-type="indexterm" data-startref="ch05-ddp2" id="idm45978847809088"></a><a data-type="indexterm" data-startref="ch05-ddp22" id="idm45978847808416"></a><a data-type="indexterm" data-startref="ch05-ddp24" id="idm45978847807744"></a><a data-type="indexterm" data-startref="ch05-ddp25" id="idm45978847807072"></a><a data-type="indexterm" data-startref="ch05-ddp26" id="idm45978847806400"></a></p>
        <div id="source-ff-common-code" data-type="example">
        <h5><span class="label">Example 5-5. </span>Pseudocode for finding common source files between components</h5>
        
        <pre data-type="programlisting" data-code-language="perl"><code class="c1"># Walk the directory structure, creating namespaces for each complete path and a list</code>
        <code class="c1"># of source file names for each component</code>
        <code class="n">LIST</code> <code class="n">component_list</code> <code class="o">=</code> <code class="n">identify_components</code><code class="p">(</code><code class="n">root_directory</code><code class="p">)</code>
        <code class="n">LIST</code> <code class="n">source_file_list</code> <code class="o">=</code> <code class="n">get_source_files</code><code class="p">(</code><code class="n">root_directory</code><code class="p">)</code>
        <code class="n">MAP</code> <code class="n">component_source_file_map</code>
        <code class="n">FOREACH</code> <code class="n">component</code> <code class="n">IN</code> <code class="n">component_list</code> <code class="p">{</code>
          <code class="n">LIST</code> <code class="n">component_source_file_list</code> <code class="o">=</code> <code class="n">get_source_files</code><code class="p">(</code><code class="n">component</code><code class="p">)</code>
          <code class="n">ADD</code> <code class="n">component</code><code class="p">,</code> <code class="n">component_source_file_list</code> <code class="n">TO</code> <code class="n">component_source_file_map</code>
        <code class="p">}</code>
        
        <code class="c1"># Locate possible common source file usage across components that are not in</code>
        <code class="c1"># the exclusion list stored in a datastore</code>
        <code class="n">LIST</code> <code class="n">excluded_source_file_list</code> <code class="o">=</code> <code class="n">read_datastore</code><code class="p">()</code>
        <code class="n">LIST</code> <code class="n">common_source_file_list</code>
        <code class="n">FOREACH</code> <code class="n">source_file</code> <code class="n">IN</code> <code class="n">source_file_list</code> <code class="p">{</code>
          <code class="n">SET</code> <code class="n">count</code> <code class="n">TO</code> <code class="mi">0</code>
          <code class="n">FOREACH</code> <code class="n">component</code><code class="p">,</code><code class="n">component_source_file_list</code> <code class="n">IN</code> <code class="n">component_source_file_map</code> <code class="p">{</code>
            <code class="n">IF</code> <code class="n">source_file</code> <code class="n">IN</code> <code class="n">component_source_file_list</code> <code class="p">{</code>
              <code class="n">ADD</code> <code class="mi">1</code> <code class="n">TO</code> <code class="n">count</code>
            <code class="p">}</code>
          <code class="p">}</code>
          <code class="n">IF</code> <code class="n">count</code> <code class="o">&gt;</code> <code class="mi">1</code> <code class="n">AND</code> <code class="n">source_file</code> <code class="n">NOT</code> <code class="n">IN</code> <code class="n">excluded_source_file_list</code> <code class="p">{</code>
            <code class="n">ADD</code> <code class="n">source_file</code> <code class="n">TO</code> <code class="n">common_source_file_list</code>
          <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1"># Send an alert if any source files are used in multiple components</code>
        <code class="n">IF</code> <code class="n">common_source_file_list</code> <code class="n">NOT</code> <code class="n">EMPTY</code> <code class="p">{</code>
            <code class="n">send_alert</code><code class="p">(</code><code class="n">common_source_file_list</code><code class="p">)</code>
        <code class="p">}</code></pre></div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Sysops Squad Saga: Gathering Common Components"><div class="sect2" id="idm45978847765648">
        <h2>Sysops Squad Saga: Gathering Common Components</h2>
        
        <p><code>Friday, November 5, 10:34</code></p>
        <div class="story">
        
        <p>Having identified and sized the components in the Sysops Squad application, <a data-type="indexterm" data-primary="Gather Common Domain Components pattern" data-secondary="Sysops Squad saga" id="ch05-ssgc2"></a><a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="gather common domain components" id="ch05-ssgc22"></a>Addison applied the Gather Common Domain Components pattern to see if any common functionality existed between components. From the list of components in <a data-type="xref" href="#table-ss-after-size">Table&nbsp;5-3</a>, Addison noticed there were three components all related to notifying a Sysops Squad customer, and listed these in <a data-type="xref" href="#table-ss-gather-before">Table&nbsp;5-4</a>.</p>
        <table id="table-ss-gather-before" style="width: 100%">
        <caption><span class="label">Table 5-4. </span>Sysops Squad components with common domain functionality</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Namespace</th>
        <th>Responsibility</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Customer Notification</p></td>
        <td><p><code>ss.customer.notification</code></p></td>
        <td><p>General notification</p></td>
        </tr>
        <tr>
        <td><p>Ticket Notify</p></td>
        <td><p><code>ss.ticket.notify</code></p></td>
        <td><p>Notify that expert is en route</p></td>
        </tr>
        <tr>
        <td><p>Survey Notify</p></td>
        <td><p><code>ss.survey.notify</code></p></td>
        <td><p>Send survey email</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>While each of these notification components had a different context for notifying a customer, Addison realized they all have one thing in common—they all sent information to a customer. <a data-type="xref" href="#fig-decomposition-patterns-ss-components-common-before">Figure 5-4</a> illustrates these common notification components within the Sysops Squad application.</p>
        
        <p>Noticing that the source code contained in these components was also very similar, Addison consulted with Austen (the other Sysops Squad architect). Austen liked the idea of a single notification component, but was concerned about impacting the overall level of coupling between components. Addison agreed that this might be an issue and investigated this trade-off further.</p>
        
        <figure><div id="fig-decomposition-patterns-ss-components-common-before" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0504.png" alt="Before Common Refactoring" width="600" height="791">
        <h6><span class="label">Figure 5-4. </span>Notification functionality is duplicated throughout the application</h6>
        </div></figure>
        
        <p>Addison analyzed the incoming (afferent) coupling level for the existing Sysops Squad notification components and came up with the resulting coupling metrics listed in <a data-type="xref" href="#table-ss-coupling-before">Table&nbsp;5-5</a>, with “CA” representing the number of other components requiring that component (afferent coupling).</p>
        <table id="table-ss-coupling-before" class="pagebreak-before" style="width: 100%">
        <caption><span class="label">Table 5-5. </span>Sysops Squad coupling analysis before component consolidation</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>CA</th>
        <th>Used by</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Customer Notification</p></td>
        <td><p>2</p></td>
        <td><p>Billing Payment, Support Contract</p></td>
        </tr>
        <tr>
        <td><p>Ticket Notify</p></td>
        <td><p>2</p></td>
        <td><p>Ticket, Ticket Route</p></td>
        </tr>
        <tr>
        <td><p>Survey Notify</p></td>
        <td><p>1</p></td>
        <td><p>Survey</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Addison then found that if the customer notification functionality was consolidated into a single component, the coupling level for the resulting single component increased to an incoming coupling level of 5, as shown in <a data-type="xref" href="#table-ss-coupling-after">Table&nbsp;5-6</a>.</p>
        <table id="table-ss-coupling-after" style="width: 100%">
        <caption><span class="label">Table 5-6. </span>Sysops Squad coupling analysis after component consolidation</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>CA</th>
        <th>Used by</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Notification</p></td>
        <td><p>5</p></td>
        <td><p>Billing Payment, Support Contract, Ticket, Ticket Route, Survey</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Addison brought these findings to Austen, and they discussed the results. What they found is that, while the new consolidated component had a fairly high level of incoming coupling, it didn’t affect the overall afferent (incoming) coupling level for notifying a customer. In other words, the three separate components had a total incoming coupling level of 5, but so did the single consolidated 
        <span class="keep-together">component</span>.</p>
        
        <p>Addison and Austen both realized how important it was to <a data-type="indexterm" data-primary="coupling" data-secondary="architectural decomposition" data-tertiary="common domain functionality consolidated" id="idm45978847618640"></a>analyze the coupling level after consolidating common domain functionality. In some cases, combining common domain functionality into a single consolidated component increased the incoming coupling level of that component, thus resulting in too many dependencies on a single shared component within the application. However, in this case both Addison and Austen were comfortable with the coupling analysis, and agreed to consolidate the notification functionality to reduce the duplication of both code and functionality.</p>
        
        <p>Addison wrote an architecture story to combine all of the notification functionality into a single namespace representing a common Notification component. Sydney, assigned to the architecture story, refactored the source code, creating a single component for customer notification, as illustrated in<a data-type="indexterm" data-startref="ch05-ssgc2" id="idm45978847616800"></a><a data-type="indexterm" data-startref="ch05-ssgc22" id="idm45978847616096"></a> <a data-type="xref" href="#fig-decomposition-patterns-ss-components-common-after">Figure 5-5</a>.</p>
        
        <figure><div id="fig-decomposition-patterns-ss-components-common-after" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0505.png" alt="After Common Refactoring" width="600" height="791">
        <h6><span class="label">Figure 5-5. </span>Notification functionality is consolidated into a new single component called Notification</h6>
        </div></figure>
        
        <p><a data-type="xref" href="#table-ss-result-common">Table&nbsp;5-7</a> shows the resulting components after Sydney implemented the architecture story Addison created. Notice that the Customer Notification component (<code>ss.customer.notification</code>), Ticket Notify component (<code>ss.ticket.notify</code>), and Survey Notify components (<code>ss.survey.notify</code>) were removed, and the source code moved to the new consolidated Notification component (
        <span class="keep-together"><code>ss.notification</code></span>).</p>
        <table id="table-ss-result-common" class="pagebreak-before" style="width: 100%">
        <caption><span class="label">Table 5-7. </span>Sysops Squad components after applying the Gather Common Domain Components pattern</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Namespace</th>
        <th>Responsibility</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Login</p></td>
        <td><p><code>ss.login</code></p></td>
        <td><p>User and customer login</p></td>
        </tr>
        <tr>
        <td><p>Billing Payment</p></td>
        <td><p><code>ss.billing.payment</code></p></td>
        <td><p>Customer monthly billing</p></td>
        </tr>
        <tr>
        <td><p>Billing History</p></td>
        <td><p><code>ss.billing.history</code></p></td>
        <td><p>Payment history</p></td>
        </tr>
        <tr>
        <td><p>Customer Profile</p></td>
        <td><p><code>ss.customer.profile</code></p></td>
        <td><p>Maintain customer profile</p></td>
        </tr>
        <tr>
        <td><p>Expert Profile</p></td>
        <td><p><code>ss.expert.profile</code></p></td>
        <td><p>Maintain expert profile</p></td>
        </tr>
        <tr>
        <td><p>KB Maint</p></td>
        <td><p><code>ss.kb.maintenance</code></p></td>
        <td><p>Maintain &amp; view knowledge base</p></td>
        </tr>
        <tr>
        <td><p>KB Search</p></td>
        <td><p><code>ss.kb.search</code></p></td>
        <td><p>Search knowledge base</p></td>
        </tr>
        <tr>
        <td><p><strong>Notification</strong></p></td>
        <td><p><code>ss.notification</code></p></td>
        <td><p><strong>All customer notification</strong></p></td>
        </tr>
        <tr>
        <td><p>Reporting Shared</p></td>
        <td><p><code>ss.reporting.shared</code></p></td>
        <td><p>Shared functionality</p></td>
        </tr>
        <tr>
        <td><p>Ticket Reports</p></td>
        <td><p><code>ss.reporting.tickets</code></p></td>
        <td><p>Create ticketing reports</p></td>
        </tr>
        <tr>
        <td><p>Expert Reports</p></td>
        <td><p><code>ss.reporting.experts</code></p></td>
        <td><p>Create expert reports</p></td>
        </tr>
        <tr>
        <td><p>Financial Reports</p></td>
        <td><p><code>ss.reporting.financial</code></p></td>
        <td><p>Create financial reports</p></td>
        </tr>
        <tr>
        <td><p>Ticket</p></td>
        <td><p><code>ss.ticket</code></p></td>
        <td><p>Ticket creation &amp; maintenance</p></td>
        </tr>
        <tr>
        <td><p>Ticket Assign</p></td>
        <td><p><code>ss.ticket.assign</code></p></td>
        <td><p>Assign expert to ticket</p></td>
        </tr>
        <tr>
        <td><p>Ticket Route</p></td>
        <td><p><code>ss.ticket.route</code></p></td>
        <td><p>Send ticket to expert</p></td>
        </tr>
        <tr>
        <td><p>Support Contract</p></td>
        <td><p><code>ss.supportcontract</code></p></td>
        <td><p>Support contract maintenance</p></td>
        </tr>
        <tr>
        <td><p>Survey</p></td>
        <td><p><code>ss.survey</code></p></td>
        <td><p>Send and receive surveys</p></td>
        </tr>
        <tr>
        <td><p>Survey Templates</p></td>
        <td><p><code>ss.survey.templates</code></p></td>
        <td><p>Maintain survey templates</p></td>
        </tr>
        <tr>
        <td><p>User Maintenance</p></td>
        <td><p><code>ss.users</code></p></td>
        <td><p>Maintain internal users</p></td>
        </tr>
        </tbody>
        </table>
        </div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Flatten Components Pattern"><div class="sect1" id="sec-pattern-flatten">
        <h1>Flatten Components Pattern</h1>
        
        <p>As mentioned previously, components—the building blocks <a data-type="indexterm" data-primary="architectural decomposition" data-secondary="component-based" data-tertiary="flatten components" id="ch05-flat"></a><a data-type="indexterm" data-primary="component-based decomposition" data-secondary="patterns" data-tertiary="flatten components" id="ch05-flat2"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="patterns for migration to service-based" data-tertiary="flatten components" id="ch05-flat4"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="monolithic migration to" data-tertiary="flatten components pattern" id="ch05-flat5"></a><a data-type="indexterm" data-primary="Flatten Components pattern" id="ch05-flat6"></a>of an application—are usually identified through namespaces, package structures, or directory structures and are implemented through class files (or source code files) contained within these structures. However, when components are built on top of other components, which are in turn built on top of other components, they start to lose their identity and stop becoming components as per our definition. The <em>Flatten Components</em> pattern is used to ensure that components are not built on top of one another, but rather flattened and represented as leaf nodes in a directory structure or namespace.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Pattern Description"><div class="sect2" id="idm45978847550224">
        <h2>Pattern Description</h2>
        
        <p>When the namespace representing a particular component gets extended<a data-type="indexterm" data-primary="namespaces" data-secondary="extend then prior a subdomain" id="idm45978847548016"></a> (in other words, another node is added to the namespace or directory structure), the prior namespace or directory no longer represents a component, but rather a subdomain. To illustrate this point, consider the customer survey functionality within the Sysops Squad application represented by two components: Survey (<code>ss.survey</code>) and Survey Templates (<code>ss.survey.templates</code>). Notice in <a data-type="xref" href="#table-flatten-survey">Table&nbsp;5-8</a> how the <code>ss.survey</code> namespace, which contains five class files used to manage and collect the surveys, is extended with the <code>ss.survey.templates</code> namespace to include seven classes representing each survey type send out to customers.</p>
        <table id="table-flatten-survey" style="width: 75%">
        <caption><span class="label">Table 5-8. </span>The Survey component contains orphaned classes and should be flattened</caption>
        <thead>
        <tr>
        <th>Component name</th>
        <th>Component namespace</th>
        <th>Files</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>→ Survey</p></td>
        <td><p><code>ss.survey</code></p></td>
        <td><p>5</p></td>
        </tr>
        <tr>
        <td><p>Survey Templates</p></td>
        <td><p><code>ss.survey.templates</code></p></td>
        <td><p>7</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>While this structure might seem to make sense from a developer’s standpoint in order to keep the template code separate from survey processing, it does create some problems because Survey Templates, as a component, would be considered part of the Survey component. One might be tempted to consider Survey Templates as a <em>subcomponent</em> of Survey, but then issues arise when trying to form services from these components—should both components reside in a single service called Survey, or should the Survey Templates be a separate service from the Survey service?</p>
        
        <p>We’ve resolved this dilemma by defining a component as the last node (or leaf node) of the namespace or directory structure. With this definition, <code>ss.survey.templates</code> is a component, whereas <code>ss.survey</code> would be considered a <em>subdomain</em>, not a component. We further define namespaces such as <code>ss.survey</code> as <em>root namespaces</em> because they are extended with other namespace nodes (in this case, <code>.templates</code>).</p>
        
        <p>Notice how the <code>ss.survey</code> root namespace in <a data-type="xref" href="#table-flatten-survey">Table&nbsp;5-8</a> contains five class files. We call these class files <em>orphaned classes</em> because they do not belong to any definable component. Recall that a component is identified by a leaf node namespace containing source code. Because the <code>ss.survey</code> namespace was extended to include <code>.templates</code>, <code>ss.survey</code> is no longer considered a component and therefore should not contain any class files.</p>
        
        <p class="pagebreak-before">The following terms and corresponding definitions are important for understanding and applying the Flatten Components decomposition pattern:</p>
        <dl>
        <dt>Component</dt>
        <dd>
        <p>A collection of classes grouped <a data-type="indexterm" data-primary="components" data-secondary="definition" id="idm45978847525072"></a>within a <em>leaf node namespace</em> that performs some sort of specific functionality in the application (such as payment processing or customer survey functionality).</p>
        </dd>
        <dt>Root namespace</dt>
        <dd>
        <p>A namespace node that has been extended by another<a data-type="indexterm" data-primary="root namespace definition" id="idm45978847521952"></a><a data-type="indexterm" data-primary="namespaces" data-secondary="root namespace definition" id="idm45978847521280"></a> namespace node. For example, given the namespaces <code>ss.survey</code> and <code>ss.survey.templates</code>, <code>ss.survey</code> would be considered a root namespace because it is extended by <code>.templates</code>. Root namespaces are also sometimes referred to as <em>subdomains</em>.</p>
        </dd>
        <dt>Orphaned classes</dt>
        <dd>
        <p>Classes contained within a root namespace, and hence have no definable component associated with them.<a data-type="indexterm" data-primary="orphaned classes definition" id="idm45978847516592"></a></p>
        </dd>
        </dl>
        
        <p>These definitions are illustrated in <a data-type="xref" href="#fig-decomposition-patterns-definitions">Figure 5-6</a>, where the box with a C represents source code contained within that namespace. This diagram (and all others like it) are purposely drawn from the bottom up to emphasize the notion of <em>hills</em> in the application, as well as emphasize the notion of namespaces <em>building upon</em> each other.</p>
        
        <figure><div id="fig-decomposition-patterns-definitions" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0506.png" alt="Component Definitions" width="600" height="310">
        <h6><span class="label">Figure 5-6. </span>Components, root namespaces, and orphaned classes (C box denotes source code)</h6>
        </div></figure>
        
        <p>Notice that since both <code>ss.survey</code> and <code>ss.ticket</code> are extended through other namespace nodes, those namespaces are considered root namespaces, and the classes contained in those root namespaces are hence orphaned classes (belonging to no defined component). Thus, the only components denoted in <a data-type="xref" href="#fig-decomposition-patterns-definitions">Figure 5-6</a> are <code>ss.survey.templates</code>, <code>ss.login</code>, <code>ss.ticket.assign</code>, and <code>ss.ticket.route</code>.</p>
        
        <p>The Flatten Components decomposition pattern is used to move orphaned classes to create well-defined components that exist only as leaf nodes of a directory or namespace, creating well-defined subdomains (root namespaces) in the process. We refer to the <em>flattening</em> of components as the breaking down (or building up) of namespaces within an application to remove orphaned classes. For example, one way of flattening the <code>ss.survey</code> root namespace in <a data-type="xref" href="#fig-decomposition-patterns-definitions">Figure 5-6</a> and remove orphaned classes is to move the source code contained in the <code>ss.survey.templates</code> namespace down to the <code>ss.survey</code> namespace, thereby making <code>ss.survey</code> a single component (<code>.survey</code> is now the leaf node of that namespace). This flattening option is illustrated in <a data-type="xref" href="#fig-decomposition-patterns-flatten-down">Figure 5-7</a>.</p>
        
        <figure><div id="fig-decomposition-patterns-flatten-down" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0507.png" alt="Flatten Down" width="600" height="234">
        <h6><span class="label">Figure 5-7. </span>Survey is flattened by moving the survey template code into the .survey namespace</h6>
        </div></figure>
        
        <p>Alternatively, flattening could also be applied by taking the source code in <code>ss.survey</code> and applying functional decomposition or domain-driven design to identify separate functional areas within the root namespace, thus forming components from those functional areas. For example, suppose the functionality within the <code>ss.survey</code> namespace creates and sends a survey to a customer, and then processes a completed survey received from the customer. Two components could be created from the <code>ss.survey</code> namespace: <code>ss.survey.create</code>, which creates and sends the survey, and <code>ss.survey.process</code>, which processes a survey received from a customer. This form of flattening is illustrated in <a data-type="xref" href="#fig-decomposition-patterns-flatten-up">Figure 5-8</a>.</p>
        
        <figure><div id="fig-decomposition-patterns-flatten-up" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0508.png" alt="Flatten Up" width="600" height="276">
        <h6><span class="label">Figure 5-8. </span>Survey is flattened by moving the orphaned classes to new leaf nodes (
        <span class="keep-together">components</span>)</h6>
        </div></figure>
        <div data-type="tip"><h6>Tip</h6>
        <p>Regardless of the direction of flattening, make sure source code files reside only in leaf node namespaces or directories so that source code can always be identified within a specific component.</p>
        </div>
        
        <p>Another common scenario where orphaned source code might reside in a root namespace is when code is shared by other components within that namespace. Consider the example in <a data-type="xref" href="#fig-decomposition-patterns-flatten-shared">Figure 5-9</a> where customer survey functionality resides in three components (<code>ss.survey.templates</code>, <code>ss.survey.create</code>, and <code>ss.survey.process</code>), but common code (such as interfaces, abstract classes, common utilities) resides in the root namespace <code>ss.survey</code>.</p>
        
        <figure><div id="fig-decomposition-patterns-flatten-shared" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0509.png" alt="Flatten Shared" width="600" height="272">
        <h6><span class="label">Figure 5-9. </span>Shared code in .survey is considered orphaned classes and should be moved</h6>
        </div></figure>
        
        <p>The shared classes in <code>ss.survey</code> would still be considered orphaned classes, even though they represent shared code. Applying the Flatten Components pattern would move those shared orphaned classes to a new component called <code>ss.survey.shared</code>, therefore removing all orphaned classes from the <code>ss.survey</code> subdomain, as illustrated in <a data-type="xref" href="#fig-decomposition-patterns-flatten-shared-component">Figure 5-10</a>.</p>
        
        <figure><div id="fig-decomposition-patterns-flatten-shared-component" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0510.png" alt="Shared Component" width="600" height="256">
        <h6><span class="label">Figure 5-10. </span>Shared survey code is moved into its own component</h6>
        </div></figure>
        
        <p>Our advice when moving shared code to a separate component (leaf node namespace)<a data-type="indexterm" data-primary="Flatten Components pattern" data-secondary="metrics for shared components" id="idm45978847482240"></a> is to pick a word that is not used in any existing codebase in the domain, such as <code>.sharedcode</code>, <code>.commoncode</code>, or some such unique name. This allows the architect to generate metrics based on the number of shared components in the codebase, as well as the <em>percentage</em> of source code that is shared in the application. This is a good indicator as to the feasibility of breaking up the monolithic application. For example, if the sum of all the statements in all namespaces ending with <code>.sharedcode</code> constitutes 45% of the overall source code, chances are moving to a distributed architecture will result in too many shared libraries and end up becoming a nightmare to maintain because of shared library dependencies.</p>
        
        <p>Another good metric involving the analysis of shared code is the <em>number</em> of components ending in <code>.sharedcode</code> (or whatever common shared namespace node is used). This metric gives the architect insight into how many shared libraries (JAR, DLL, and so on) or shared services will result from breaking up the monolithic application.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Fitness Functions for Governance"><div class="sect2" id="idm45978847549280">
        <h2>Fitness Functions for Governance</h2>
        
        <p>Applying the Flatten Components decomposition pattern involves<a data-type="indexterm" data-primary="Flatten Components pattern" data-secondary="fitness functions" id="idm45978847476272"></a><a data-type="indexterm" data-primary="fitness functions for governance" data-secondary="patterns for component-based decomposition" data-tertiary="flatten components" id="idm45978847475200"></a> a fair amount of subjectivity. For example, should code from leaf nodes be consolidated into the root namespace, or should code in a root namespace be moved into leaf nodes? That said, the following fitness function can assist in automating the governance of keeping components flat (only in leaf nodes).</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: No source code should reside in a root namespace"><div class="sect3" id="sec-ff-orphans">
        <h3>Fitness function: No source code should reside in a root namespace</h3>
        
        <p>This automated holistic fitness function can be triggered on deployment through a CI/CD pipeline to locate orphaned classes—classes that reside in a root namespace. Use of this fitness function helps keep components flat when undergoing a monolithic migration, especially when performing ongoing maintenance to the monolithic application during the migration effort. <a data-type="xref" href="#source-ff-orphans">Example&nbsp;5-6</a> shows the pseudocode that alerts an architect when orphaned classes appear anywhere in the codebase.<a data-type="indexterm" data-startref="ch05-flat" id="idm45978847470960"></a><a data-type="indexterm" data-startref="ch05-flat2" id="idm45978847470288"></a><a data-type="indexterm" data-startref="ch05-flat4" id="idm45978847469616"></a><a data-type="indexterm" data-startref="ch05-flat5" id="idm45978847468944"></a><a data-type="indexterm" data-startref="ch05-flat6" id="idm45978847468272"></a></p>
        <div id="source-ff-orphans" data-type="example">
        <h5><span class="label">Example 5-6. </span>Pseudocode for finding code in root namespaces</h5>
        
        <pre data-type="programlisting" data-code-language="perl"><code class="c1"># Walk the directory structure, creating namespaces for each complete path</code>
        <code class="n">LIST</code> <code class="n">component_list</code> <code class="o">=</code> <code class="n">identify_components</code><code class="p">(</code><code class="n">root_directory</code><code class="p">)</code>
        
        <code class="c1"># Send an alert if a non-leaf node in any component contains source files</code>
        <code class="n">FOREACH</code> <code class="n">component</code> <code class="n">IN</code> <code class="n">component_list</code> <code class="p">{</code>
          <code class="n">LIST</code> <code class="n">component_node_list</code> <code class="o">=</code> <code class="n">get_nodes</code><code class="p">(</code><code class="n">component</code><code class="p">)</code>
          <code class="n">FOREACH</code> <code class="n">node</code> <code class="n">IN</code> <code class="n">component_node_list</code> <code class="p">{</code>
            <code class="n">IF</code> <code class="n">contains_code</code><code class="p">(</code><code class="n">node</code><code class="p">)</code> <code class="n">AND</code> <code class="n">NOT</code> <code class="n">last_node</code><code class="p">(</code><code class="n">component_node_list</code><code class="p">)</code> <code class="p">{</code>
              <code class="n">send_alert</code><code class="p">(</code><code class="n">component</code><code class="p">)</code>
            <code class="p">}</code>
          <code class="p">}</code>
        <code class="p">}</code></pre></div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Sysops Squad Saga: Flattening Components"><div class="sect2" id="idm45978847442672">
        <h2>Sysops Squad Saga: Flattening Components</h2>
        
        <p><code>Wednesday, November 10, 11:10</code></p>
        <div class="story">
        
        <p>After applying the <a data-type="xref" href="#sec-pattern-gather-common">“Gather Common Domain Components Pattern”</a>, Addison<a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="flatten components" id="ch05-ssfla"></a><a data-type="indexterm" data-primary="Flatten Components pattern" data-secondary="Sysops Squad saga" id="ch05-ssfla3"></a> analyzed the results in <a data-type="xref" href="#table-ss-result-common">Table&nbsp;5-7</a> and observed that the Survey and Ticket components contained orphaned classes. Addison highlighted these components in <a data-type="xref" href="#table-ss-flatten-analysis">Table&nbsp;5-9</a> and in <a data-type="xref" href="#fig-decomposition-patterns-ss-components-flatten-before">Figure 5-11</a>.</p>
        
        <figure><div id="fig-decomposition-patterns-ss-components-flatten-before" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0511.png" alt="Before Flattening Refactoring" width="600" height="791">
        <h6><span class="label">Figure 5-11. </span>The Survey and Ticket components contain orphaned classes and should be flattened</h6>
        </div></figure>
        <table id="table-ss-flatten-analysis" style="width: 80%">
        <caption><span class="label">Table 5-9. </span>Sysops Squad Ticket and Survey components should be flattened</caption>
        <thead>
        <tr>
        <th>Component name</th>
        <th>Component namespace</th>
        <th>Statements</th>
        <th>Files</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p><strong>Ticket</strong></p></td>
        <td><p><code>ss.ticket</code></p></td>
        <td><p><strong>7,009</strong></p></td>
        <td><p><strong>45</strong></p></td>
        </tr>
        <tr>
        <td><p>Ticket Assign</p></td>
        <td><p><code>ss.ticket.assign</code></p></td>
        <td><p>7,845</p></td>
        <td><p>14</p></td>
        </tr>
        <tr>
        <td><p>Ticket Route</p></td>
        <td><p><code>ss.ticket.route</code></p></td>
        <td><p>1,468</p></td>
        <td><p>4</p></td>
        </tr>
        <tr>
        <td><p><strong>Survey</strong></p></td>
        <td><p><code>ss.survey</code></p></td>
        <td><p><strong>2,204</strong></p></td>
        <td><p><strong>5</strong></p></td>
        </tr>
        <tr>
        <td><p>Survey Templates</p></td>
        <td><p><code>ss.survey.templates</code></p></td>
        <td><p>1,672</p></td>
        <td><p>7</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Addison decided to address the ticketing components first. Knowing that flattening components meant getting rid of source code in nonleaf nodes, Addison had two choices: consolidate the code contained in the ticket assignment and ticket routing components into the <code>ss.ticket</code> component, or break up the 45 classes in the <code>ss.ticket</code> component into separate components, thus making <code>ss.ticket</code> a subdomain. Addison discussed these options with Sydney (one of the Sysops Squad developers), and based on the complexity and frequent changes in the ticket assignment functionality, decided to keep those components separate and move the orphaned code from the <code>ss.ticket</code> root namespace into other namespaces, thus forming new components.</p>
        
        <p>With help from Sydney, Addison found that the 45 orphaned classes contained in the <code>ss.ticket</code> namespace implemented the following ticketing functionality:</p>
        
        <ul>
        <li>
        <p>Ticket creation and maintenance (creating a ticket, updating a ticket, canceling a ticket, etc.)</p>
        </li>
        <li>
        <p>Ticket completion logic</p>
        </li>
        <li>
        <p>Shared code common to most of the ticketing functionality</p>
        </li>
        </ul>
        
        <p>Since ticket assignment and ticket routing functionality were already in their own components (<code>ss.ticket.assign</code> and <code>ss.ticket.route</code>, respectively), Addison created an architecture story to move the source code contained in the <code>ss.ticket</code> namespace to three new components, as shown in <a data-type="xref" href="#table-ss-flatten-ticket">Table&nbsp;5-10</a>.</p>
        <table id="table-ss-flatten-ticket" style="width: 100%">
        <caption><span class="label">Table 5-10. </span>The prior Sysops Squad Ticket component broken into three new components</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Namespace</th>
        <th>Responsibility</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p><strong>Ticket Shared</strong></p></td>
        <td><p><code>ss.ticket.shared</code></p></td>
        <td><p>Common code and utilities</p></td>
        </tr>
        <tr>
        <td><p><strong>Ticket Maintenance</strong></p></td>
        <td><p><code>ss.ticket.maintenance</code></p></td>
        <td><p>Add and maintain tickets</p></td>
        </tr>
        <tr>
        <td><p><strong>Ticket Completion</strong></p></td>
        <td><p><code>ss.ticket.completion</code></p></td>
        <td><p>Complete ticket and initiate survey</p></td>
        </tr>
        <tr>
        <td><p>Ticket Assign</p></td>
        <td><p><code>ss.ticket.assign</code></p></td>
        <td><p>Assign expert to ticket</p></td>
        </tr>
        <tr>
        <td><p>Ticket Route</p></td>
        <td><p><code>ss.ticket.route</code></p></td>
        <td><p>Send ticket to expert</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Addison then considered the survey functionality. Working with Sydney, Addison found that the survey functionality rarely changed and was not overly complicated. Sydney talked with Skyler, the Sysops Squad developer who originally created the <code>ss.survey.templates</code> namespace, and found there was no compelling reason to separate the survey templates into their own namespace (“It just seemed like a good idea at the time,” said Skyler). With this information, Addison created an architecture story to move the seven class files from <code>ss.survey.templates</code> into the <code>ss.survey</code> namespace and removed the <code>ss.survey.template</code> component, as shown in <a data-type="xref" href="#table-ss-flatten-survey-templates">Table&nbsp;5-11</a>.</p>
        <table id="table-ss-flatten-survey-templates" style="width: 100%">
        <caption><span class="label">Table 5-11. </span>The prior Sysops Squad Survey components flattened into a single component</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Namespace</th>
        <th>Responsibility</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p><strong>Survey</strong></p></td>
        <td><p><code>ss.survey</code></p></td>
        <td><p>Send and receive surveys</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>After applying the Flatten Components pattern (illustrated in <a data-type="xref" href="#fig-decomposition-patterns-ss-components-flatten-after">Figure 5-12</a>), Addison observed that there were no “hills” (component upon component) or orphaned classes and that all of the components were contained only in the leaf nodes of the corresponding namespace.</p>
        
        <figure><div id="fig-decomposition-patterns-ss-components-flatten-after" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0512.png" alt="After Flattening Refactoring" width="600" height="791">
        <h6><span class="label">Figure 5-12. </span>The Survey component was flattened into a single component, whereas the Ticket component was raised up and flattened, creating a Ticket subdomain</h6>
        </div></figure>
        
        <p>Addison recorded the results of the refactoring efforts thus far in applying these decomposition patterns and listed them in <a data-type="xref" href="#table-ss-result-flattening">Table&nbsp;5-12</a>.<a data-type="indexterm" data-startref="ch05-ssfla" id="idm45978847308848"></a><a data-type="indexterm" data-startref="ch05-ssfla3" id="idm45978847308144"></a></p>
        <table id="table-ss-result-flattening" style="width: 100%">
        <caption><span class="label">Table 5-12. </span>Sysops Squad components after applying the Flatten Components pattern</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Namespace</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Login</p></td>
        <td><p><code>ss.login</code></p></td>
        </tr>
        <tr>
        <td><p>Billing Payment</p></td>
        <td><p><code>ss.billing.payment</code></p></td>
        </tr>
        <tr>
        <td><p>Billing History</p></td>
        <td><p><code>ss.billing.history</code></p></td>
        </tr>
        <tr>
        <td><p>Customer Profile</p></td>
        <td><p><code>ss.customer.profile</code></p></td>
        </tr>
        <tr>
        <td><p>Expert Profile</p></td>
        <td><p><code>ss.expert.profile</code></p></td>
        </tr>
        <tr>
        <td><p>KB Maint</p></td>
        <td><p><code>ss.kb.maintenance</code></p></td>
        </tr>
        <tr>
        <td><p>KB Search</p></td>
        <td><p><code>ss.kb.search</code></p></td>
        </tr>
        <tr>
        <td><p>Notification</p></td>
        <td><p><code>ss.notification</code></p></td>
        </tr>
        <tr>
        <td><p>Reporting Shared</p></td>
        <td><p><code>ss.reporting.shared</code></p></td>
        </tr>
        <tr>
        <td><p>Ticket Reports</p></td>
        <td><p><code>ss.reporting.tickets</code></p></td>
        </tr>
        <tr>
        <td><p>Expert Reports</p></td>
        <td><p><code>ss.reporting.experts</code></p></td>
        </tr>
        <tr>
        <td><p>Financial Reports</p></td>
        <td><p><code>ss.reporting.financial</code></p></td>
        </tr>
        <tr>
        <td><p><strong>Ticket Shared</strong></p></td>
        <td><p><code>ss.ticket.shared</code></p></td>
        </tr>
        <tr>
        <td><p><strong>Ticket Maintenance</strong></p></td>
        <td><p><code>ss.ticket.maintenance</code></p></td>
        </tr>
        <tr>
        <td><p><strong>Ticket Completion</strong></p></td>
        <td><p><code>ss.ticket.completion</code></p></td>
        </tr>
        <tr>
        <td><p><strong>Ticket Assign</strong></p></td>
        <td><p><code>ss.ticket.assign</code></p></td>
        </tr>
        <tr>
        <td><p><strong>Ticket Route</strong></p></td>
        <td><p><code>ss.ticket.route</code></p></td>
        </tr>
        <tr>
        <td><p>Support Contract</p></td>
        <td><p><code>ss.supportcontract</code></p></td>
        </tr>
        <tr>
        <td><p><strong>Survey</strong></p></td>
        <td><p><code>ss.survey</code></p></td>
        </tr>
        <tr>
        <td><p>User Maintenance</p></td>
        <td><p><code>ss.users</code></p></td>
        </tr>
        </tbody>
        </table>
        </div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Determine Component Dependencies Pattern"><div class="sect1" id="sec-pattern-dependencies">
        <h1>Determine Component Dependencies Pattern</h1>
        
        <p>Three of the most common questions asked when considering a migration from a monolithic application to a distributed architecture are as follows:<a data-type="indexterm" data-primary="dependencies" data-secondary="Determine Component Dependencies pattern" id="ch05-dcdp47"></a><a data-type="indexterm" data-primary="architectural decomposition" data-secondary="component-based" data-tertiary="determine component dependencies" id="ch05-dcdp4"></a><a data-type="indexterm" data-primary="component-based decomposition" data-secondary="patterns" data-tertiary="determine component dependencies" id="ch05-dcdp42"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="patterns for migration to service-based" data-tertiary="determine component dependencies" id="ch05-dcdp44"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="monolithic migration to" data-tertiary="determine component dependencies" id="ch05-dcdp45"></a><a data-type="indexterm" data-primary="Determine Component Dependencies pattern" id="ch05-dcdp46"></a></p>
        <ol>
        <li>
        <p>Is it feasible to break apart the existing monolithic application?</p>
        </li>
        <li>
        <p>What is the rough overall level of effort for this migration?</p>
        </li>
        <li>
        <p>Is this going to require a rewrite of the code or a refactoring of the code?</p>
        </li>
        
        </ol>
        
        <p class="pagebreak-before">One of your authors was engaged several years ago in a large migration effort to move a complex monolithic application to microservices. On the first day of the project, the CIO wanted to know only one thing—was this migration effort a golfball, basketball, or an airliner? Your author was curious about the sizing comparisons, but the CIO insisted that the answer to this simple question shouldn’t be that difficult given that kind of coarse-grained sizing. As it turned out, applying the <em>Determine Component Dependencies</em> pattern quickly and easily answered this question for the CIO—the effort was unfortunately an airliner, but only a small Embraer 190 migration rather than a large Boeing 787 Dreamliner migration.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Pattern Description"><div class="sect2" id="idm45978847253056">
        <h2>Pattern Description</h2>
        
        <p>The purpose of the <em>Determine Component Dependencies</em> pattern is to analyze the incoming and outgoing dependencies<a data-type="indexterm" data-primary="coupling" data-secondary="architectural decomposition" data-tertiary="determining component dependencies" id="idm45978847250608"></a><a data-type="indexterm" data-primary="components" data-secondary="dependencies determination" id="idm45978847249232"></a> (coupling) between <em>components</em> to determine what the resulting service dependency graph might look like after breaking up the monolithic application. While there are many factors in determining the right level of granularity for a service (see <a data-type="xref" href="ch07.html#ch07-service-granularity">Chapter&nbsp;7</a>), each component in the monolithic application is potentially a service candidate (depending on the target distributed architecture style). For this reason, it is critical to understand the interactions and dependencies between components.</p>
        
        <p>It’s important to note that this pattern is about component dependencies, not individual class dependencies within a component. A <em>component dependency</em> is formed when a class from one component (namespace) interacts with a class from another component (namespace). For example, suppose the <code>CustomerSurvey</code> class in the <code>ss.survey</code> component invokes a method in the <code>CustomerNotification</code> class in the <code>ss.notification</code> component to send out the customer survey, as illustrated in the pseudocode in <a data-type="xref" href="#source-dependency">Example&nbsp;5-7</a>.</p>
        <div id="source-dependency" data-type="example">
        <h5><span class="label">Example 5-7. </span>Pseudocode showing a dependency between the Survey and Notification components</h5>
        
        <pre data-type="programlisting" data-code-language="java"><code class="n">namespace</code> <code class="n">ss</code><code class="o">.</code><code class="na">survey</code>
        <code class="kd">class</code> <code class="nc">CustomerSurvey</code> <code class="o">{</code>
           <code class="n">function</code> <code class="n">createSurvey</code> <code class="o">{</code>
              <code class="o">...</code>
           <code class="o">}</code>
        
           <code class="n">function</code> <code class="n">sendSurvey</code> <code class="o">{</code>
              <code class="o">...</code>
              <code class="n">ss</code><code class="o">.</code><code class="na">notification</code><code class="o">.</code><code class="na">CustomerNotification</code><code class="o">.</code><code class="na">send</code><code class="o">(</code><code class="n">customer_id</code><code class="o">,</code> <code class="n">survey</code><code class="o">)</code>
           <code class="o">}</code>
        <code class="o">}</code></pre></div>
        
        <p>Notice the dependency between the Survey and Notification components, because the <code>CustomerNotification</code> class used by the <code>CustomerSurvey</code> class resides outside the <code>ss.survey</code> namespace. Specifically, the Survey component would have an efferent (or outgoing) dependency on the Notification component, and the Notification component would have an afferent (or incoming) dependency on the Survey component.</p>
        
        <p>Note that the classes <em>within</em> a particular component may be a highly coupled mess of numerous dependencies, but that doesn’t matter when applying this pattern—what matters is only those dependencies <em>between</em> components.</p>
        
        <p><a href="https://oreil.ly/XyIgr">Several tools</a> are <a data-type="indexterm" data-primary="tools" data-secondary="visualization" data-tertiary="dependencies" id="idm45978847184528"></a><a data-type="indexterm" data-primary="online resources" data-see="resources online" id="idm45978847183248"></a><a data-type="indexterm" data-primary="resources online" data-secondary="dependency tools" data-tertiary="visualization" id="idm45978847172752"></a><a data-type="indexterm" data-primary="tools" data-secondary="dependencies" data-tertiary="visualization" id="idm45978847171632"></a><a data-type="indexterm" data-primary="visualization tools" data-secondary="dependencies" id="idm45978847170416"></a><a data-type="indexterm" data-primary="dependencies" data-secondary="tools" data-tertiary="visualization tools resource" id="idm45978847169472"></a>available that can assist in applying this pattern and visualizing component dependencies. In addition, many modern IDEs have plug-ins that will produce dependency diagrams of the components, or namespaces, within a particular codebase. These visualizations can be useful in answering the three key questions posed at the start of this section.</p>
        
        <p>For example, consider the dependency diagram shown in <a data-type="xref" href="#fig-decomposition-patterns-dependencies-golfball">Figure 5-13</a>, where the boxes represent components (not classes), and the lines represent coupling points between the components. Notice there is only a single dependency between the components in this diagram, making this application a good candidate for breaking apart since the components are functionally independent from one another.</p>
        
        <figure><div id="fig-decomposition-patterns-dependencies-golfball" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0513.png" alt="Minimal Dependencies" width="600" height="581">
        <h6><span class="label">Figure 5-13. </span>A monolithic application with minimal component dependencies takes less effort to break apart (golf ball sizing)</h6>
        </div></figure>
        
        <p>With a dependency diagram like <a data-type="xref" href="#fig-decomposition-patterns-dependencies-golfball">Figure 5-13</a>, the answers to the three key questions are as follows:</p>
        <ol>
        <li>
        <p>Is it feasible to break apart the existing monolithic application? <em>Yes</em></p>
        </li>
        <li>
        <p>What is the rough overall level of effort for this migration? <em>A golf ball (relatively straightforward)</em></p>
        </li>
        <li>
        <p>Is this going to be a rewrite of the code or a refactoring of the code? <em>Refactoring (moving existing code into separately deployed services)</em></p>
        </li>
        
        </ol>
        
        <p>Now look at the dependency diagram shown in <a data-type="xref" href="#fig-decomposition-patterns-dependencies-basketball">Figure 5-14</a>. Unfortunately, this diagram is typical of the dependencies between components in most business applications. Notice in particular how the lefthand side of this diagram has the highest level of coupling, whereas the righthand side looks much more feasible to break apart.</p>
        
        <figure><div id="fig-decomposition-patterns-dependencies-basketball" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0514.png" alt="High Dependencies" width="600" height="581">
        <h6><span class="label">Figure 5-14. </span>A monolithic application with a high number of component dependencies takes more effort to break apart (basketball sizing)</h6>
        </div></figure>
        
        <p class="pagebreak-before">With this level of tight coupling between components, the answers to the three key questions are not very encouraging:</p>
        <ol>
        <li>
        <p>Is it feasible to break apart the existing monolithic application? <em>Maybe…</em></p>
        </li>
        <li>
        <p>What is the rough overall level of effort for this migration? <em>A basketball (much harder)</em></p>
        </li>
        <li>
        <p>Is this going to be a rewrite of the code or a refactoring of the code? <em>Likely a combination of some refactoring and some rewriting of the existing code</em></p>
        </li>
        
        </ol>
        
        <p>Finally, consider the dependency diagram illustrated in <a data-type="xref" href="#fig-decomposition-patterns-dependencies-airliner">Figure 5-15</a>. In this case, the architect should turn around and run in the opposite direction as fast as they can!</p>
        
        <figure><div id="fig-decomposition-patterns-dependencies-airliner" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0515.png" alt="Too Many Dependencies" width="600" height="581">
        <h6><span class="label">Figure 5-15. </span>A monolithic application with too many component dependencies is not feasible to break apart (airliner sizing)</h6>
        </div></figure>
        
        <p class="pagebreak-before">The answers to the three key questions for applications with this sort of component dependency matrix are not surprising:</p>
        <ol>
        <li>
        <p>Is it feasible to break apart the existing monolithic application? <em>No</em></p>
        </li>
        <li>
        <p>What is the rough overall level of effort for this migration? <em>An airliner</em></p>
        </li>
        <li>
        <p>Is this going to be a rewrite of the code or a refactoring of the code? <em>Total rewrite of the application</em></p>
        </li>
        
        </ol>
        
        <p>We cannot stress enough the importance of these kinds of<a data-type="indexterm" data-primary="tools" data-secondary="visualization" data-tertiary="dependencies" id="idm45978847143072"></a><a data-type="indexterm" data-primary="tools" data-secondary="visualization" data-tertiary="about importance of" id="idm45978847141744"></a><a data-type="indexterm" data-primary="visualization tools" data-secondary="dependencies" data-tertiary="importance of visualization" id="idm45978847140528"></a><a data-type="indexterm" data-primary="dependencies" data-secondary="tools" data-tertiary="visualization importance" id="idm45978847139344"></a><a data-type="indexterm" data-primary="tools" data-secondary="dependencies" data-tertiary="visualization" id="idm45978847138112"></a> visual diagrams when breaking apart a monolithic application. In essence these diagrams form a <em>radar</em> from which to determine where the enemy (high component coupling) is located, and also paint a picture of what the resulting service dependency matrix might look like if the monolithic application were to be broken into a highly distributed architecture.</p>
        
        <p>It has been our experience that component coupling is one of the most significant factors in determining the overall success (and feasibility) of a monolithic migration effort. Identifying and understanding the level of component coupling not only allows the architect to determine the feasibility of the migration effort, but also what to expect in terms of the overall level of effort. Unfortunately, all too often we see teams jump straight into breaking a monolithic application into microservices without having any analysis or visuals into what the monolithic application even looks like. And not surprisingly, those teams struggle to break apart their monolithic applications.</p>
        
        <p>This pattern is useful not only for identifying the overall level of component coupling in an application, but also for determining dependency refactoring opportunities prior to breaking apart the application. When analyzing the coupling level between components, it is important to analyze both afferent (incoming) coupling (denoted in most tools as <em>CA</em>), and efferent (outgoing) coupling (denoted in most tools as <em>CE</em>). <em>CT</em>, or total coupling, is the sum of both afferent and efferent coupling.</p>
        
        <p>Many times, breaking apart a component can reduce the level of coupling of that component. For example, assume component A has an afferent coupling level of 20 (meaning, 20 other components are dependent on the functionality of the component). This does not necessarily mean that all 20 of the other components require <em>all</em> of the functionality from component A. Maybe 14 of the other components require only a small part of the functionality contained in component A. Breaking component A into two different components (component A1 containing the smaller, coupled functionality, and component A2 containing the majority of the functionality) reduces the afferent coupling in component A2 to 6, with component A1 having an afferent coupling level of 14.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Fitness Functions for Governance"><div class="sect2" id="idm45978847252144">
        <h2>Fitness Functions for Governance</h2>
        
        <p>Two ways to automate the governance for component dependencies<a data-type="indexterm" data-primary="fitness functions for governance" data-secondary="patterns for component-based decomposition" data-tertiary="determine component dependencies" id="idm45978847132272"></a><a data-type="indexterm" data-primary="Determine Component Dependencies pattern" data-secondary="fitness functions" id="idm45978847130832"></a> are to make sure no component has “too many” dependencies, and to restrict certain components from being coupled to other components. The fitness functions described next are some ways of governing these type of dependencies.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: No component shall have more than <some number> of total dependencies"><div class="sect3" id="sec-ff-dependency-limit">
        <h3>Fitness function: No component shall have more than &lt;some number&gt; of total dependencies</h3>
        
        <p>This automated holistic fitness function can be triggered on deployment through a CI/CD pipeline to make sure that the coupling level of any given component doesn’t exceed a certain threshold. It is up to the architect to determine that this maximum threshold should be based on the overall level of coupling within the application and the number of components. An alert generated from this fitness function allows the architect to discuss any sort of increase in coupling with the development team, possibly promoting action to break apart components to reduce coupling. This fitness function could also be modified to generate an alert for a threshold limit of incoming only, outgoing only, or both (as separate fitness functions). <a data-type="xref" href="#source-ff-dependency-limit">Example&nbsp;5-8</a> shows the pseudocode for sending an alert if the total coupling (incoming and outgoing) exceeds a combined level of 15, which for most applications would be considered relatively high.</p>
        <div id="source-ff-dependency-limit" data-type="example">
        <h5><span class="label">Example 5-8. </span>Pseudocode for limiting the total number of dependencies of any given component</h5>
        
        <pre data-type="programlisting" data-code-language="perl" class="small"><code class="c1"># Walk the directory structure, gathering components and the source code files</code>
        <code class="c1"># contained within those components</code>
        <code class="n">LIST</code> <code class="n">component_list</code> <code class="o">=</code> <code class="n">identify_components</code><code class="p">(</code><code class="n">root_directory</code><code class="p">)</code>
        <code class="n">MAP</code> <code class="n">component_source_file_map</code>
        <code class="n">FOREACH</code> <code class="n">component</code> <code class="n">IN</code> <code class="n">component_list</code> <code class="p">{</code>
          <code class="n">LIST</code> <code class="n">component_source_file_list</code> <code class="o">=</code> <code class="n">get_source_files</code><code class="p">(</code><code class="n">component</code><code class="p">)</code>
          <code class="n">ADD</code> <code class="n">component</code><code class="p">,</code> <code class="n">component_source_file_list</code> <code class="n">TO</code> <code class="n">component_source_file_map</code>
        <code class="p">}</code>
        
        <code class="c1"># Determine how many references exist for each source file and send an alert if</code>
        <code class="c1"># the total dependency count is greater than 15</code>
        <code class="n">FOREACH</code> <code class="n">component</code><code class="p">,</code><code class="n">component_source_file_list</code> <code class="n">IN</code> <code class="n">component_source_file_map</code> <code class="p">{</code>
          <code class="n">FOREACH</code> <code class="n">source_file</code> <code class="n">IN</code> <code class="n">component_source_file_list</code> <code class="p">{</code>
            <code class="n">incoming</code> <code class="n">count</code> <code class="o">=</code> <code class="n">used_by_other_components</code><code class="p">(</code><code class="n">source_file</code><code class="p">,</code> <code class="n">component_source_file_map</code><code class="p">)</code> <code class="p">{</code>
            <code class="n">outgoing_count</code> <code class="o">=</code> <code class="n">uses_other_components</code><code class="p">(</code><code class="n">source_file</code><code class="p">)</code> <code class="p">{</code>
            <code class="n">total_count</code> <code class="o">=</code> <code class="n">incoming</code> <code class="n">count</code> <code class="o">+</code> <code class="n">outgoing</code> <code class="n">count</code>
          <code class="p">}</code>
          <code class="n">IF</code> <code class="n">total_count</code> <code class="o">&gt;</code> <code class="mi">15</code> <code class="p">{</code>
            <code class="n">send_alert</code><code class="p">(</code><code class="n">component</code><code class="p">,</code> <code class="n">total_count</code><code class="p">)</code>
          <code class="p">}</code>
        <code class="p">}</code></pre></div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: <some component> should not have a dependency on <another component>"><div class="sect3" id="sec-ff-dependency-restriction">
        <h3>Fitness function: &lt;some component&gt; should not have a dependency on &lt;another component&gt;</h3>
        
        <p>This automated holistic fitness function can be triggered on deployment through a CI/CD pipeline to restrict certain components from having a dependency on other ones. In most cases, there will be one fitness function for each dependency restriction so that, if there were 10 different component restrictions, there would be 10 different fitness functions, one for each component in question. <a data-type="xref" href="#source-ff-dependency-restriction">Example&nbsp;5-9</a> shows an example using <a href="https://www.archunit.org">ArchUnit</a> for ensuring that the Ticket Maintenance component (<code>ss.ticket.maintenance</code>) does not have a dependency on the Expert Profile component (<code>ss.expert.profile</code>).<a data-type="indexterm" data-startref="ch05-dcdp4" id="idm45978847016144"></a><a data-type="indexterm" data-startref="ch05-dcdp42" id="idm45978847015408"></a><a data-type="indexterm" data-startref="ch05-dcdp44" id="idm45978846980288"></a><a data-type="indexterm" data-startref="ch05-dcdp45" id="idm45978846979680"></a><a data-type="indexterm" data-startref="ch05-dcdp46" id="idm45978846979072"></a><a data-type="indexterm" data-startref="ch05-dcdp47" id="idm45978846978464"></a></p>
        <div id="source-ff-dependency-restriction" data-type="example">
        <h5><span class="label">Example 5-9. </span>ArchUnit code for governing dependency restrictions between components</h5>
        
        <pre data-type="programlisting" data-code-language="java"><code class="kd">public</code> <code class="kt">void</code> <code class="nf">ticket_maintenance_cannot_access_expert_profile</code><code class="o">()</code> <code class="o">{</code>
           <code class="n">noClasses</code><code class="o">().</code><code class="na">that</code><code class="o">()</code>
           <code class="o">.</code><code class="na">resideInAPackage</code><code class="o">(</code><code class="s">"..ss.ticket.maintenance.."</code><code class="o">)</code>
           <code class="o">.</code><code class="na">should</code><code class="o">().</code><code class="na">accessClassesThat</code><code class="o">()</code>
           <code class="o">.</code><code class="na">resideInAPackage</code><code class="o">(</code><code class="s">"..ss.expert.profile.."</code><code class="o">)</code>
           <code class="o">.</code><code class="na">check</code><code class="o">(</code><code class="n">myClasses</code><code class="o">);</code>
        <code class="o">}</code></pre></div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Sysops Squad Saga: Identifying Component Dependencies"><div class="sect2" id="idm45978846913408">
        <h2>Sysops Squad Saga: Identifying Component Dependencies</h2>
        
        <p><code>Monday, November 15, 09:45</code></p>
        <div class="story">
        
        <p>After reading about the Determine Component Dependencies pattern,<a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="determine component dependencies" id="ch05-sosd"></a><a data-type="indexterm" data-primary="Determine Component Dependencies pattern" data-secondary="Sysops Squad saga" id="ch05-sosd3"></a> Addison wondered what the Sysops Squad application dependency matrix looked like and whether it was feasible to even break the application apart. Addison used an IDE plug-in to generate a component dependency diagram of the current Sysops Squad application. Initially, Addison felt a bit discouraged because <a data-type="xref" href="#fig-decomposition-patterns-dependencies-ss">Figure 5-16</a> showed a lot of dependencies between the Sysops Squad application components.</p>
        
        <figure><div id="fig-decomposition-patterns-dependencies-ss" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0516.png" alt="Sysops Squad Dependencies" width="600" height="630">
        <h6><span class="label">Figure 5-16. </span>Component dependencies in the Sysops Squad application</h6>
        </div></figure>
        
        <p>However, after further analysis, Addison saw that the Notification component had the most dependencies, which was not surprising given that it’s a shared component. However, Addison also saw lots of dependencies within the Ticketing and Reporting components. Both of these domain areas have a specific component for shared code (interfaces, helper classes, entity classes, and so on). Realizing that both the ticketing and reporting shared code contains mostly compile-based class references and would likely be implemented as shared libraries rather than services, Addison filtered out these components to get a better view of the dependencies between the core functionality of the application, which is illustrated in <a data-type="xref" href="#fig-decomposition-patterns-dependencies-ss-filtered">Figure 5-17</a>.</p>
        
        <figure><div id="fig-decomposition-patterns-dependencies-ss-filtered" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0517.png" alt="Sysops Squad Filtered Dependencies" width="600" height="541">
        <h6><span class="label">Figure 5-17. </span>Component dependencies in the Sysops Squad application without shared library dependencies</h6>
        </div></figure>
        
        <p>With the shared components filtered out, Addison saw that the dependencies were fairly minimal. Addison showed these results to Austen, and they both agreed that most of the components were relatively self-contained and it appeared that the Sysops Squad application was a good candidate for breaking apart into a distributed architecture.<a data-type="indexterm" data-startref="ch05-sosd" id="idm45978846943088"></a><a data-type="indexterm" data-startref="ch05-sosd3" id="idm45978846942384"></a></p>
        <hr>
        </div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Create Component Domains Pattern"><div class="sect1" id="sec-pattern-create-domains">
        <h1>Create Component Domains Pattern</h1>
        
        <p>While each component identified within a monolithic application<a data-type="indexterm" data-primary="architectural decomposition" data-secondary="component-based" data-tertiary="create component domains" id="ch05-ccdp5"></a><a data-type="indexterm" data-primary="component-based decomposition" data-secondary="patterns" data-tertiary="create component domains" id="ch05-ccdp52"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="patterns for migration to service-based" data-tertiary="create component domains" id="ch05-ccdp54"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="monolithic migration to" data-tertiary="create component domains" id="ch05-ccdp55"></a><a data-type="indexterm" data-primary="Create Component Domains pattern" id="ch05-ccdp56"></a><a data-type="indexterm" data-primary="components" data-secondary="Create Component Domains pattern" id="ch05-ccdp57"></a><a data-type="indexterm" data-primary="services" data-secondary="component-based decomposition" data-tertiary="Create Component Domains pattern" id="idm45978846893392"></a> can be considered a possible candidate for a separate service, in most cases the relationship between a service and components is a one-to-many relationship—that is, a single service may contain one or more components. The purpose of the <em>Create Component Domains</em> pattern is to logically group components together so that more coarse-grained domain services can be created when breaking up an application.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Pattern Description"><div class="sect2" id="idm45978846891472">
        <h2>Pattern Description</h2>
        
        <p>Identifying component domains—the grouping of components that perform some sort of related functionality—is a critical part of breaking apart any monolithic application. <a data-type="indexterm" data-primary="microservices" data-secondary="service-based architecture as stepping-stone" id="idm45978846889344"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="stepping-stone to microservices" id="idm45978846888336"></a>Recall the advice from <a data-type="xref" href="ch04.html#ch04-architectural-decomposition">Chapter&nbsp;4</a>:</p>
        <blockquote>
        <p><em>When breaking apart monolithic applications, consider first moving to service-based architecture as a stepping-stone to other distributed architectures</em>.</p></blockquote>
        
        <p>Creating component domains is an effective way of determining what will eventually become domain services in a service-based architecture.<a data-type="indexterm" data-primary="service-based architecture" data-secondary="domain services from component domains" id="idm45978846884608"></a><a data-type="indexterm" data-primary="domain services" data-secondary="component domains into" id="idm45978846883600"></a></p>
        
        <p>Component domains are physically manifested in an application through <a data-type="indexterm" data-primary="namespaces" data-secondary="component domains" id="idm45978846882048"></a>component namespaces (or directories). Because namespace nodes are hierarchical in nature, they become an excellent way of representing the domains and subdomains of functionality. This technique is illustrated in <a data-type="xref" href="#fig-decomposition-patterns-domain-namespace">Figure 5-18</a>, where the second node in the namespace (<code>.customer</code>) refers to the <em>domain</em>, the third node represents a <em>subdomain</em> under the customer domain (<code>.billing</code>), and the leaf node (<code>.payment</code>) refers to the <em>component</em>. The <code>.MonthlyBilling</code> at the end of this namespace refers to a class file contained within the Payment component.</p>
        
        <figure><div id="fig-decomposition-patterns-domain-namespace" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0518.png" alt="Namespace Nodes and Domains" width="600" height="189">
        <h6><span class="label">Figure 5-18. </span>Component domains are identified through the namespace nodes</h6>
        </div></figure>
        
        <p>Since many older monolithic applications were implemented prior to the widespread<a data-type="indexterm" data-primary="Domain-Driven Design (DDD)" data-secondary="information link" id="idm45978846874624"></a><a data-type="indexterm" data-primary="Domain-Driven Design (DDD)" data-secondary="namespaces from applications prior to" id="idm45978846873632"></a><a data-type="indexterm" data-primary="namespaces" data-secondary="component domains" data-tertiary="applications prior to Domain-Driven Design" id="idm45978846872656"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="namespaces prior to Domain-Driven Design" id="idm45978846871408"></a> use of <a href="https://oreil.ly/AaKR2">domain-driven design</a>, in many cases refactoring of the namespaces is needed to structurally identify domains within the application. For example, consider the components listed in <a data-type="xref" href="#table-customer-before">Table&nbsp;5-13</a> that make up the Customer domain within the Sysops Squad application.</p>
        <table id="table-customer-before" style="width: 65%">
        <caption><span class="label">Table 5-13. </span>Components related to the Customer domain before refactoring</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Namespace</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Billing Payment</p></td>
        <td><p><code>ss.billing.payment</code></p></td>
        </tr>
        <tr>
        <td><p>Billing History</p></td>
        <td><p><code>ss.billing.history</code></p></td>
        </tr>
        <tr>
        <td><p>Customer Profile</p></td>
        <td><p><code>ss.customer.profile</code></p></td>
        </tr>
        <tr>
        <td><p>Support Contract</p></td>
        <td><p><code>ss.supportcontract</code></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Notice how each component is related to customer functionality, but the corresponding namespaces don’t reflect that association. To properly identify the Customer domain (manifested through the namespace <code>ss.customer</code>), the namespaces for the Billing Payment, Billing History, and Support Contract components would have to be modified to add the <code>.customer</code> node at the beginning of the namespace, as shown in <a data-type="xref" href="#table-customer-after">Table&nbsp;5-14</a>.</p>
        <table id="table-customer-after" style="width: 65%">
        <caption><span class="label">Table 5-14. </span>Components related to the Customer domain after refactoring</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Namespace</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Billing Payment</p></td>
        <td><p><code>ss.customer.billing.payment</code></p></td>
        </tr>
        <tr>
        <td><p>Billing History</p></td>
        <td><p><code>ss.customer.billing.history</code></p></td>
        </tr>
        <tr>
        <td><p>Customer Profile</p></td>
        <td><p><code>ss.customer.profile</code></p></td>
        </tr>
        <tr>
        <td><p>Support Contract</p></td>
        <td><p><code>ss.customer.supportcontract</code></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Notice in the prior table that all of the customer-related functionality (billing, profile maintenance, and support contract maintenance) is now grouped under <code>.customer</code>, aligning each component with that particular domain.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Fitness Functions for Governance"><div class="sect2" id="idm45978846890880">
        <h2>Fitness Functions for Governance</h2>
        
        <p>Once refactored, it’s important to govern the component domains to ensure<a data-type="indexterm" data-primary="components" data-secondary="Create Component Domains pattern" data-tertiary="fitness functions" id="idm45978846842880"></a><a data-type="indexterm" data-primary="Create Component Domains pattern" data-secondary="fitness functions" id="idm45978846841568"></a><a data-type="indexterm" data-primary="fitness functions for governance" data-secondary="patterns for component-based decomposition" data-tertiary="create component domains" id="idm45978846840608"></a><a data-type="indexterm" data-primary="namespaces" data-secondary="component domains" data-tertiary="fitness functions for governance" id="idm45978846839264"></a> that namespace rules are enforced and that no code exists outside the context of a component domain or subdomain. The following automated fitness function can be used to help govern component domains once they are established within the monolithic application.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: All namespaces under <root namespace node> should be restricted to <list of domains>"><div class="sect3" id="ff-domain-restriction">
        <h3>Fitness function: All namespaces under &lt;root namespace node&gt; should be restricted to &lt;list of domains&gt;</h3>
        
        <p>This automated holistic fitness function can be triggered on deployment through a CI/CD pipeline to restrict the domains contained within an application. This fitness function helps prevent additional domains from being inadvertently created by development teams and alerts the architect if any new namespaces (or directories) are created outside the approved list of domains. <a data-type="xref" href="#source-ff-domain-restriction">Example&nbsp;5-10</a> shows an example using <a href="https://www.archunit.org">ArchUnit</a> for ensuring that only the ticket, customer, and admin domains exist within an application.<a data-type="indexterm" data-startref="ch05-ccdp5" id="idm45978846834096"></a><a data-type="indexterm" data-startref="ch05-ccdp52" id="idm45978846833392"></a><a data-type="indexterm" data-startref="ch05-ccdp53" id="idm45978846832720"></a><a data-type="indexterm" data-startref="ch05-ccdp54" id="idm45978846832048"></a><a data-type="indexterm" data-startref="ch05-ccdp55" id="idm45978846831376"></a><a data-type="indexterm" data-startref="ch05-ccdp56" id="idm45978846830704"></a><a data-type="indexterm" data-startref="ch05-ccdp57" id="idm45978846830032"></a></p>
        <div id="source-ff-domain-restriction" data-type="example" class="pagebreak-before less_space">
        <h5><span class="label">Example 5-10. </span>ArchUnit code for governing domains within an application</h5>
        
        <pre data-type="programlisting" data-code-language="java"><code class="kd">public</code> <code class="kt">void</code> <code class="nf">restrict_domains</code><code class="o">()</code> <code class="o">{</code>
           <code class="n">classes</code><code class="o">()</code>
             <code class="o">.</code><code class="na">should</code><code class="o">().</code><code class="na">resideInAPackage</code><code class="o">(</code><code class="s">"..ss.ticket.."</code><code class="o">)</code>
             <code class="o">.</code><code class="na">orShould</code><code class="o">().</code><code class="na">resideInAPackage</code><code class="o">(</code><code class="s">"..ss.customer.."</code><code class="o">)</code>
             <code class="o">.</code><code class="na">orShould</code><code class="o">().</code><code class="na">resideInAPackage</code><code class="o">(</code><code class="s">"..ss.admin.."</code><code class="o">)</code>
             <code class="o">.</code><code class="na">check</code><code class="o">(</code><code class="n">myClasses</code><code class="o">);</code>
        <code class="o">}</code></pre></div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Sysops Squad Saga: Creating Component Domains"><div class="sect2" id="idm45978846808080">
        <h2>Sysops Squad Saga: Creating Component Domains</h2>
        
        <p><code>Thursday, November 18, 13:15</code></p>
        <div class="story">
        
        <p>Addison and Austen consulted with Parker, the Sysops Squad product owner, <a data-type="indexterm" data-primary="Create Component Domains pattern" data-secondary="Sysops Squad saga" id="ch05-sssc52"></a><a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="create component domains" id="ch05-sssc53"></a>and together they identified five main domains within the application: a Ticketing domain (<code>ss.ticket</code>) containing all ticket-related functionality, including ticket processing, customer surveys, and knowledge base (KB) functionality; a Reporting domain (<code>ss.reporting</code>) containing all reporting functionality; a Customer domain (<code>ss.customer</code>) containing customer profile, billing, and support contracts; an Admin domain (<code>ss.admin</code>) containing maintenance of users and Sysops Squad experts; and finally, a Shared domain (<code>ss.shared</code>) containing login and notification functionality used by the other domains.</p>
        
        <p>Addison created a domain diagram (see <a data-type="xref" href="#fig-decomposition-patterns-ss-components-domain">Figure 5-19</a>) showing the various domains and corresponding groups of components within each domain, and was satisfied with this grouping as no component was left out, and there was good cohesion between the components within each domain.</p>
        
        <p>The exercise Addison did in diagramming and grouping the <a data-type="indexterm" data-primary="tools" data-secondary="visualization" data-tertiary="domain diagramming exercise" id="idm45978846791664"></a><a data-type="indexterm" data-primary="visualization tools" data-secondary="domain diagramming exercise" id="idm45978846790448"></a>components was an important one as it validated the identified domain candidates and also demonstrated the need for collaboration with business stakeholders (such as the product owner or business application sponsor). Had the components not lined up properly or Addison was left with components that didn’t belong anywhere, more collaboration with Parker (the product owner) would have been necessary.</p>
        
        <p>Satisfied that all of the components fit nicely into these domains, Addison then looked at the various component namespaces in <a data-type="xref" href="#table-ss-result-flattening">Table&nbsp;5-12</a> after applying the <a data-type="xref" href="#sec-pattern-flatten">“Flatten Components Pattern”</a> and identified the component domain refactoring that needed to take place.</p>
        
        <figure><div id="fig-decomposition-patterns-ss-components-domain" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0519.png" alt="Component Domains" width="600" height="791">
        <h6><span class="label">Figure 5-19. </span>The five domains identified (with darkened borders) within the Sysops Squad application</h6>
        </div></figure>
        
        <p>Addison started with the Ticket domain and saw that while the core ticket functionality started with the namespace <code>ss.ticket</code>, the survey and knowledge base components did not. Therefore, Addison wrote an architecture story to refactor the components listed in <a data-type="xref" href="#table-ss-ticket">Table&nbsp;5-15</a> to align with the ticketing domain.</p>
        <table id="table-ss-ticket" class="pagebreak-before less_space" style="width: 100%">
        <caption><span class="label">Table 5-15. </span>Sysops Squad component refactoring for the Ticket domain</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Domain</th>
        <th>Current namespace</th>
        <th>Target namespace</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>KB Maint</p></td>
        <td><p>Ticket</p></td>
        <td><p><code>ss.kb.maintenance</code></p></td>
        <td><p><code>ss.ticket.kb.maintenance</code></p></td>
        </tr>
        <tr>
        <td><p>KB Search</p></td>
        <td><p>Ticket</p></td>
        <td><p><code>ss.kb.search</code></p></td>
        <td><p><code>ss.ticket.kb.search</code></p></td>
        </tr>
        <tr>
        <td><p>Ticket Shared</p></td>
        <td><p>Ticket</p></td>
        <td><p><code>ss.ticket.shared</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        <tr>
        <td><p>Ticket Maintenance</p></td>
        <td><p>Ticket</p></td>
        <td><p><code>ss.ticket.maintenance</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        <tr>
        <td><p>Ticket Completion</p></td>
        <td><p>Ticket</p></td>
        <td><p><code>ss.ticket.completion</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        <tr>
        <td><p>Ticket Assign</p></td>
        <td><p>Ticket</p></td>
        <td><p><code>ss.ticket.assign</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        <tr>
        <td><p>Ticket Route</p></td>
        <td><p>Ticket</p></td>
        <td><p><code>ss.ticket.route</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        <tr>
        <td><p>Survey</p></td>
        <td><p>Ticket</p></td>
        <td><p><code>ss.survey</code></p></td>
        <td><p><code>ss.ticket.survey</code></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Next Addison considered the customer-related components, and found that the billing and survey components needed to be refactored to include them under the Customer domain, creating a Billing subdomain in the process. Addison wrote an architecture story for the refactoring of the Customer domain functionality, shown in <a data-type="xref" href="#table-ss-customer">Table&nbsp;5-16</a>.</p>
        <table id="table-ss-customer" style="width: 100%">
        <caption><span class="label">Table 5-16. </span>Sysops Squad component refactoring for the Customer domain</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Domain</th>
        <th>Current namespace</th>
        <th>Target namespace</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Billing Payment</p></td>
        <td><p>Customer</p></td>
        <td><p><code>ss.billing.payment</code></p></td>
        <td><p><code>ss.customer.billing.payment</code></p></td>
        </tr>
        <tr>
        <td><p>Billing History</p></td>
        <td><p>Customer</p></td>
        <td><p><code>ss.billing.history</code></p></td>
        <td><p><code>ss.customer.billing.history</code></p></td>
        </tr>
        <tr>
        <td><p>Customer Profile</p></td>
        <td><p>Customer</p></td>
        <td><p><code>ss.customer.profile</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        <tr>
        <td><p>Support Contract</p></td>
        <td><p>Customer</p></td>
        <td><p><code>ss.supportcontract</code></p></td>
        <td><p><code>ss.customer.supportcontract</code></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>By applying the <a data-type="xref" href="#sec-pattern-identify-size">“Identify and Size Components Pattern”</a>, Addison found that the reporting domain was already aligned, and no further action was needed with the reporting components listed in <a data-type="xref" href="#table-ss-reporting">Table&nbsp;5-17</a>.</p>
        <table id="table-ss-reporting" style="width: 100%">
        <caption><span class="label">Table 5-17. </span>Sysops Squad Reporting components are already aligned with the Reporting domain</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Domain</th>
        <th>Current namespace</th>
        <th>Target namespace</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Reporting Shared</p></td>
        <td><p>Reporting</p></td>
        <td><p><code>ss.reporting.shared</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        <tr>
        <td><p>Ticket Reports</p></td>
        <td><p>Reporting</p></td>
        <td><p><code>ss.reporting.tickets</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        <tr>
        <td><p>Expert Reports</p></td>
        <td><p>Reporting</p></td>
        <td><p><code>ss.reporting.experts</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        <tr>
        <td><p>Financial Reports</p></td>
        <td><p>Reporting</p></td>
        <td><p><code>ss.reporting.financial</code></p></td>
        <td><p>Same (no change)</p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Addison saw that both the Admin and Shared domains needed alignment as well, and decided to create a single architecture story for this refactoring effort and listed these components in <a data-type="xref" href="#table-ss-admin">Table&nbsp;5-18</a>. Addison also decided to rename the <code>ss.expert.profile</code> namespace to <code>ss.experts</code> to avoid an unnecessary Expert subdomain under the Admin domain.</p>
        <table id="table-ss-admin" style="width: 100%">
        <caption><span class="label">Table 5-18. </span>Sysops Squad component refactoring for the Admin and Shared domains</caption>
        <thead>
        <tr>
        <th>Component</th>
        <th>Domain</th>
        <th>Current namespace</th>
        <th>Target namespace</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Login</p></td>
        <td><p>Shared</p></td>
        <td><p><code>ss.login</code></p></td>
        <td><p><code>aa.shared.login</code></p></td>
        </tr>
        <tr>
        <td><p>Notification</p></td>
        <td><p>Shared</p></td>
        <td><p><code>ss.notification</code></p></td>
        <td><p><code>ss.shared.notification</code></p></td>
        </tr>
        <tr>
        <td><p>Expert Profile</p></td>
        <td><p>Admin</p></td>
        <td><p><code>ss.expert.profile</code></p></td>
        <td><p><code>ss.admin.experts</code></p></td>
        </tr>
        <tr>
        <td><p>User Maintenance</p></td>
        <td><p>Admin</p></td>
        <td><p><code>ss.users</code></p></td>
        <td><p><code>ss.admin.users</code></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>With this pattern complete, Addison realized they were now prepared to structurally break apart the monolithic application and move to the first stage of a distributed architecture by applying the Create Domain Services pattern (described in the next section).<a data-type="indexterm" data-startref="ch05-sssc52" id="idm45978846661248"></a><a data-type="indexterm" data-startref="ch05-sssc53" id="idm45978846660544"></a></p>
        <hr>
        </div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Create Domain Services Pattern"><div class="sect1" id="sec-pattern-domain-services">
        <h1>Create Domain Services Pattern</h1>
        
        <p>Once components have been properly sized, flattened, and grouped into domains, <a data-type="indexterm" data-primary="architectural decomposition" data-secondary="component-based" data-tertiary="create domain services" id="ch05-cdsp6"></a><a data-type="indexterm" data-primary="component-based decomposition" data-secondary="patterns" data-tertiary="create domain services" id="ch05-cdsp62"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="patterns for migration to service-based" data-tertiary="create domain services" id="ch05-cdsp63"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="monolithic migration to" data-tertiary="create domain services" id="ch05-cdsp64"></a><a data-type="indexterm" data-primary="Create Domain Services pattern" id="ch05-cdsp65"></a><a data-type="indexterm" data-primary="domain services" data-secondary="component domains into" data-tertiary="Create Domain Services pattern" id="ch05-cdsp66"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="domain services from component domains" data-tertiary="Create Domain Services pattern" id="ch05-cdsp67"></a><a data-type="indexterm" data-primary="domain services" data-secondary="service-based architecture definition" id="idm45978846647184"></a>those domains can then be moved to separately deployed <em>domain services</em>, creating what is known as a service-based architecture (see <a data-type="xref" href="app01.html#sec-references">Appendix&nbsp;A</a>). <a data-type="indexterm" data-primary="domain services" data-secondary="about" id="idm45978846644880"></a>Domain services are coarse-grained, separately deployed units of software containing all of the functionality for a particular domain (such as Ticketing, Customer, Reporting, and so on).</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Pattern Description"><div class="sect2" id="idm45978846643776">
        <h2>Pattern Description</h2>
        
        <p>The previous <a data-type="xref" href="#sec-pattern-create-domains">“Create Component Domains Pattern”</a> forms well-defined component domains within a monolithic application and manifests those domains through the component namespaces (or directory structures). This pattern takes those well-defined component domains and extracts those component groups into separately deployed services, known as a <em>domain services</em>, thus creating a service-based architecture.</p>
        
        <p>In its simplest form, service-based architecture consists of a <a data-type="indexterm" data-primary="service-based architecture" data-secondary="about" id="idm45978846640592"></a>user interface that remotely accesses coarse-grained domain services, all sharing a single monolithic database. Although there are many topologies within service-based architecture (such as breaking up the user interface, breaking up the database, adding an API gateway, and so on), the basic topology shown in <a data-type="xref" href="#fig-decomposition-patterns-sba">Figure 5-20</a> is a good starting point for migrating a monolithic application.</p>
        
        <figure><div id="fig-decomposition-patterns-sba" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0520.png" alt="Service-Based Architecture" width="600" height="364">
        <h6><span class="label">Figure 5-20. </span>The basic topology for a service-based architecture</h6>
        </div></figure>
        
        <p>In addition to the benefits mentioned in <a data-type="xref" href="ch04.html#sec-component-decomposition">“Component-Based Decomposition”</a>, moving to service-based architecture<a data-type="indexterm" data-primary="service-based architecture" data-secondary="stepping-stone to microservices" id="idm45978846635216"></a><a data-type="indexterm" data-primary="microservices" data-secondary="service-based architecture as stepping-stone" id="idm45978846634192"></a><a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="6. create domain services" id="idm45978846633152"></a> first allows the architect and development team to learn more about each domain service to determine whether it should be broken into smaller services within a microservices architecture or left as a larger domain service. Too many teams make the mistake of starting out too fine-grained, and as a result must embrace all of the trappings of microservices (such as data decomposition, distributed workflows, distributed transactions, operational automation, containerization, and so on) without the need for all of those fine-grained microservices.</p>
        
        <p><a data-type="xref" href="#fig-decomposition-patterns-domain-service">Figure 5-21</a> illustrates how the <em>Create Domain Services</em> pattern works. Notice in the diagram how the Reporting component domain defined in the <a data-type="xref" href="#sec-pattern-create-domains">“Create Component Domains Pattern”</a> is extracted from of the monolithic application, forming its own separately deployed Reporting service.</p>
        
        <figure><div id="fig-decomposition-patterns-domain-service" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0521.png" alt="Domain Service Extraction" width="600" height="641">
        <h6><span class="label">Figure 5-21. </span>Component domains are moved to external domain services</h6>
        </div></figure>
        
        <p>A word of advice, however: don’t apply this pattern until <em>all</em> of the component domains have been identified and refactored. This helps reduce the amount of modification needed to each domain service when moving components (and hence source code) around. For example, suppose all of the ticketing and knowledge base functionality in the Sysops Squad application was grouped and refactored into a Ticket domain, and a new Ticket service created from that domain. Now suppose that the customer survey component (identified through the <code>ss.customer.survey</code> namespace) was deemed part of the Ticket domain. Since the Ticket domain had already been migrated, the Ticket service would now have to be modified to include the Survey component. Better to align and refactor all of the components into component domains first, <em>then</em> start migrating those component domains to domain services.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Fitness Functions for Governance"><div class="sect2" id="idm45978846625296">
        <h2>Fitness Functions for Governance</h2>
        
        <p>It is important to keep the components within each domain service aligned with the domain, <a data-type="indexterm" data-primary="Create Domain Services pattern" data-secondary="fitness functions" id="idm45978846623568"></a><a data-type="indexterm" data-primary="fitness functions for governance" data-secondary="patterns for component-based decomposition" data-tertiary="create domain services" id="idm45978846622528"></a>particularly if the domain service will be broken into smaller microservices. This type of governance helps keep domain services from becoming their own unstructured monolithic service. The following fitness function ensures that the namespace (and hence components) are kept consistent within a domain service.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Fitness function: All components in <some domain service> should start with the same namespace"><div class="sect3" id="ff-domain-services">
        <h3>Fitness function: All components in &lt;some domain service&gt; should start with the same namespace</h3>
        
        <p>This automated holistic fitness function can <a data-type="indexterm" data-primary="namespaces" data-secondary="fitness function" id="idm45978846618752"></a><a data-type="indexterm" data-primary="domain services" data-secondary="component domains into" data-tertiary="fitness function for namespace" id="idm45978846617776"></a><a data-type="indexterm" data-primary="ArchUnit tool" id="idm45978846616592"></a><a data-type="indexterm" data-primary="tools" data-secondary="ArchUnit" id="idm45978846615920"></a><a data-type="indexterm" data-primary="resources online" data-secondary="ArchUnit tool" id="idm45978846614976"></a>be triggered on deployment through a CI/CD pipeline to make sure the namespaces for components within a domain service remain consistent. For example, all components within the Ticket domain service should start with <code>ss.ticket</code>. <a data-type="xref" href="#source-ff-domain-services">Example&nbsp;5-11</a> uses ArchUnit for ensuring this constraint. Each domain service would have its own corresponding fitness function based on its particular domain.<a data-type="indexterm" data-startref="ch05-cdsp6" id="idm45978846612240"></a><a data-type="indexterm" data-startref="ch05-cdsp62" id="idm45978846611568"></a><a data-type="indexterm" data-startref="ch05-cdsp63" id="idm45978846610896"></a><a data-type="indexterm" data-startref="ch05-cdsp64" id="idm45978846610224"></a><a data-type="indexterm" data-startref="ch05-cdsp65" id="idm45978846609552"></a><a data-type="indexterm" data-startref="ch05-cdsp66" id="idm45978846608880"></a><a data-type="indexterm" data-startref="ch05-cdsp67" id="idm45978846608208"></a></p>
        <div id="source-ff-domain-services" data-type="example">
        <h5><span class="label">Example 5-11. </span>ArchUnit code for governing components within the Ticket domain service</h5>
        
        <pre data-type="programlisting" data-code-language="java"><code class="kd">public</code> <code class="kt">void</code> <code class="nf">restrict_domain_within_ticket_service</code><code class="o">()</code> <code class="o">{</code>
           <code class="n">classes</code><code class="o">().</code><code class="na">should</code><code class="o">().</code><code class="na">resideInAPackage</code><code class="o">(</code><code class="s">"..ss.ticket.."</code><code class="o">)</code>
           <code class="o">.</code><code class="na">check</code><code class="o">(</code><code class="n">myClasses</code><code class="o">);</code>
        <code class="o">}</code></pre></div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Sysops Squad Saga: Creating Domain Services"><div class="sect2" id="idm45978846591680">
        <h2>Sysops Squad Saga: Creating Domain Services</h2>
        
        <p><code>Tuesday, November 23, 09:04</code></p>
        <div class="story">
        
        <p>Addison and Austen worked closely with the Sysops Squad<a data-type="indexterm" data-primary="Create Domain Services pattern" data-secondary="Sysops Squad saga" id="idm45978846589472"></a><a data-type="indexterm" data-primary="Create Component Domains pattern" data-secondary="Sysops Squad saga" id="idm45978846583184"></a><a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="create domain services" id="idm45978846582272"></a> development team to develop a migration plan to stage the migration from component domains to domain services. They realized this effort not only required the code within each component domain to be extracted from the monolith and moved to a new project workspace, but also for the user interface to now remotely access the functionality within that domain.</p>
        
        <p>Working from the component domains identified previously in <a data-type="xref" href="#fig-decomposition-patterns-ss-components-domain">Figure 5-19</a>, the team migrated each component, one at a time, eventually arriving at a service-based architecture, as shown in <a data-type="xref" href="#fig-decomposition-patterns-ss-components-domain-services">Figure 5-22</a>. Notice how each domain area identified in the previous pattern now becomes a separately deployed service.</p>
        
        <figure><div id="fig-decomposition-patterns-ss-components-domain-services" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0522.png" alt="Domain Services" width="576" height="800">
        <h6><span class="label">Figure 5-22. </span>Separately deployed domain services result in a distributed Sysops Squad application</h6>
        </div></figure>
        </div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45978846576464">
        <h1>Summary</h1>
        
        <p>It has been our experience that “seat-of-the-pants” migration efforts rarely produce positive results. Applying these component-based decomposition patterns provides a structured, controlled, and incremental approach for breaking apart monolithic architectures. Once these patterns are applied, teams can now work to decompose monolithic data (see <a data-type="xref" href="ch06.html#ch06-decomposing-operational-data">Chapter&nbsp;6</a>) and begin breaking apart domain services into more fine-grained microservices (see <a data-type="xref" href="ch07.html#ch07-service-granularity">Chapter&nbsp;7</a>) as needed.</p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492086888/files/epub.css" crossorigin="anonymous"><script src="https://learning.oreilly.comhttps://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-svg.js"></script></div></div></section>
</div>

https://learning.oreilly.com