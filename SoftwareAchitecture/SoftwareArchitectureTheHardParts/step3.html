<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Architectural Modularity"><div class="chapter" id="ch03-architectural-modularity">
        <h1><span class="label">Chapter 3. </span>Architectural Modularity</h1>
        
        
        <p><code>Tuesday, September 21 09:33</code></p>
        <div class="story">
        
        <p>It was the same conference room they had been in a hundred times before, but today the atmosphere was different. <a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="Sysops Squad saga" id="idm45978857079968"></a><a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" id="idm45978857078656"></a><a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="Sysops Squad saga" id="idm45978857077696"></a>Very different. As people gathered, no small talk was exchanged. Only silence. The sort of dead silence that you could cut with a knife. Yes, that was indeed an appropriate cliche given the topic of the meeting.</p>
        
        <p>The business leaders and sponsors of the failing Sysops Squad ticketing application met with the application architects, Addison and Austen, with the purpose of voicing their concern and frustration about the inability of the IT department to fix the never-ending issues associated with the trouble ticket application. “Without a working application,” they had said, “we cannot possibly continue to support this business line.”</p>
        
        <p>As the tense meeting ended, the business sponsors quietly filed out one by one, leaving Addison and Austen alone in the conference room.</p>
        
        <p>“That was a bad meeting,” said Addison. “I can’t believe they’re actually blaming <em>us</em> for all the issues we’re currently facing with the trouble ticket application. This is a really bad situation.”</p>
        
        <p>“Yeah, I know,” said Austen. “Especially the part about possibly closing down the product support business line. We’ll be assigned to other projects, or worse, maybe even let go. Although I’d rather be spending all of my time on the soccer field or on the slopes skiing in the winter, I really can’t afford to lose this job.”</p>
        
        <p>“Neither can I,” said Addison. “Besides, I really like the development team we have in place, and I’d hate to see it broken up.”</p>
        
        <p>“Me too,” said Austen. “I still think breaking apart the application would solve most of these issues.”</p>
        
        <p class="pagebreak-before">“I agree with you,” said Addison, “but how do we convince the business to spend more money and time to refactor the architecture? You saw how they complained in the meeting about the amount of money we’ve already spent applying patches here and there, only to create additional issues in the process.”</p>
        
        <p>“You’re right,” Austen said. “They would never agree to an expensive and time-consuming architecture migration effort at this point.”</p>
        
        <p>“But if we both agree that we need to break apart the application to keep it alive, how in the world are we going to convince the business and get the funding and time we need to completely restructure the Sysops Squad application?” asked Addison.</p>
        
        <p>“Beats me,” said Austen. “Let’s see if Logan is available to discuss this problem with us.”</p>
        
        <p>Addison looked online and saw that Logan, the lead architect for Penultimate Electronics, was available. Addison sent a message explaining that they wanted to break apart the existing monolithic application, but weren’t sure how to convince the business that this approach would work. Addison explained in the message that they were in a real bind and could use some advice. Logan agreed to meet with them and joined them in the conference room.</p>
        
        <p>“What makes you so sure that breaking apart the Sysops Squad application will solve all of the issues?” asked Logan.</p>
        
        <p>“Because,” said Austen, “we’ve tried patching the code over and over, and it doesn’t seem to be working. We still have way too many issues.”</p>
        
        <p>“You’re completely missing my point,” said Logan. “Let me ask you the question a different way. What assurances do you have that breaking apart the system will accomplish anything more than just spending more money and wasting more valuable time?”</p>
        
        <p>“Well,” said Austen, “actually, we don’t.”</p>
        
        <p>“Then how do you know breaking apart the application is the right approach?” asked Logan.</p>
        
        <p>“We already told you,” said Austen, “because nothing else we try seems to work!”</p>
        
        <p>“Sorry,” said Logan, “but you know as well as I do that’s not a reasonable justification for the business. You’ll never get the funding you need with that kind of reason.”</p>
        
        <p>“So, what would be a good business justification?” asked Addison. “How do we sell this approach to the business and get the additional funding approved?”</p>
        
        <p>“Well,” said Logan, “to build a good business case for something of this magnitude, you first need to understand the benefits of architectural modularity, match those benefits to the issues you are facing with the current system, and finally analyze and document the trade-offs involved with breaking apart the application.”</p>
        <hr>
        </div>
        
        <p>Businesses today face a torrent of change; market evolution seems to keep accelerating at a blistering pace.<a data-type="indexterm" data-primary="modularity" data-secondary="about" data-tertiary="about change" id="ch03-chng"></a> Business drivers (such as mergers and acquisitions), increased competition in the marketplace, increased consumer demand, and increased innovation (such as automation through machine learning and artificial intelligence) necessarily require changes to underlying computer systems. In many cases, those changes in computer systems consequently necessitate changes to the underlying architectures supporting them.</p>
        
        <p>However, it’s not only business that’s undergoing constant and rapid change—it’s also the technical environment in which those computer systems reside. <a data-type="indexterm" data-primary="architecture" data-secondary="evolution of" data-seealso="modularity" id="idm45978857063008"></a>Containerization, the move to cloud-based infrastructure, the adoption of DevOps, and even new advancements in continuous delivery pipelines all impact the underlying architecture of those computer systems.</p>
        
        <p>It’s difficult in today’s world to manage all of this constant and rapid change with respect to software architecture. Software architecture is the foundational structure of a system, and is therefore generally thought of as something that should remain stable and not undergo frequent change, similar to the underlying structural aspects of a large building or skyscraper. However, unlike the structural architecture of a building, software architecture must constantly change and adapt to meet the new demands of today’s business and technology environment.</p>
        
        <p>Consider the increased number of mergers and acquisitions happening in today’s marketplace. <a data-type="indexterm" data-primary="scalability" data-secondary="modularity providing" id="idm45978857060496"></a>When one company acquires another, not only does it acquire the physical aspects of a company (such as people, buildings, inventory, and so on) but also more customers. Can the existing systems in either company scale to meet the increase in user volume as a result of the merger or acquisition? Scalability is a big part of mergers and acquisitions, as is agility and extensibility, all of which are <em>architectural concerns</em>.</p>
        
        <p>Large monolithic (single deployment) systems generally do not provide the<a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="about need for" id="idm45978857058560"></a><a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="about need for modularity" id="idm45978857057296"></a> level of scalability, agility, and extensibility required to support most mergers and acquisitions. The capacity for additional machine resources (threads, memory, and CPU) fills up very quickly. <a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="water glass analogy" id="idm45978857055712"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="water glass analogy" id="idm45978857054480"></a>To illustrate this point, consider the water glass shown in <a data-type="xref" href="#fig-modularity-vs-granularity-fullglass">Figure 3-1</a>. The glass represents the server (or virtual machine), and the water represents the application. As monolithic applications grow to handle increased consumer demand and user load (whether from mergers, acquisitions, or company growth), they begin to consume more and more resources. As more water is added to the glass (representing the growing monolithic application), the glass begins to fill up. Adding another glass (represented as another server or virtual machine) does nothing, because the new glass would contain the same amount of water as the first one.</p>
        
        <figure><div id="fig-modularity-vs-granularity-fullglass" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0301.png" alt="Full Glass Representing Monolithic Application" width="391" height="581">
        <h6><span class="label">Figure 3-1. </span>A full glass representing a large monolithic application close to capacity</h6>
        </div></figure>
        
        <p>One aspect of architectural modularity is <a data-type="indexterm" data-primary="modularity" data-secondary="about" id="idm45978857049888"></a><a data-type="indexterm" data-primary="modularity" data-secondary="drivers of" data-tertiary="scalability" id="idm45978857048912"></a>breaking large monolithic applications into separate and smaller parts to provide more capacity for further scalability and growth, while at the same time facilitating constant and rapid change. In turn, these capabilities can help achieve a company’s strategic goals.</p>
        
        <p>By adding another empty glass to our water glass example and breaking the water (application) into two separate parts, half the water can now be poured into the new empty glass, providing 50% more capacity, as shown in <a data-type="xref" href="#fig-modularity-vs-granularity-halfglass">Figure 3-2</a>. The water glass analogy is a great way of explaining architectural modularity (the breaking up of monolithic applications) to business stakeholders and C-level executives, who will inevitably be paying for the architecture-refactoring effort.</p>
        
        <figure><div id="fig-modularity-vs-granularity-halfglass" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0302.png" alt="Half Glass Representing Modular Application" width="600" height="396">
        <h6><span class="label">Figure 3-2. </span>Two half-full glasses representing an application broken apart with plenty of capacity for growth</h6>
        </div></figure>
        
        <p class="pagebreak-before">Increased scalability is only one benefit of architectural modularity. <a data-type="indexterm" data-primary="agility" data-secondary="modularity providing" id="idm45978857042688"></a><a data-type="indexterm" data-primary="modularity" data-secondary="drivers of" data-tertiary="agility" id="idm45978857041632"></a>Another important benefit is <em>agility</em>, the ability to respond quickly to change. An <a href="https://oreil.ly/2im3v">article from <em>Forbes</em></a> in January 2020 by David Benjamin and David Komlos stated the following:</p>
        <blockquote>
        <p>There is one thing that will separate the pack into winners and losers: the on-demand capability to make bold and decisive course-corrections that are executed effectively and with urgency.</p></blockquote>
        
        <p>Businesses must be agile in order to survive in today’s world. However, while business stakeholders may be able to make quick decisions and change direction quickly, the company’s technology staff may not be able to implement those new directives fast enough to make a difference. Enabling technology to move as fast as the business (or, conversely, preventing technology from slowing the business) requires a certain level of architectural agility.<a data-type="indexterm" data-startref="" id="idm45978851956880"></a></p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Modularity Drivers"><div class="sect1" id="idm45978851956048">
        <h1>Modularity Drivers</h1>
        
        <p>Architects shouldn’t break a system into smaller parts unless clear business drivers exist.<a data-type="indexterm" data-primary="modularity" data-secondary="drivers of" data-tertiary="about" id="idm45978851954240"></a><a data-type="indexterm" data-primary="speed-to-market as modularity driver" id="idm45978851952992"></a><a data-type="indexterm" data-primary="competitive advantage as modularity driver" id="idm45978851952256"></a> The primary business drivers for breaking applications into smaller parts include <em>speed-to-market</em> (sometimes called time-to-market) and achieving a level of <em>competitive advantage</em> in the marketplace.</p>
        
        <p>Speed-to-market is achieved through architectural <a data-type="indexterm" data-primary="agility" data-secondary="speed-to-market via" id="idm45978851950096"></a>agility—the ability to respond quickly to change. Agility is a compound architectural characteristic made up of many other architecture characteristics, including maintainability, testability, and deployability.</p>
        
        <p>Competitive advantage is achieved through speed-to-market <a data-type="indexterm" data-primary="scalability" data-secondary="modularity providing" data-tertiary="modularity driver" id="idm45978851948384"></a><a data-type="indexterm" data-primary="fault tolerance" data-secondary="modularity driver" id="idm45978851947056"></a>combined with scalability and overall application availability and fault tolerance. The better a company does, the more it grows, hence the need for more scalability to support increased user activity. <em>Fault tolerance</em>, the ability of an application to fail and continue to operate, is necessary to ensure that as parts of the application fail, other parts are still able to function as normal, minimizing the overall impact to the end user. <a data-type="xref" href="#fig-modularity-vs-granularity-drivers">Figure 3-3</a> illustrates the relationship between the technical drivers and the resulting business drivers for modularity (enclosed within boxes).</p>
        
        <p>Businesses must be agile to survive in today’s fast-paced and ever-changing<a data-type="indexterm" data-primary="agility" data-secondary="modularity providing" id="idm45978851943760"></a><a data-type="indexterm" data-primary="modularity" data-secondary="drivers of" data-tertiary="agility" id="idm45978851942784"></a> volatile market, meaning the underlying architectures must be agile as well. As illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-drivers">Figure 3-3</a>, the five key architectural characteristics to support agility, speed-to-market, and, ultimately, competitive advantage in today’s marketplace are availability (fault tolerance), scalability, deployability, testability, maintainability.</p>
        
        <figure><div id="fig-modularity-vs-granularity-drivers" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0303.png" alt="Modularity Drivers" width="600" height="512">
        <h6><span class="label">Figure 3-3. </span>The drivers for modularity and the relationships among them</h6>
        </div></figure>
        
        <p>Note that <em>architectural modularity</em> does not always have to <a data-type="indexterm" data-primary="modularity" data-secondary="about" id="idm45978851936960"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="modular monoliths" id="idm45978851936016"></a><a data-type="indexterm" data-primary="microkernel architecture" id="idm45978851934736"></a><a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="about modularity" id="idm45978851934048"></a><a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="modular monoliths" id="idm45978851932816"></a>translate to a distributed architecture. Maintainability, testability, and deployability (defined in the following sections) can also be achieved through monolithic architectures such as a modular monolith or even a microkernel architecture (see <a data-type="xref" href="app02.html#sec-adr-list">Appendix&nbsp;B</a> for a list of references providing more information about these architecture styles). Both of these architecture styles offer a level of architectural modularity based on the way the components are <em>structured</em>. <a data-type="indexterm" data-primary="domain partitioned architecture" id="idm45978851929808"></a>For example, with a modular monolith, components are grouped into well-formed domains, providing for what is known as a <em>domain partitioned architecture</em> (see <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/fundamentals-of-software/9781492043447"><em>Fundamentals of Software Architecture</em></a>, Chapter 8, page 103). With the microkernel architecture, functionality is partitioned into separate plug-in components, allowing for a much smaller testing and deployment scope.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Maintainability"><div class="sect2" id="idm45978851926848">
        <h2>Maintainability</h2>
        
        <p><em>Maintainability</em> is about the ease of adding, changing, or removing features,<a data-type="indexterm" data-primary="modularity" data-secondary="drivers of" data-tertiary="maintainability" id="ch03-main"></a><a data-type="indexterm" data-primary="maintainability of modular architecture" id="ch03-main2"></a><a data-type="indexterm" data-primary="Zitzewitz, Alexander von" id="idm45978851921904"></a><a data-type="indexterm" data-primary="Hello2morrow" id="idm45978851921216"></a><a data-type="indexterm" data-primary="maintainability of modular architecture" data-secondary="metric for tracking" id="idm45978851920544"></a> as well as applying internal changes such as maintenance patches, framework upgrades, third-party upgrades, and so on. As with most composite architecture characteristics, maintainability is hard to define objectively. Alexander von Zitzewitz, software architect and founder of <a href="http://www.hello2morrow.com">hello2morrow</a>, wrote an <a href="https://oreil.ly/TbFjN">article</a> about a new metric for objectively defining the maintainability level of an application. While von Zitzewitz’s maintainability metric is fairly complicated and involves lots of factors, its initial form is as 
        <span class="keep-together">follows</span>:</p>
        <div data-type="equation">
        <mjx-container class="MathJax CtxtMenu_Attached_0" jax="SVG" display="true" tabindex="0" ctxtmenu_counter="0" style="position: relative;"><svg xmlns="http://www.w3.org/2000/svg" width="16.824ex" height="6.757ex" role="img" focusable="false" viewBox="0 -1740.7 7436.2 2986.6" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" style="vertical-align: -2.819ex;"><defs><path id="MJX-1-TEX-I-1D440" d="M289 629Q289 635 232 637Q208 637 201 638T194 648Q194 649 196 659Q197 662 198 666T199 671T201 676T203 679T207 681T212 683T220 683T232 684Q238 684 262 684T307 683Q386 683 398 683T414 678Q415 674 451 396L487 117L510 154Q534 190 574 254T662 394Q837 673 839 675Q840 676 842 678T846 681L852 683H948Q965 683 988 683T1017 684Q1051 684 1051 673Q1051 668 1048 656T1045 643Q1041 637 1008 637Q968 636 957 634T939 623Q936 618 867 340T797 59Q797 55 798 54T805 50T822 48T855 46H886Q892 37 892 35Q892 19 885 5Q880 0 869 0Q864 0 828 1T736 2Q675 2 644 2T609 1Q592 1 592 11Q592 13 594 25Q598 41 602 43T625 46Q652 46 685 49Q699 52 704 61Q706 65 742 207T813 490T848 631L654 322Q458 10 453 5Q451 4 449 3Q444 0 433 0Q418 0 415 7Q413 11 374 317L335 624L267 354Q200 88 200 79Q206 46 272 46H282Q288 41 289 37T286 19Q282 3 278 1Q274 0 267 0Q265 0 255 0T221 1T157 2Q127 2 95 1T58 0Q43 0 39 2T35 11Q35 13 38 25T43 40Q45 46 65 46Q135 46 154 86Q158 92 223 354T289 629Z"></path><path id="MJX-1-TEX-I-1D43F" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"></path><path id="MJX-1-TEX-N-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path><path id="MJX-1-TEX-N-31" d="M213 578L200 573Q186 568 160 563T102 556H83V602H102Q149 604 189 617T245 641T273 663Q275 666 285 666Q294 666 302 660V361L303 61Q310 54 315 52T339 48T401 46H427V0H416Q395 3 257 3Q121 3 100 0H88V46H114Q136 46 152 46T177 47T193 50T201 52T207 57T213 61V578Z"></path><path id="MJX-1-TEX-N-30" d="M96 585Q152 666 249 666Q297 666 345 640T423 548Q460 465 460 320Q460 165 417 83Q397 41 362 16T301 -15T250 -22Q224 -22 198 -16T137 16T82 83Q39 165 39 320Q39 494 96 585ZM321 597Q291 629 250 629Q208 629 178 597Q153 571 145 525T137 333Q137 175 145 125T181 46Q209 16 250 16Q290 16 318 46Q347 76 354 130T362 333Q362 478 354 524T321 597Z"></path><path id="MJX-1-TEX-N-2A" d="M215 721Q216 732 225 741T248 750Q263 750 273 742T284 721L270 571L327 613Q383 654 388 657T399 660Q412 660 423 650T435 624T424 600T376 575Q363 569 355 566L289 534L355 504L424 470Q435 462 435 447Q435 431 424 420T399 409Q393 409 388 412T327 456L270 498L277 423L284 348Q280 320 250 320T215 348L229 498L172 456Q116 415 111 412T100 409Q87 409 76 420T64 447Q64 461 75 470L144 504L210 534L144 566Q136 570 122 576Q83 593 74 600T64 624Q64 639 75 649T100 660Q106 660 111 657T172 613L229 571Q229 578 222 643T215 721Z"></path><path id="MJX-1-TEX-LO-2211" d="M60 948Q63 950 665 950H1267L1325 815Q1384 677 1388 669H1348L1341 683Q1320 724 1285 761Q1235 809 1174 838T1033 881T882 898T699 902H574H543H251L259 891Q722 258 724 252Q725 250 724 246Q721 243 460 -56L196 -356Q196 -357 407 -357Q459 -357 548 -357T676 -358Q812 -358 896 -353T1063 -332T1204 -283T1307 -196Q1328 -170 1348 -124H1388Q1388 -125 1381 -145T1356 -210T1325 -294L1267 -449L666 -450Q64 -450 61 -448Q55 -446 55 -439Q55 -437 57 -433L590 177Q590 178 557 222T452 366T322 544L56 909L55 924Q55 945 60 948Z"></path><path id="MJX-1-TEX-I-1D456" d="M184 600Q184 624 203 642T247 661Q265 661 277 649T290 619Q290 596 270 577T226 557Q211 557 198 567T184 600ZM21 287Q21 295 30 318T54 369T98 420T158 442Q197 442 223 419T250 357Q250 340 236 301T196 196T154 83Q149 61 149 51Q149 26 166 26Q175 26 185 29T208 43T235 78T260 137Q263 149 265 151T282 153Q302 153 302 143Q302 135 293 112T268 61T223 11T161 -11Q129 -11 102 10T74 74Q74 91 79 106T122 220Q160 321 166 341T173 380Q173 404 156 404H154Q124 404 99 371T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Z"></path><path id="MJX-1-TEX-I-1D458" d="M121 647Q121 657 125 670T137 683Q138 683 209 688T282 694Q294 694 294 686Q294 679 244 477Q194 279 194 272Q213 282 223 291Q247 309 292 354T362 415Q402 442 438 442Q468 442 485 423T503 369Q503 344 496 327T477 302T456 291T438 288Q418 288 406 299T394 328Q394 353 410 369T442 390L458 393Q446 405 434 405H430Q398 402 367 380T294 316T228 255Q230 254 243 252T267 246T293 238T320 224T342 206T359 180T365 147Q365 130 360 106T354 66Q354 26 381 26Q429 26 459 145Q461 153 479 153H483Q499 153 499 144Q499 139 496 130Q455 -11 378 -11Q333 -11 305 15T277 90Q277 108 280 121T283 145Q283 167 269 183T234 206T200 217T182 220H180Q168 178 159 139T145 81T136 44T129 20T122 7T111 -2Q98 -11 83 -11Q66 -11 57 -1T48 16Q48 26 85 176T158 471L195 616Q196 629 188 632T149 637H144Q134 637 131 637T124 640T121 647Z"></path><path id="MJX-1-TEX-I-1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mrow"><g data-mml-node="mi"><use data-c="1D440" xlink:href="#MJX-1-TEX-I-1D440"></use></g><g data-mml-node="mi" transform="translate(1051,0)"><use data-c="1D43F" xlink:href="#MJX-1-TEX-I-1D43F"></use></g><g data-mml-node="mo" transform="translate(2009.8,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(3065.6,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use><use data-c="30" xlink:href="#MJX-1-TEX-N-30" transform="translate(500,0)"></use><use data-c="30" xlink:href="#MJX-1-TEX-N-30" transform="translate(1000,0)"></use></g><g data-mml-node="mo" transform="translate(4565.6,0)"><use data-c="2A" xlink:href="#MJX-1-TEX-N-2A"></use></g><g data-mml-node="munderover" transform="translate(5065.6,0)"><g data-mml-node="mo"><use data-c="2211" xlink:href="#MJX-1-TEX-LO-2211"></use></g><g data-mml-node="mrow" transform="translate(148.2,-1087.9) scale(0.707)"><g data-mml-node="mi"><use data-c="1D456" xlink:href="#MJX-1-TEX-I-1D456"></use></g><g data-mml-node="mo" transform="translate(345,0)"><use data-c="3D" xlink:href="#MJX-1-TEX-N-3D"></use></g><g data-mml-node="mn" transform="translate(1123,0)"><use data-c="31" xlink:href="#MJX-1-TEX-N-31"></use></g></g><g data-mml-node="mi" transform="translate(537.8,1150) scale(0.707)"><use data-c="1D458" xlink:href="#MJX-1-TEX-I-1D458"></use></g></g><g data-mml-node="msub" transform="translate(6676.2,0)"><g data-mml-node="mi"><use data-c="1D450" xlink:href="#MJX-1-TEX-I-1D450"></use></g><g data-mml-node="mi" transform="translate(466,-150) scale(0.707)"><use data-c="1D456" xlink:href="#MJX-1-TEX-I-1D456"></use></g></g></g></g></g></svg><mjx-assistive-mml unselectable="on" display="block"><math xmlns="http://www.w3.org/1998/Math/MathML" alttext="upper M upper L equals 100 asterisk sigma-summation Underscript i equals 1 Overscript k Endscripts c Subscript i" display="block"><mrow><mi>M</mi><mi>L</mi><mo>=</mo><mn>100</mn><mo data-mjx-pseudoscript="true">*</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>k</mi></munderover><msub><mi>c</mi><mi>i</mi></msub></mrow></math></mjx-assistive-mml></mjx-container>
        </div>
        
        <p>where <em>ML</em> is the maintainability level of the overall system (percentage from 0% to 100%), <em>k</em> is the total number of logical components in the system, and <em>c<sub>i</sub></em> is the coupling level for any given component, with a special focus on incoming coupling levels. This equation basically demonstrates that the higher the incoming coupling level between components, the lower the overall maintainability level of the codebase.</p>
        
        <p>Putting aside complicated mathematics, some of the typical metrics used for determining the relative maintainability of an application based on components (the architectural building blocks of an application) include the following:</p>
        <dl>
        <dt>Component coupling</dt>
        <dd>
        <p>The degree and manner to which components know about one another<a data-type="indexterm" data-primary="coupling" data-secondary="maintainability and" id="idm45978851903328"></a></p>
        </dd>
        <dt>Component cohesion</dt>
        <dd>
        <p>The degree and manner to which the operations of a component interrelate<a data-type="indexterm" data-primary="cohesion" data-secondary="maintainability and" id="idm45978851900992"></a><a data-type="indexterm" data-primary="components" data-secondary="maintainability and" id="idm45978851900016"></a></p>
        </dd>
        <dt>Cyclomatic complexity</dt>
        <dd>
        <p>The overall level of indirection and nesting within a component<a data-type="indexterm" data-primary="cyclomatic complexity and maintainability" id="idm45978851897792"></a></p>
        </dd>
        <dt>Component size</dt>
        <dd>
        <p>The number of aggregated statements of code within a component</p>
        </dd>
        <dt>Technical versus domain partitioning</dt>
        <dd>
        <p>Components aligned by technical usage or by domain <a data-type="indexterm" data-primary="technical partitioning" data-secondary="maintainability and" id="idm45978851894272"></a><a data-type="indexterm" data-primary="domain partitioned architecture" data-secondary="maintainability and" id="idm45978851893296"></a>purpose—see <a data-type="xref" href="app01.html#sec-references">Appendix&nbsp;A</a></p>
        </dd>
        </dl>
        
        <p>Within the context of architecture, we are <a data-type="indexterm" data-primary="components" data-secondary="definition" id="idm45978851891008"></a>defining a <em>component</em> as an architectural building block of the application that does some sort of business or infrastructure function, usually manifested through a package structure (Java), namespace (C#), or physical grouping of files (classes) within some sort of directory structure. For example, the component Order History might be implemented through a set of class files located in the namespace <code>app.business.order.history</code>.</p>
        
        <p>Large monolithic architectures generally have low <a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="maintainability" id="idm45978851888592"></a><a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="maintainability" id="idm45978851887280"></a>levels of maintainability due to the technical partitioning of functionality into layers, the tight coupling between components, and weak component cohesion from a domain perspective. <a data-type="indexterm" data-primary="layered architecture" data-secondary="modular architecture" data-tertiary="maintainability" id="idm45978851885712"></a>For example, consider a new requirement within a traditional monolithic layered architecture to add an expiration date to items contained in a customer’s wish list (items in a list to maybe purchase at a later time). Notice in <a data-type="xref" href="#fig-modularity-vs-granularity-maintain-app">Figure 3-4</a> that the change scope of the new requirement is at an <em>application level</em> since the change is propagated to all of the layers within the application.</p>
        
        <figure><div id="fig-modularity-vs-granularity-maintain-app" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0304.png" alt="Application-Level Scope" width="600" height="619">
        <h6><span class="label">Figure 3-4. </span>With monolithic layered architectures, change is at an application level</h6>
        </div></figure>
        
        <p>Depending on the team structure, implementing this simple change to add an expiration date to wish list items in a monolithic layered architecture could possibly require the coordination of at least three teams:</p>
        
        <ul>
        <li>
        <p>A member from the user interface team would be needed to add the new expiry field to the screen.</p>
        </li>
        <li>
        <p>A member from the backend team would be needed to add business rules associated with the expiry date and change contracts to add the new expiry field.</p>
        </li>
        <li>
        <p>A member from the database team would be needed to change the table schema to add the new expiry column in the Wishlist table.</p>
        </li>
        </ul>
        
        <p>Since the Wishlist domain is spread throughout the entire architecture, it becomes harder to maintain a particular domain or subdomain (such as Wishlist). Modular architectures, on the other hand, partition domains and subdomains into smaller, separately deployed units of software, thereby making it easier to modify a domain or subdomain. Notice that with a distributed service-based architecture, as shown in <a data-type="xref" href="#fig-modularity-vs-granularity-maintain-domain">Figure 3-5</a>, the change scope of the new requirement is at a <em>domain level</em> within a particular domain service, making it easier to isolate the specific deployment unit requiring the change.</p>
        
        <p>Moving to even more architectural modularity <a data-type="indexterm" data-primary="microservices" data-secondary="modularity" id="idm45978851874224"></a>such as a microservices architecture, as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-maintain-function">Figure 3-6</a>, places the new requirement at a <em>function-level</em> change scope, isolating the change to a specific service responsible for the wish list 
        <span class="keep-together">functionality</span>.</p>
        
        <figure><div id="fig-modularity-vs-granularity-maintain-domain" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0305.png" alt="Domain-Level Scope" width="600" height="426">
        <h6><span class="label">Figure 3-5. </span>With service-based architectures, change is at a domain level</h6>
        </div></figure>
        
        <figure><div id="fig-modularity-vs-granularity-maintain-function" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0306.png" alt="Function-Level Scope" width="600" height="318">
        <h6><span class="label">Figure 3-6. </span>With microservices architectures, change is at a function level</h6>
        </div></figure>
        
        <p>These three progressions toward modularity demonstrate that as the level of architectural modularity increases, so does maintainability, making it easier to add, change, or remove 
        <span class="keep-together">functionality</span>.<a data-type="indexterm" data-startref="ch03-main" id="idm45978851865552"></a><a data-type="indexterm" data-startref="ch03-main2" id="idm45978851864816"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Testability"><div class="sect2" id="idm45978851926256">
        <h2>Testability</h2>
        
        <p><em>Testability</em> is defined as the ease of testing (usually implemented through automated tests)<a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="testability" id="idm45978851862096"></a><a data-type="indexterm" data-primary="modularity" data-secondary="drivers of" data-tertiary="testability" id="idm45978851860832"></a><a data-type="indexterm" data-primary="testability as modularity driver" id="idm45978851859616"></a><a data-type="indexterm" data-primary="agility" data-secondary="testability for" id="idm45978851858928"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="testability" id="idm45978851857984"></a><a data-type="indexterm" data-primary="layered architecture" data-secondary="modular architecture" data-tertiary="testability" id="idm45978851856752"></a> as well as the <em>completeness</em> of testing. Testability is an essential ingredient for architectural agility. Large monolithic architecture styles like the layered architecture support relatively low levels of testability (and hence agility) due to the difficulty in achieving full and complete regression testing of all features within the large deployment unit. Even if a monolithic application did have a suite of full regression tests, imagine the frustration of having to execute hundreds or even thousands of unit tests for a simple code change. Not only would it take a long time to execute all of the tests, but the poor developer would be stuck researching why dozens of tests failed when in fact the failed tests have nothing to do with the change.</p>
        
        <p>Architectural modularity—the breaking apart of applications into smaller deployment units—significantly<a data-type="indexterm" data-primary="deployment" data-secondary="architectural modularity described" id="idm45978851854576"></a> reduces the overall testing scope for changes made to a service, allowing for better completeness of testing as well as ease of testing. Not only does modularity result in smaller, more targeted test suites, but maintaining the unit tests becomes easier as well.</p>
        
        <p>While architectural modularity generally improves testability, it can sometimes lead to the same problems that exist with monolithic, single-deployment applications. <a data-type="indexterm" data-primary="services" data-secondary="modularity" data-tertiary="testability" id="idm45978851852848"></a>For example, consider an application that was broken into three smaller self-contained deployment units (services), as depicted in <a data-type="xref" href="#fig-modularity-vs-granularity-modularity-testability">Figure 3-7</a>.</p>
        
        <p>Making a change to Service A limits the testing scope to only that service, since Service B and Service C are not coupled to Service A. However, as communication increases among these services, as shown at the bottom of <a data-type="xref" href="#fig-modularity-vs-granularity-modularity-testability">Figure 3-7</a>, testability declines rapidly because the testing scope for a change to Service A now includes Service B and Service C, therefore impacting both the ease of testing and the completeness of testing.</p>
        
        <figure><div id="fig-modularity-vs-granularity-modularity-testability" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0307.png" alt="Testability and Modularity" width="600" height="454">
        <h6><span class="label">Figure 3-7. </span>Testing scope is increased as services communicate with one another</h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Deployability"><div class="sect2" id="idm45978851846592">
        <h2>Deployability</h2>
        
        <p><em>Deployability</em> is not only about the ease of deployment—it is also about<a data-type="indexterm" data-primary="modularity" data-secondary="drivers of" data-tertiary="deployability" id="idm45978857533472"></a><a data-type="indexterm" data-primary="deployment" data-secondary="architectural modularity described" data-tertiary="deployability in modularity" id="idm45978857532144"></a> the frequency of deployment and the overall risk of deployment. To support agility and respond quickly to change, applications must support all three of these factors. Deploying software every two weeks (or more) not only increases the overall risk of deployment (due to grouping multiple changes together), but in most cases unnecessarily delays new features or bug fixes that are ready to be pushed out to customers. Of course, deployment frequency must be balanced with the customer’s (or end user’s) ability to be able to absorb changes quickly.</p>
        
        <p>Monolithic architectures generally support low levels of <a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="deployability" id="idm45978857530384"></a><a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="deployability" id="idm45978857529040"></a>deployability due to the amount of ceremony involved in deploying the application (such as code freezes, mock deployments, and so on), the increased risk that something else might break once new features or bug fixes are deployed, and a long time frame between deployments (weeks to months). Applications having a certain level of architectural modularity in terms of separately deployed units of software have less deployment ceremony, less risk of deployment, and can be deployed more frequently than a large, single monolithic application.</p>
        
        <p class="pagebreak-before">Like testability, deployability is also negatively impacted as <a data-type="indexterm" data-primary="services" data-secondary="modularity" data-tertiary="deployability" id="idm45978857526848"></a><a data-type="indexterm" data-primary="microservices" data-secondary="modularity" data-tertiary="deployability" id="idm45978857525520"></a>services become smaller and communicate more with each other to complete a business transaction. Deployment risk is increased, and it becomes more difficult to deploy a simple change for fear of breaking other services. <a data-type="indexterm" data-primary="Stine, Matt" id="idm45978857523936"></a>
        To quote software architect <a href="https://www.mattstine.com">Matt Stine</a> in his <a href="https://oreil.ly/e9EGN">article on orchestrating microservices</a>:</p>
        <blockquote>
        <p>If your microservices must be deployed as a complete set in a specific order, please put them back in a monolith and save yourself some pain.</p></blockquote>
        
        <p>This scenario leads to what is commonly referred to as the “big ball of distributed mud,” where very few (if any) of the benefits of architectural modularity are realized.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Scalability"><div class="sect2" id="idm45978857520416">
        <h2>Scalability</h2>
        
        <p><em>Scalability</em> is defined as the ability of a system to remain<a data-type="indexterm" data-primary="modularity" data-secondary="drivers of" data-tertiary="scalability" id="ch03-sca"></a><a data-type="indexterm" data-primary="scalability" data-secondary="definition" id="idm45978857516816"></a><a data-type="indexterm" data-primary="scalability" data-secondary="modularity providing" data-tertiary="modularity driver" id="ch03-sca2"></a><a data-type="indexterm" data-primary="elasticity" data-secondary="definition" id="idm45978857514384"></a><a data-type="indexterm" data-primary="scalability" data-secondary="elasticity versus" id="idm45978857513440"></a><a data-type="indexterm" data-primary="elasticity" data-secondary="scalability versus" id="idm45978857512496"></a> responsive as user load gradually increases over time. Related to scalability is <em>elasticity</em>, which is defined as the ability of a system to remain responsive during significantly high instantaneous and erratic spikes in user load.  <a data-type="xref" href="#fig-modularity-vs-granularity-modularity-elasticity">Figure 3-8</a> illustrates the differences between scalability and elasticity.</p>
        
        <figure><div id="fig-modularity-vs-granularity-modularity-elasticity" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0308.png" alt="Scalability vs. Elasticity" width="600" height="230">
        <h6><span class="label">Figure 3-8. </span>Scalability is different from elasticity</h6>
        </div></figure>
        
        <p>While both of these architectural characteristics include responsiveness as a function of the number of concurrent requests (or users in the system), they are handled differently from an architectural and implementation standpoint. Scalability generally occurs over a longer period of time as a function of normal company growth, whereas elasticity is the immediate response to a spike in user load.</p>
        
        <p>A great example to further illustrate the difference is that of a concert-ticketing 
        <span class="keep-together">system</span>. Between major concert events, there is usually a fairly light concurrent user load. However, the minute tickets go on sale for a popular concert, concurrent user load significantly spikes. The system may go from 20 concurrent users to 3,000 concurrent users in a matter of seconds. To maintain responsiveness, the system must have the capacity to handle the high peaks in user load, and also have the ability to instantaneously start up additional services to handle the spike in traffic. <a data-type="indexterm" data-primary="elasticity" data-secondary="mean time to startup and" id="idm45978857506384"></a><a data-type="indexterm" data-primary="mean time to startup and elasticity" id="idm45978857505440"></a>Elasticity relies on services having a very small <em>mean time to startup</em> (MTTS), which is achieved <em>architecturally</em> by having very small, fine-grained services. With an appropriate architectural solution in place, MTTS (and hence elasticity) can then be further managed through design-time techniques such as small lightweight platforms and runtime 
        <span class="keep-together">environments</span>.</p>
        
        <p>Although both scalability and elasticity improve with finer-grained services, <a data-type="indexterm" data-primary="granularity" data-secondary="elasticity as function of" id="idm45978857502272"></a><a data-type="indexterm" data-primary="granularity" data-secondary="definition" id="idm45978857501328"></a>elasticity is more a function of granularity (the size of a deployment unit), whereas <a data-type="indexterm" data-primary="scalability" data-secondary="modularity providing" id="idm45978857500256"></a>scalability is more a function of modularity (the breaking apart of applications into separate deployment units). <a data-type="indexterm" data-primary="layered architecture" data-secondary="modular architecture" data-tertiary="scalability and elasticity" id="idm45978857498960"></a><a data-type="indexterm" data-primary="service-based architecture" data-secondary="modular architecture scalability and elasticity" id="idm45978857497728"></a><a data-type="indexterm" data-primary="microservices" data-secondary="modularity" data-tertiary="scalability and elasticity" id="idm45978857496672"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="scalability and elasticity" id="idm45978857495440"></a><a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="scalability and elasticity" id="idm45978857494192"></a>Consider the traditional layered architecture, service-based architecture, and microservices architecture styles and their corresponding star ratings for scalability and elasticity, as illustrated in <a data-type="xref" href="#fig-modularity-vs-granularity-modularity-scalability">Figure 3-9</a> (the details of these architecture styles and their corresponding star ratings can be found in our previous book, <a class="orm:hideurl" href="https://learning.oreilly.com/library/view/fundamentals-of-software/9781492043447"><em>Fundamentals of Software Architecture</em></a>. Note that one star means that the capability is not well supported by the architecture style, whereas five stars means that capability is a major feature of the architecture style and is well supported.</p>
        
        <p>Notice that scalability and elasticity rate relatively low with the monolithic layered architecture. Large monolithic layered architectures are both difficult and expensive to scale because all of the application functionality must scale to the same degree (application-level scalability and poor MTTS). This can become particularly costly in cloud-based infrastructures. <a data-type="indexterm" data-primary="services" data-secondary="modularity" data-tertiary="scalability and elasticity" id="idm45978857489808"></a>However, with service-based architecture, notice that scalability improves, but not as much as elasticity. This is because domain services in a service-based architecture are coarse grained and usually contain the entire domain in one deployment unit (such as order processing or warehouse management), and generally have too long of a mean time to startup (MTTS) to respond fast enough to immediate demand for elasticity due to their large size (domain-level scalability and fair MTTS). Notice that with microservices, both scalability and elasticity are maximized because of the small, single-purpose, fine-grained nature of each separately deployed service (function-level scalability and excellent MTTS).</p>
        
        <p>Like testability and deployability, the more services communicate with one other<a data-type="indexterm" data-primary="communication" data-secondary="service scalability and elasticity" id="idm45978857488064"></a><a data-type="indexterm" data-primary="synchronous communication" data-secondary="scalability and elasticity versus" id="idm45978857487072"></a> to complete a single business transaction, the greater the negative impact on scalability and elasticity. For this reason, it is important to keep synchronous communication among services to a minimum when requiring high levels of scalability and elasticity.<a data-type="indexterm" data-startref="ch03-sca" id="idm45978857485696"></a><a data-type="indexterm" data-startref="ch03-sca2" id="idm45978857485024"></a></p>
        
        <figure><div id="fig-modularity-vs-granularity-modularity-scalability" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492086888/files/assets/sahp_0309.png" alt="Scalability and Modularity" width="600" height="589">
        <h6><span class="label">Figure 3-9. </span>Scalability and elasticity improve with modularity</h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Availability/Fault Tolerance"><div class="sect2" id="idm45978857482144">
        <h2>Availability/Fault Tolerance</h2>
        
        <p>Like many architecture characteristics, <em>fault tolerance</em> has varying definitions.<a data-type="indexterm" data-primary="modularity" data-secondary="drivers of" data-tertiary="fault tolerance" id="idm45978857480272"></a><a data-type="indexterm" data-primary="fault tolerance" data-secondary="definition" id="idm45978857479024"></a><a data-type="indexterm" data-primary="fault tolerance" data-secondary="modularity driver" id="idm45978857478080"></a><a data-type="indexterm" data-primary="availability" data-secondary="modularity and" id="idm45978857477136"></a> Within the context of architectural modularity, we define fault tolerance as the ability for some parts of the system to remain responsive and available as other parts of the system fail. For example, if a fatal error (such as an out-of-memory condition) in the payment-processing portion of a retail application occurs, the users of the system should still be able to search for items and place orders, even though the payment processing is unavailable.</p>
        
        <p>All monolithic systems suffer from low levels of <a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="fault tolerance" id="idm45978857475616"></a><a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="fault tolerance" id="idm45978857474304"></a>fault tolerance. While fault tolerance can be somewhat mitigated in a monolithic system by having multiple instances of the entire application load balanced, this technique is both expensive and ineffective. If the fault is due to a programming bug, that bug will exist in both instances, therefore potentially bringing down both instances.</p>
        
        <p>Architectural modularity is essential to achieving domain-level and function-level fault tolerance in a system. <a data-type="indexterm" data-primary="deployment" data-secondary="architectural modularity described" data-tertiary="fault tolerance" id="idm45978857472432"></a>By breaking apart the system into multiple deployment units, catastrophic failure is isolated to only that deployment unit, thereby allowing the rest of the system to function normally. <a data-type="indexterm" data-primary="asynchronous communication" data-secondary="fault tolerance" id="idm45978857470832"></a><a data-type="indexterm" data-primary="synchronous communication" data-secondary="fault tolerance" id="idm45978857469872"></a>There is a caveat to this, however: if other services are synchronously dependent on a service that is failing, fault tolerance is not achieved. This is one of the reasons asynchronous communication between services is essential for maintaining a good level of fault tolerance in a distributed system.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Sysops Squad Saga: Creating a Business Case"><div class="sect1" id="idm45978851955456">
        <h1>Sysops Squad Saga: Creating a Business Case</h1>
        
        <p><code>Thursday, September 30, 12:01</code></p>
        <div class="story">
        
        <p>Armed with a better understanding of what is meant by<a data-type="indexterm" data-primary="Sysops Squad sagas" data-secondary="monolithic application broken apart" data-tertiary="business case for" id="ch03-bc"></a><a data-type="indexterm" data-primary="monolithic architectures" data-secondary="modular architecture" data-tertiary="Sysops Squad saga" id="ch03-bc2"></a><a data-type="indexterm" data-primary="modularity" data-secondary="monolithic architectures" data-tertiary="Sysops Squad saga" id="ch03-bc3"></a><a data-type="indexterm" data-primary="business case for modularity" id="ch03-bc4"></a> <em>architectural modularity</em> and the corresponding drivers for breaking apart a system, Addison and Austen met to discuss the Sysops Squad issues and try to match them to modularity drivers in order to build a solid business justification to present to the business sponsors.</p>
        
        <p>“Let’s take each of the issues we are facing and see if we can match them to some of the modularity drivers,” said Addison. “That way, we can demonstrate to the business that breaking apart the application will in fact address the issues we are facing.”</p>
        
        <p>“Good idea,” said Austen. “Let’s start with the first issue they talked about in the meeting—change. We cannot seem to effectively apply changes to the existing monolithic system without something else breaking. Also, changes take way too long, and testing the changes is a real pain.”</p>
        
        <p>“And the developers are constantly complaining that the codebase is too large, and it’s difficult to find the right place to apply changes to new features or bug fixes,” said Addison.</p>
        
        <p>“OK,” said Austen, “so clearly, overall maintainability is a key issue here.”</p>
        
        <p>“Right,” said Addison. “So, by breaking apart the application, it would not only decouple the code, but it would isolate and partition the functionality into separately deployed services, making it easier for developers to  apply changes.”</p>
        
        <p>“Testability is another key characteristic related to this problem, but we have that covered already because of all our automated unit tests,” said Austen.</p>
        
        <p>“Actually, it’s not,” replied Addison. “Take a look at this.”</p>
        
        <p>Addison showed Austen that over 30% of the test cases are commented out or obsolete, and there are missing test cases for some of the critical workflow parts of the system. Addison also explained that the developers were continually complaining that the entire unit test suite had to be run for any change (big or small), which not only took a long time, but developers were faced with having to fix issues not related to their change. This was one of the reasons it was taking so long to apply even the simplest of changes.</p>
        
        <p>“Testability is about the ease of testing, but also the completeness of testing,” said Addison. “We have neither. By breaking apart the application, we can significantly reduce the scope of testing for changes made to the application, group relevant automated unit tests together, and get better completeness of testing—hence fewer bugs.”</p>
        
        <p>“The same is true with deployability,” continued Addison. “Because we have a monolithic application, we have to deploy the entire system, even for a small bug fix. Because our deployment risk is so high, Parker insists on doing production releases on a monthly basis. What Parker doesn’t understand is that by doing so, we pile multiple changes onto every release, some of which haven’t even been tested in conjunction with each other.”</p>
        
        <p>“I agree,” said Austen, “and besides, the mock deployments and code freezes we do for each release take up valuable time—time we don’t have. However, what we’re talking about here is not an architecture issue, but purely a deployment pipeline issue.”</p>
        
        <p>“I disagree,” said Addison. “It’s definitely architecture related as well. Think about it for a minute, Austen. If we broke the system into separately deployed services, then a change for any given service would be scoped to that service only. For example, let’s say we make yet another change to the ticket assignment process. If that process was a separate service, not only would the testing scope be reduced, but we would significantly reduce the deployment risk. That means we could deploy more frequently with much less ceremony, as well as significantly reduce the number of bugs.”</p>
        
        <p>“I see what you mean,” said Austen, “and while I agree with you, I still maintain that at some point we will have to modify our current deployment pipeline as well.”</p>
        
        <p>Satisfied that breaking apart the Sysops Squad application and moving to a distributed architecture would address the change issues, Addison and Austen moved on to the other business sponsor concerns.</p>
        
        <p>“OK,” said Addison, “the other big thing the business sponsors complained about in the meeting was overall customer satisfaction. Sometimes the system isn’t available, the system seems to crash at certain times during the day, and we’ve experienced too many lost tickets and ticket routing issues. It’s no wonder customers are starting to cancel their support plans.”</p>
        
        <p>“Hold on,” said Austen. “I have some latest metrics here that show it’s not the core ticketing functionality that keeps bringing the system down, but the customer survey functionality and reporting.”</p>
        
        <p>“This is excellent news,” said Addison. “So by breaking apart that functionality of the system into separate services, we can isolate those faults, keeping the core ticketing functionality operational. That’s a good justification in and of itself!”</p>
        
        <p>“Exactly,” said Austen. “So, we are in agreement then that overall availability through fault tolerance will address the application not always being available for the customers since they only interact with the ticketing portion of the system.”</p>
        
        <p>“But what about the system freezing up?” asked Addison. “How do we justify that part with breaking up the application?”</p>
        
        <p>“It just so happens I asked Sydney from the Sysops Squad development team to run some analysis for me regarding exactly that issue,” said Austen. “It turns out that it is a combination of two things. First, whenever we have more than 25 customers creating tickets at the same time, the system freezes. But, check this out—whenever they run the operational reports during the day when customers are entering problem tickets, the system also freezes up.”</p>
        
        <p>“So,” said Addison, “it appears we have both a scalability and a database load issue here.”</p>
        
        <p>“Exactly!” Austen said. “And get this—by breaking up the application <em>and</em> the monolithic database, we can segregate reporting into its own system and also provide the added scalability for the customer-facing ticketing functionality.”</p>
        
        <p>Satisfied that they had a good business case to present to the business sponsors and confident that this was the right approach for saving this business line, Addison created an Architecture Decision Record (ADR) for the decision to break apart the system and create a corresponding business case presentation for the business sponsors.</p>
        <blockquote>
        <p class="adr" id="adr_2"><em>ADR: Migrate Sysops Squad Application to a Distributed Architecture</em></p>
        
        <p><em>Context</em><br>
        The Sysops Squad is currently a monolithic problem ticket application that supports many different business functions related to problem tickets, including customer registration, problem ticket entry and processing, operations and analytical reporting, billing and payment processing, and various administrative maintenance functions. The current application has numerous issues involving scalability, availability, and maintainability.</p>
        
        <p><em>Decision</em><br>
        We will migrate the existing monolithic Sysops Squad application to a distributed architecture. Moving to a distributed architecture will accomplish the following:</p>
        
        <ul>
        <li>
        <p>Make the core ticketing functionality more available for our external customers, therefore providing better fault tolerance</p>
        </li>
        <li>
        <p>Provide better scalability for customer growth and ticket creation, resolving the frequent application freeze-ups we’ve been experiencing</p>
        </li>
        <li>
        <p>Separate the reporting functionality and reporting load on the database, resolving the frequent application
        freeze-ups we’ve been experiencing</p>
        </li>
        <li>
        <p>Allow teams to implement new features and fix bugs much faster than with the current monolithic application, therefore providing for better overall agility</p>
        </li>
        <li>
        <p>Reduce the amount of bugs introduced into the system when changes occur, therefore providing better testability</p>
        </li>
        <li>
        <p>Allow us to deploy new features and bug fixes at a much faster rate (weekly or even daily), therefore providing better deployability</p>
        </li>
        </ul>
        
        <p><em>Consequences</em><br>
        The migration effort will cause delays for new features being introduced since most of the developers will be needed for the architecture migration.</p>
        
        <p>The migration effort will incur additional cost (cost estimates to be determined).</p>
        
        <p>Until the existing deployment pipeline is modified, release engineers will have to manage the release and monitoring of multiple deployment units.</p>
        
        <p>The migration effort will require us to break apart the monolithic database.</p></blockquote>
        
        <p>Addison and Austen met with the business sponsors for the Sysops Squad problem ticketing system and presented their case in a clear and concise manner. The business sponsors were pleased with the presentation and agreed with the approach, informing Addison and Austen to move forward with the migration.<a data-type="indexterm" data-startref="ch03-bc" id="idm45978857433056"></a><a data-type="indexterm" data-startref="ch03-bc2" id="idm45978857432352"></a><a data-type="indexterm" data-startref="ch03-bc3" id="idm45978857431680"></a><a data-type="indexterm" data-startref="ch03-bc4" id="idm45978857431008"></a></p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492086888/files/epub.css" crossorigin="anonymous"><script src="https://learning.oreilly.comhttps://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-svg.js"></script></div></div></section>
</div>

https://learning.oreilly.com