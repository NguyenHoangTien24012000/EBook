<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Architecture Characteristics Defined"><div class="chapter" id="ch-architecture-characteristics-defined">
        <h1><span class="label">Chapter 4. </span>Architecture Characteristics Defined</h1>
        
        
        <p>A company decides to solve a particular problem using software, so it gathers a list of requirements for that system.<a data-type="indexterm" data-primary="architecture characteristics" id="ix_archch"></a> A wide variety of techniques exist for the exercise of requirements gathering, generally defined by the software development process used by the team. <a data-type="indexterm" data-primary="architecture characteristics" data-secondary="about" id="ix_archchabt"></a>But the architect must consider many other factors in designing a software solution, as illustrated in <a data-type="xref" href="#fig_requirements_and_characteristics">Figure&nbsp;4-1</a>.</p>
        
        <figure><div id="fig_requirements_and_characteristics" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0107.png" alt="Requirements" width="1412" height="218">
        <h6><span class="label">Figure 4-1. </span>A software solution consists of both domain requirements and architectural characteristics</h6>
        </div></figure>
        
        <p>Architects may collaborate on defining the domain or business requirements, but one key responsibility entails defining, discovering, and otherwise analyzing all the things the software must do that isn’t directly related to the domain functionality: <em>architectural characteristics</em>.</p>
        
        <p>What distinguishes software architecture from coding and design? Many things, including the role that architects have in defining architectural characteristics, the important aspects of the system independent of the problem domain. Many organizations describe these features of software with a variety of terms, including <em>nonfunctional requirements</em>, but we dislike that term because it is self-denigrating. Architects created that term to distinguish architecture characteristics from <em>functional requirements</em>, but naming something <em>nonfunctional</em> has a negative impact from a language standpoint: how can teams be convinced to pay enough attention to something “nonfunctional”? Another popular term is <em>quality attributes</em>, which we dislike because it implies after-the-fact quality assessment rather than design. We prefer <em>architecture characteristics</em> because it describes concerns critical to the success of the architecture, and therefore the system as a whole, without discounting its importance.</p>
        
        <p>An architecture characteristic meets three criteria:</p>
        
        <ul>
        <li>
        <p>Specifies a nondomain design consideration</p>
        </li>
        <li>
        <p>Influences some structural aspect of the design</p>
        </li>
        <li>
        <p>Is critical or important to application success</p>
        </li>
        </ul>
        
        <p>These interlocking parts of our definition are illustrated in <a data-type="xref" href="#ch-defined-triangle">Figure&nbsp;4-2</a>.</p>
        
        <figure><div id="ch-defined-triangle" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0402.png" alt="Characteristics Triangle" width="895" height="681">
        <h6><span class="label">Figure 4-2. </span>The differentiating features of architecture characteristics</h6>
        </div></figure>
        
        <p>The definition illustrated in <a data-type="xref" href="#ch-defined-triangle">Figure&nbsp;4-2</a> consists of the three components listed, in addition to a few modifiers:</p>
        <dl>
        <dt>Specifies a nondomain design consideration</dt>
        <dd>
        <p>When designing an application, the requirements specify what the application should do; architecture characteristics specify operational and design criteria for success, concerning how to implement the requirements and why certain choices were made. For example, a common important architecture characteristic specifies a certain level of performance for the application, which often doesn’t appear in a requirements document. Even more pertinent: no requirements document states “prevent technical debt,” but it is a common design consideration for architects and developers. We cover this distinction between explicit and implicit characteristics in depth in <a data-type="xref" href="ch05.html#sec-extract">“Extracting Architecture Characteristics from Domain Concerns”</a>.</p>
        </dd>
        </dl>
        <dl>
        <dt>Influences some structural aspect of the design</dt>
        <dd><p>The primary reason architects try to describe architecture characteristics on projects concerns design considerations: does this architecture characteristic require special structural consideration to succeed? For example, <em>security</em> is a concern in virtually every project, and all systems must take a baseline of precautions during design and coding. However, it rises to the level of architecture characteristic when the architect needs to design something special. Consider two cases surrounding payment in an example system:</p>
        
        <dl>
        <dt>Third-party payment processor</dt>
        <dd><p>If an integration point handles payment details, then the architecture shouldn’t require special structural considerations. The design should incorporate standard security hygiene, such as encryption and hashing, but doesn’t require special structure.</p></dd>
        
        <dt>In-application payment processing</dt>
        <dd><p>If the application under design must handle payment processing, the architect may design a specific module, component, or service for that purpose to isolate the critical security concerns structurally. Now, the architecture characteristic has an impact on both architecture and design.</p>
        </dd></dl>
        
        <p>Of course, even these two criteria aren’t sufficient in many cases to make this determination: past security incidents, the nature of the integration with the third party, and a host of other criteria may be present during this decision. Still, it shows some of the considerations architects must make when determining how to design for certain capabilities.</p></dd>
        
        </dl>
        <dl>
        <dt>Critical or important to application success</dt>
        <dd>
        <p>Applications <em>could</em> support a huge number of architecture characteristics…but shouldn’t. Support for each architecture characteristic adds complexity to the design. Thus, a critical job for architects lies in choosing the fewest architecture characteristics rather than the most possible.</p>
        </dd>
        </dl>
        
        <p>We further subdivide architecture characteristics into implicit versus explicit architecture characteristics.<a data-type="indexterm" data-primary="explicit versus implicit architecture characteristics" id="idm45838980525408"></a><a data-type="indexterm" data-primary="implicit architecture characteristics" data-secondary="explicit characteristics versus" id="idm45838980524608"></a> Implicit ones rarely appear in requirements, yet they’re necessary for project success. For example, availability, reliability, and security underpin virtually all applications, yet they’re rarely specified in design documents.<a data-type="indexterm" data-primary="availability" id="idm45838980523200"></a><a data-type="indexterm" data-primary="reliability" id="idm45838980522528"></a><a data-type="indexterm" data-primary="security" id="idm45838980521856"></a> Architects must use their knowledge of the problem domain to uncover these architecture characteristics during the analysis phase. For example, a high-frequency trading firm may not have to specify low latency in every system, yet the architects in that problem domain know how critical it is. Explicit architecture characteristics appear in requirements documents or other specific instructions.</p>
        
        <p>In <a data-type="xref" href="#ch-defined-triangle">Figure&nbsp;4-2</a>, the choice of a triangle is intentional: each of the definition elements supports the others, which in turn support the overall design of the system. The fulcrum created by the triangle illustrates the fact that these architecture characteristics often interact with one another, leading to the pervasive use among architects of the term <em>trade-off</em>.<a data-type="indexterm" data-primary="architecture characteristics" data-secondary="about" data-startref="ix_archchabt" id="idm45838980518656"></a></p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Architectural Characteristics (Partially) Listed"><div class="sect1" id="idm45838980517232">
        <h1>Architectural Characteristics (Partially) Listed</h1>
        
        <p>Architecture characteristics exist along a broad spectrum <a data-type="indexterm" data-primary="architecture characteristics" data-secondary="partial listing of" id="idm45838980515728"></a>of the software system, ranging from low-level code characteristics, such as modularity, to sophisticated operational concerns, such as scalability and elasticity. No true universal standard exists despite attempts to codify ones in the past. Instead, each organization creates its own interpretation of these terms. Additionally, because the software ecosystem changes so fast, new concepts, terms, measures, and verifications constantly appear, providing new opportunities for architecture characteristics definitions.</p>
        
        <p>Despite the volume and scale, architects commonly separate architecture characteristics into broad categories. The following sections describe a few, along with some examples.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Operational Architecture Characteristics"><div class="sect2" id="idm45838980513360">
        <h2>Operational Architecture Characteristics</h2>
        
        <p>Operational architecture characteristics cover capabilities such as performance, scalability, elasticity, availability, and reliability.<a data-type="indexterm" data-primary="operations" data-secondary="operational architecture characteristics" id="idm45838980511904"></a><a data-type="indexterm" data-primary="architecture characteristics" data-secondary="operational" id="idm45838980510832"></a> <a data-type="xref" href="#table_chars_OAC">Table&nbsp;4-1</a> lists some operational architecture characteristics.</p>
        <table id="table_chars_OAC">
        <caption><span class="label">Table 4-1. </span>Common operational architecture characteristics</caption>
        <thead>
        <tr>
        <th>Term</th>
        <th>Definition</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Availability</p></td>
        <td><p>How long the system will need to be available (if 24/7, steps need to be in place to allow the system to be up and running quickly in case of any failure).<a data-type="indexterm" data-primary="continuity" id="idm45838980503888"></a></p></td>
        </tr>
        <tr>
        <td><p>Continuity</p></td>
        <td><p>Disaster recovery capability.</p></td>
        </tr>
        <tr>
        <td><p>Performance</p></td>
        <td><p>Includes stress testing, peak analysis, analysis of the frequency of functions used, capacity required, and response times. Performance acceptance sometimes requires an exercise of its own, taking months to complete.<a data-type="indexterm" data-primary="performance" data-secondary="as an architecture characteristic" id="idm45838980499840"></a></p></td>
        </tr>
        <tr>
        <td><p>Recoverability</p></td>
        <td><p>Business continuity requirements (e.g., in case of a disaster, how quickly is the system required to be on-line again?). This will affect the backup strategy and requirements for duplicated hardware.<a data-type="indexterm" data-primary="recoverability" id="idm45838980497104"></a></p></td>
        </tr>
        <tr>
        <td><p>Reliability/safety</p></td>
        <td><p>Assess if the system needs to be fail-safe, or if it is mission critical in a way that affects lives. If it fails, will it cost the company large sums of money?<a data-type="indexterm" data-primary="reliability" id="idm45838980494688"></a><a data-type="indexterm" data-primary="robustness" id="idm45838980493984"></a></p></td>
        </tr>
        <tr>
        <td><p>Robustness</p></td>
        <td><p>Ability to handle error and boundary conditions while running if the internet connection goes down or if there’s a power outage or hardware failure.</p></td>
        </tr>
        <tr>
        <td><p>Scalability</p></td>
        <td><p>Ability for the system to perform and operate as the number of users or requests increases.<a data-type="indexterm" data-primary="scalability" id="idm45838980489936"></a></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Operational architecture characteristics heavily overlap with operations and DevOps concerns, forming the intersection of those concerns in many software projects.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Structural Architecture Characteristics"><div class="sect2" id="idm45838980488160">
        <h2>Structural Architecture Characteristics</h2>
        
        <p>Architects must concern themselves with code structure.<a data-type="indexterm" data-primary="structural architecture characteristics" id="idm45838980486832"></a><a data-type="indexterm" data-primary="architecture characteristics" data-secondary="structural" id="idm45838980486112"></a> In many cases, the architect has sole or shared responsibility for code quality concerns, such as good modularity, controlled coupling between components, readable code, and a host of other internal quality assessments. <a data-type="xref" href="#table-struct">Table&nbsp;4-2</a> lists a few structural architecture characteristics.</p>
        <table id="table-struct">
        <caption><span class="label">Table 4-2. </span>Structural architecture characteristics</caption>
        <thead>
        <tr>
        <th>Term</th>
        <th>Definition</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Configurability</p></td>
        <td><p>Ability for the end users to easily change aspects of the software’s configuration (through usable interfaces).<a data-type="indexterm" data-primary="configurability" id="idm45838980479008"></a></p></td>
        </tr>
        <tr>
        <td><p>Extensibility</p></td>
        <td><p>How important it is to plug new pieces of functionality in.</p></td>
        </tr>
        <tr>
        <td><p>Installability</p></td>
        <td><p>Ease of system installation on all necessary platforms.</p></td>
        </tr>
        <tr>
        <td><p>Leverageability/reuse</p></td>
        <td><p>Ability to leverage common components across multiple products.<a data-type="indexterm" data-primary="extensibility" id="idm45838980473568"></a><a data-type="indexterm" data-primary="installability" id="idm45838980472864"></a><a data-type="indexterm" data-primary="leverageability" id="idm45838980472192"></a></p></td>
        </tr>
        <tr>
        <td><p>Localization</p></td>
        <td><p>Support for multiple languages on entry/query screens in data fields; on reports, multibyte character requirements and units of measure or currencies.<a data-type="indexterm" data-primary="localization" id="idm45838980469824"></a><a data-type="indexterm" data-primary="maintainability" id="idm45838980469120"></a></p></td>
        </tr>
        <tr>
        <td><p>Maintainability</p></td>
        <td><p>How easy it is to apply changes and enhance the system?</p></td>
        </tr>
        <tr>
        <td><p>Portability</p></td>
        <td><p>Does the system need to run on more than one platform? (For example, does the frontend need to run against Oracle as well as SAP DB?<a data-type="indexterm" data-primary="portability" data-secondary="as structural architecture characteristic" id="idm45838980465136"></a></p></td>
        </tr>
        <tr>
        <td><p>Upgradeability</p></td>
        <td><p>Ability to easily/quickly upgrade from a previous version of this application/solution to a newer version on servers and clients.</p></td>
        </tr>
        </tbody>
        </table>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Cross-Cutting Architecture Characteristics"><div class="sect2" id="idm45838980461872">
        <h2>Cross-Cutting Architecture Characteristics</h2>
        
        <p>While many architecture characteristics fall into easily recognizable categories,<a data-type="indexterm" data-primary="architecture characteristics" data-secondary="cross-cutting" id="idm45838980460208"></a><a data-type="indexterm" data-primary="cross-cutting architecture characteristics" id="idm45838980459168"></a> many fall outside or defy categorization yet form important design constraints and considerations. <a data-type="xref" href="#table-crosscut">Table&nbsp;4-3</a> describes a few of these.</p>
        <table id="table-crosscut">
        <caption><span class="label">Table 4-3. </span>Cross-cutting architecture characteristics</caption>
        <thead>
        <tr>
        <th>Term</th>
        <th>Definition</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p>Accessibility</p></td>
        <td><p>Access to all your users, including those with disabilities like colorblindness or hearing loss.<a data-type="indexterm" data-primary="accessibility" id="idm45838975033904"></a><a data-type="indexterm" data-primary="archivability" id="idm45838975033200"></a></p></td>
        </tr>
        <tr>
        <td><p>Archivability</p></td>
        <td><p>Will the data need to be archived or deleted after a period of time? (For example, customer accounts are to be deleted after three months or marked as obsolete and archived to a secondary database for future access.)</p></td>
        </tr>
        <tr>
        <td><p>Authentication</p></td>
        <td><p>Security requirements to ensure users are who they say they are.</p></td>
        </tr>
        <tr>
        <td><p>Authorization</p></td>
        <td><p>Security requirements to ensure users can access only certain functions within the application (by use case, subsystem, webpage, business rule, field level, etc.).<a data-type="indexterm" data-primary="authentication/authorization" id="idm45838975027360"></a><a data-type="indexterm" data-primary="security" data-secondary="in cross-cutting architectural characteristics" data-secondary-sortas="cross-cutting" id="idm45838975026640"></a></p></td>
        </tr>
        <tr>
        <td><p>Legal</p></td>
        <td><p>What legislative constraints is the system operating in (data protection, Sarbanes Oxley, GDPR, etc.)? What reservation rights does the company require? Any regulations regarding the way the application is to be built or deployed?<a data-type="indexterm" data-primary="legal requirements" id="idm45838975023616"></a><a data-type="indexterm" data-primary="privacy" id="idm45838975022912"></a></p></td>
        </tr>
        <tr>
        <td><p>Privacy</p></td>
        <td><p>Ability to hide transactions from internal company employees (encrypted transactions so even DBAs and network architects cannot see them).</p></td>
        </tr>
        <tr>
        <td><p>Security</p></td>
        <td><p>Does the data need to be encrypted in the database? Encrypted for network communication between internal systems? What type of authentication needs to be in place for remote user access?</p></td>
        </tr>
        <tr>
        <td><p>Supportability</p></td>
        <td><p>What level of technical support is needed by the application? What level of logging and other facilities are required to debug errors in the system?<a data-type="indexterm" data-primary="supportability" id="idm45838975017040"></a><a data-type="indexterm" data-primary="usability/achievability" id="idm45838975016336"></a></p></td>
        </tr>
        <tr>
        <td><p>Usability/achievability</p></td>
        <td><p>Level of training required for users to achieve their goals with the application/solution. Usability requirements need to be treated as seriously as any other architectural issue.<a data-type="indexterm" data-primary="achievability" id="idm45838975013936"></a></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>Any list of architecture characteristics will necessarily be an incomplete list; any software may invent important architectural characteristics based on unique factors (see <a data-type="xref" href="#sidebar_scotland">“Italy-ility”</a> for an example).</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar_scotland">
        <h5>Italy-ility</h5>
        <p>One of Neal’s colleagues recounts a story about the unique nature of architectural characteristics.<a data-type="indexterm" data-primary="Italy-ility" id="idm45838975009760"></a> She worked for a client whose mandate required a centralized architecture. Yet, for each proposed design, the first question from the client was “But what happens if we lose Italy?” Years ago, because of a freak communication outage, the head office had lost communication with the Italian branches, and it was organizationally traumatic. Thus, a firm requirement of all future architectures insisted upon what the team eventually called <em>Italy-ility</em>, which they all knew meant a unique combination of availability, recoverability, and resilience.<a data-type="indexterm" data-primary="availability" data-secondary="Italy-ility and" id="idm45838975007968"></a><a data-type="indexterm" data-primary="recoverability" data-secondary="Italy-ility and" id="idm45838975006992"></a><a data-type="indexterm" data-primary="resilience" id="idm45838975006048"></a></p>
        </div></aside>
        
        <p>Additionally, many of the preceding terms are imprecise and ambiguous, sometimes because of subtle nuance or the lack of objective definitions. For example, <em>interoperability</em> and <em>compatibility</em> may appear equivalent, which will be true for some systems.<a data-type="indexterm" data-primary="interoperability" data-secondary="compatibility versus" id="idm45838975003600"></a><a data-type="indexterm" data-primary="compatibility" data-secondary="interoperability versus" id="idm45838975002544"></a> However, they differ because <em>interoperability</em> implies ease of integration with other systems, which in turn implies published, documented APIs. <em>Compatibility</em>, on the other hand, is more concerned with industry and domain standards. Another example is <em>learnability</em>.<a data-type="indexterm" data-primary="learnability" id="idm45838975000032"></a> One definition is how easy it is for users to learn to use the software, and another definition is the level at which the system can automatically learn about its environment in order to become self-configuring or self-optimizing using machine learning algorithms.</p>
        
        <p>Many of the definitions overlap. For example, consider availability and reliability, which seem to overlap in almost all cases.<a data-type="indexterm" data-primary="availability" data-secondary="reliability versus" id="idm45838974998480"></a><a data-type="indexterm" data-primary="reliability" data-secondary="availability versus" id="idm45838974997504"></a> Yet consider the internet protocol IP, which underlies TCP. IP is <em>available</em> but not <em>reliable</em>: the packets may arrive out of order, and the receiver may have to ask for missing packets again.</p>
        
        <p>No complete list of standards exists. The International Organization for Standards (ISO) publishes a <a href="https://oreil.ly/SKc_Y">list organized by capabilities</a>, overlapping many of the ones we’ve listed, but mainly establishing an incomplete category list. The following are some of the<a data-type="indexterm" data-primary="architecture characteristics" data-secondary="definitions of terms from the ISO" id="idm45838974994048"></a><a data-type="indexterm" data-primary="International Organization for Standards (ISO)" data-secondary="definitions of software architecture terms" id="idm45838974993024"></a> ISO definitions:</p>
        <dl>
        <dt>Performance efficiency</dt>
        <dd>
        <p>Measure of the performance relative to the amount of resources used under known conditions.<a data-type="indexterm" data-primary="performance" data-secondary="performance efficiency, defined" id="idm45838974989664"></a> This includes <em>time behavior</em> (measure of response,  processing times, and/or throughput rates), <em>resource utilization</em> (amounts and types of resources used), and <em>capacity</em> (degree to which the maximum established limits are exceeded).<a data-type="indexterm" data-primary="time behavior" id="idm45838974987264"></a><a data-type="indexterm" data-primary="resource utilization" id="idm45838974986480"></a><a data-type="indexterm" data-primary="capacity" id="idm45838974985808"></a></p>
        </dd>
        <dt>Compatibility</dt>
        <dd>
        <p>Degree to which a product, system, or component can exchange information with other products, systems, or components and/or perform its required functions while sharing the same hardware or software environment.<a data-type="indexterm" data-primary="compatibility" data-secondary="defined" id="idm45838974983760"></a> It includes <em>coexistence</em> (can perform its required functions efficiently while sharing a common environment and resources with other products) and <em>interoperability</em> (degree to which two or more systems can exchange and utilize information).<a data-type="indexterm" data-primary="coexistence" id="idm45838974981680"></a><a data-type="indexterm" data-primary="interoperability" id="idm45838974980976"></a></p>
        </dd>
        <dt>Usability</dt>
        <dd>
        <p>Users can use the system effectively, efficiently, and satisfactorily for its intended purpose.<a data-type="indexterm" data-primary="usability" data-secondary="defined" id="idm45838974978688"></a> It includes <em>appropriateness recognizability</em> (users can recognize whether the software is appropriate for their needs), <em>learnability</em> (how easy users can learn how to use the software), <em>user error protection</em> (protection against users making errors), and <em>accessibility</em> (make the software available to people with the widest range of characteristics and capabilities).<a data-type="indexterm" data-primary="learnability" data-secondary="usability and" id="idm45838974975712"></a><a data-type="indexterm" data-primary="user error protection" id="idm45838974974736"></a><a data-type="indexterm" data-primary="errors (user), protection against" id="idm45838974974064"></a></p>
        </dd>
        <dt>Reliability</dt>
        <dd>
        <p>Degree to which a system functions under specified conditions for a specified period of time. <a data-type="indexterm" data-primary="reliability" data-secondary="defined" id="idm45838974971888"></a><a data-type="indexterm" data-primary="maturity" id="idm45838974970912"></a><a data-type="indexterm" data-primary="fault tolerance" data-secondary="reliability and" id="idm45838974970240"></a><a data-type="indexterm" data-primary="recoverability" data-secondary="reliability and" id="idm45838974969296"></a>This characteristic includes subcategories such as <em>maturity</em> (does the software meet the reliability needs under normal operation), <em>availability</em> (software is operational and accessible), <em>fault tolerance</em> (does the software operate as intended despite hardware or software faults), and <em>recoverability</em> (can the software recover from failure by recovering any affected data and reestablish the desired state of the system.</p>
        </dd>
        <dt>Security</dt>
        <dd>
        <p>Degree the software protects information and data so that people or other products or systems have the degree of data access appropriate to their types and levels of authorization.<a data-type="indexterm" data-primary="security" data-secondary="defined" id="idm45838974964720"></a><a data-type="indexterm" data-primary="confidentiality" id="idm45838974963744"></a><a data-type="indexterm" data-primary="integrity" id="idm45838974963072"></a><a data-type="indexterm" data-primary="nonrepudiation" id="idm45838974962400"></a> This family of characteristics includes <em>confidentiality</em> (data is accessible only to those authorized to have access), <em>integrity</em> (the software prevents unauthorized access to or modification of software or data), <em>nonrepudiation</em>, (can actions or events be proven to have taken place), <em>accountability</em> (can user actions of a user be traced), and <em>authenticity</em> (proving the identity of a user).<a data-type="indexterm" data-primary="accountability" id="idm45838974959264"></a><a data-type="indexterm" data-primary="authenticity" id="idm45838974958560"></a></p>
        </dd>
        <dt>Maintainability</dt>
        <dd>
        <p>Represents the degree of effectiveness and efficiency to which developers can modify the software to improve it, correct it, or adapt it to changes in environment and/or requirements. <a data-type="indexterm" data-primary="maintainability" data-secondary="defined" id="idm45838974956304"></a><a data-type="indexterm" data-primary="modularity" data-secondary="maintainability and" id="idm45838974955328"></a><a data-type="indexterm" data-primary="reusability" id="idm45838974954384"></a>This characteristic includes <em>modularity</em> (degree to which the software is composed of discrete components), <em>reusability</em> (degree to which developers can use an asset in more than one system or in building other assets), <em>analyzability</em> (how easily developers can gather concrete metrics about the software), <em>modifiability</em> (degree to which developers can modify the software without introducing defects or degrading existing product quality), and <em>testability</em> (how easily developers and others can test the software).<a data-type="indexterm" data-primary="analyzability" id="idm45838974951200"></a><a data-type="indexterm" data-primary="modifiability" id="idm45838974950416"></a></p>
        </dd>
        <dt>Portability</dt>
        <dd>
        <p>Degree to which developers can transfer a system, product, or component from one hardware, software, or <a data-type="indexterm" data-primary="portability" data-secondary="defined" id="idm45838974948240"></a>other operational or usage environment to another.<a data-type="indexterm" data-primary="adaptability" id="idm45838974947072"></a><a data-type="indexterm" data-primary="installability" data-secondary="portability and" id="idm45838974946400"></a><a data-type="indexterm" data-primary="replaceability" id="idm45838974945456"></a> This characteristic includes the subcharacteristics of <em>adaptability</em> (can developers effectively and efficiently adapt the software for different or evolving hardware, software, or other operational or usage environments), <em>installability</em> (can the software be installed and/or uninstalled in a specified environment), and <em>replaceability</em> (how easily developers can replace the functionality with other software).</p>
        </dd>
        </dl>
        
        <p>The last item in the ISO list addresses the functional aspects of software, which we do not believe belongs in this list:<a data-type="indexterm" data-primary="functional aspects of software" id="idm45838974942784"></a><a data-type="indexterm" data-primary="International Organization for Standards (ISO)" data-secondary="functional aspects of software" id="idm45838974942064"></a></p>
        <dl>
        <dt>Functional suitability</dt>
        <dd>This characteristic represents the degree to which a product or system provides functions that meet stated and implied needs when used under specified conditions. This characteristic is composed of the following subcharacteristics:
        <dl>
        <dt>Functional completeness</dt>
        <dd>Degree to which the set of functions covers all the specified tasks and user objectives.</dd>
        
        <dt>Functional correctness</dt>
        <dd>Degree to which a product or system provides the correct results with the needed degree of precision.</dd>
        
        <dt>Functional appropriateness</dt>
        <dd>Degree to which the functions facilitate the accomplishment of specified tasks and objectives.
        
        These are not architecture characteristics but rather the motivational requirements to build the software. This illustrates how thinking about the relationship between architecture characteristics and the problem domain has evolved. We cover this evolution in <a data-type="xref" href="ch07.html#ch-scope">Chapter&nbsp;7</a>.</dd>
        </dl>
        </dd>
        </dl>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45838974934592">
        <h5>The Many Ambiguities in Software Architecture</h5>
        <p>A consistent frustration amongst architects is the lack of clear definitions of so many critical things, including the activity of software architecture itself! <a data-type="indexterm" data-primary="software architecture" data-secondary="lack of clear definitions in" id="idm45838974933088"></a>This leads companies to define their own terms for common things, which leads to industry-wide confusion because architects either use opaque terms or, worse yet, use the same terms for wildly different meanings. As much as we’d like, we can’t impose a standard nomenclature on the software development world. However, we do follow<a data-type="indexterm" data-primary="ubiquitous language, use of" id="idm45838974931568"></a> and recommend the advice from domain-driven design to establish and use a ubiquitous language amongst fellow employees to help ensure fewer term-based <span class="keep-together">misunderstandings</span>.</p>
        </div></aside>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Trade-Offs and Least Worst Architecture"><div class="sect1" id="sec-tradeoffs">
        <h1>Trade-Offs and Least Worst Architecture</h1>
        
        <p>Applications can only support a few of the architecture characteristics we’ve listed for a variety of reasons.<a data-type="indexterm" data-primary="architecture characteristics" data-secondary="trade-offs and least worst architecture" id="idm45838974927632"></a><a data-type="indexterm" data-primary="trade-offs in software architecture" data-secondary="architecture characteristics and least worst architecture" id="idm45838974926720"></a> First, each of the supported characteristics requires design effort and perhaps structural support. Second, the bigger problem lies with the fact that each architecture characteristic often has an impact on others.<a data-type="indexterm" data-primary="security" data-secondary="trade-offs with performance" id="idm45838974925360"></a><a data-type="indexterm" data-primary="performance" data-secondary="trade-offs with security" id="idm45838974924400"></a> For example, if an architect wants to improve <em>security</em>, it will almost certainly negatively impact <em>performance</em>: the application must do more on-the-fly encryption, indirection for secrets hiding, and other activities that potentially degrade performance.</p>
        
        <p>A metaphor will help illustrate this interconnectivity. Apparently, pilots often struggle learning to fly helicopters because it requires a control for each hand and each foot, and changing one impacts the others. Thus, flying a helicopter is a balancing exercise, which nicely describes the trade-off process when choosing architecture characteristics. Each architecture characteristic that an architect designs support for potentially complicates the overall design.</p>
        
        <p>Thus, architects rarely encounter the situation where they are able to design a system and maximize every single architecture characteristic. More often, the decisions come down to trade-offs between several competing concerns.<a data-type="indexterm" data-primary="least worst architecture" id="idm45838974920864"></a></p>
        <div data-type="tip"><h6>Tip</h6>
        <p>Never shoot for the <em>best</em> architecture, but rather the <em>least worst</em> architecture.</p>
        </div>
        
        <p>Too many architecture characteristics leads to generic solutions that are trying to solve every business problem, and those architectures rarely work because the design becomes unwieldy.</p>
        
        <p>This suggests that architects should strive to design architecture to be as iterative as possible. If you can make changes to the architecture more easily, you can stress less about discovering the exact correct thing in the first attempt. One of the most important lessons of Agile software development is the value of iteration; this holds true at all levels of software development, including architecture.<a data-type="indexterm" data-primary="architecture characteristics" data-startref="ix_archch" id="idm45838974916720"></a></p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492043447/files/epub.css" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-svg.js"></script></div></div></section>
</div>

https://learning.oreilly.com