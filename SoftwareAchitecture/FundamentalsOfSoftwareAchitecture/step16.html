<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 16. Orchestration-Driven Service-Oriented Architecture"><div class="chapter" id="ch-style-esb-soa">
        <h1><span class="label">Chapter 16. </span>Orchestration-Driven <span class="keep-together">Service-Oriented Architecture</span></h1>
        
        
        <p>Architecture styles, like art movements, must be understood in the context of the era in which they evolved, and this architecture exemplifies this rule more than any other. <a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" id="ix_odsoa"></a>The combination of external forces that often influence architecture decisions, combined with a logical but ultimately disastrous organizational philosophy, doomed this architecture to irrelevance. However, it provides a great example of how a particular organizational idea can make logical sense yet hinder most important parts of the development process.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="History and Philosophy"><div class="sect1" id="idm45838970568592">
        <h1>History and Philosophy</h1>
        
        <p>This style of service-oriented architecture appeared just as companies were becoming enterprises <a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="history and philosophy of" id="idm45838970567184"></a>in the late 1990s: merging with smaller companies, growing at a break-neck pace, and requiring more sophisticated IT to accommodate this growth. However, computing resources were scarce, precious, and commercial. Distributed computing had just become possible and necessary, and many companies needed the variable scalability and other beneficial characteristics.</p>
        
        <p>Many external drivers forced architects in this era toward distributed architectures with significant constraints. Before open source operating systems were thought reliable enough for serious work, operating systems were expensive and licensed per machine.<a data-type="indexterm" data-primary="operating systems" data-secondary="before open source, expensive licensing of" id="idm45838970564944"></a><a data-type="indexterm" data-primary="databases" data-secondary="licensing of database servers, problems with" id="idm45838970563936"></a> Similarly, commercial database servers came with Byzantine licensing schemes, which caused application server vendors (which offered database connection pooling) to battle with database vendors.<a data-type="indexterm" data-primary="application servers" data-secondary="vendors battling with database server vendors" id="idm45838970562624"></a> Thus, architects were expected to reuse as much as possible. In fact, <em>reuse</em> in all forms became the dominant philosophy in this architecture, the side effects of which we cover in <a data-type="xref" href="#sec-soa-reuse">“Reuse…and Coupling”</a>.</p>
        
        <p>This style of architecture also exemplifies how far architects can push the idea of technical partitioning, which had good motivations but bad consequences.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Topology"><div class="sect1" id="idm45838970559248">
        <h1>Topology</h1>
        
        <p>The topology of this type of service-oriented architecture <a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="topology" id="idm45838970557744"></a>is shown in <a data-type="xref" href="#fig-ch-style-esb-soa-topo">Figure&nbsp;16-1</a>.</p>
        
        <figure><div id="fig-ch-style-esb-soa-topo" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1601.png" alt="" width="1418" height="842">
        <h6><span class="label">Figure 16-1. </span>Topology of orchestration-driven service-oriented architecture</h6>
        </div></figure>
        
        <p>Not all examples of this style of architecture had the exact layers illustrated in <a data-type="xref" href="#fig-ch-style-esb-soa-topo">Figure&nbsp;16-1</a>, but they all followed the same idea of establishing a taxonomy of services within the architecture, each layer with a specific responsibility.</p>
        
        <p>Service-oriented architecture is a distributed architecture; the exact demarcation of boundaries isn’t shown in <a data-type="xref" href="#fig-ch-style-esb-soa-topo">Figure&nbsp;16-1</a> because it varied based on organization.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Taxonomy"><div class="sect1" id="idm45838970550704">
        <h1>Taxonomy</h1>
        
        <p>The architect’s driving philosophy in this architecture centered around enterprise-level reuse. <a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="taxonomy" id="ix_odsoatax"></a>Many large companies were annoyed at how much they had to continue to rewrite software, and they struck on a strategy to gradually solve that problem. Each layer of the taxonomy supported this goal.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" class="pagebreak-before less_space" data-pdf-bookmark="Business Services"><div class="sect2" id="idm45838970547344">
        <h2>Business Services</h2>
        
        <p><em>Business services</em> sit at the top of this architecture and provide the entry point. For example, services like <code>ExecuteTrade</code> or <code>PlaceOrder</code> represent domain behavior. One litmus test common at the time—could an architect answer affirmatively to the question “Are we in the business of…” for each of these services?</p>
        
        <p>These service definitions contained no code—just input, output, and sometimes schema information. They were usually defined by business users, hence the name business services.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Enterprise Services"><div class="sect2" id="idm45838970543440">
        <h2>Enterprise Services</h2>
        
        <p>The <em>enterprise services</em> contain fine-grained, shared implementations. Typically, a team of developers is tasked with building atomic behavior around particular business domains: <code>CreateCustomer</code>, <code>CalculateQuote</code>, and so on. These services are the building blocks that make up the coarse-grained business services, tied together via the orchestration engine.</p>
        
        <p>This separation of responsibility flows from the reuse goal in this architecture. If developers can build fine-grained enterprise services at just the correct level of granularity, the business won’t have to rewrite that part of the business workflow again. Gradually, the business will build up a collection of reusable assets in the form of reusable enterprise services.</p>
        
        <p>Unfortunately, the dynamic nature of reality defies these attempts. Business components aren’t like construction materials, where solutions last decades. Markets, technology changes, engineering practices, and a host of other factors confound attempts to impose stability on the software world.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Application Services"><div class="sect2" id="idm45838970538672">
        <h2>Application Services</h2>
        
        <p>Not all services in the architecture require the same level of granularity or reuse as the<a data-type="indexterm" data-primary="application services" id="idm45838970537232"></a><a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="taxonomy" data-tertiary="application services" id="idm45838970536528"></a> enterprise services. <em>Application services</em> are one-off, single-implementation services. For example, perhaps one application needs geo-location, but the organization doesn’t want to take the time or effort to make that a reusable service. An application service, typically owned by a single application team, solves these problems.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Infrastructure Services"><div class="sect2" id="idm45838970534176">
        <h2>Infrastructure Services</h2>
        
        <p><em>Infrastructure services</em> supply the operational concerns, such as monitoring, logging, authentication, and authorization.<a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="taxonomy" data-tertiary="infrastructure services" id="idm45838970532448"></a><a data-type="indexterm" data-primary="infrastructure services" id="idm45838970531168"></a> These services tend to be concrete implementations, owned by a shared infrastructure team that works closely with operations.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Orchestration Engine"><div class="sect2" id="idm45838970529968">
        <h2>Orchestration Engine</h2>
        
        <p>The <em>orchestration engine</em> forms the heart of this distributed architecture, stitching together<a data-type="indexterm" data-primary="orchestration engines" id="idm45838970528048"></a><a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="taxonomy" data-tertiary="orchestration engine" id="idm45838970527264"></a> the business service implementations using orchestration, including features like transactional coordination and message transformation. This architecture is typically tied to a single relational database, or a few, rather than a database per service as in microservices architectures. Thus, transactional behavior is handled declaratively in the orchestration engine rather than in the database.<a data-type="indexterm" data-primary="transactions" data-secondary="in orchestration-driven service-oriented architecture" id="idm45838970525472"></a></p>
        
        <p>The orchestration engine defines the relationship between the business and enterprise services, how they map together, and where transaction boundaries lie. It also acts as an integration hub, allowing architects to integrate custom code with package and legacy software systems.</p>
        
        <p>Because this mechanism forms the heart of the architecture, Conway’s law (see <a data-type="xref" href="ch08.html#sidebar-conway">“Conway’s Law”</a>) correctly predicts that the team of integration architects responsible for this engine become a political force within an organization, and eventually a bureaucratic bottleneck.<a data-type="indexterm" data-primary="Conway's law" data-secondary="orchestration engine and" id="idm45838970522384"></a></p>
        
        <p>While this approach might sound appealing, in practice it was mostly a disaster. Off-loading transaction behavior to an orchestration tool sounded good, but finding the correct level of granularity of transactions became more and more difficult. While building a few services wrapped in a distributed transaction is possible, the architecture becomes increasingly complex as developers must figure out where the appropriate transaction boundaries lie between services.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Message Flow"><div class="sect2" id="idm45838970520432">
        <h2>Message Flow</h2>
        
        <p>All requests go through the orchestration engine—it is the location within this architecture where logic resides. <a data-type="indexterm" data-primary="messaging" data-secondary="message flow in orchestration-driven service-oriented architecture" id="idm45838970518976"></a><a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="taxonomy" data-tertiary="message flow" id="idm45838970517952"></a>Thus, message flow goes through the engine even for internal calls, as shown in <a data-type="xref" href="#fig-style-esb-soa-msgflow">Figure&nbsp;16-2</a>.</p>
        
        <figure class="width-75"><div id="fig-style-esb-soa-msgflow" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1602.png" alt="" width="1185" height="986">
        <h6><span class="label">Figure 16-2. </span>Message flow with service-oriented architecture</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-style-esb-soa-msgflow">Figure&nbsp;16-2</a>, the <code>CreateQuote</code> business-level service calls the service bus, which defines the workflow that consists of calls to <code>CreateCustomer</code> and <code>CalculateQuote</code>, each of which also has calls to application services. The service bus acts as the intermediary for all calls within this architecture, serving as both an integration hub and orchestration engine.<a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="taxonomy" data-startref="ix_odsoatax" id="idm45838970510464"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Reuse…and Coupling"><div class="sect1" id="sec-soa-reuse">
        <h1>Reuse…and Coupling</h1>
        
        <p>A major goal of this architecture is reuse at the service level—the ability to gradually build <a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="reuse and coupling in" id="ix_odsoareu"></a><a data-type="indexterm" data-primary="reuse and coupling" data-secondary="in orchestration-driven service-oriented architecture" data-secondary-sortas="orchestration" id="ix_reuse"></a>business behavior that can be incrementally reused over time. Architects in this architecture were instructed to find reuse opportunities as aggressively as possible. For example, consider the situation illustrated in <a data-type="xref" href="#fig-style-esb-soa-reuse-begin">Figure&nbsp;16-3</a>.</p>
        
        <figure><div id="fig-style-esb-soa-reuse-begin" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1603.png" alt="" width="1057" height="838">
        <h6><span class="label">Figure 16-3. </span>Seeking reuse opportunities in service-oriented architecture</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-style-esb-soa-reuse-begin">Figure&nbsp;16-3</a>, an architect realizes that each of these divisions within an insurance company all contain a notion of <code>Customer</code>. Therefore, the proper strategy for service-oriented architecture entails extracting the customer parts into a reusable service and allowing the original services to reference the canonical <code>Customer</code> service, shown in <a data-type="xref" href="#fig-style-esb-soa-reuse-end">Figure&nbsp;16-4</a>.</p>
        
        <figure><div id="fig-style-esb-soa-reuse-end" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1604.png" alt="" width="1387" height="832">
        <h6><span class="label">Figure 16-4. </span>Building canonical representations in service-oriented architecture</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-style-esb-soa-reuse-end">Figure&nbsp;16-4</a>, the architect has isolated all customer behavior into a single <code>Customer</code> service, achieving obvious reuse goals.</p>
        
        <p>However, architects only slowly realized the negative trade-offs of this design. First, when a team builds a system primarily around reuse, they also incur a huge amount of coupling between components.<a data-type="indexterm" data-primary="coupling" data-secondary="reuse and, in orchestration-driven service-oriented architecture" id="idm45838970493136"></a> For example, in <a data-type="xref" href="#fig-style-esb-soa-reuse-end">Figure&nbsp;16-4</a>, a change to the <span class="keep-together"><code>Customer</code></span> service ripples out to all the other services, making change risky. Thus, in service-oriented architecture, architects struggled with making incremental change—each change had a potential huge ripple effect. That in turn led to the need for coordinated deployments, holistic testing, and other drags on engineering efficiency.</p>
        
        <p>Another negative side effect of consolidating behavior into a single place: consider the case of auto and disability insurance in <a data-type="xref" href="#fig-style-esb-soa-reuse-end">Figure&nbsp;16-4</a>. To support a single <code>Customer</code> service, it must include all the details the organization knows about customers. Auto insurance requires a driver’s license, which is a property of the person, not the vehicle. Therefore, the <code>Customer</code> service will have to include details about driver’s licenses that the <em>disability insurance division</em> cares nothing about. Yet, the team that deals with disability must deal with the extra complexity of a single customer definition.</p>
        
        <p>Perhaps the most damaging revelation from this architecture came with the realization of the impractically of building an architecture so focused on technical partitioning. <a data-type="indexterm" data-primary="technical partitioning (components)" data-secondary="in orchestration-driven service-oriented architecture" id="idm45838970486288"></a>While it makes sense from a separation and reuse philosophy standpoint, it was a practical nightmare. Domain concepts like <code>CatalogCheckout</code> were spread so thinly throughout this architecture that they were virtually ground to dust. Developers commonly work on tasks like “add a new address line to <code>CatalogCheckout</code>.” In a service-oriented architecture, that could entail dozens of services in several different tiers, plus changes to a single database schema. And, if the current enterprise services aren’t defined at the correct transactional granularity, the developers will either have to change their design or build a new, near-identical service to change transactional behavior. So much for reuse.<a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="reuse and coupling in" data-startref="ix_odsoareu" id="idm45838970483488"></a><a data-type="indexterm" data-primary="reuse and coupling" data-secondary="in orchestration-driven service-oriented architecture" data-secondary-sortas="orchestration" data-startref="ix_reuse" id="idm45838970482208"></a><a data-type="indexterm" data-primary="reuse and coupling" data-secondary="in orchestration-driven service-oriented architecture" data-startref="ix_reuse" id="idm45838970480688"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Architecture Characteristics Ratings"><div class="sect1" id="idm45838970508432">
        <h1>Architecture Characteristics Ratings</h1>
        
        <p>Many of the modern criteria we use to evaluate architecture now were not priorities when this architecture was popular.<a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-secondary="architecture characteristics ratings" id="idm45838970477936"></a><a data-type="indexterm" data-primary="architecture characteristics" data-secondary="ratings in orchestration-driven service-oriented architecture" id="idm45838970476880"></a> In fact, the Agile software movement had just started and had not penetrated into the size of organizations likely to use this <span class="keep-together">architecture.</span></p>
        
        <p>A one-star rating in the characteristics ratings table in <a data-type="xref" href="#ch-style-esb-soa-rating">Figure&nbsp;16-5</a> means the specific architecture characteristic isn’t well supported in the architecture, whereas a five-star rating means the architecture characteristic is one of the strongest features in the architecture style. The definition for each characteristic identified in the scorecard can be found in <a data-type="xref" href="ch04.html#ch-architecture-characteristics-defined">Chapter&nbsp;4</a>.</p>
        
        <p>Service-oriented architecture is perhaps the most technically partitioned general-purpose architecture ever attempted! <a data-type="indexterm" data-primary="partitioning of components" data-secondary="in orchestration-driven service-oriented architecture" id="idm45838970472032"></a>In fact, the backlash against the disadvantages of this structure lead to more modern architectures such as microservices. <a data-type="indexterm" data-primary="architecture quantum" data-secondary="in orchestration-driven service-oriented architecture" id="idm45838970470736"></a>It has a single quantum even though it is a distributed architecture for two reasons. First, it generally uses a single database or just a few databases, creating coupling points within the architecture across many different concerns.<a data-type="indexterm" data-primary="orchestration engines" data-secondary="acting as giant coupling points" id="idm45838970469376"></a><a data-type="indexterm" data-primary="databases" data-secondary="in orchestration-driven service-oriented architecture" data-secondary-sortas="orchestration" id="idm45838970468416"></a> Second, and more importantly, the orchestration engine acts as a giant coupling point—no part of the architecture can have different architecture characteristics than the mediator that orchestrates all behavior. Thus, this architecture manages to find the disadvantages of both monolithic <em>and</em> distributed architectures.</p>
        
        <figure class="width-75"><div id="ch-style-esb-soa-rating" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1605.png" alt="" width="1240" height="1401">
        <h6><span class="label">Figure 16-5. </span>Ratings for service-oriented architecture</h6>
        </div></figure>
        
        <p>Modern engineering goals such as deployability and testability score disastrously in <a data-type="indexterm" data-primary="testability" data-secondary="rating in orchestration-driven service-oriented architecture" id="idm45838970463696"></a><a data-type="indexterm" data-primary="deployability" data-secondary="rating in orchestration-driven service-oriented architecture" id="idm45838970462672"></a>this architecture, both because they were poorly supported and because those were not important (or even aspirational) goals during that era.</p>
        
        <p>This architecture did support some goals such as elasticity and scalability, despite the difficulties<a data-type="indexterm" data-primary="elasticity" data-secondary="rating in orchestration-driven service-oriented architecture" id="idm45838970460896"></a><a data-type="indexterm" data-primary="scalability" data-secondary="rating in orchestration-driven service-oriented architecture" id="idm45838970459872"></a> in implementing those behaviors, because tool vendors poured enormous effort into making these systems scalable by building session replication across application servers and other techniques.<a data-type="indexterm" data-primary="performance" data-secondary="rating in orchestration-driven service-oriented architecture" id="idm45838970458544"></a> However, being a distributed architecture, performance was never a highlight of this architecture style and was extremely poor because each business request was split across so much of the architecture.</p>
        
        <p>Because of all these factors, simplicity and cost have the inverse relationship most architects would prefer. <a data-type="indexterm" data-primary="simplicity" data-secondary="in orchestration-driven service-oriented architecture" id="idm45838970456688"></a><a data-type="indexterm" data-primary="cost" data-secondary="in orchestration-driven service-oriented architecture" data-secondary-sortas="orchestration" id="idm45838970455616"></a><a data-type="indexterm" data-primary="transactions" data-secondary="difficulty of distributed transactions" id="idm45838970454368"></a>This architecture was an important milestone because it taught architects how difficult distributed transactions can be in the real world and the practical limits of technical partitioning.<a data-type="indexterm" data-primary="orchestration-driven service-oriented architecture" data-startref="ix_odsoa" id="idm45838970453024"></a></p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492043447/files/epub.css" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-svg.js"></script></div></div></section>
</div>

https://learning.oreilly.com