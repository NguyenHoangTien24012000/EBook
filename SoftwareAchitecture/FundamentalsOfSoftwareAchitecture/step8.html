<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Component-Based Thinking"><div class="chapter" id="ch-component-based-thinking">
        <h1><span class="label">Chapter 8. </span>Component-Based Thinking</h1>
        
        
        <p>In <a data-type="xref" href="ch03.html#ch-modularity">Chapter&nbsp;3</a>, we discussed <em>modules</em> as a collection of related code. However, architects typically think in terms of <em>components</em>, the physical manifestation of a module.<a data-type="indexterm" data-primary="component-based thinking" id="ix_cmpth"></a></p>
        
        <p>Developers physically package modules in different ways, sometimes depending on their development platform.<a data-type="indexterm" data-primary="components" data-secondary="defined" id="idm45838979985824"></a> We call physical packaging of modules <em>components</em>. Most languages support physical packaging as well: <code>jar</code> files in Java, <code>dll</code> in .NET, <code>gem</code> in Ruby, and so on. In this chapter, we discuss architectural considerations around components, ranging from scope to discovery.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Component Scope"><div class="sect1" id="idm45838979982816">
        <h1>Component Scope</h1>
        
        <p>Developers find it useful <a data-type="indexterm" data-primary="component-based thinking" data-secondary="component scope" id="ix_cmpthcs"></a>to subdivide the concept of <em>component</em> based on a wide host of factors, a few of which appear in <a data-type="xref" href="#ch-component-based-thinking-types">Figure&nbsp;8-1</a>.</p>
        
        <p>Components offer a language-specific mechanism to group artifacts together, often nesting them to create stratification. As shown in <a data-type="xref" href="#ch-component-based-thinking-types">Figure&nbsp;8-1</a>, the simplest component wraps code at a higher level of modularity than classes (or functions, in nonobject-oriented languages). <a data-type="indexterm" data-primary="libraries" id="idm45838979976928"></a>This simple wrapper is often called a <em>library</em>, which tends to run in the same memory address as the calling code and communicate via language function call mechanisms. Libraries are usually compile-time dependencies (with notable exceptions like dynamic link libraries [DLLs] that were the bane of Windows users for many years).</p>
        
        <figure class="width-75"><div id="ch-component-based-thinking-types" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0801.png" alt="" width="1393" height="1021">
        <h6><span class="label">Figure 8-1. </span>Different varieties of components</h6>
        </div></figure>
        
        <p>Components also appear as subsystems or layers in architecture, as the deployable unit of work for many event processors.<a data-type="indexterm" data-primary="services" id="idm45838979972576"></a> Another type of component, a <em>service</em>, tends to run in its own address space and communicates via low-level networking protocols like TCP/IP or higher-level formats like REST or message queues, forming stand-alone, deployable units in architectures like microservices.<a data-type="indexterm" data-primary="microservices" data-secondary="components and" id="idm45838979971072"></a></p>
        
        <p>Nothing requires an architect to use components—it just so happens that it’s often useful to have a higher level of modularity than the lowest level offered by the language. For example, in microservices architectures, simplicity is one of the architectural principles. Thus, a service may consist of enough code to warrant components or may be simple enough to just contain a small bit of code, as illustrated in <a data-type="xref" href="#ch-component-based-thinking-scope">Figure&nbsp;8-2</a>.</p>
        
        <p>Components form the fundamental modular building block in architecture, making them a critical consideration for architects. In fact, one of the primary decisions an architect must make concerns the top-level partitioning of components in the <span class="keep-together">architecture.</span><a data-type="indexterm" data-primary="component-based thinking" data-secondary="component scope" data-startref="ix_cmpthcs" id="idm45838979967152"></a></p>
        
        <figure class="width-50"><div id="ch-component-based-thinking-scope" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0802.png" alt="" width="975" height="763">
        <h6><span class="label">Figure 8-2. </span>A microservice might have so little code that components aren’t necessary</h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Architect Role"><div class="sect1" id="idm45838979963536">
        <h1>Architect Role</h1>
        
        <p>Typically, the architect defines, refines, manages, and governs components within an architecture.<a data-type="indexterm" data-primary="component-based thinking" data-secondary="software architect's role" id="ix_cmpthsftar"></a><a data-type="indexterm" data-primary="software architects" data-secondary="role in components" id="ix_sftarcmp"></a> Software architects, in collaboration with business analysts, subject matter experts, developers, QA engineers, operations, and enterprise architects, create the initial design for software, incorporating the architecture characteristics discussed in <a data-type="xref" href="ch04.html#ch-architecture-characteristics-defined">Chapter&nbsp;4</a> and the requirements for the software system.</p>
        
        <p>Virtually all the details we cover in this book exist independently from whatever software development process teams use: architecture is independent from the development process.<a data-type="indexterm" data-primary="development process, separation from software architecture" id="idm45838979957648"></a><a data-type="indexterm" data-primary="Agile development" data-secondary="software architecture and" id="idm45838979956896"></a> The primary exception to this rule entails the engineering practices pioneered in the various flavors of Agile software development, particularly in the areas of deployment and automating governance. However, in general, software architecture exists separate from the process. Thus, architects ultimately don’t care where requirements originate: a formal Joint Application Design (JAD) process, lengthy waterfall-style analysis and design, Agile story cards…or any hybrid variation of those.</p>
        
        <p>Generally<a data-type="indexterm" data-primary="components" data-secondary="defined" id="idm45838979954912"></a> the component is the lowest level of the software system an architect interacts directly with, with the exception of many of the code quality metrics discussed in <a data-type="xref" href="ch06.html#ch-measuring">Chapter&nbsp;6</a> that affect code bases holistically. Components consist of classes or functions (depending on the implementation platform), whose design falls under the responsibility of tech leads or developers. It’s not that architects shouldn’t involve themselves in class design (particularly when discovering or applying design patterns), but they should avoid micromanaging each decision from top to bottom in the system. If architects never allow other roles to make decisions of consequence, the organization will struggle with empowering the next generation of architects.</p>
        
        <p>An architect must identify components as one of the first tasks on a new project. But before an architect can identify components, they must know how to partition the architecture.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Architecture Partitioning"><div class="sect2" id="idm45838979951504">
        <h2>Architecture Partitioning</h2>
        
        <p>The First Law of Software Architecture states that everything in software is a trade-off, including how architects create components in an architecture.<a data-type="indexterm" data-primary="architecture partitioning" id="idm45838979949632"></a> Because components represent a general containership mechanism, an architect can build any type of partitioning they want. Several common styles exist, with different sets of trade-offs. We discuss architecture styles in depth in <a data-type="xref" href="part02.html#part2-styles">Part&nbsp;II</a>. Here we discuss an important aspect of styles, the <em>top-level partitioning</em> in an architecture.<a data-type="indexterm" data-primary="top-level partitioning in an architecture" id="idm45838979947312"></a></p>
        
        <p>Consider the two types of architecture styles shown in <a data-type="xref" href="#ch-component-based-thinking-generic-partition">Figure&nbsp;8-3</a>.</p>
        
        <figure class="width-75"><div id="ch-component-based-thinking-generic-partition" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0803.png" alt="" width="1402" height="934">
        <h6><span class="label">Figure 8-3. </span>Two types of top-level architecture partitioning: <em>layered</em> and <em>modular</em></h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#ch-component-based-thinking-generic-partition">Figure&nbsp;8-3</a>, one type <a data-type="indexterm" data-primary="layered monoliths" id="idm45838979940560"></a>of architecture familiar to many is the <em>layered monolith</em> (discussed in detail in <a data-type="xref" href="ch10.html#ch-style-layered">Chapter&nbsp;10</a>). The other is an architecture style popularized by <a href="https://www.codingthearchitecture.com">Simon Brown</a> called a <em>modular monolith</em>, a single deployment unit associated with a database and partitioned around domains rather than technical capabilities.<a data-type="indexterm" data-primary="Brown, Simon" id="idm45838979937184"></a><a data-type="indexterm" data-primary="modular monoliths" id="idm45838979936480"></a> These two styles represent different ways to <em>top-level partition</em> the architecture. Note that in each variation, each of the top-level components (layers or components) likely has other components embedded within. The top-level partitioning is of particular interest to architects because it defines the fundamental architecture style and way of partitioning code.</p>
        
        <p><a data-type="indexterm" data-primary="technical partitioning (components)" data-secondary="technical top-level partitioning" id="idm45838979934752"></a>Organizing architecture based on technical capabilities like the layered monolith represents <em>technical top-level partitioning</em>. A common version of this appears in <a data-type="xref" href="#ch-component-based-thinking-partition-specific">Figure&nbsp;8-4</a>.</p>
        
        <figure class="width-75"><div id="ch-component-based-thinking-partition-specific" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0804.png" alt="" width="1387" height="793">
        <h6><span class="label">Figure 8-4. </span>Two types of top-level partitioning in architecture</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#ch-component-based-thinking-partition-specific">Figure&nbsp;8-4</a>, the architect has partitioned the functionality of the system into <em>technical</em> capabilities: presentation, business rules, services, persistence, and so on. This way of organizing a code base certainly makes sense. <a data-type="indexterm" data-primary="persistence" data-secondary="in component-based thinking" data-secondary-sortas="component-based" id="idm45838979927952"></a>All the persistence code resides in one layer in the architecture, making it easy for developers to find persistence-related code. Even though the basic concept of layered architecture predates it by decades, the Model-View-Controller design pattern matches with this architectural pattern, making it easy for developers to understand. Thus, it is often the default architecture in many organizations.</p>
        
        <p>An interesting side effect of the predominance of the layered architecture relates to how companies seat different project roles. When using a layered architecture, it makes some sense to have all the backend developers sit together in one department, the DBAs in another, the presentation team in another, and so on. Because of <em>Conway’s law</em>, this makes some sense in those organizations.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sidebar-conway">
        <h5>Conway’s Law</h5>
        <p>Back in the late 1960s, <a href="https://oreil.ly/z2Swa">Melvin Conway</a> made an <a data-type="indexterm" data-primary="Conway's law" id="idm45838979922288"></a>observation that has become known as <em>Conway’s law</em>:</p>
        <blockquote>
        <p>Organizations which design systems … are constrained to produce designs which are copies of the communication structures of these organizations.</p></blockquote>
        
        <p>Paraphrased, this law suggests that when a group of people designs some technical artifact, the communication structures between the people end up replicated in the design. People at all levels of organizations see this law in action, and they sometimes make decisions based on it. For example, it is common for organizations to partition workers based on technical capabilities, which makes sense from a pure organizational sense but hampers collaboration because of artificial separation of common concerns.</p>
        
        <p>A related observation coined by Jonny Leroy of ThoughtWorks is the <a href="https://oreil.ly/9EYd6">Inverse Conway Maneuver</a>, which suggests evolving team and organizational structure together to promote the desired architecture.<a data-type="indexterm" data-primary="Inverse Conway Maneuver" id="idm45838979917840"></a><a data-type="indexterm" data-primary="Leroy, Jonny" id="idm45838979917136"></a></p>
        </div></aside>
        
        <p>The other architectural variation in <a data-type="xref" href="#ch-component-based-thinking-partition-specific">Figure&nbsp;8-4</a> represents <em>domain partitioning</em>, inspired by <a data-type="indexterm" data-primary="domain partitioning (components)" data-secondary="defined" id="idm45838979914624"></a>the Eric Evan book <em>Domain-Driven Design</em>, which is a modeling technique for decomposing complex software systems. In DDD, the architect identifies domains or workflows independent and decoupled from each other. <a data-type="indexterm" data-primary="top-level partitioning in an architecture" data-secondary="domain partitioning" id="idm45838979912816"></a><a data-type="indexterm" data-primary="domain-driven design (DDD)" data-secondary="component partitioning and" id="idm45838979911808"></a>The microservices architecture style (discussed in <a data-type="xref" href="ch17.html#ch-style-microservices">Chapter&nbsp;17</a>) is based on this philosophy. In a modular monolith, the architect partitions the architecture around domains or workflows rather than technical capabilities. As components often nest within one another, each of the components in <a data-type="xref" href="#ch-component-based-thinking-partition-specific">Figure&nbsp;8-4</a> in the domain partitioning (for example, <em>CatalogCheckout</em>) may use a persistence library and have a separate layer for business rules, but the top-level partitioning revolves around domains.</p>
        
        <p>One of the fundamental distinctions between different architecture patterns is what type of top-level partitioning each supports, which we cover for each individual pattern. It also has a huge impact on how an architect decides how to initially identify components—does the architect want to partition things technically or by domain?</p>
        
        <p>Architects using technical partitioning organize the components of the system by technical capabilities: presentation, business rules, persistence, and so on. Thus, one of the organizing principles of this architecture is <em>separation of technical concerns</em>. <a data-type="indexterm" data-primary="separation of technical concerns" id="idm45838979906304"></a>This in turn creates useful levels of decoupling: if the service layer is only connected to the persistence layer below and business rules layer above, then changes in persistence will only potentially affect those layers.<a data-type="indexterm" data-primary="persistence" data-secondary="persistence layer" id="idm45838979905264"></a><a data-type="indexterm" data-primary="business rules layer" id="idm45838979904320"></a><a data-type="indexterm" data-primary="services" data-secondary="service layer" id="idm45838979903648"></a> This style of partitioning provides a decoupling technique, reducing rippling side effects on dependent components. We cover more details of this architecture style in the layered architecture pattern in <a data-type="xref" href="ch10.html#ch-style-layered">Chapter&nbsp;10</a>. It is certainly logical to organize systems using technical partitioning, but, like all things in software architecture, this offers some trade-offs.</p>
        
        <p>The separation enforced by technical partitioning enables developers to find certain categories of the code base quickly, as it is organized by capabilities. However, most realistic software systems require workflows that cut across technical capabilities. Consider the common business workflow of <em>CatalogCheckout</em>. The code to handle <em>CatalogCheckout</em> in <a data-type="indexterm" data-primary="workflows" data-secondary="in technical and domain-partitioned architecture" data-secondary-sortas="technical" id="idm45838979899952"></a><a data-type="indexterm" data-primary="domains" data-secondary="in technical and domain-partitioned architectures" data-secondary-sortas="technical" id="idm45838979898576"></a>the technically layered architecture appears in all the layers, as shown in <a data-type="xref" href="#ch-component-based-thinking-domains">Figure&nbsp;8-5</a>.</p>
        
        <figure class="width-75"><div id="ch-component-based-thinking-domains" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0805.png" alt="" width="1387" height="793">
        <h6><span class="label">Figure 8-5. </span>Where domains/workflows appear in technical- and domain-partitioned architectures</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#ch-component-based-thinking-domains">Figure&nbsp;8-5</a>, in the technically partitioned architecture, <em>CatalogCheckout</em> appears in all the layers; the domain is smeared across the technical layers. Contrast this with domain partitioning, which uses a top-level partitioning that organizes components by domain rather than technical capabilities. In <a data-type="xref" href="#ch-component-based-thinking-domains">Figure&nbsp;8-5</a>, architects designing the domain-partitioned architecture build top-level components around workflows and/or domains. Each component in the domain partitioning may have subcomponents, including layers, but the top-level partitioning focuses on domains, which better reflects the kinds of changes that most often occur on projects.</p>
        
        <p>Neither of these styles is more correct than the other—refer to the First Law of Software Architecture. That said, we have observed a decided industry trend over the last few years toward domain partitioning for the monolithic and distributed (for example, microservices) architectures. However, it is one of the first decisions an architect must make.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Case Study: Silicon Sandwiches: Partitioning"><div class="sect2" id="idm45838979950880">
        <h2>Case Study: Silicon Sandwiches: Partitioning</h2>
        
        <p>Consider the case of one of our example katas, <a data-type="xref" href="ch05.html#ch-identifying-ss">“Case Study: Silicon Sandwiches”</a>. When deriving <a data-type="indexterm" data-primary="Silicon Sandwiches partitioning case study" id="ix_SSpart"></a>components, one of the fundamental decisions facing an architect is the top-level partitioning. Consider the first of two different possibilities for Silicon Sandwiches, a domain partitioning, illustrated in <a data-type="xref" href="#ch-component-based-thinking-SS-domain">Figure&nbsp;8-6</a>.</p>
        <figure><div id="ch-component-based-thinking-SS-domain" class="figure"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0806.png" width="1404" height="620">
        <h6><span class="label">Figure 8-6. </span>A domain-partitioned design for Silicon Sandwiches</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#ch-component-based-thinking-SS-domain">Figure&nbsp;8-6</a>, the architect has designed around domains (workflows), creating discrete components for <code>Purchase</code>, <code>Promotion</code>, <code>MakeOrder</code>, <code>ManageInventory</code>, <code>Recipes</code>, <code>Delivery</code>, and <code>Location</code>. Within many of these components resides a subcomponent to handle the various types of customization required, covering both common and local variations.</p>
        
        <p>An alternative design isolates the <code>common</code> and <code>local</code> parts into their own partition, illustrated in <a data-type="xref" href="#ch-component-based-thinking-SS-technical">Figure&nbsp;8-7</a>. <code>Common</code> and <code>Local</code> represent top-level components, with <code>Purchase</code> and <code>Delivery</code> remaining to handle the workflow.</p>
        
        <p>Which is better? It depends! Each partitioning offers different advantages and <span class="keep-together">drawbacks</span>.</p>
        
        <figure><div id="ch-component-based-thinking-SS-technical" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0807.png" alt="" width="1408" height="720">
        <h6><span class="label">Figure 8-7. </span>A technically partitioned design for Silicon Sandwiches</h6>
        </div></figure>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Domain partitioning"><div class="sect3" id="idm45838979872000">
        <h3>Domain partitioning</h3>
        
        <p>Domain-partitioned architectures separate top-level components by workflows and/or domains.<a data-type="indexterm" data-primary="Silicon Sandwiches partitioning case study" data-secondary="domain partitioning" id="idm45838979870560"></a><a data-type="indexterm" data-primary="domain partitioning (components)" data-secondary="in Silicon Sandwiches partitioning case study" data-secondary-sortas="Silicon" id="idm45838979869488"></a></p>
        <dl>
        <dt>Advantages</dt>
        <dd>
        
        <ul>
        <li>
        <p>Modeled more closely toward how the business functions rather than an implementation detail</p>
        </li>
        <li>
        <p>Easier to utilize the Inverse Conway Maneuver to build cross-functional teams around domains<a data-type="indexterm" data-primary="Inverse Conway Maneuver" id="idm45838979864512"></a></p>
        </li>
        <li>
        <p>Aligns more closely to the modular monolith and microservices architecture styles<a data-type="indexterm" data-primary="modular monoliths" data-secondary="domain partitioning in Silicon Sandwiches case study" id="idm45838979862976"></a><a data-type="indexterm" data-primary="microservices" data-secondary="domain partitioning in Silicon Sandwiches case study" id="idm45838979861872"></a><a data-type="indexterm" data-primary="distributed architectures" data-secondary="domain partitioning and" id="idm45838979860896"></a></p>
        </li>
        <li>
        <p>Message flow matches the problem domain</p>
        </li>
        <li>
        <p>Easy to migrate data and components to distributed architecture</p>
        </li>
        </ul>
        </dd>
        <dt>Disadvantage</dt>
        <dd>
        
        <ul>
        <li>
        <p>Customization code appears in multiple places</p>
        </li>
        </ul>
        </dd>
        </dl>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Technical partitioning"><div class="sect3" id="idm45838979855264">
        <h3>Technical partitioning</h3>
        
        <p>Technically partitioned architectures separate top-level components based on technical capabilities rather than discrete workflows.<a data-type="indexterm" data-primary="technical partitioning (components)" data-secondary="in Silicon Sandwiches patitioning case study" data-secondary-sortas="Silicon" id="idm45838979853792"></a> This may manifest as layers inspired by Model-View-Controller separation or some other ad hoc technical partitioning. <a data-type="xref" href="#ch-component-based-thinking-SS-technical">Figure&nbsp;8-7</a> separates components based on customization.<a data-type="indexterm" data-primary="layered architecture" data-secondary="technical partitioning in Silicon Sandwiches case study" id="idm45838979851344"></a><a data-type="indexterm" data-primary="layered architecture" data-secondary="technical partitioning of components" id="idm45838979850304"></a></p>
        <dl>
        <dt>Advantages</dt>
        <dd>
        
        <ul>
        <li>
        <p>Clearly separates customization code.</p>
        </li>
        <li>
        <p>Aligns more closely to the layered architecture pattern.</p>
        </li>
        </ul>
        </dd>
        <dt>Disadvantages</dt>
        <dd>
        
        <ul>
        <li>
        <p>Higher degree of global coupling. Changes to either the <code>Common</code> or <code>Local</code> component will likely affect all the other components.</p>
        </li>
        <li>
        <p>Developers may have to duplicate domain concepts in both <code>common</code> and <code>local</code> layers.</p>
        </li>
        <li>
        <p>Typically higher coupling at the data level. In a system like this, the application and data architects would likely collaborate to create a single database, including customization and domains. That in turn creates difficulties in untangling the data relationships if the architects later want to migrate this architecture to a distributed system.</p>
        </li>
        </ul>
        </dd>
        </dl>
        
        <p>Many other factors contribute to an architect’s decision on what architecture style to<a data-type="indexterm" data-primary="Silicon Sandwiches partitioning case study" data-startref="ix_SSpart" id="idm45838979838928"></a><a data-type="indexterm" data-primary="component-based thinking" data-secondary="software architect's role" data-startref="ix_cmpthsftar" id="idm45838979837856"></a><a data-type="indexterm" data-primary="software architecture" data-secondary="role in components" data-startref="ix_sftarcmp" id="idm45838979836560"></a> base their design upon, covered in <a data-type="xref" href="part02.html#part2-styles">Part&nbsp;II</a>.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Developer Role"><div class="sect1" id="idm45838979834160">
        <h1>Developer Role</h1>
        
        <p>Developers typically take components, jointly designed with the architect role, and further subdivide them into classes, functions, or subcomponents.<a data-type="indexterm" data-primary="component-based thinking" data-secondary="developers' role" id="idm45838979832672"></a><a data-type="indexterm" data-primary="developers" data-secondary="role in components" id="idm45838979831728"></a> In general, class and function design is the shared responsibility of architects, tech leads, and developers, with the lion’s share going to developer roles.</p>
        
        <p>Developers should never take components designed by architects as the last word; all software design benefits from iteration. Rather, that initial design should be viewed as a first draft, where implementation will reveal more details and refinements.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Component Identification Flow"><div class="sect1" id="idm45838979829568">
        <h1>Component Identification Flow</h1>
        
        <p>Component identification works best as an iterative process,<a data-type="indexterm" data-primary="component-based thinking" data-secondary="component identification flow" id="ix_cmpthcif"></a> producing candidates and refinements through feedback, illustrated in <a data-type="xref" href="#ch-component-based-thinking-comp-cycle">Figure&nbsp;8-8</a>.</p>
        
        <figure class="width-90"><div id="ch-component-based-thinking-comp-cycle" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0808.png" alt="" width="1412" height="508">
        <h6><span class="label">Figure 8-8. </span>Component identification cycle</h6>
        </div></figure>
        
        <p>This cycle describes a generic architecture exposition cycle. Certain specialized domains may insert other steps in this process or change it altogether. For example, in some domains, some code must undergo security or auditing steps in this process. Descriptions of each step in <a data-type="xref" href="#ch-component-based-thinking-comp-cycle">Figure&nbsp;8-8</a> appear in the following sections.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Identifying Initial Components"><div class="sect2" id="idm45838979821600">
        <h2>Identifying Initial Components</h2>
        
        <p>Before any code exists for a software project, the architect must somehow determine what top-level components to begin with, based on what type of top-level partitioning they choose.<a data-type="indexterm" data-primary="initial components, identifying" id="idm45838979820096"></a> Outside that, an architect has the freedom to make up whatever components they want, then map domain functionality to them to see where behavior should reside. While this may sound arbitrary, it’s hard to start with anything more concrete if an architect designs a system from scratch. The likelihood of achieving a good design from this initial set of components is disparagingly small, which is why architects must iterate on component design to improve it.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Assign Requirements to Components"><div class="sect2" id="idm45838979818464">
        <h2>Assign Requirements to Components</h2>
        
        <p>Once an architect has identified initial components,<a data-type="indexterm" data-primary="requirements" data-secondary="assigning to components" id="idm45838979817200"></a> the next step aligns requirements (or user stories) to those components to see how well they fit. This may entail creating new components, consolidating existing ones, or breaking components apart because they have too much responsibility. This mapping doesn’t have to be exact—the architect is attempting to find a good coarse-grained substrate to allow further design and refinement by architects, tech leads, and/or developers.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Analyze Roles and Responsibilities"><div class="sect2" id="idm45838979815392">
        <h2>Analyze Roles and Responsibilities</h2>
        
        <p>When assigning stories to components, the architect also looks at the roles and responsibilities elucidated during the requirements to make sure that the granularity matches. <a data-type="indexterm" data-primary="roles and responsibilities, analyzing for components" id="idm45838979813888"></a>Thinking about both the roles and behaviors the application must support allows the architect to align the component and domain granularity. One of the greatest challenges for architects entails discovering the correct granularity for components, which encourages the iterative approach described here.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Analyze Architecture Characteristics"><div class="sect2" id="idm45838979812448">
        <h2>Analyze Architecture Characteristics</h2>
        
        <p>When assigning requirements to components, the architect should also look at the architecture<a data-type="indexterm" data-primary="architecture characteristics" data-secondary="analyzing for components" id="idm45838979811024"></a> characteristics discovered earlier in order to think about how they might impact component division and granularity. For example, while two parts of a system might deal with user input, the part that deals with hundreds of concurrent users will need different architecture characteristics than another part that needs to support only a few. Thus, while a purely functional view of component design might yield a single component to handle user interaction, analyzing the architecture characteristics will lead to a subdivision.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Restructure Components"><div class="sect2" id="idm45838979809040">
        <h2>Restructure Components</h2>
        
        <p>Feedback is critical in software design. <a data-type="indexterm" data-primary="restructuring of components" data-secondary-sortas="components" id="idm45838979807744"></a>Thus, architects must continually iterate on their component design with developers. Designing software provides all kinds of unexpected difficulties—no one can anticipate all the unknown issues that usually occur during software projects. Thus, an iterative approach to component design is key. First, it’s virtually impossible to account for all the different discoveries and edge cases that will arise that encourage redesign. Secondly, as the architecture and developers delve more deeply into building the application, they gain a more nuanced understanding of where behavior and roles should lie.<a data-type="indexterm" data-primary="component-based thinking" data-secondary="component identification flow" data-startref="ix_cmpthcif" id="idm45838979806000"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" class="pagebreak-before less_space" data-pdf-bookmark="Component Granularity"><div class="sect1" id="idm45838979804496">
        <h1>Component Granularity</h1>
        
        <p>Finding the proper granularity for components is one of an architect’s most difficult tasks. <a data-type="indexterm" data-primary="component-based thinking" data-secondary="granularity of components" id="idm45838979802848"></a>Too fine-grained a component design leads to too much communication between components to achieve results. Too coarse-grained components encourage high internal coupling, which leads to difficulties in deployability and testability, as well as modularity-related negative side effects.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Component Design"><div class="sect1" id="idm45838979801152">
        <h1>Component Design</h1>
        
        <p>No accepted “correct” way exists to design components.<a data-type="indexterm" data-primary="component-based thinking" data-secondary="component design" id="ix_cmpthdes"></a> Rather, a wide variety of techniques exist, all with various trade-offs. In all processes, an architect takes requirements and tries to determine what coarse-grained building blocks will make up the application. Lots of different techniques exist, all with varying trade-offs and coupled to the software development process used by the team and organization. Here, we talk about a few general ways to discover components and traps to avoid.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Discovering Components"><div class="sect2" id="idm45838979797792">
        <h2>Discovering Components</h2>
        
        <p>Architects, often in collaboration with other roles such as developers, business analysts, and subject matter experts, create an initial component design based on general knowledge of the system and how they choose to decompose it, based on technical or domain partitioning. The team goal is an initial design that partitions the problem space into coarse chunks that take into account differing architecture characteristics.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Entity trap"><div class="sect3" id="sec-entity-trap">
        <h3>Entity trap</h3>
        
        <p>While there is no one true way to ascertain components, a common anti-pattern lurks: the <em>entity trap</em>.<a data-type="indexterm" data-primary="entity trap" id="idm45838979793312"></a><a data-type="indexterm" data-primary="anti-patterns" data-secondary="Entity Trap" id="idm45838979792576"></a> Say that an architect is working on designing components for our kata Going, Going, Gone and ends up with a design resembling <a data-type="xref" href="#ch-component-based-thinking-entitytrap">Figure&nbsp;8-9</a>.</p>
        
        <figure class="width-90"><div id="ch-component-based-thinking-entitytrap" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0809.png" alt="" width="1428" height="457">
        <h6><span class="label">Figure 8-9. </span>Building an architecture as an object-relational mapping</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#ch-component-based-thinking-entitytrap">Figure&nbsp;8-9</a>, the architect has basically taken each entity identified in the requirements and made a <code>Manager</code> component based on that entity.<a data-type="indexterm" data-primary="databases" data-secondary="component-relational mapping of framework to" id="idm45838979786416"></a> This isn’t an architecture; it’s an object-relational mapping (ORM) of a framework to a database. In other words, if a system only needs simple database CRUD operations (create, read, update, delete), then the architect can download a framework to create user interfaces directly from the database. Many popular ORM frameworks exist to solve this common CRUD behavior.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="sb_naked">
        <h5>Naked Objects and Similar Frameworks</h5>
        <p>More than a decade ago, a family of frameworks appeared that makes building simple CRUD applications trivial, <a data-type="indexterm" data-primary=".NET" data-secondary="Naked Objects framework" data-primary-sortas="NET" id="idm45838979782720"></a><a data-type="indexterm" data-primary="Naked Objects framework" id="idm45838979781472"></a>exemplified by Naked Objects (which has since split into two projects, a .NET version still called <a href="https://oreil.ly/RQ8XQ">NakedObjects</a>, and a Java version that moved to the Apache open source foundation under the name <a href="http://isis.apache.org">Isis</a>). The premise behind these frameworks offers to build a user interface frontend on database entities.<a data-type="indexterm" data-primary="database entities, user interface frontend built on" id="idm45838979779104"></a><a data-type="indexterm" data-primary="Isis framework" id="idm45838979778368"></a><a data-type="indexterm" data-primary="Java" data-secondary="Isis framework" id="idm45838979777696"></a> For example, in Naked Objects, the developer points the framework to database tables, and the framework builds a user interface based on the tables and their defined relationships.</p>
        
        <p>Several other popular frameworks exist that basically provide a default user interface based on database table structure: the scaffolding feature of the <a href="https://rubyonrails.org">Ruby on Rails</a> framework provides the same kind of default mappings from website to database (with many options to extend and add sophistication to the resulting application).<a data-type="indexterm" data-primary="Ruby on Rails, mappings from website to database" id="idm45838979775136"></a></p>
        
        <p>If an architect’s needs require merely a simple mapping from a database to a user interface, full-blown architecture isn’t necessary; one of these frameworks will suffice.</p>
        </div></aside>
        
        <p>The entity trap anti-pattern arises when an architect incorrectly identifies the database relationships as workflows in the application, a correspondence that rarely manifests in the real world.<a data-type="indexterm" data-primary="workflows" data-secondary="database relationships incorrectly identified as" id="idm45838979773200"></a> Rather, this anti-pattern generally indicates lack of thought about the actual workflows of the application. Components created with the entity trap also tend to be too coarse-grained, offering no guidance whatsoever to the development team in terms of the packaging and overall structuring of the source code.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Actor/Actions approach"><div class="sect3" id="idm45838979771616">
        <h3>Actor/Actions approach</h3>
        
        <p>The <em>actor/actions</em> approach is a popular way that architects use to map requirements to components.<a data-type="indexterm" data-primary="actor/actions approach to designing components" id="idm45838979769872"></a> In this approach, originally defined by the Rational Unified Process, architects identify actors who perform activities with the application and the actions those actors may perform. It provides a technique for discovering the typical users of the system and what kinds of things they might do with the system.</p>
        
        <p>The actor/actions approach became popular in conjunction with particular software development processes, especially more formal processes that favor a significant portion of upfront design. It is still popular and works well when the requirements feature distinct roles and the kinds of actions they can perform. This style of component decomposition works well for all types of systems, monolithic or distributed.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Event storming"><div class="sect3" id="idm45838979767616">
        <h3>Event storming</h3>
        
        <p><em>Event storming</em> as a component discovery technique comes from domain-driven design (DDD) and shares popularity with microservices, also heavily influenced by DDD.<a data-type="indexterm" data-primary="event storming in component discovery" id="idm45838979765840"></a><a data-type="indexterm" data-primary="domain-driven design (DDD)" data-secondary="event storming" id="idm45838979765168"></a> In event storming, the architect assumes the project will use messages and/or events to communicate between the various components. To that end, the team tries to determine which events occur in the system based on requirements and identified roles, and build components around those event and message handlers. This works well in distributed architectures like microservices that use events and messages, because it helps architects define the messages used in the eventual system.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Workflow approach"><div class="sect3" id="idm45838979763328">
        <h3>Workflow approach</h3>
        
        <p>An alternative to event storming offers a more generic approach for architects not using DDD or messaging.<a data-type="indexterm" data-primary="workflows" data-secondary="workflow approach to designing components" id="idm45838979761904"></a> The <em>workflow approach</em> models the components around workflows, much like event storming, but without the explicit constraints of building a message-based system. A workflow approach identifies the key roles, determines the kinds of workflows these roles engage in, and builds components around the identified activities.</p>
        
        <p>None of these techniques is superior to the others; all offer a different set of trade-offs. If a team uses a waterfall approach or other older software development processes, they might prefer the Actor/Actions approach because it is general. When using DDD and corresponding architectures like microservices, <em>event storming</em> matches the software development process exactly.<a data-type="indexterm" data-primary="component-based thinking" data-secondary="component design" data-startref="ix_cmpthdes" id="idm45838979758880"></a></p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Case Study: Going, Going, Gone: Discovering Components"><div class="sect1" id="sec-ggg-comp-discovery">
        <h1>Case Study: Going, Going, Gone: Discovering Components</h1>
        
        <p>If a team has no special constraints and is looking for a good general-purpose component decomposition, the Actor/Actions approach works well as a generic solution. It’s the one we use in our case study for Going, Going, Gone.<a data-type="indexterm" data-primary="actor/actions approach to designing components" data-secondary="in Going, Going, Gone case study" data-secondary-sortas="Going" id="idm45838979755056"></a><a data-type="indexterm" data-primary="Going, Going, Gone: discovering components case study" id="ix_GGGdccs"></a></p>
        
        <p>In <a data-type="xref" href="ch07.html#ch-scope">Chapter&nbsp;7</a>, we introduced the architecture kata for Going, Going, Gone (GGG) and discovered architecture characteristics for this system. This system has three obvious roles: the <em>bidder</em>, the <em>auctioneer</em>, and a frequent participant in this modeling technique, the <em>system</em>, for internal actions. The roles interact with the application, represented here by the system, which identifies when the application initiates an event rather than one of the roles. For example, in GGG, once the auction is complete, the system triggers the payment system to process payments.</p>
        
        <p class="pagebreak-before">We can also identify a starting set of actions for each of these roles:</p>
        <dl>
        <dt><code>Bidder</code></dt>
        <dd>
        <p>View live video stream,
        view live bid stream,
        place a bid</p>
        </dd>
        <dt><code>Auctioneer</code></dt>
        <dd>
        <p>Enter live bids into system,
        receive online bids,
        mark item as sold</p>
        </dd>
        <dt><code>System</code></dt>
        <dd>
        <p>Start auction,
        make payment,
        track bidder activity</p>
        </dd>
        </dl>
        
        <p>Given these actions, we can iteratively build a set of starter components for GGG; one such solution appears in <a data-type="xref" href="#ch-component-based-thinking-GGGcomps">Figure&nbsp;8-10</a>.</p>
        
        <figure><div id="ch-component-based-thinking-GGGcomps" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0810.png" alt="" width="1328" height="919">
        <h6><span class="label">Figure 8-10. </span>Initial set of components for Going, Going, Gone</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#ch-component-based-thinking-GGGcomps">Figure&nbsp;8-10</a>, each of the roles and actions maps to a component, which in turn may need to collaborate on information. These are the components we identified for this solution:</p>
        <dl>
        <dt><code>VideoStreamer</code></dt>
        <dd>
        <p>Streams a live auction to users.</p>
        </dd>
        <dt><code>BidStreamer</code></dt>
        <dd>
        <p>Streams bids as they occur to the users. Both <code>VideoStreamer</code> and <code>BidStreamer</code> offer read-only views of the auction to the bidder.</p>
        </dd>
        <dt><code>BidCapture</code></dt>
        <dd>
        <p>This component captures bids from both the auctioneer and bidders.</p>
        </dd>
        <dt><code>BidTracker</code></dt>
        <dd>
        <p>Tracks bids and acts as the system of record.</p>
        </dd>
        <dt><code>AuctionSession</code></dt>
        <dd>
        <p>Starts and stops an auction. When the bidder ends the auction, performs the payment and resolution steps, including notifying bidders of ending.</p>
        </dd>
        <dt><code>Payment</code></dt>
        <dd>
        <p>Third-party payment processor for credit card payments.</p>
        </dd>
        </dl>
        
        <p>Referring to the component identification flow diagram in <a data-type="xref" href="#ch-component-based-thinking-comp-cycle">Figure&nbsp;8-8</a>, after the initial identification of components, the architect next analyzes architecture characteristics to determine if that will change the design. For this system, the architect can definitely identify different sets of architecture characteristics. For example, the current design features a <code>BidCapture</code> component to capture bids from both bidders and the auctioneer, which makes sense functionally: capturing bids from anyone can be handled the same. However, what about architecture characteristics around bid capture? The auctioneer doesn’t need the same level of scalability or elasticity as potentially thousands of bidders.<a data-type="indexterm" data-primary="reliability" data-secondary="in Going, Going, Gone: discovering commponents case study" data-secondary-sortas="Going" id="idm45838979726128"></a> By the same token, an architect must ensure that architecture characteristics like reliability (connections don’t drop) and availability (the system is up) for the auctioneer could be higher than other parts of the system.<a data-type="indexterm" data-primary="availability" data-secondary="in Going, Going, Gone: discovering commponents case study" id="idm45838979724464"></a> For example, while it’s bad for business if a bidder can’t log in to the site or if they suffer from a dropped connection, it’s disastrous to the auction if either of those things happen to the auctioneer.</p>
        
        <p>Because they have differing levels of architecture characteristics, the architect decides to split the <code>Bid Capture</code> component into <code>Bid Capture</code> and <code>Auctioneer Capture</code> so that each of the two components can support differing architecture characteristics. <a data-type="indexterm" data-primary="architecture characteristics" data-secondary="incorporating into Going, Going, Gone component design" id="idm45838979720976"></a>The updated design appears in <a data-type="xref" href="#ch-component-based-thinking-GGG-final-comps">Figure&nbsp;8-11</a>.</p>
        
        <p>The architect creates a new component for <code>Auctioneer Capture</code> and updates information links to both <code>Bid Streamer</code> (so that online bidders see the live bids) and <code>Bid Tracker</code>, which is managing the bid streams. Note that <code>Bid Tracker</code> is now the component that will unify the two very different information streams: the single stream of information from the auctioneer and the multiple streams from <span class="keep-together">bidders.</span></p>
        
        <figure><div id="ch-component-based-thinking-GGG-final-comps" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_0811.png" alt="" width="1328" height="919">
        <h6><span class="label">Figure 8-11. </span>Incorporating architecture characteristics into GGG component design</h6>
        </div></figure>
        
        <p>The design shown in <a data-type="xref" href="#ch-component-based-thinking-GGG-final-comps">Figure&nbsp;8-11</a> isn’t likely the final design. More requirements must be uncovered (how do people register, administration functions around payment, and so on). However, this example provides a good starting point to start iterating further on the design.</p>
        
        <p>This is one possible set of components to solve the GGG problem—but it’s not necessarily correct, nor is it the only one. Few software systems have only one way that developers can implement them; every design has different sets of trade-offs. As an architect, don’t obsess over finding the one true design, because many will suffice (and less likely overengineered). Rather, try to objectively assess the trade-offs between different design decisions, and choose the one that has the least worst set of trade-offs.<a data-type="indexterm" data-primary="Going, Going, Gone: discovering components case study" data-startref="ix_GGGdccs" id="idm45838979711520"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Architecture Quantum Redux: Choosing Between Monolithic Versus Distributed Architectures"><div class="sect1" id="idm45838979756640">
        <h1>Architecture Quantum Redux: Choosing Between Monolithic Versus Distributed Architectures</h1>
        
        <p>Recalling the discussion defining architecture quantum in <a data-type="xref" href="ch07.html#sec-quantum-def">“Architectural Quanta and Granularity”</a>, the architecture quantum defines <a data-type="indexterm" data-primary="distributed architectures" data-secondary="monolithic architectures versus" data-tertiary="in Going, Going, Gone case study" id="ix_distvmono"></a><a data-type="indexterm" data-primary="monolithic architecture" data-secondary="distributed architecture versus" data-tertiary="in Going, Going, Gone case study" id="ix_monvdist"></a><a data-type="indexterm" data-primary="component-based thinking" data-secondary="choosing between monolithic and distributed architectures in Going, Going, Gone component design" id="ix_cmpthGGGch"></a><a data-type="indexterm" data-primary="architecture quantum" data-secondary="choosing between monolithic and distributed architectures in Going, Going, Gone component design" id="ix_archquanGGGc"></a>the scope of architecture characteristics. That in turn leads an architect toward an important decision as they finish their initial component design: should the architecture be monolithic or <span class="keep-together">distributed?</span></p>
        
        <p>A <em>monolithic</em> architecture typically features a single deployable unit, including all functionality of the system that runs in the process, typically connected to a single database. Types of monolithic architectures include the layered and modular monolith, discussed fully in <a data-type="xref" href="ch10.html#ch-style-layered">Chapter&nbsp;10</a>. A <em>distributed</em> architecture is the opposite—the application consists of multiple services running in their own ecosystem, communicating via networking protocols. Distributed architectures may feature finer-grained deployment models, where each service may have its own release cadence and engineering practices, based on the development team and their priorities.</p>
        
        <p>Each architecture style offers a variety of trade-offs, covered in <a data-type="xref" href="part02.html#part2-styles">Part&nbsp;II</a>. However, the fundamental decision rests on how many quanta the architecture discovers during the design process. If the system can manage with a single quantum (in other words, one set of architecture characteristics), then a monolith architecture offers many advantages. On the other hand, differing architecture characteristics for components, as illustrated in the GGG component analysis, requires a distributed architecture to accommodate differing architecture characteristics. For example, the <code>VideoStreamer</code> and <code>BidStreamer</code> both offer read-only views of the auction to bidders. From a design standpoint, an architect would rather not deal with read-only streaming mixed with high-scale updates. Along with the aforementioned differences between bidder and auctioneer, these differing characteristics lead an architect to choose a distributed architecture.</p>
        
        <p>The ability to determine a fundamental design characteristic of architecture (monolith versus distributed)  early in the design process highlights one of the advantages of using the architecture quantum as a way of analyzing architecture characteristics scope and coupling.<a data-type="indexterm" data-primary="distributed architectures" data-secondary="monolithic architectures versus" data-tertiary="in Going, Going, Gone case study" data-startref="ix_distvmono" id="idm45838979694944"></a><a data-type="indexterm" data-primary="monolithic architecture" data-secondary="distributed architecture versus" data-tertiary="in Going, Going, Gone case study" data-startref="ix_monvdist" id="idm45838979693376"></a><a data-type="indexterm" data-primary="component-based thinking" data-secondary="choosing between monolithic and distributed architectures in Going, Going, Gone component design" data-startref="ix_cmpthGGGch" id="idm45838979691856"></a><a data-type="indexterm" data-primary="architecture quantum" data-secondary="choosing between monolithic and distributed architectures in Going, Going, Gone component design" data-startref="ix_archquanGGGc" id="idm45838979690544"></a><a data-type="indexterm" data-primary="component-based thinking" data-startref="ix_cmpth" id="idm45838979689248"></a></p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492043447/files/epub.css" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-svg.js"></script></div></div></section>
</div>

https://learning.oreilly.com