<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Discovering Domain Knowledge"><div class="chapter" id="discovering_domain_knowledge">
        <h1><span class="label">Chapter 2. </span>Discovering Domain Knowledge</h1>
        <p>In the previous chapter, we spoke about ways of navigating through a company’s business domain. In this chapter, we’ll talk about how to effectively learn from and share the domain experts’ knowledge of the business domain.</p>
        <section data-type="sect1" data-pdf-bookmark="Knowledge Discovery"><div class="sect1" id="knowledge_discovery">
          <h1>Knowledge Discovery</h1>
          <p>The software systems we are building are solutions to business problems. Regarding problems, a wise man once said: </p>
          <blockquote>
            <p>If I had an hour to solve a problem I’d spend 55 minutes thinking about the problem and 5 minutes thinking about solutions. </p>
            <p>—Albert Einstein</p>
          </blockquote>
          <p>The key idea here is that building the right solution requires knowledge of the problem domain. As we discussed in the previous chapter, this knowledge belongs to domain experts: it’s their job to specialize in and comprehend all the intricacies of the business domain. Modeling and building software solutions relies on domain experts sharing this knowledge with software engineers. </p>
          <p>As Alberto Brandolini<sup><a data-type="noteref" id="idm46528345996328-marker" href="ch02.html#idm46528345996328">1</a></sup> says, software development is a learning process; working code is a side effect. Software engineers have no choice but to gain proficiency in the business domain—you have to understand the problem in order to solve it. In this chapter, we are going to explore the tool DDD provides for effective knowledge sharing.</p>
          <section data-type="sect2" data-pdf-bookmark="Communication"><div class="sect2" id="communication">
            <h2>Communication</h2>
            <p>It’s safe to say that almost all software projects require the collaboration of stakeholders in different roles: domain experts, product owners, engineers, UI and UX designers, project managers, testers, analysts, and others. As in any collaborative effort, the outcome depends on how well all those parties can work together. For example, do all stakeholders agree on what problem is being solved? What about the solution they are building—do they hold any conflicting assumptions about its functional and nonfunctional requirements? Agreement and alignment on all project-related matters are essential for a project’s success.</p>
            <p>Research into the reasons why software projects fail has shown that effective communication is essential for knowledge sharing and project success.<sup><a data-type="noteref" id="idm46528345997704-marker" href="ch02.html#idm46528345997704">2</a></sup> Yet despite its importance, effective communication is rarely observed in software projects. Often businesspeople and engineers have no direct interaction with each other. Instead, domain knowledge is pushed down from domain experts to engineers. It is delivered through people playing the role of mediators, or “translators”—systems/business analysts, product owners, and project managers.</p>
            <p>During the traditional software development lifecycle, the domain knowledge is “translated” into an engineer-friendly form known as an <em>analysis model</em>—a description of the system’s requirements, rather than an understanding of the business domain behind it. While the intentions may be good, such mediation is hazardous to knowledge sharing. In any translation, information is lost; in this case, domain knowledge that is essential for solving business problems gets lost on its way to the software engineers. The information loss may lead to the wrong solutions being developed, or the right solutions to the wrong problems—in either case, the outcome is the same: failed software projects.</p>
            <p>Domain-driven design proposes a better way of getting the knowledge from domain experts to software engineers—using a <em>ubiquitous language</em>.</p>
          </div></section>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="What Is Ubiquitous Language?"><div class="sect1" id="what_is_ubiquitous_language">
          <h1>What Is Ubiquitous Language?</h1>
          <p>Using a ubiquitous language is the cornerstone practice of domain-driven design. The idea behind this practice is simple and straightforward: if parties need to communicate efficiently, they have to speak the same language.</p>
          <p>Although this notion is borderline common sense, as Voltaire said, “common sense is not so common.” The traditional software development lifecycle implies the following translations:</p>
          <ol>
            <li>
              <p>Domain knowledge into analysis model</p>
            </li>
            <li>
              <p>Analysis model into requirements</p>
            </li>
            <li>
              <p>Requirements into system design</p>
            </li>
            <li>
              <p>System design into source code</p>
            </li>
          </ol>
          <p>Instead of continuously translating domain knowledge, domain-driven design calls for cultivating a single language for describing the business domain: the ubiquitous language.</p>
          <p>All project-related stakeholders—software engineers, product owners, domain experts, UI/UX designers—should use the ubiquitous language for describing the business domain. Most importantly, domain experts must be comfortable using the ubiquitous language to reason about the business domain; this language will then represent both the business domain and the domain experts’ mental models.</p>
          <p>Only through the continuous use of the ubiquitous language and the grasp of its terms can a shared understanding between all of the project’s stakeholders be cultivated.</p>
          <section data-type="sect2" data-pdf-bookmark="Language of the Business"><div class="sect2" id="language_of_the_business">
            <h2>Language of the Business</h2>
            <p>It’s crucial to emphasize that the ubiquitous language is the language of the business. As such, it should consist of business domain–related terms only. No technical jargon! Your goal is not to teach business domain experts about singletons and abstract factories. The purpose of the ubiquitous language is to frame the domain experts’ understanding and mental models of the business domain in easily understandable terms.</p>
          </div></section>
          <section data-type="sect2" data-pdf-bookmark="Examples"><div class="sect2" id="examples_idjLiPyO">
            <h2>Examples</h2>
            <p>Let’s say we are working on an advertisement campaign management system. Consider the following statements:</p>
            <ul>
              <li>
                <p>An advertising campaign can display different creative <span class="keep-together">materials.</span></p>
              </li>
              <li>
                <p>A campaign can be published only if at least one of its placements is active.</p>
              </li>
              <li>
                <p>Sales commissions are accounted for approved transactions.</p>
              </li>
            </ul>
            <p>All of these statements are formulated in the language of the business. That is, they reflect the domain experts’ view of the business domain.</p>
            <p>On the other hand, the following statements are strictly technical, and thus do <em>not</em> fit the notion of the ubiquitous language:</p>
            <ul>
              <li>
                <p>The advertisement <code>iframe</code> displays an HTML file.</p>
              </li>
              <li>
                <p>A campaign can only be published if it has at least one associated record in the <code>active-placements</code> table.</p>
              </li>
              <li>
                <p>Sales commissions are based on correlated records from the <code>transactions</code> and <code>approved-sales</code> tables.</p>
              </li>
            </ul>
            <p>These statements are purely technical and will be unclear to domain experts. If engineers are only familiar with this technical solution–oriented view of the business domain, they won’t be able to completely understand the business logic or why it operates the way it does, which will limit their ability to model and implement an effective solution.</p>
          </div></section>
          <section data-type="sect2" data-pdf-bookmark="Consistency"><div class="sect2" id="consistency_2">
            <h2>Consistency</h2>
            <p>The ubiquitous language must be precise and consistent. It should eliminate the need for assumptions and make the business domain’s logic explicit.</p>
            <p>Since ambiguity hinders communication, each term of the ubiquitous language should have one and only one meaning. Let’s look at a few examples of unclear terminology and how it can be improved.</p>
            <section data-type="sect3" data-pdf-bookmark="Ambiguous terms "><div class="sect3" id="ambiguous_terms">
              <h3>Ambiguous terms </h3>
              <p>Let’s say that in some business domain, the term “policy” has multiple meanings: it can mean a regulatory rule or an insurance contract. The exact meaning can be worked out in human-to-human interaction, depending on the context. Software, however, doesn’t cope well with ambiguity, and it can be cumbersome and challenging to model the “policy” entity in code. </p>
              <p>Ubiquitous language demands a single meaning for each term, and hence “policy” should be modeled explicitly using the two terms “regulatory rule” and “insurance contract.”</p>
            </div></section>
            <section data-type="sect3" data-pdf-bookmark="Synonymous terms"><div class="sect3" id="synonymous_terms">
              <h3>Synonymous terms</h3>
              <p>Two terms cannot be used interchangeably in a ubiquitous language. For example, many systems use the term “user.” However, a careful examination of the domain experts’ lingo may reveal that “user” and other terms are used interchangeably: for example, “user,” “visitor,” “administrator,” “account,” etc.</p>
              <p>Synonymous terms can seem harmless at first. However, in most cases, they denote different concepts. In this example, both “visitor” and “account” technically refer to the system’s users; however, in the majority of systems unregistered and registered users represent different roles and have different behaviors. As an example, the “visitors” data is used mainly for analysis purposes, whereas “accounts” are actually using the system and its functionality.</p>
              <p>It is preferable to use each term explicitly, in its specific context. An understanding of the differences between the terms in use allows for building simpler and clearer models and implementations of the business domain’s entities.</p>
            </div></section>
          </div></section>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="Model of the Business Domain"><div class="sect1" id="model_of_the_business_domain">
          <h1>Model of the Business Domain</h1>
          <p>Now let’s look at the ubiquitous language from a different perspective: modeling.</p>
          <section data-type="sect2" data-pdf-bookmark="What Is a Model?"><div class="sect2" id="what_is_a_model">
            <h2>What Is a Model?</h2>
            <p>A model is not a copy of the real world, but a human construct that helps us to make sense of real-world systems.</p>
            <p>A canonical example of a model is a map. Any map is a model, including navigation maps, terrain maps, world maps, subway maps, etc. (see <a data-type="xref" href="#fig_2_maps">Figure&nbsp;2-1</a>).</p>
            <figure><div id="fig_2_maps" class="figure">
              <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492057802/files/assets/widd_0201.png" alt="Maps" width="1440" height="678">
              <h6><span class="label">Figure 2-1. </span>Maps</h6>
            </div></figure>
            <p>None of these maps represents all the details of our planet. Instead, each map contains just enough data to support its particular purpose—the problem it is supposed to solve.</p>
          </div></section>
          <section data-type="sect2" data-pdf-bookmark="Effective Modeling"><div class="sect2" id="effective_modeling">
            <h2>Effective Modeling</h2>
            <p>All models have a purpose, and an effective model contains neither more nor less details than are needed to fulfill its purpose. For example, you won’t see subway stops on a world map. On the other hand, you cannot use a subway map to estimate distances. Each map contains just the information it is supposed to provide.</p>
            <p>This point is worth reiterating: a useful model is not a copy of the real world. Instead, a model is intended to solve a problem, and it should provide just enough details for that purpose. Or, as statistician George Box put it, “All models are wrong, but some are useful.”</p>
          </div></section>
          <section data-type="sect2" data-pdf-bookmark="Modeling the Business Domain"><div class="sect2" id="modeling_the_business_domain">
            <h2>Modeling the Business Domain</h2>
            <p>When cultivating a ubiquitous language, we are effectively building a model of the business domain. The language we use is not supposed to cover all the possible details of the business. That would be equivalent to making every stakeholder a domain expert. Instead, the ubiquitous language is supposed to include just enough aspects of the business domain to make it possible to implement the required system. </p>
            <p>The ubiquitous language is a model of the business domain. It reflects the domain experts’ way of reasoning about the problem domain, and in the next chapters, you will see how this model can drive low-level design decisions.</p>
          </div></section>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="Continuous Effort"><div class="sect1" id="continuous_effort">
          <h1>Continuous Effort</h1>
          <p>Formulation of a ubiquitous language requires interaction with its natural holders—domain experts. Only interactions with real domain experts can uncover inaccuracies, wrong assumptions, or an overall flawed understanding of the business domain.</p>
          <p>All stakeholders should consistently use the ubiquitous language in all project-related communications to spread knowledge about and foster a shared understanding of the business domain.</p>
          <p>Once a ubiquitous language is formulated, it should be continuously reinforced throughout the project: requirements, tests, documentation, and even the source code itself should use this language. </p>
          <p>Most importantly, the cultivation of a ubiquitous language is an ongoing process. It should be constantly validated and evolved. Everyday use of the language will over time reveal deeper insights into the business domain. When such breakthroughs happen, the ubiquitous language must evolve to keep pace with the newly acquired domain knowledge.</p>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion_2">
          <h1>Conclusion</h1>
          <p>Ubiquitous language is a cornerstone of domain-driven design. It allows us to share knowledge of the business domain effectively, and it fosters communication between different stakeholders. It should be used throughout the project, in conversations, documentation, tests, diagrams, source code, etc. Additionally, this ubiquitous language should be consistent—no ambiguous and no synonymous terms. </p>
          <p>It’s crucial to continuously evolve the language as new insights into the business domain are discovered.</p>
        </div></section>
      <div data-type="footnotes"><p data-type="footnote" id="idm46528345996328"><sup><a href="ch02.html#idm46528345996328-marker">1</a></sup> Brandolini, Alberto. nd. <a href="https://www.eventstorming.com/book"><em>Introducing EventStorming</em></a>. Leanpub.</p><p data-type="footnote" id="idm46528345997704"><sup><a href="ch02.html#idm46528345997704-marker">2</a></sup> Sudhakar, Goparaju Purna. 2012. “A Model of Critical Success Factors for Software Projects.” <em>Journal of Enterprise Information Management</em> 25 (6): 537–558.<br></p></div></div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492057802/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com