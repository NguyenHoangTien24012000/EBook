<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 9. Evolutionary Design"><div class="chapter" id="evolutionary_design">
        <h1><span class="label">Chapter 9. </span>Evolutionary Design</h1>
        <p>In the modern, fast-paced world we inhabit, companies cannot afford to be lethargic. To keep up with the competition, they have to continually change, evolve, and even reinvent themselves over time. We cannot ignore this fact when designing systems, especially if we intend to design software that’s well adapted to its business domain.</p>
        <p>Even the most sophisticated and thoughtful design will turn into a big ball of mud if it isn’t evolved on par with the changes in its business domain.</p>
        <p>In this chapter, we will discuss how changes in the business domain can affect both strategic and tactical design decisions and how to react to such changes. We will examine three specific vectors of change: changes in subdomains, organizational changes, and evolution of domain knowledge.</p>
        <section data-type="sect1" data-pdf-bookmark="Changes in Subdomains"><div class="sect1" id="changes_in_subdomains">
          <h1>Changes in Subdomains</h1>
          <p>In <a data-type="xref" href="ch02.html#discovering_domain_knowledge">Chapter&nbsp;2</a>, you saw that you have to identify a company’s subdomains to comprehend its business domain. DDD distinguishes three types of subdomains:</p>
          <dl>
            <dt>Core</dt>
            <dd>
              <p>Activities that the company is performing differently from its competitors to gain competitive advantage</p>
            </dd>
            <dt>Supporting</dt>
            <dd>
              <p>Things that the company is doing differently from its competitors, but they do not provide a competitive edge</p>
            </dd>
            <dt>Generic</dt>
            <dd>
              <p>Things that all companies do in the same way</p>
            </dd>
          </dl>
          <p>During a company’s lifetime, it’s not unusual for some of its subdomains to change from one type to another. Let’s look at some examples of such changes.</p>
          <section data-type="sect2" data-pdf-bookmark="Core to Generic"><div class="sect2" id="core_to_generic">
            <h2>Core to Generic</h2>
            <p>Suppose an online retail company—say, “Azamon”—has been implementing its own order delivery solution. It came up with an ingenious algorithm for optimizing its couriers’ paths, and thus was able to provide cheaper delivery prices than its competitors.</p>
            <p>One day, however, another company—“Ureb”—disrupted the delivery industry. It claimed that it had solved the traveling salesman problem, and provided path optimization as a service. Not only was Ureb’s optimization more advanced, but it was also offered at a fraction of the price that it cost Azamon to perform the same task.</p>
            <p>From Azamon’s perspective, once Ureb’s solution became available as an off-the-shelf product, its core subdomain turned into a generic subdomain. The optimal solution became available to all of Azamon’s competitors, and it could no longer provide any competitive advantage.</p>
          </div></section>
          <section data-type="sect2" data-pdf-bookmark="Generic to Core"><div class="sect2" id="generic_to_core">
            <h2>Generic to Core</h2>
            <p>A by-the-book example of a company turning a generic into a core subdomain is Amazon. Amazon, like all service providers, needed an infrastructure on which to run its services. The company was able to “reinvent” the way it managed its physical infrastructure, and later even turned it into a profitable business: Amazon Web <span class="keep-together">Services.</span></p>
          </div></section>
          <section data-type="sect2" data-pdf-bookmark="Supporting to Core"><div class="sect2" id="supporting_to_core">
            <h2>Supporting to Core</h2>
            <p>A supporting subdomain can also turn into a core subdomain—for example, if a company found a way to optimize the supporting logic in such a way that it either reduced costs or generated additional profits.</p>
            <p>The typical symptom of such a transformation is the increasing complexity of the supporting subdomain’s business logic. Supporting subdomains, by definition, are simple, resembling mostly CRUD interfaces or ETL processes. However, if over time the business logic becomes more complicated, there should be a reason for the additional complexity. If it doesn’t affect the company’s profits, why would it become more complicated? If it does enhance the company’s profitability, it’s a sign of a supporting subdomain becoming a core subdomain.</p>
          </div></section>
          <section data-type="sect2" data-pdf-bookmark="Tactical Design Concerns"><div class="sect2" id="tactical_design_concerns">
            <h2>Tactical Design Concerns</h2>
            <p>Another symptom of a change in a subdomain’s type is the inability of the existing technical design to support the current business needs.</p>
            <p>Let’s go back to the example of a supporting subdomain becoming core. Supporting subdomains are implemented with relatively simple design patterns for modeling the business logic—namely, the transaction script or active record patterns. As you saw in <a data-type="xref" href="ch05.html#business_logic_implementation_patterns">Chapter&nbsp;5</a>, these patterns are not a good fit for business logic involving complex rules and invariants.</p>
            <p>If, over time, complicated rules and invariants are added to the business logic, the codebase will become more and more complex as well. It will be painful to add the new functionality, as the design won’t support the new level of complexity. This “pain” is an important signal. Use it as a call for reassessing the business domain and design choices.</p>
            <section data-type="sect3" data-pdf-bookmark="Evolving tactical design"><div class="sect3" id="evolving_tactical_design">
              <h3>Evolving tactical design</h3>
              <p>The need for change in the implementation strategy is nothing to fear. It’s normal. We cannot foresee how a business will evolve down the road. We also cannot apply the most elaborate design patterns for all types of subdomains—that would be wasteful and ineffective. We have to choose the most appropriate design and evolve it when needed.</p>
              <p>If the decision of how to model the business logic is made consciously, and you are aware of all the possible design choices and the differences between them, migrating from one design pattern to another is not that troublesome. Here are a few examples:</p>
              <dl>
                <dt>Transaction script to active record</dt>
                <dd>
                  <p>Look for complicated data structures and encapsulate them in active record objects. Instead of accessing the database directly, use active records to abstract its model and structure.</p>
                </dd>
                <dt>Active record to domain model</dt>
                <dd>
                  <p>Start by identifying value objects. What data structures can be modeled as immutable objects? Look for the related business logic, and make it a part of the value objects as well.</p>
                </dd>
                <dd>
                  <p>Next, analyze the data structures and look for transactional boundaries. What hierarchies are needed to ensure strongly consistent checking of business rules and invariants? Those are good candidates for aggregates. Finally, for each aggregate, identify its root—the entry point for its public interface.</p>
                </dd>
                <dt>Domain model to event-sourced domain model</dt>
                <dd>
                  <p>Once you have a domain model with properly designed aggregate boundaries, it can be naturally transitioned to the event-sourced model. Just model the domain events needed to represent the aggregate’s lifecycle.</p>
                </dd>
              </dl>
            </div></section>
          </div></section>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="Organizational Changes"><div class="sect1" id="organizational_changes">
          <h1>Organizational Changes</h1>
          <p>Another type of change that can affect a system’s design is change in the organization itself. In <a data-type="xref" href="ch05.html#business_logic_implementation_patterns">Chapter&nbsp;5</a>, we looked at different patterns of integrating bounded contexts: partnership, shared kernel, conformist, anticorruption layer, open-host service, and separate ways. Organizational changes can affect teams’ communication and collaboration levels and, as a result, the ways bounded contexts can be integrated.</p>
          <p>A trivial example of such change is growing development centers. To accommodate evolving business needs, development centers grow and often are expanded to different geographical locations. Let’s see how this may cause integration patterns to evolve as well:</p>
          <dl>
            <dt>Shared kernel to partnership</dt>
            <dd>
              <p>As we’ve seen, the shared kernel pattern suits cases where multiple bounded contexts are implemented by the same team. As the organization grows, the work on those bounded contexts might get distributed across different teams. If the new team structure supports cooperation and collaboration between the teams, it makes sense to move away from the shared kernel to the partnership pattern.</p>
            </dd>
            <dt>Partnership to customer–supplier</dt>
            <dd>
              <p>The partnership pattern assumes that there is strong communication and collaboration between teams. As time goes by, that might cease to be the case—for example, when work on one of the bounded contexts is moved to a distant development center. Such a change will negatively affect the teams’ communication, and it may make sense to move away from the partnership pattern toward a customer–supplier relationship.</p>
            </dd>
            <dt>Customer–supplier to separate ways</dt>
            <dd>
              <p>Unfortunately, it’s not uncommon for teams to have severe communication problems. The issues might be caused by geographical distance or organizational politics. Such teams may experience more and more integration issues over time. At some point, it may become more cost-effective to duplicate the functionality, instead of continuously chasing each other’s tails.</p>
            </dd>
            <dt>Separate ways to partnership or customer–supplier</dt>
            <dd>
              <p>As you saw earlier, teams can go separate ways for supporting and generic subdomains (business-wise, it wouldn’t make sense to duplicate the functionality of a core subdomain). Earlier in this chapter, you also saw how both supporting and generic subdomains can evolve into core subdomains. If the evolved subdomain’s functionality has been duplicated by multiple teams, they have no choice but to integrate their implementations. The customer–supplier relationship will typically make the most sense, since the core subdomain will be implemented by one team only.</p>
            </dd>
          </dl>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="Domain Knowledge"><div class="sect1" id="domain_knowledge">
          <h1>Domain Knowledge</h1>
          <p>The core tenet of domain-driven design is that <em>domain knowledge is essential for the design of a solution</em>. Acquiring domain knowledge is one of the most challenging aspects of software engineering—especially for the core subdomains, where the logic not only is complicated but is also expected to change often.</p>
          <p>Uncertainty of domain knowledge imposes risks, especially in strategic design. The cost of decomposing a system into bounded contexts that over time turn out to be incorrect can be high.</p>
          <p>Therefore, when the domain logic is unclear and changes often, it makes sense to design bounded contexts with wide boundaries. Then, as domain knowledge is discovered over time and the amount of changes to the business logic stabilizes, those wide bounded contexts can be decomposed into contexts with narrower boundaries—i.e., microservices.</p>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="Conclusion"><div class="sect1" id="conclusion_9">
          <h1>Conclusion</h1>
          <p>As Heraclitus famously said, the only thing that is constant is change. Businesses are no exception. To stay competitive, companies constantly strive to evolve and reinvent themselves. Those changes should be treated as first-class elements of the design process.</p>
          <p>As the business domain evolves, changes to its subdomains have to be identified and acted upon in the system’s design. It’s also important to recognize that changes in the organizational structure can affect communication and cooperation between teams and the ways their bounded contexts can be integrated.</p>
          <p>Finally, learning about the business domain is an ongoing process. As more domain knowledge is discovered over time, it makes certain design decisions less risky—e.g., decomposing wide bounded contexts into microservices.</p>
        </div></section>
      </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492057802/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com