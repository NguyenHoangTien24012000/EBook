<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Data Models and Query Languages"><div class="chapter" id="ch_datamodels">
        <h1><span class="label">Chapter 2. </span>Data Models and Query Languages</h1>
        
        <blockquote data-type="epigraph" epub:type="epigraph">
          <p><em>The limits of my language mean the limits of my world.</em></p>
          <p data-type="attribution">Ludwig Wittgenstein, <em>Tractatus Logico-Philosophicus</em> (1922)</p>
        </blockquote>
        
        <div class="map-ebook">
          <img id="c268" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/ch02-map-ebook.png" width="2756" height="2100">
        </div>
        
        <p><a data-type="indexterm" data-primary="data models" id="ix_datamod"></a>
        Data models are perhaps the most important part of developing software, because they have such a
        profound effect: not only on how the software is written, but also on how we <em>think about the problem</em>
        that we are solving.</p>
        
        <p>Most applications are built by layering one data model on top of another. For each layer, the key
        question is: how is it <em>represented</em> in terms of the next-lower layer? For example:</p>
        <ol>
        <li>
        <p><a data-type="indexterm" data-primary="Application Programming Interfaces (APIs)" id="idm45085119001520"></a>
        As an application developer, you look at the real world (in which there are people,
        organizations, goods, actions, money flows, sensors, etc.) and model it in terms of objects or
        data structures, and APIs that manipulate those data structures. Those structures are often
        specific to your application.</p>
        </li>
        <li>
        <p>When you want to store those data structures, you express them in terms of a general-purpose
        data model, such as JSON or XML documents, tables in a relational database, or a graph model.</p>
        </li>
        <li>
        <p>The engineers who built your database software decided on a way of representing that
        JSON/XML/relational/graph data in terms of bytes in memory, on disk, or on a network. The
        representation may allow the data to be queried, searched, manipulated, and processed in various
        ways.</p>
        </li>
        <li>
        <p>On yet lower levels, hardware engineers have figured out how to represent bytes in terms of
        electrical currents, pulses of light, magnetic fields, and more.</p>
        </li>
        
        </ol>
        
        <p><a data-type="indexterm" data-primary="abstraction" id="idm45085118996496"></a>
        <a data-type="indexterm" data-primary="complexity" data-secondary="hiding using abstraction" id="idm45085118995664"></a>
        In a complex application there may be more intermediary levels, such as APIs built upon APIs, but
        the basic idea is still the same: each layer hides the complexity of the layers below it by
        providing a clean data model. These abstractions allow different groups of people—for example,
        the engineers at the database vendor and the application developers using their database—to work
        together effectively.</p>
        
        <p>There are many different kinds of data models, and every data model embodies assumptions about how
        it is going to be used. Some kinds of usage are easy and some are not supported; some operations are
        fast and some perform badly; some data transformations feel natural and some are awkward.</p>
        
        <p>It can take a lot of effort to master just one data model (think how many books there are on
        relational data modeling). Building software is hard enough, even when working with just one data
        model and without worrying about its inner workings. But since the data model has such a profound
        effect on what the software above it can and can’t do, it’s important to choose one that is
        appropriate to the application.</p>
        
        <p>In this chapter we will look at a range of general-purpose data models for data storage and
        querying (point 2 in the preceding list). In particular, we will compare the relational model,
        the document model, and a few graph-based data models. We will also look at various query languages
        and compare their use cases. In <a data-type="xref" href="ch03.html#ch_storage">Chapter&nbsp;3</a> we will discuss how storage engines work; that is,
        how these data models are actually implemented (point 3 in the list).</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Relational Model Versus Document Model"><div class="sect1" id="sec_datamodels_history">
        <h1>Relational Model Versus Document Model</h1>
        
        <p><a data-type="indexterm" data-primary="data models" data-secondary="relational model versus document model" id="ix_DMreldoc"></a>
        <a data-type="indexterm" data-primary="relational data model" id="ix_relationmod"></a>
        <a data-type="indexterm" data-primary="SQL (Structured Query Language)" id="idm45085118986256"></a>
        The best-known data model today is probably that of SQL, based on the relational model proposed by
        Edgar Codd in 1970 [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Codd1970dg-marker" href="ch02.html#Codd1970dg">1</a>]:
        data is organized into <em>relations</em> (called <em>tables</em> in SQL), where each relation is an unordered collection
        of <em>tuples</em> (<em>rows</em> in SQL).</p>
        
        <p><a data-type="indexterm" data-primary="relational databases" data-secondary="history" id="idm45085118980608"></a>
        The relational model was a theoretical proposal, and many people at the time doubted whether it
        could be implemented efficiently. However, by the mid-1980s, relational database management systems
        (RDBMSes) and SQL had become the tools of choice for most people who needed to store and query data
        with some kind of regular structure. The dominance of relational databases has lasted around
        25‒30 years—an eternity in computing history.</p>
        
        <p><a data-type="indexterm" data-primary="business data processing" id="idm45085118978800"></a>
        <a data-type="indexterm" data-primary="batch processing" id="idm45085118977808"></a>
        <a data-type="indexterm" data-primary="transaction processing" id="idm45085118976944"></a>
        The roots of relational databases lie in <em>business data processing</em>, which was performed on
        mainframe computers in the 1960s and ’70s. The use cases appear mundane from today’s perspective:
        typically <em>transaction processing</em> (entering sales or banking transactions, airline reservations,
        stock-keeping in warehouses) and <em>batch processing</em> (customer invoicing, payroll, reporting).</p>
        
        <p>Other databases at that time forced application developers to think a lot about the internal
        representation of the data in the database. The goal of the relational model was to hide that
        implementation detail behind a cleaner interface.</p>
        
        <p>Over the years, there have been many competing approaches to data storage and querying. In the 1970s
        and early 1980s, the <em>network model</em> and the <em>hierarchical model</em> were the main alternatives, but
        the relational model came to dominate them. Object databases came and went again in the late 1980s
        and early 1990s. XML databases appeared in the early 2000s, but have only seen niche adoption. Each
        competitor to the relational model generated a lot of hype in its time, but it never lasted
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Stonebraker2005wv-marker" href="ch02.html#Stonebraker2005wv">2</a>].</p>
        
        <p>As computers became vastly more powerful and networked, they started being used for increasingly
        diverse purposes. And remarkably, relational databases turned out to generalize very well, beyond
        their original scope of business data processing, to a broad variety of use cases. Much of what you
        see on the web today is still powered by relational databases, be it online publishing,
        discussion, social networking, ecommerce, games, software-as-a-service productivity applications,
        or much more.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="The Birth of NoSQL"><div class="sect2" id="idm45085118969056">
        <h2>The Birth of NoSQL</h2>
        
        <p><a data-type="indexterm" data-primary="relational data model" data-secondary="NoSQL as alternative to" id="idm45085118967616"></a>
        <a data-type="indexterm" data-primary="NoSQL" id="idm45085118966352"></a>
        Now, in the 2010s, <em>NoSQL</em> is the latest attempt to overthrow the relational model’s dominance. The
        name “NoSQL” is unfortunate, since it doesn’t actually refer to any particular technology—it was
        originally intended simply as a catchy Twitter hashtag for a meetup on open source, distributed, nonrelational
        databases in 2009 [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="nosql-distilled-marker" href="ch02.html#nosql-distilled">3</a>]. Nevertheless, the term struck a nerve and quickly spread through the
        web startup community and beyond. A number of interesting database systems are now associated with
        the #NoSQL hashtag, and it has been retroactively reinterpreted as <em>Not Only SQL</em>
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Evans2009tc-marker" href="ch02.html#Evans2009tc">4</a>].</p>
        
        <p>There are several driving forces behind the adoption of NoSQL databases, including:</p>
        
        <ul>
        <li>
        <p>A need for greater scalability than relational databases can easily achieve, including very large
        datasets or very high write throughput</p>
        </li>
        <li>
        <p>A widespread preference for free and open source software over commercial database products</p>
        </li>
        <li>
        <p>Specialized query operations that are not well supported by the relational model</p>
        </li>
        <li>
        <p>Frustration with the restrictiveness of relational schemas, and a desire for a more dynamic and
        expressive data model [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Phillips2012we-marker" href="ch02.html#Phillips2012we">5</a>]</p>
        </li>
        </ul>
        
        <p><a data-type="indexterm" data-primary="polyglot persistence" id="idm45085118953040"></a>
        Different applications have different requirements, and the best choice of technology for one use
        case may well be different from the best choice for another use case. It therefore seems likely that
        in the foreseeable future, relational databases will continue to be used alongside a broad variety
        of nonrelational datastores—an idea that is sometimes called <em>polyglot persistence</em>
        [<a data-type="noteref" href="ch02.html#nosql-distilled">3</a>].</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="The Object-Relational Mismatch"><div class="sect2" id="sec_datamodels_document">
        <h2>The Object-Relational Mismatch</h2>
        
        <p><a data-type="indexterm" data-primary="object-relational mismatch" id="idm45085118948608"></a>
        <a data-type="indexterm" data-primary="relational data model" data-secondary="object-relational mismatch" id="idm45085118947712"></a>
        <a data-type="indexterm" data-primary="impedance mismatch" id="idm45085118946592"></a>
        Most application development today is done in object-oriented programming languages, which leads to
        a common criticism of the SQL data model: if data is stored in relational tables, an awkward
        translation layer is required between the objects in the application code and the database model of
        tables, rows, and columns. The disconnect between the models is sometimes called an
        <em>impedance mismatch</em>.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm45085118944976-marker" href="ch02.html#idm45085118944976">i</a></sup></p>
        
        <p><a data-type="indexterm" data-primary="object-relational mapping (ORM) frameworks" id="idm45085118943440"></a>
        <a data-type="indexterm" data-primary="ActiveRecord (object-relational mapper)" id="idm45085118942576"></a>
        <a data-type="indexterm" data-primary="Hibernate (object-relational mapper)" id="idm45085118941728"></a>
        Object-relational mapping (ORM) frameworks like ActiveRecord and Hibernate reduce the amount of
        boilerplate code required for this translation layer, but they can’t completely hide the differences
        between the two models.</p>
        
        <p><a data-type="indexterm" data-primary="one-to-many relationships" id="idm45085118940384"></a>
        <a data-type="indexterm" data-primary="SQL (Structured Query Language)" data-secondary="résumé (example)" id="idm45085118939392"></a>
        <a data-type="indexterm" data-primary="LinkedIn" data-secondary="profile (example)" id="idm45085118938320"></a>
        For example, <a data-type="xref" href="#fig_billgates_relational">Figure&nbsp;2-1</a> illustrates how a résumé (a LinkedIn profile) could be
        expressed in a relational schema. The profile as a whole can be identified by a unique identifier,
        <code>user_id</code>. Fields like <code>first_name</code> and <code>last_name</code> appear exactly once per user, so they can be
        modeled as columns on the <code>users</code> table. However, most people have had more than one job in their
        career (positions), and people may have varying numbers of periods of education and any number of
        pieces of contact information. There is a one-to-many relationship from the user to these items,
        which can be represented in various ways:</p>
        
        <ul>
        <li>
        <p>In the traditional SQL model (prior to SQL:1999), the most common normalized representation is to
        put positions, education, and contact information in separate tables, with a foreign key reference
        to the <code>users</code> table, as in <a data-type="xref" href="#fig_billgates_relational">Figure&nbsp;2-1</a>.</p>
        </li>
        <li>
        <p><a data-type="indexterm" data-primary="JSON" data-secondary="in relational databases" id="idm45085118931040"></a>
        <a data-type="indexterm" data-primary="XML" data-secondary="in relational databases" id="idm45085118929744"></a>
        <a data-type="indexterm" data-primary="Oracle (database)" data-secondary="XML support" id="idm45085118928640"></a>
        <a data-type="indexterm" data-primary="IBM" data-secondary="DB2 (database)" data-tertiary="XML and JSON support" id="idm45085118927536"></a>
        <a data-type="indexterm" data-primary="SQL Server (database)" data-secondary="XML support" id="idm45085118926160"></a>
        <a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="XML and JSON support" id="idm45085118925056"></a>
        <a data-type="indexterm" data-primary="MySQL (database)" data-secondary="JSON support" id="idm45085118923952"></a>
        Later versions of the SQL standard added support for structured datatypes and XML data;
        this allowed multi-valued data to be stored within a single row, with support for querying and
        indexing inside those documents. These features are supported to varying degrees by Oracle, IBM
        DB2, MS SQL Server, and PostgreSQL [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Wagner2010wc-marker" href="ch02.html#Wagner2010wc">6</a>,
        <a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="SQLServer2013-marker" href="ch02.html#SQLServer2013">7</a>].
        A JSON datatype is also supported by several databases, including IBM DB2, MySQL, and PostgreSQL
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="PostgreSQL2013-marker" href="ch02.html#PostgreSQL2013">8</a>].</p>
        </li>
        <li>
        <p><a data-type="indexterm" data-primary="document data model" id="ix_docdata"></a>
        A third option is to encode jobs, education, and contact info as a JSON or XML document, store it on a text column
        in the database, and let the application interpret its structure and content. In this setup,
        you typically cannot use the database to query for values inside that encoded column.</p>
        </li>
        </ul>
        
        <figure><div id="fig_billgates_relational" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/ddia_0201.png" alt="ddia 0201" width="2880" height="2607">
        <h6><span class="label">Figure 2-1. </span>Representing a LinkedIn profile using a relational schema. Photo of Bill Gates courtesy of Wikimedia Commons, Ricardo Stuckert, Agência Brasil.</h6>
        </div></figure>
        
        <p><a data-type="indexterm" data-primary="JSON" data-secondary="representing a résumé (example)" id="idm45085118912480"></a>
        <a data-type="indexterm" data-primary="MongoDB (database)" data-secondary="document data model" id="idm45085118910960"></a>
        <a data-type="indexterm" data-primary="CouchDB (database)" data-secondary="document data model" id="idm45085118909856"></a><a data-type="indexterm" data-primary="Apache CouchDB" data-see="CouchDB" id="idm45085118908880"></a>
        <a data-type="indexterm" data-primary="RethinkDB (database)" data-secondary="document data model" id="idm45085118907808"></a>
        <a data-type="indexterm" data-primary="LinkedIn" data-secondary="Espresso (database)" id="idm45085118906704"></a>
        <a data-type="indexterm" data-primary="document data model" data-secondary="document-oriented databases" id="idm45085118905600"></a>
        For a data structure like a résumé, which is mostly a self-contained <em>document</em>, a JSON
        representation can be quite appropriate: see <a data-type="xref" href="#fig_billgates_json">Example&nbsp;2-1</a>. JSON has the appeal of being
        much simpler than XML. Document-oriented databases like MongoDB
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="MongoDB2013-marker" href="ch02.html#MongoDB2013">9</a>],
        RethinkDB
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="RethinkDB2013-marker" href="ch02.html#RethinkDB2013">10</a>],
        CouchDB
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="CouchDB2014_ch2-marker" href="ch02.html#CouchDB2014_ch2">11</a>],
        and Espresso
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Qiao2013uv_ch2-marker" href="ch02.html#Qiao2013uv_ch2">12</a>]
        support this data model.</p>
        <div id="fig_billgates_json" data-type="example">
        <h5><span class="label">Example 2-1. </span>Representing a LinkedIn profile as a JSON document</h5>
        
        <pre data-type="programlisting" data-code-language="json"><code class="p">{</code>
          <code class="nt">"user_id"</code><code class="p">:</code>     <code class="mi">251</code><code class="p">,</code>
          <code class="nt">"first_name"</code><code class="p">:</code>  <code class="s2">"Bill"</code><code class="p">,</code>
          <code class="nt">"last_name"</code><code class="p">:</code>   <code class="s2">"Gates"</code><code class="p">,</code>
          <code class="nt">"summary"</code><code class="p">:</code>     <code class="s2">"Co-chair of the Bill &amp; Melinda Gates... Active blogger."</code><code class="p">,</code>
          <code class="nt">"region_id"</code><code class="p">:</code>   <code class="s2">"us:91"</code><code class="p">,</code>
          <code class="nt">"industry_id"</code><code class="p">:</code> <code class="mi">131</code><code class="p">,</code>
          <code class="nt">"photo_url"</code><code class="p">:</code>   <code class="s2">"/p/7/000/253/05b/308dd6e.jpg"</code><code class="p">,</code>
          <code class="nt">"positions"</code><code class="p">:</code> <code class="p">[</code>
            <code class="p">{</code><code class="nt">"job_title"</code><code class="p">:</code> <code class="s2">"Co-chair"</code><code class="p">,</code> <code class="nt">"organization"</code><code class="p">:</code> <code class="s2">"Bill &amp; Melinda Gates Foundation"</code><code class="p">},</code>
            <code class="p">{</code><code class="nt">"job_title"</code><code class="p">:</code> <code class="s2">"Co-founder, Chairman"</code><code class="p">,</code> <code class="nt">"organization"</code><code class="p">:</code> <code class="s2">"Microsoft"</code><code class="p">}</code>
          <code class="p">],</code>
          <code class="nt">"education"</code><code class="p">:</code> <code class="p">[</code>
            <code class="p">{</code><code class="nt">"school_name"</code><code class="p">:</code> <code class="s2">"Harvard University"</code><code class="p">,</code>       <code class="nt">"start"</code><code class="p">:</code> <code class="mi">1973</code><code class="p">,</code> <code class="nt">"end"</code><code class="p">:</code> <code class="mi">1975</code><code class="p">},</code>
            <code class="p">{</code><code class="nt">"school_name"</code><code class="p">:</code> <code class="s2">"Lakeside School, Seattle"</code><code class="p">,</code> <code class="nt">"start"</code><code class="p">:</code> <code class="kc">null</code><code class="p">,</code> <code class="nt">"end"</code><code class="p">:</code> <code class="kc">null</code><code class="p">}</code>
          <code class="p">],</code>
          <code class="nt">"contact_info"</code><code class="p">:</code> <code class="p">{</code>
            <code class="nt">"blog"</code><code class="p">:</code>    <code class="s2">"https://www.gatesnotes.com/"</code><code class="p">,</code>
            <code class="nt">"twitter"</code><code class="p">:</code> <code class="s2">"https://twitter.com/BillGates"</code>
          <code class="p">}</code>
        <code class="p">}</code></pre></div>
        
        <p>Some developers feel that the JSON model reduces the impedance mismatch between the application code
        and the storage layer. However, as we shall see in <a data-type="xref" href="ch04.html#ch_encoding">Chapter&nbsp;4</a>, there are also problems with
        JSON as a data encoding format. The lack of a schema is often cited as an advantage; we will discuss
        this in <a data-type="xref" href="#sec_datamodels_schema_flexibility">“Schema flexibility in the document model”</a>.</p>
        
        <p><a data-type="indexterm" data-primary="locality (data access)" id="idm45085125431408"></a>
        The JSON representation has better <em>locality</em> than the multi-table schema in
        <a data-type="xref" href="#fig_billgates_relational">Figure&nbsp;2-1</a>. If you want to fetch a profile in the relational example, you need to
        either perform multiple queries (query each table by <code>user_id</code>) or perform a messy multi-way join
        between the <code>users</code> table and its subordinate tables. In the JSON representation, all the relevant
        information is in one place, and one query is sufficient.</p>
        
        <p><a data-type="indexterm" data-primary="one-to-many relationships" data-secondary="JSON representation" id="idm45085125427888"></a>
        The one-to-many relationships from the user profile to the user’s positions, educational history, and
        contact information imply a tree structure in the data, and the JSON representation makes this tree
        structure explicit (see <a data-type="xref" href="#fig_json_tree">Figure&nbsp;2-2</a>).</p>
        
        <figure><div id="fig_json_tree" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/ddia_0202.png" alt="ddia 0202" width="2880" height="1268">
        <h6><span class="label">Figure 2-2. </span>One-to-many relationships forming a tree structure.</h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Many-to-One and Many-to-Many Relationships"><div class="sect2" id="sec_datamodels_many_to_many">
        <h2>Many-to-One and Many-to-Many Relationships</h2>
        
        <p>In <a data-type="xref" href="#fig_billgates_json">Example&nbsp;2-1</a> in the preceding section, <code>region_id</code> and <code>industry_id</code> are given as IDs,
        not as plain-text strings <code>"Greater Seattle Area"</code> and <code>"Philanthropy"</code>. Why?</p>
        
        <p><a data-type="indexterm" data-primary="many-to-one and many-to-many relationships" id="ix_manyrel"></a>
        <a data-type="indexterm" data-primary="relational data model" data-secondary="many-to-one and many-to-many relationships" id="idm45085125405408"></a>
        If the user interface has free-text fields for entering the region and the industry, it makes sense
        to store them as plain-text strings. But there are advantages to having standardized lists of
        geographic regions and industries, and letting users choose from a drop-down list or autocompleter:</p>
        
        <ul>
        <li>
        <p>Consistent style and spelling across profiles</p>
        </li>
        <li>
        <p>Avoiding ambiguity (e.g., if there are several cities with the same name)</p>
        </li>
        <li>
        <p>Ease of updating—the name is stored in only one place, so it is easy to update across the board if
        it ever needs to be changed (e.g., change of a city name due to political events)</p>
        </li>
        <li>
        <p>Localization support—when the site is translated into other languages, the standardized lists can
        be localized, so the region and industry can be displayed in the viewer’s language</p>
        </li>
        <li>
        <p>Better search—e.g., a search for philanthropists in the state of Washington can match
        this profile, because the list of regions can encode the fact that Seattle is in Washington (which
        is not apparent from the string <code>"Greater Seattle Area"</code>)</p>
        </li>
        </ul>
        
        <p>Whether you store an ID or a text string is a question of duplication. When you use an ID, the
        information that is meaningful to humans (such as the word <em>Philanthropy</em>) is stored in only one
        place, and everything that refers to it uses an ID (which only has meaning within the database).
        When you store the text directly, you are duplicating the human-meaningful information in every
        record that uses it.</p>
        
        <p><a data-type="indexterm" data-primary="normalization (data representation)" id="idm45085125396560"></a>
        The advantage of using an ID is that because it has no meaning to humans, it never needs to change:
        the ID can remain the same, even if the information it identifies changes. Anything that is
        meaningful to humans may need to change sometime in the future—and if that information is duplicated,
        all the redundant copies need to be updated. That incurs write overheads, and risks
        inconsistencies (where some copies of the information are updated but others aren’t). Removing such
        duplication is the key idea behind <em>normalization</em> in
        databases.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm45085125394752-marker" href="ch02.html#idm45085125394752">ii</a></sup></p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><a data-type="indexterm" data-primary="denormalization (data representation)" id="idm45085125392768"></a>
        Database administrators and developers love to argue about normalization and denormalization, but
        we will suspend judgment for now. In <a data-type="xref" href="part03.html#part_systems">Part&nbsp;III</a> of this book we will return to this topic and
        explore systematic ways of dealing with caching, denormalization, and derived data.</p>
        </div>
        
        <p><a data-type="indexterm" data-primary="many-to-one relationships" id="idm45085125390432"></a>
        <a data-type="indexterm" data-primary="joins" data-secondary="in relational and document databases" id="idm45085125389440"></a>
        <a data-type="indexterm" data-primary="CouchDB (database)" data-secondary="join support" id="idm45085125388368"></a>
        <a data-type="indexterm" data-primary="MongoDB (database)" data-secondary="lack of join support" id="idm45085125387264"></a>
        <a data-type="indexterm" data-primary="RethinkDB (database)" data-secondary="join support" id="idm45085125386160"></a>
        Unfortunately, normalizing this data requires <em>many-to-one</em> relationships (many people live in one
        particular region, many people work in one particular industry), which don’t fit nicely into the
        document model. In relational databases, it’s normal to refer to rows in other tables by ID, because
        joins are easy. In document databases, joins are not needed for one-to-many tree structures, and
        support for joins is often weak.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm45085125384224-marker" href="ch02.html#idm45085125384224">iii</a></sup></p>
        
        <p>If the database itself does not support joins, you have to emulate a join in application code by
        making multiple queries to the database. (In this case, the lists of regions and industries are
        probably small and slow-changing enough that the application can simply keep them in memory. But
        nevertheless, the work of making the join is shifted from the database to the application code.)</p>
        
        <p>Moreover, even if the initial version of an application fits well in a join-free document model,
        data has a tendency of becoming more interconnected as features are added to applications. For
        example, consider some changes we could make to the résumé example:</p>
        <dl>
        <dt>Organizations and schools as entities</dt>
        <dd>
        <p>In the previous description, <code>organization</code> (the company where the user worked) and <code>school_name</code>
        (where they studied) are just strings. Perhaps they should be references to entities instead?
        <a data-type="indexterm" data-primary="LinkedIn" data-secondary="reference to company entity (example)" id="idm45085125379424"></a>
        Then each organization, school, or university could have its own web page (with logo, news feed,
        etc.); each résumé could link to the organizations and schools that it mentions, and include their
        logos and other information (see <a data-type="xref" href="#fig_datamodels_linked_entity">Figure&nbsp;2-3</a> for an example from LinkedIn).</p>
        </dd>
        <dt>Recommendations</dt>
        <dd>
        <p>Say you want to add a new feature: one user can write a recommendation for another user. The
        recommendation is shown on the résumé of the user who was recommended, together with the name and
        photo of the user making the recommendation. If the recommender updates their photo, any
        recommendations they have written need to reflect the new photo. Therefore, the recommendation
        should have a reference to the author’s profile.</p>
        </dd>
        </dl>
        
        <figure class="width-50"><div id="fig_datamodels_linked_entity" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/ddia_0203.png" alt="ddia 0203" width="1009" height="834">
        <h6><span class="label">Figure 2-3. </span>The company name is not just a string, but a link to a company entity. Screenshot of linkedin.com.</h6>
        </div></figure>
        
        <p><a data-type="xref" href="#fig_datamodels_many_to_many">Figure&nbsp;2-4</a> illustrates how these new features require many-to-many
        relationships. The data within each dotted rectangle can be grouped into one document, but the
        references to organizations, schools, and other users need to be represented as references, and
        require joins when queried.</p>
        
        <figure><div id="fig_datamodels_many_to_many" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/ddia_0204.png" alt="ddia 0204" width="2880" height="1967">
        <h6><span class="label">Figure 2-4. </span>Extending résumés with many-to-many relationships.</h6>
        </div></figure>
        
        <p><a data-type="indexterm" data-primary="many-to-one and many-to-many relationships" data-startref="ix_manyrel" id="idm45085125369056"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Are Document Databases Repeating History?"><div class="sect2" id="sec_datamodels_codasyl">
        <h2>Are Document Databases Repeating History?</h2>
        
        <p><a data-type="indexterm" data-primary="document data model" data-secondary="many-to-many relationships and joins" id="idm45085125366176"></a>
        While many-to-many relationships and joins are routinely used in relational databases, document
        databases and NoSQL reopened the debate on how best to represent such relationships in a database.
        This debate is much older than NoSQL—in fact, it goes back to the very earliest computerized
        database systems.</p>
        
        <p><a data-type="indexterm" data-primary="IBM" data-secondary="IMS (database)" id="idm45085125364480"></a><a data-type="indexterm" data-primary="rockets" id="idm45085125363504"></a>
        The most popular database for business data processing in the 1970s was IBM’s <em>Information
        Management System</em> (IMS), originally developed for stock-keeping in the Apollo
        space program and first commercially released in 1968
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Long2000wy-marker" href="ch02.html#Long2000wy">13</a>].
        It is still in use and maintained today, running on OS/390 on IBM mainframes
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Bartlett2013uo-marker" href="ch02.html#Bartlett2013uo">14</a>].</p>
        
        <p><a data-type="indexterm" data-primary="hierarchical model" id="idm45085125358416"></a>
        The design of IMS used a fairly simple data model called the <em>hierarchical model</em>, which has some
        remarkable similarities to the JSON model used by document databases
        [<a data-type="noteref" href="ch02.html#Stonebraker2005wv">2</a>]. It represented all data as a tree
        of records nested within records, much like the JSON structure of <a data-type="xref" href="#fig_json_tree">Figure&nbsp;2-2</a>.</p>
        
        <p>Like document databases, IMS worked well for one-to-many relationships, but it made many-to-many
        relationships difficult, and it didn’t support joins. Developers had to decide whether to duplicate
        (denormalize) data or to manually resolve references from one record to another. These problems of
        the 1960s and ’70s were very much like the problems that developers are running into with document databases
        today [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Mei2013vz-marker" href="ch02.html#Mei2013vz">15</a>].</p>
        
        <p>Various solutions were proposed to solve the limitations of the hierarchical model. The two most
        prominent were the <em>relational model</em> (which became SQL, and took over the world) and the <em>network
        model</em> (which initially had a large following but eventually faded into obscurity). The “great
        debate” between these two camps lasted for much of the 1970s
        [<a data-type="noteref" href="ch02.html#Stonebraker2005wv">2</a>].</p>
        
        <p>Since the problem that the two models were solving is still so relevant today, it’s worth briefly
        revisiting this debate in today’s light.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="The network model"><div class="sect3" id="idm45085125349312">
        <h3>The network model</h3>
        
        <p><a data-type="indexterm" data-primary="network model" id="idm45085125347872"></a>
        <a data-type="indexterm" data-primary="CODASYL model" data-seealso="network model" id="idm45085125347040"></a>
        The network model was standardized by a committee called the Conference on Data Systems Languages
        (CODASYL) and implemented by several different database vendors; it is also known as the
        <em>CODASYL model</em> [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Knowles1984tm-marker" href="ch02.html#Knowles1984tm">16</a>].</p>
        
        <p>The CODASYL model was a generalization of the hierarchical model. In the tree structure of the
        hierarchical model, every record has exactly one parent; in the network model, a record could have
        multiple parents. For example, there could be one record for the <code>"Greater Seattle Area"</code> region,
        and every user who lived in that region could be linked to it. This allowed many-to-one and
        many-to-many relationships to be modeled.</p>
        
        <p><a data-type="indexterm" data-primary="access path (in network model)" id="idm45085125342272"></a>
        The links between records in the network model were not foreign keys, but more like pointers in a
        programming language (while still being stored on disk). The only way of accessing a record was to
        follow a path from a root record along these chains of links. This was called an <em>access path</em>.</p>
        
        <p>In the simplest case, an access path could be like the traversal of a linked list: start at the head
        of the list, and look at one record at a time until you find the one you want. But in a world of
        many-to-many relationships, several different paths can lead to the same record, and a programmer
        working with the network model had to keep track of these different access paths in their head.</p>
        
        <p>A query in CODASYL was performed by moving a cursor through the database by iterating over lists of
        records and following access paths. If a record had multiple parents (i.e., multiple incoming
        pointers from other records), the application code had to keep track of all the various
        relationships. Even CODASYL committee members admitted that this was like navigating around an
        <em>n</em>-dimensional data space [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Bachman1973hs-marker" href="ch02.html#Bachman1973hs">17</a>].</p>
        
        <p>Although manual access path selection was able to make the most efficient use of the very limited
        hardware capabilities in the 1970s (such as tape drives, whose seeks are extremely slow), the
        problem was that they made the code for querying and updating the database complicated and
        inflexible. With both the hierarchical and the network model, if you didn’t have a path to the data
        you wanted, you were in a difficult situation. You could change the access paths, but then you had
        to go through a lot of handwritten database query code and rewrite it to handle the new access
        paths. It was difficult to make changes to an application’s data model.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="The relational model"><div class="sect3" id="idm45085125334560">
        <h3>The relational model</h3>
        
        <p>What the relational model did, by contrast, was to lay out all the data in the open: a relation
        (table) is simply a collection of tuples (rows), and that’s it. There are no labyrinthine nested
        structures, no complicated access paths to follow if you want to look at the data. You can read any
        or all of the rows in a table, selecting those that match an arbitrary condition. You can read a
        particular row by designating some columns as a key and matching on those. You can insert a new row
        into any table without worrying about foreign key relationships to and from other
        tables.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm45085125332400-marker" href="ch02.html#idm45085125332400">iv</a></sup></p>
        
        <p><a data-type="indexterm" data-primary="query optimizers" id="idm45085125331040"></a>
        In a relational database, the query optimizer automatically decides which parts of the query to
        execute in which order, and which indexes to use. Those choices are effectively the “access path,”
        but the big difference is that they are made automatically by the query optimizer, not by the
        application developer, so we rarely need to think about them.</p>
        
        <p>If you want to query your data in new ways, you can just declare a new index, and queries will
        automatically use whichever indexes are most appropriate. You don’t need to change your queries to
        take advantage of a new index. (See also <a data-type="xref" href="#sec_datamodels_query">“Query Languages for Data”</a>.) The relational model thus made
        it much easier to add new features to applications.</p>
        
        <p>Query optimizers for relational databases are complicated beasts, and they have consumed many years
        of research and development effort
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Hellerstein2007be-marker" href="ch02.html#Hellerstein2007be">18</a>].
        But a key insight of the relational model was this: you only need to build a query optimizer once,
        and then all applications that use the database can benefit from it. If you don’t have a query
        optimizer, it’s easier to handcode the access paths for a particular query than to write a
        general-purpose optimizer—but the general-purpose solution wins in the long run.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Comparison to document databases"><div class="sect3" id="idm45085125324640">
        <h3>Comparison to document databases</h3>
        
        <p>Document databases reverted back to the hierarchical model in one aspect: storing nested records
        (one-to-many relationships, like <code>positions</code>, <code>education</code>, and <span class="keep-together"><code>contact_info</code></span> in
        <a data-type="xref" href="#fig_billgates_relational">Figure&nbsp;2-1</a>) within their parent record rather than in a separate table.</p>
        
        <p><a data-type="indexterm" data-primary="foreign keys" id="idm45085125320448"></a><a data-type="indexterm" data-primary="document data model" data-secondary="document references" id="idm45085125319744"></a>
        However, when it comes to representing many-to-one and many-to-many relationships, relational and
        document databases are not fundamentally different: in both cases, the related item is referenced by
        a unique identifier, which is called a <em>foreign key</em> in the relational model and a <em>document
        reference</em> in the document model [<a data-type="noteref" href="ch02.html#MongoDB2013">9</a>]. That
        identifier is resolved at read time by using a join or follow-up queries. To date, document
        databases have not followed the path of CODASYL.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Relational Versus Document Databases Today"><div class="sect2" id="sec_datamodels_document_summary">
        <h2>Relational Versus Document Databases Today</h2>
        
        <p><a data-type="indexterm" data-primary="relational data model" data-secondary="comparison to document model" id="ix_relvsdoc"></a>
        <a data-type="indexterm" data-primary="document data model" data-secondary="comparison to relational model" id="ix_docvsrel"></a>
        There are many differences to consider when comparing relational databases to document databases,
        including their fault-tolerance properties (see <a data-type="xref" href="ch05.html#ch_replication">Chapter&nbsp;5</a>) and handling of concurrency (see
        <a data-type="xref" href="ch07.html#ch_transactions">Chapter&nbsp;7</a>). In this chapter, we will concentrate only on the differences in the data model.</p>
        
        <p>The main arguments in favor of the document data model are schema flexibility, better performance
        due to locality, and that for some applications it is closer to the data structures used by the
        application. The relational model counters by providing better support for joins, and many-to-one
        and many-to-many relationships.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Which data model leads to simpler application code?"><div class="sect3" id="idm45085125309344">
        <h3>Which data model leads to simpler application code?</h3>
        
        <p><a data-type="indexterm" data-primary="shredding (in relational model)" id="idm45085125307936"></a>
        If the data in your application has a document-like structure (i.e., a tree of one-to-many
        relationships, where typically the entire tree is loaded at once), then it’s probably a good idea to
        use a document model. The relational technique of <em>shredding</em>—splitting a document-like structure
        into multiple tables (like <code>positions</code>, <code>education</code>, and <code>contact_info</code> in
        <a data-type="xref" href="#fig_billgates_relational">Figure&nbsp;2-1</a>)—can lead to cumbersome schemas and unnecessarily complicated
        application code.</p>
        
        <p>The document model has limitations: for example, you cannot refer directly to a nested item
        within a document, but instead you need to say something like “the second item in the list of
        positions for user 251” (much like an access path in the hierarchical model). However, as long as
        documents are not too deeply nested, that is not usually a problem.</p>
        
        <p><a data-type="indexterm" data-primary="many-to-many relationships" data-secondary="in document model versus relational model" id="idm45085125303200"></a>
        The poor support for joins in document databases may or may not be a problem, depending on the
        application. For example, many-to-many relationships may never be needed in an analytics application
        that uses a document database to record which events occurred at which time
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Parikh2013vf-marker" href="ch02.html#Parikh2013vf">19</a>].</p>
        
        <p><a data-type="indexterm" data-primary="denormalization (data representation)" data-secondary="costs" id="idm45085125299424"></a>
        <a data-type="indexterm" data-primary="normalization (data representation)" data-secondary="executing joins" id="idm45085125298256"></a>
        However, if your application does use many-to-many relationships, the document model becomes less
        appealing. It’s possible to reduce the need for joins by denormalizing, but then the application
        code needs to do additional work to keep the denormalized data consistent. Joins can be emulated in
        application code by making multiple requests to the database, but that also moves complexity into
        the application and is usually slower than a join performed by specialized code inside the
        database. In such cases, using a document model can lead to significantly more complex application
        code and worse performance [<a data-type="noteref" href="ch02.html#Mei2013vz">15</a>].</p>
        
        <p>It’s not possible to say in general which data model leads to simpler application code; it depends
        on the kinds of relationships that exist between data items. For highly interconnected data, the
        document model is awkward, the relational model is acceptable, and graph models (see
        <a data-type="xref" href="#sec_datamodels_graph">“Graph-Like Data Models”</a>) are the most <span class="keep-together">natural.</span></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Schema flexibility in the document model"><div class="sect3" id="sec_datamodels_schema_flexibility">
        <h3>Schema flexibility in the document model</h3>
        
        <p><a data-type="indexterm" data-primary="schemas" data-secondary="flexibility in document model" id="idm45085125291664"></a>
        Most document databases, and the JSON support in relational databases, do not enforce any schema on
        the data in documents. XML support in relational databases usually comes with optional schema
        validation. No schema means that arbitrary keys and values can be added to a document, and when
        reading, clients have no guarantees as to what fields the documents may contain.</p>
        
        <p><a data-type="indexterm" data-primary="schema-on-read" id="idm45085125289904"></a><a data-type="indexterm" data-primary="schema-on-write" id="idm45085125289008"></a><a data-type="indexterm" data-primary="schemaless databases" data-see="schema-on-read" id="idm45085125288336"></a>
        <a data-type="indexterm" data-primary="evolvability" data-secondary="schema-on-read" id="idm45085125287264"></a>
        Document databases are sometimes called <em>schemaless</em>, but that’s misleading, as the code that reads
        the data usually assumes some kind of structure—i.e., there is an implicit schema, but it is not
        enforced by the database [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Fowler2013uq-marker" href="ch02.html#Fowler2013uq">20</a>]. A more accurate term is <em>schema-on-read</em> (the structure
        of the data is implicit, and only interpreted when the data is read), in contrast with
        <em>schema-on-write</em> (the traditional approach of relational databases, where the schema is explicit
        and the database ensures all written data conforms to it)
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Awadallah2009vi-marker" href="ch02.html#Awadallah2009vi">21</a>].</p>
        
        <p><a data-type="indexterm" data-primary="statically typed languages" data-secondary="analogy to schema-on-write" id="idm45085125279936"></a>
        <a data-type="indexterm" data-primary="dynamically typed languages" data-secondary="analogy to schema-on-read" id="idm45085125278800"></a>
        <a data-type="indexterm" data-primary="type checking, dynamic versus static" id="idm45085125277664"></a>
        Schema-on-read is similar to dynamic (runtime) type checking in programming languages, whereas
        schema-on-write is similar to static (compile-time) type checking. Just as the advocates of static
        and dynamic type checking have big debates about their relative merits
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Odersky2013wz-marker" href="ch02.html#Odersky2013wz">22</a>],
        enforcement of schemas in database is a contentious topic, and in general there’s no right or wrong
        answer.</p>
        
        <p>The difference between the approaches is particularly noticeable in situations where an application
        wants to change the format of its data. For example, say you are currently storing each user’s full
        name in one field, and you instead want to store the first name and last name separately
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Irwin2013tb-marker" href="ch02.html#Irwin2013tb">23</a>].
        In a document database, you would just start writing new documents with the new fields and have
        code in the application that handles the case when old documents are read. For example:</p>
        
        <pre data-type="programlisting" data-code-language="javascript"><code class="k">if</code> <code class="p">(</code><code class="nx">user</code> <code class="o">&amp;&amp;</code> <code class="nx">user</code><code class="p">.</code><code class="nx">name</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">user</code><code class="p">.</code><code class="nx">first_name</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// Documents written before Dec 8, 2013 don't have first_name</code>
            <code class="nx">user</code><code class="p">.</code><code class="nx">first_name</code> <code class="o">=</code> <code class="nx">user</code><code class="p">.</code><code class="nx">name</code><code class="p">.</code><code class="nx">split</code><code class="p">(</code><code class="s2">" "</code><code class="p">)[</code><code class="mi">0</code><code class="p">];</code>
        <code class="p">}</code></pre>
        
        <p><a data-type="indexterm" data-primary="evolvability" data-secondary="of databases" id="idm45085125240128"></a>
        <a data-type="indexterm" data-primary="relational databases" data-secondary="schema changes" id="idm45085125222768"></a>
        <a data-type="indexterm" data-primary="migrating (rewriting) data" id="idm45085125221696"></a>
        <a data-type="indexterm" data-primary="ALTER TABLE statement (SQL)" id="idm45085125220848"></a>
        On the other hand, in a “statically typed” database schema, you would typically perform a
        <em>migration</em> along the lines of:</p>
        
        <pre data-type="programlisting" data-code-language="sql"><code class="k">ALTER</code> <code class="k">TABLE</code> <code class="n">users</code> <code class="k">ADD</code> <code class="k">COLUMN</code> <code class="n">first_name</code> <code class="nb">text</code><code class="p">;</code>
        <code class="k">UPDATE</code> <code class="n">users</code> <code class="k">SET</code> <code class="n">first_name</code> <code class="o">=</code> <code class="n">split_part</code><code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>      <code class="c1">-- PostgreSQL</code>
        <code class="k">UPDATE</code> <code class="n">users</code> <code class="k">SET</code> <code class="n">first_name</code> <code class="o">=</code> <code class="n">substring_index</code><code class="p">(</code><code class="n">name</code><code class="p">,</code> <code class="s1">' '</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>      <code class="c1">-- MySQL</code></pre>
        
        <p><a data-type="indexterm" data-primary="MySQL (database)" data-secondary="schema changes in" id="idm45085125160560"></a>
        Schema changes have a bad reputation of being slow and requiring downtime. This reputation is not
        entirely deserved: most relational database systems execute the <code>ALTER TABLE</code> statement in a few
        milliseconds. MySQL is a notable exception—it copies the entire table on <code>ALTER TABLE</code>, which
        can mean minutes or even hours of downtime when altering a large table—although various tools exist to work
        around this limitation [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Percona2013wb-marker" href="ch02.html#Percona2013wb">24</a>,
        <a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Keddo2013vj-marker" href="ch02.html#Keddo2013vj">25</a>,
        <a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Noach2016bq-marker" href="ch02.html#Noach2016bq">26</a>].</p>
        
        <p><a data-type="indexterm" data-primary="UPDATE statement (SQL)" id="idm45085125114640"></a>
        Running the <code>UPDATE</code> statement on a large table is likely to be slow on any database, since every
        row needs to be rewritten. If that is not acceptable, the application can leave <code>first_name</code> set to
        its default of <code>NULL</code> and fill it in at read time, like it would with a document database.</p>
        
        <p>The schema-on-read approach is advantageous if the items in the
        collection don’t all have the same structure for some reason (i.e., the data is heterogeneous)—for example, because:</p>
        
        <ul>
        <li>
        <p>There are many different types of objects, and it is not practicable to put each type of object in
        its own table.</p>
        </li>
        <li>
        <p>The structure of the data is determined by external systems over which you have no control and
        which may change at any time.</p>
        </li>
        </ul>
        
        <p>In situations like these, a schema may hurt more than it helps, and schemaless documents can be a
        much more natural data model. But in cases where all records are expected to have the same
        structure, schemas are a useful mechanism for documenting and enforcing that structure. We will
        discuss schemas and schema evolution in more detail in <a data-type="xref" href="ch04.html#ch_encoding">Chapter&nbsp;4</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Data locality for queries"><div class="sect3" id="sec_datamodels_document_locality">
        <h3>Data locality for queries</h3>
        
        <p><a data-type="indexterm" data-primary="locality (data access)" id="idm45085125106032"></a>
        <a data-type="indexterm" data-primary="data locality" data-see="locality" id="idm45085125104976"></a>
        <a data-type="indexterm" data-primary="relational data model" data-secondary="versus document model" data-tertiary="data locality" id="idm45085125103872"></a>
        <a data-type="indexterm" data-primary="document data model" data-secondary="versus relational model" data-tertiary="data locality" id="idm45085125102496"></a>
        <a data-type="indexterm" data-primary="MongoDB (database)" data-secondary="BSON" id="idm45085125101120"></a>
        A document is usually stored as a single continuous string, encoded as JSON, XML, or a binary variant
        thereof (such as MongoDB’s BSON). If your application often needs to access the entire document
        (for example, to render it on a web page), there is a performance advantage to this <em>storage
        locality</em>. If data is split across multiple tables, like in <a data-type="xref" href="#fig_billgates_relational">Figure&nbsp;2-1</a>, multiple
        index lookups are required to retrieve it all, which may require more disk seeks and take more time.</p>
        
        <p>The locality advantage only applies if you need large parts of the document at the same time. The
        database typically needs to load the entire document, even if you access only a small portion of it,
        which can be wasteful on large documents. On updates to a document, the entire document usually
        needs to be rewritten—only modifications that don’t change the encoded size of a document can
        easily be performed in place [<a data-type="noteref" href="ch02.html#Parikh2013vf">19</a>]. For these
        reasons, it is generally recommended that you keep documents fairly small and avoid writes that
        increase the size of a document [<a data-type="noteref" href="ch02.html#MongoDB2013">9</a>]. These
        performance limitations significantly reduce the set of situations in which document databases are
        useful.</p>
        
        <p><a data-type="indexterm" data-primary="multi-table index cluster tables (Oracle)" id="idm45085125095536"></a>
        <a data-type="indexterm" data-primary="Oracle (database)" data-secondary="multi-table index cluster tables" id="idm45085125094272"></a>
        <a data-type="indexterm" data-primary="Cassandra (database)" data-secondary="column-family data model" id="idm45085125093200"></a><a data-type="indexterm" data-primary="Apache Cassandra" data-see="Cassandra" id="idm45085125092208"></a>
        <a data-type="indexterm" data-primary="HBase (database)" data-secondary="column-family data model" id="idm45085125091136"></a><a data-type="indexterm" data-primary="Apache HBase" data-see="HBase" id="idm45085125090144"></a>
        <a data-type="indexterm" data-primary="Bigtable data model" id="idm45085125089072"></a><a data-type="indexterm" data-primary="Google" data-secondary="Bigtable (database)" data-tertiary="data model" data-see="Bigtable data model" id="idm45085125088368"></a>
        <a data-type="indexterm" data-primary="column families (Bigtable)" id="idm45085125086752"></a>
        <a data-type="indexterm" data-primary="Spanner (database)" data-secondary="data locality" id="idm45085125085904"></a><a data-type="indexterm" data-primary="Google" data-secondary="Spanner" data-see="Spanner" id="idm45085125084928"></a>
        It’s worth pointing out that the idea of grouping related data together for locality is not limited
        to the document model. For example, Google’s Spanner database offers the same locality properties in
        a relational data model, by allowing the schema to declare that a table’s rows should be interleaved
        (nested) within a parent table
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Corbett2012uz_ch2-marker" href="ch02.html#Corbett2012uz_ch2">27</a>].
        Oracle allows the same, using a feature called <em>multi-table index cluster tables</em>
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="BurlesonCwtEpWL2-marker" href="ch02.html#BurlesonCwtEpWL2">28</a>].
        The <em>column-family</em> concept in the Bigtable data model (used in
        Cassandra and HBase) has a similar purpose of managing locality
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Chang2006ta_ch2-marker" href="ch02.html#Chang2006ta_ch2">29</a>].</p>
        
        <p>We will also see more on locality in <a data-type="xref" href="ch03.html#ch_storage">Chapter&nbsp;3</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Convergence of document and relational databases"><div class="sect3" id="idm45085125074768">
        <h3>Convergence of document and relational databases</h3>
        
        <p><a data-type="indexterm" data-primary="XML" data-secondary="in relational databases" id="idm45085125073360"></a>
        <a data-type="indexterm" data-primary="relational data model" data-secondary="versus document model" data-tertiary="convergence of models" id="idm45085125072256"></a>
        <a data-type="indexterm" data-primary="document data model" data-secondary="versus relational model" data-tertiary="convergence of models" id="idm45085125070880"></a>
        Most relational database systems (other than MySQL) have supported XML since the mid-2000s. This
        includes functions to make local modifications to XML documents and the ability to index and query
        inside XML documents, which allows applications to use data models very similar to what they would
        do when using a document database.</p>
        
        <p><a data-type="indexterm" data-primary="JSON" data-secondary="in relational databases" id="idm45085125068896"></a>
        <a data-type="indexterm" data-primary="IBM" data-secondary="DB2 (database)" data-tertiary="XML and JSON support" id="idm45085125067568"></a>
        <a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="XML and JSON support" id="idm45085125066192"></a>
        <a data-type="indexterm" data-primary="MySQL (database)" data-secondary="JSON support" id="idm45085125065088"></a>
        PostgreSQL since version 9.3 [<a data-type="noteref" href="ch02.html#PostgreSQL2013">8</a>],
        MySQL since version 5.7, and IBM DB2 since version 10.5
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Cochrane2013ui-marker" href="ch02.html#Cochrane2013ui">30</a>]
        also have a similar level of support for JSON documents. Given the popularity of JSON for web APIs,
        it is likely that other relational databases will follow in their footsteps and add JSON support.</p>
        
        <p><a data-type="indexterm" data-primary="joins" data-secondary="support in document databases" id="idm45085125061136"></a>
        <a data-type="indexterm" data-primary="normalization (data representation)" data-secondary="executing joins" id="idm45085125060000"></a>
        <a data-type="indexterm" data-primary="MongoDB (database)" data-secondary="lack of join support" id="idm45085125058880"></a>
        <a data-type="indexterm" data-primary="RethinkDB (database)" data-secondary="join support" id="idm45085125057776"></a>
        On the document database side, RethinkDB supports relational-like joins in its query language, and
        some MongoDB drivers automatically resolve document references (effectively performing a client-side
        join, although this is likely to be slower than a join performed in the database since it requires
        additional network round-trips and is less optimized).</p>
        
        <p>It seems that relational and document databases are becoming more similar over time, and that is a
        good thing: the data models complement each
        other.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm45085125055760-marker" href="ch02.html#idm45085125055760">v</a></sup> If a database is able to handle document-like data and also perform
        relational queries on it, applications can use the combination of features that best fits their
        needs.</p>
        
        <p>A hybrid of the relational and document models is a good route for databases to take in the future.
        <a data-type="indexterm" data-primary="data models" data-secondary="relational model versus document model" data-startref="ix_DMreldoc" id="idm45085125052400"></a>
        <a data-type="indexterm" data-primary="relational data model" data-secondary="comparison to document model" data-startref="ix_relvsdoc" id="idm45085125051008"></a>
        <a data-type="indexterm" data-primary="document data model" data-secondary="comparison to relational model" data-startref="ix_docvsrel" id="idm45085125049616"></a>
        <a data-type="indexterm" data-primary="relational data model" data-startref="ix_relationmod" id="idm45085125048224"></a>
        <a data-type="indexterm" data-primary="document data model" data-startref="ix_docdata" id="idm45085125047120"></a></p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Query Languages for Data"><div class="sect1" id="sec_datamodels_query">
        <h1>Query Languages for Data</h1>
        
        <p><a data-type="indexterm" data-primary="data models" data-secondary="query languages" id="ix_DMquerylang"></a>
        <a data-type="indexterm" data-primary="query languages" id="ix_querylang"></a>
        <a data-type="indexterm" data-primary="imperative languages" id="idm45085125041632"></a>
        <a data-type="indexterm" data-primary="declarative languages" id="idm45085125040800"></a>
        When the relational model was introduced, it included a new way of querying data: SQL is a
        <em>declarative</em> query language, whereas IMS and CODASYL queried the database using <em>imperative</em> code.
        What does that mean?</p>
        
        <p><a data-type="indexterm" data-primary="sharks" data-secondary="finding (example)" id="idm45085125038896"></a>
        Many commonly used programming languages are imperative. For example, if you have a list of animal
        species, you might write something like this to return only the sharks in the list:</p>
        
        <pre data-type="programlisting" data-code-language="javascript"><code class="kd">function</code> <code class="nx">getSharks</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">sharks</code> <code class="o">=</code> <code class="p">[];</code>
            <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">animals</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">animals</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">family</code> <code class="o">===</code> <code class="s2">"Sharks"</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">sharks</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">animals</code><code class="p">[</code><code class="nx">i</code><code class="p">]);</code>
                <code class="p">}</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">sharks</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p><a data-type="indexterm" data-primary="relational data model" data-secondary="relational algebra and SQL" id="idm45085125036448"></a>
        <a data-type="indexterm" data-primary="declarative languages" data-secondary="relational algebra and SQL" id="idm45085124951840"></a>
        <a data-type="indexterm" data-primary="query languages" data-secondary="relational algebra and SQL" id="idm45085124950800"></a>
        In the relational algebra, you would instead write:</p>
        <blockquote>
        <p>sharks&nbsp;&nbsp;=&nbsp;&nbsp;σ<sub>family = “Sharks”</sub> (animals)</p></blockquote>
        
        <p>where σ (the Greek letter sigma) is the selection operator, returning only those animals that
        match the condition <em>family = “Sharks”</em>.</p>
        
        <p><a data-type="indexterm" data-primary="SQL (Structured Query Language)" id="idm45085124947248"></a>
        When SQL was defined, it followed the structure of the relational algebra fairly closely:</p>
        
        <pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code> <code class="o">*</code> <code class="k">FROM</code> <code class="n">animals</code> <code class="k">WHERE</code> <code class="n">family</code> <code class="o">=</code> <code class="s1">'Sharks'</code><code class="p">;</code></pre>
        
        <p>An imperative language tells the computer to perform certain operations in a certain order. You can
        imagine stepping through the code line by line, evaluating conditions, updating variables, and
        deciding whether to go around the loop one more time.</p>
        
        <p>In a declarative query language, like SQL or relational algebra, you just specify the pattern of the
        data you want—what conditions the results must meet, and how you want the data to be transformed (e.g.,
        sorted, grouped, and aggregated)—but not <em>how</em> to achieve that goal. It is up to the database
        system’s query optimizer to decide which indexes and which join methods to use, and in which order
        to execute various parts of the query.</p>
        
        <p>A declarative query language is attractive because it is typically more concise and easier to work
        with than an imperative API. But more importantly, it also hides implementation details of the
        database engine, which makes it possible for the database system to introduce performance
        improvements without requiring any changes to queries.</p>
        
        <p>For example, in the imperative code shown at the beginning of this section, the list of animals
        appears in a particular order. If the database wants to reclaim unused disk space behind the scenes,
        it might need to move records around, changing the order in which the animals appear. Can the
        database do that safely, without breaking queries?</p>
        
        <p>The SQL example doesn’t guarantee any particular ordering, and so it doesn’t mind if the order
        changes. But if the query is written as imperative code, the database can never be sure whether the
        code is relying on the ordering or not. The fact that SQL is more limited in functionality gives the
        database much more room for automatic optimizations.</p>
        
        <p><a data-type="indexterm" data-primary="CPUs" data-secondary="increasing parallelism" id="idm45085124923280"></a>
        Finally, declarative languages often lend themselves to parallel execution. Today, CPUs are getting
        faster by adding more cores, not by running at significantly higher clock speeds than before
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Sutter2005us-marker" href="ch02.html#Sutter2005us">31</a>].
        Imperative code is very hard to parallelize across multiple cores and multiple machines, because it
        specifies instructions that must be performed in a particular order. Declarative languages have a
        better chance of getting faster in parallel execution because they specify only the pattern of the
        results, not the algorithm that is used to determine the results. The database is free to use a
        parallel implementation of the query language, if appropriate
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Hellerstein2010uq-marker" href="ch02.html#Hellerstein2010uq">32</a>].</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Declarative Queries on the Web"><div class="sect2" id="idm45085124937664">
        <h2>Declarative Queries on the Web</h2>
        
        <p><a data-type="indexterm" data-primary="declarative languages" data-secondary="CSS and XSL" id="idm45085124936128"></a>
        <a data-type="indexterm" data-primary="query languages" data-secondary="CSS and XSL" id="idm45085124935024"></a>
        The advantages of declarative query languages are not limited to just databases. To illustrate the
        point, let’s compare declarative and imperative approaches in a completely different environment: a
        web browser.</p>
        
        <p><a data-type="indexterm" data-primary="sharks" data-secondary="website about (example)" id="idm45085124933440"></a>
        Say you have a website about animals in the ocean. The user is currently viewing the page on sharks,
        so you mark the navigation item “Sharks” as currently selected, like this:</p>
        
        <pre data-type="programlisting" data-code-language="html"><code class="nt">&lt;ul</code><code class="nt">&gt;</code><code>
            </code><code class="nt">&lt;li</code><code> </code><code class="na">class=</code><code class="s">"selected"</code><code class="nt">&gt;</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO1-1" href="#callout_data_models_and_query_languages_CO1-1"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/1.png" alt="1" width="12" height="12"></a><code>
                </code><code class="nt">&lt;p</code><code class="nt">&gt;</code><code>Sharks</code><code class="nt">&lt;/p&gt;</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO1-2" href="#callout_data_models_and_query_languages_CO1-2"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/2.png" alt="2" width="12" height="12"></a><code>
                </code><code class="nt">&lt;ul</code><code class="nt">&gt;</code><code>
                    </code><code class="nt">&lt;li</code><code class="nt">&gt;</code><code>Great White Shark</code><code class="nt">&lt;/li&gt;</code><code>
                    </code><code class="nt">&lt;li</code><code class="nt">&gt;</code><code>Tiger Shark</code><code class="nt">&lt;/li&gt;</code><code>
                    </code><code class="nt">&lt;li</code><code class="nt">&gt;</code><code>Hammerhead Shark</code><code class="nt">&lt;/li&gt;</code><code>
                </code><code class="nt">&lt;/ul&gt;</code><code>
            </code><code class="nt">&lt;/li&gt;</code><code>
            </code><code class="nt">&lt;li</code><code class="nt">&gt;</code><code>
                </code><code class="nt">&lt;p</code><code class="nt">&gt;</code><code>Whales</code><code class="nt">&lt;/p&gt;</code><code>
                </code><code class="nt">&lt;ul</code><code class="nt">&gt;</code><code>
                    </code><code class="nt">&lt;li</code><code class="nt">&gt;</code><code>Blue Whale</code><code class="nt">&lt;/li&gt;</code><code>
                    </code><code class="nt">&lt;li</code><code class="nt">&gt;</code><code>Humpback Whale</code><code class="nt">&lt;/li&gt;</code><code>
                    </code><code class="nt">&lt;li</code><code class="nt">&gt;</code><code>Fin Whale</code><code class="nt">&lt;/li&gt;</code><code>
                </code><code class="nt">&lt;/ul&gt;</code><code>
            </code><code class="nt">&lt;/li&gt;</code><code>
        </code><code class="nt">&lt;/ul&gt;</code></pre>
        <dl class="calloutlist">
        <dt><a class="co" id="callout_data_models_and_query_languages_CO1-1" href="#co_data_models_and_query_languages_CO1-1"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/1.png" alt="1" width="12" height="12"></a></dt>
        <dd><p>The selected item is marked with the CSS class <code>"selected"</code>.</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO1-2" href="#co_data_models_and_query_languages_CO1-2"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/2.png" alt="2" width="12" height="12"></a></dt>
        <dd><p><code>&lt;p&gt;Sharks&lt;/p&gt;</code> is the title of the currently selected page.</p></dd>
        </dl>
        
        <p><a data-type="indexterm" data-primary="CSS (Cascading Style Sheets)" id="idm45085124831280"></a>
        Now say you want the title of the currently selected page to have a blue background, so that it is
        visually highlighted. This is easy, using CSS:</p>
        
        <pre data-type="programlisting" data-code-language="css"><code class="nt">li</code><code class="nc">.selected</code> <code class="o">&gt;</code> <code class="nt">p</code> <code class="p">{</code>
            <code class="k">background-color</code><code class="o">:</code> <code class="nb">blue</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>Here the CSS selector <code>li.selected &gt; p</code> declares the pattern of elements to which we want to apply
        the blue style: namely, all <code>&lt;p&gt;</code> elements whose direct parent is an <code>&lt;li&gt;</code> element with a CSS class
        of <code>selected</code>. The element <code>&lt;p&gt;Sharks&lt;/p&gt;</code> in the example matches this pattern, but <code>&lt;p&gt;Whales&lt;/p&gt;</code>
        does not match because its <code>&lt;li&gt;</code> parent lacks <code>class="selected"</code>.</p>
        
        <p class="pagebreak-before"><a data-type="indexterm" data-primary="XSL/XPath" id="idm45085124781712"></a>
        If you were using XSL instead of CSS, you could do something similar:</p>
        
        <pre data-type="programlisting" data-code-language="xslt"><code class="k">&lt;xsl:template</code> <code class="na">match=</code><code class="s">"li[@class='selected']/p"</code><code class="nt">&gt;</code>
            <code class="nt">&lt;fo:block</code> <code class="na">background-color=</code><code class="s">"blue"</code><code class="nt">&gt;</code>
                <code class="k">&lt;xsl:apply-templates</code><code class="nt">/&gt;</code>
            <code class="nt">&lt;/fo:block&gt;</code>
        <code class="k">&lt;/xsl:template&gt;</code></pre>
        
        <p>Here, the XPath expression <code>li[@class='selected']/p</code> is equivalent to
        the CSS selector <code>li.selected &gt; p</code> in the previous example. What CSS and XSL have in common is that
        they are both <em>declarative</em> languages for specifying the styling of a document.</p>
        
        <p>Imagine what life would be like if you had to use an imperative approach. In JavaScript, using the
        core Document Object Model (DOM) API, the result might look something like this:</p>
        
        <pre data-type="programlisting" data-code-language="javascript"><code class="kd">var</code> <code class="nx">liElements</code> <code class="o">=</code> <code class="nb">document</code><code class="p">.</code><code class="nx">getElementsByTagName</code><code class="p">(</code><code class="s2">"li"</code><code class="p">);</code>
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">liElements</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">liElements</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">className</code> <code class="o">===</code> <code class="s2">"selected"</code><code class="p">)</code> <code class="p">{</code>
                <code class="kd">var</code> <code class="nx">children</code> <code class="o">=</code> <code class="nx">liElements</code><code class="p">[</code><code class="nx">i</code><code class="p">].</code><code class="nx">childNodes</code><code class="p">;</code>
                <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">j</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">j</code> <code class="o">&lt;</code> <code class="nx">children</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">j</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                    <code class="kd">var</code> <code class="nx">child</code> <code class="o">=</code> <code class="nx">children</code><code class="p">[</code><code class="nx">j</code><code class="p">];</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">child</code><code class="p">.</code><code class="nx">nodeType</code> <code class="o">===</code> <code class="nx">Node</code><code class="p">.</code><code class="nx">ELEMENT_NODE</code> <code class="o">&amp;&amp;</code> <code class="nx">child</code><code class="p">.</code><code class="nx">tagName</code> <code class="o">===</code> <code class="s2">"P"</code><code class="p">)</code> <code class="p">{</code>
                        <code class="nx">child</code><code class="p">.</code><code class="nx">setAttribute</code><code class="p">(</code><code class="s2">"style"</code><code class="p">,</code> <code class="s2">"background-color: blue"</code><code class="p">);</code>
                    <code class="p">}</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p><a data-type="indexterm" data-primary="JavaScript" data-secondary="setting element styles (example)" id="idm45085124742816"></a>
        <a data-type="indexterm" data-primary="imperative languages" data-secondary="setting element styles (example)" id="idm45085124500192"></a>
        This JavaScript imperatively sets the element <code>&lt;p&gt;Sharks&lt;/p&gt;</code> to have a blue background, but the code is
        awful. Not only is it much longer and harder to understand than the CSS and XSL equivalents, but it
        also has some serious problems:</p>
        
        <ul>
        <li>
        <p>If the <code>selected</code> class is removed (e.g., because the user clicks a different page), the blue
        color won’t be removed, even if the code is rerun—and so the item will remain highlighted
        until the entire page is reloaded. With CSS, the browser automatically detects when the <code>li.selected &gt; p</code>
        rule no longer applies and removes the blue background as soon as the <code>selected</code> class is
        removed.</p>
        </li>
        <li>
        <p>If you want to take advantage of a new API, such as <code>document.getElementsByClassName("selected")</code>
        or even <code>document.evaluate()</code>—which may improve performance—you have to rewrite the code.
        On the other hand, browser vendors can improve the performance of CSS and XPath without breaking
        compatibility.</p>
        </li>
        </ul>
        
        <p><a data-type="indexterm" data-primary="network model" data-secondary="imperative query APIs" id="idm45085124493360"></a>
        <a data-type="indexterm" data-primary="IBM" data-secondary="IMS (database)" data-tertiary="imperative query APIs" id="idm45085124492256"></a>
        In a web browser, using declarative CSS styling is much better than manipulating styles imperatively in
        JavaScript. Similarly, in databases, declarative query languages like SQL turned out to be much
        better than imperative query APIs.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm45085124490624-marker" href="ch02.html#idm45085124490624">vi</a></sup></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="MapReduce Querying"><div class="sect2" id="sec_datamodels_mapreduce">
        <h2>MapReduce Querying</h2>
        
        <p><a data-type="indexterm" data-primary="query languages" data-secondary="MapReduce querying" id="ix_queryMR"></a>
        <a data-type="indexterm" data-primary="MapReduce (batch processing)" data-secondary="implementation in MongoDB" id="ix_mapredmongo"></a>
        <a data-type="indexterm" data-primary="CouchDB (database)" data-secondary="MapReduce support" id="idm45085124482912"></a>
        <a data-type="indexterm" data-primary="MongoDB (database)" data-secondary="MapReduce support" id="idm45085124481808"></a>
        <em>MapReduce</em> is a programming model for processing large amounts of data in bulk across many
        machines, popularized by Google
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Dean2004ua_ch2-marker" href="ch02.html#Dean2004ua_ch2">33</a>]. A limited form of MapReduce is supported by
        some NoSQL datastores, including MongoDB and CouchDB, as a mechanism for performing read-only
        queries across many documents.</p>
        
        <p>MapReduce in general is described in more detail in <a data-type="xref" href="ch10.html#ch_batch">Chapter&nbsp;10</a>. For now, we’ll just briefly
        discuss MongoDB’s use of the model.</p>
        
        <p>MapReduce is neither a declarative query language nor a fully imperative query API, but somewhere
        in between: the logic of the query is expressed with snippets of code, which are called repeatedly
        by the processing framework. It is based on the <code>map</code> (also known as <code>collect</code>) and <code>reduce</code> (also
        known as <code>fold</code> or <code>inject</code>) functions that exist in many functional programming languages.</p>
        
        <p><a data-type="indexterm" data-primary="sharks" data-secondary="counting (example)" id="ix_sharkcount"></a>
        To give an example, imagine you are a marine biologist, and you add an observation record to your
        database every time you see animals in the ocean. Now you want to generate a report saying how many
        sharks you have sighted per month.</p>
        
        <p>In PostgreSQL you might express that query like this:</p>
        
        <pre data-type="programlisting" data-code-language="sql"><code class="k">SELECT</code><code> </code><code class="n">date_trunc</code><code class="p">(</code><code class="s1">'month'</code><code class="p">,</code><code> </code><code class="n">observation_timestamp</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">observation_month</code><code class="p">,</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO2-1" href="#callout_data_models_and_query_languages_CO2-1"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/1.png" alt="1" width="12" height="12"></a><code>
               </code><code class="k">sum</code><code class="p">(</code><code class="n">num_animals</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="n">total_animals</code><code>
        </code><code class="k">FROM</code><code> </code><code class="n">observations</code><code>
        </code><code class="k">WHERE</code><code> </code><code class="n">family</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Sharks'</code><code>
        </code><code class="k">GROUP</code><code> </code><code class="k">BY</code><code> </code><code class="n">observation_month</code><code class="p">;</code></pre>
        <dl class="calloutlist">
        <dt><a class="co" id="callout_data_models_and_query_languages_CO2-1" href="#co_data_models_and_query_languages_CO2-1"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/1.png" alt="1" width="12" height="12"></a></dt>
        <dd><p>The <code>date_trunc('month', timestamp)</code> function determines the calendar month
        containing <code>timestamp</code>, and returns another timestamp representing the beginning of that month. In
        other words, it rounds a timestamp down to the nearest month.</p></dd>
        </dl>
        
        <p>This query first filters the observations to only show species in the <code>Sharks</code> family, then groups
        the observations by the calendar month in which they occurred, and finally adds up the number of
        animals seen in all observations in that month.</p>
        
        <p><a data-type="indexterm" data-primary="JavaScript" data-secondary="in MapReduce querying" id="idm45085124434080"></a>
        The same can be expressed with MongoDB’s MapReduce feature as follows:</p>
        
        <pre data-type="programlisting" data-code-language="javascript"><code class="nx">db</code><code class="p">.</code><code class="nx">observations</code><code class="p">.</code><code class="nx">mapReduce</code><code class="p">(</code><code>
            </code><code class="kd">function</code><code> </code><code class="nx">map</code><code class="p">(</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO3-1" href="#callout_data_models_and_query_languages_CO3-2"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/2.png" alt="2" width="12" height="12"></a><code>
                </code><code class="kd">var</code><code> </code><code class="nx">year</code><code>  </code><code class="o">=</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">observationTimestamp</code><code class="p">.</code><code class="nx">getFullYear</code><code class="p">(</code><code class="p">)</code><code class="p">;</code><code>
                </code><code class="kd">var</code><code> </code><code class="nx">month</code><code> </code><code class="o">=</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">observationTimestamp</code><code class="p">.</code><code class="nx">getMonth</code><code class="p">(</code><code class="p">)</code><code> </code><code class="o">+</code><code> </code><code class="mi">1</code><code class="p">;</code><code>
                </code><code class="nx">emit</code><code class="p">(</code><code class="nx">year</code><code> </code><code class="o">+</code><code> </code><code class="s2">"-"</code><code> </code><code class="o">+</code><code> </code><code class="nx">month</code><code class="p">,</code><code> </code><code class="k">this</code><code class="p">.</code><code class="nx">numAnimals</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO3-2" href="#callout_data_models_and_query_languages_CO3-3"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/3.png" alt="3" width="12" height="12"></a><code>
            </code><code class="p">}</code><code class="p">,</code><code>
            </code><code class="kd">function</code><code> </code><code class="nx">reduce</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code><code> </code><code class="nx">values</code><code class="p">)</code><code> </code><code class="p">{</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO3-3" href="#callout_data_models_and_query_languages_CO3-4"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/4.png" alt="4" width="12" height="12"></a><code>
                </code><code class="k">return</code><code> </code><code class="nb">Array</code><code class="p">.</code><code class="nx">sum</code><code class="p">(</code><code class="nx">values</code><code class="p">)</code><code class="p">;</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO3-4" href="#callout_data_models_and_query_languages_CO3-5"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/5.png" alt="5" width="12" height="12"></a><code>
            </code><code class="p">}</code><code class="p">,</code><code>
            </code><code class="p">{</code><code>
                </code><code class="nx">query</code><code class="o">:</code><code> </code><code class="p">{</code><code> </code><code class="nx">family</code><code class="o">:</code><code> </code><code class="s2">"Sharks"</code><code> </code><code class="p">}</code><code class="p">,</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO3-5" href="#callout_data_models_and_query_languages_CO3-1"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/1.png" alt="1" width="12" height="12"></a><code>
                </code><code class="nx">out</code><code class="o">:</code><code> </code><code class="s2">"monthlySharkReport"</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO3-6" href="#callout_data_models_and_query_languages_CO3-6"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/6.png" alt="6" width="12" height="12"></a><code>
            </code><code class="p">}</code><code>
        </code><code class="p">)</code><code class="p">;</code></pre>
        <dl class="calloutlist">
        <dt><a class="co" id="callout_data_models_and_query_languages_CO3-1" href="#co_data_models_and_query_languages_CO3-5"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/1.png" alt="1" width="12" height="12"></a></dt>
        <dd><p>The filter to consider only shark species can be specified declaratively (this is a
        MongoDB-specific extension to MapReduce).</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO3-2" href="#co_data_models_and_query_languages_CO3-1"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/2.png" alt="2" width="12" height="12"></a></dt>
        <dd><p>The JavaScript function <code>map</code> is called once for every document that matches <code>query</code>, with
        <code>this</code> set to the document object.</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO3-3" href="#co_data_models_and_query_languages_CO3-2"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/3.png" alt="3" width="12" height="12"></a></dt>
        <dd><p>The <code>map</code> function emits a key (a string consisting of year and month, such as <code>"2013-12"</code> or
        <code>"2014-1"</code>) and a value (the number of animals in that observation).</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO3-4" href="#co_data_models_and_query_languages_CO3-3"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/4.png" alt="4" width="12" height="12"></a></dt>
        <dd><p>The key-value pairs emitted by <code>map</code> are grouped by key. For all key-value pairs with the same
        key (i.e., the same month and year), the <code>reduce</code> function is called once.</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO3-5" href="#co_data_models_and_query_languages_CO3-4"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/5.png" alt="5" width="12" height="12"></a></dt>
        <dd><p>The <code>reduce</code> function adds up the number of animals from all observations in a particular month.</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO3-6" href="#co_data_models_and_query_languages_CO3-6"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/6.png" alt="6" width="12" height="12"></a></dt>
        <dd><p>The final output is written to the collection <code>monthlySharkReport</code>.</p></dd>
        </dl>
        
        <p>For example, say the <code>observations</code> collection contains these two documents:</p>
        
        <pre data-type="programlisting" data-code-language="javascript"><code class="p">{</code>
            <code class="nx">observationTimestamp</code><code class="o">:</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="s2">"Mon, 25 Dec 1995 12:34:56 GMT"</code><code class="p">),</code>
            <code class="nx">family</code><code class="o">:</code>     <code class="s2">"Sharks"</code><code class="p">,</code>
            <code class="nx">species</code><code class="o">:</code>    <code class="s2">"Carcharodon carcharias"</code><code class="p">,</code>
            <code class="nx">numAnimals</code><code class="o">:</code> <code class="mi">3</code>
        <code class="p">}</code>
        <code class="p">{</code>
            <code class="nx">observationTimestamp</code><code class="o">:</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="s2">"Tue, 12 Dec 1995 16:17:18 GMT"</code><code class="p">),</code>
            <code class="nx">family</code><code class="o">:</code>     <code class="s2">"Sharks"</code><code class="p">,</code>
            <code class="nx">species</code><code class="o">:</code>    <code class="s2">"Carcharias taurus"</code><code class="p">,</code>
            <code class="nx">numAnimals</code><code class="o">:</code> <code class="mi">4</code>
        <code class="p">}</code></pre>
        
        <p>The <code>map</code> function would be called once for each document, resulting in
        <code>emit("1995-12", 3)</code> and
        <code>emit("1995-12", 4)</code>. Subsequently, the <code>reduce</code> function
        would be called with <code>reduce("1995-12", [3, 4])</code>, returning
        <code>7</code>.</p>
        
        <p><a data-type="indexterm" data-primary="pure functions" id="idm45085124157792"></a>
        The <code>map</code> and <code>reduce</code> functions are somewhat restricted in what they are allowed to do. They must be
        <em>pure</em> functions, which means they only use the data that is passed to them as input, they cannot
        perform additional database queries, and they must not have any side effects. These restrictions
        allow the database to run the functions anywhere, in any order, and rerun them on failure. However,
        they are nevertheless powerful: they can parse strings, call library functions, perform calculations,
        and more.</p>
        
        <p><a data-type="indexterm" data-primary="SQL (Structured Query Language)" data-secondary="distributed query execution" id="idm45085124154976"></a>
        MapReduce is a fairly low-level programming model for distributed execution on a cluster of
        machines. Higher-level query languages like SQL can be implemented as a pipeline of MapReduce
        operations (see <a data-type="xref" href="ch10.html#ch_batch">Chapter&nbsp;10</a>), but there are also many distributed implementations of SQL that don’t
        use MapReduce. Note there is nothing in SQL that constrains it to running on a single machine, and
        MapReduce doesn’t have a monopoly on distributed query execution.</p>
        
        <p><a data-type="indexterm" data-primary="JavaScript" data-secondary="use in advanced queries" id="idm45085124152304"></a>
        Being able to use JavaScript code in the middle of a query is a great feature for advanced queries,
        but it’s not limited to MapReduce—some SQL databases can be extended with JavaScript functions
        too [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Kerstiens2013ur-marker" href="ch02.html#Kerstiens2013ur">34</a>].</p>
        
        <p><a data-type="indexterm" data-primary="MongoDB (database)" data-secondary="aggregation pipeline" id="idm45085124148496"></a>
        <a data-type="indexterm" data-primary="aggregation pipeline query language" id="idm45085124147392"></a>
        <a data-type="indexterm" data-primary="query languages" data-secondary="aggregation pipeline" id="idm45085124146496"></a>
        A usability problem with MapReduce is that you have to write two carefully coordinated JavaScript
        functions, which is often harder than writing a single query. Moreover, a declarative query language
        offers more opportunities for a query optimizer to improve the performance of a query. For these
        reasons, MongoDB 2.2 added support for a declarative query language called the <em>aggregation pipeline</em>
        [<a data-type="noteref" href="ch02.html#MongoDB2013">9</a>]. In this language, the same shark-counting
        query looks like this:</p>
        
        <pre data-type="programlisting" data-code-language="javascript"><code class="nx">db</code><code class="p">.</code><code class="nx">observations</code><code class="p">.</code><code class="nx">aggregate</code><code class="p">([</code>
            <code class="p">{</code> <code class="nx">$match</code><code class="o">:</code> <code class="p">{</code> <code class="nx">family</code><code class="o">:</code> <code class="s2">"Sharks"</code> <code class="p">}</code> <code class="p">},</code>
            <code class="p">{</code> <code class="nx">$group</code><code class="o">:</code> <code class="p">{</code>
                <code class="nx">_id</code><code class="o">:</code> <code class="p">{</code>
                    <code class="nx">year</code><code class="o">:</code>  <code class="p">{</code> <code class="nx">$year</code><code class="o">:</code>  <code class="s2">"$observationTimestamp"</code> <code class="p">},</code>
                    <code class="nx">month</code><code class="o">:</code> <code class="p">{</code> <code class="nx">$month</code><code class="o">:</code> <code class="s2">"$observationTimestamp"</code> <code class="p">}</code>
                <code class="p">},</code>
                <code class="nx">totalAnimals</code><code class="o">:</code> <code class="p">{</code> <code class="nx">$sum</code><code class="o">:</code> <code class="s2">"$numAnimals"</code> <code class="p">}</code>
            <code class="p">}</code> <code class="p">}</code>
        <code class="p">]);</code></pre>
        
        <p>The aggregation pipeline language is similar in expressiveness to a subset of SQL, but it uses a
        JSON-based syntax rather than SQL’s English-sentence-style syntax; the difference is perhaps a
        matter of taste. The moral of the story is that a NoSQL system may find itself accidentally
        reinventing SQL, albeit in disguise.
        <a data-type="indexterm" data-primary="sharks" data-secondary="counting (example)" data-startref="ix_sharkcount" id="idm45085124060624"></a>
        <a data-type="indexterm" data-primary="MapReduce (batch processing)" data-secondary="implementation in MongoDB" data-startref="ix_mapredmongo" id="idm45085124059408"></a>
        <a data-type="indexterm" data-primary="query languages" data-secondary="MapReduce querying" data-startref="ix_queryMR" id="idm45085124058000"></a>
        <a data-type="indexterm" data-primary="data models" data-secondary="query languages" data-startref="ix_DMquerylang" id="idm45085124056624"></a>
        <a data-type="indexterm" data-primary="query languages" data-startref="ix_querylang" id="idm45085124055248"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Graph-Like Data Models"><div class="sect1" id="sec_datamodels_graph">
        <h1>Graph-Like Data Models</h1>
        
        <p><a data-type="indexterm" data-primary="graphs" data-secondary="as data models" id="ix_graphDM"></a>
        <a data-type="indexterm" data-primary="data models" data-secondary="graph-like models" id="ix_DMgraph"></a>
        We saw earlier that many-to-many relationships are an important distinguishing feature between
        different data models. If your application has mostly one-to-many relationships (tree-structured
        data) or no relationships between records, the document model is appropriate.</p>
        
        <p><a data-type="indexterm" data-primary="many-to-many relationships" data-secondary="modeling as graphs" id="idm45085124049744"></a>
        But what if many-to-many relationships are very common in your data? The relational model can handle
        simple cases of many-to-many relationships, but as the connections within your data become more
        complex, it becomes more natural to start modeling your data as a graph.</p>
        
        <p><a data-type="indexterm" data-primary="vertices (in graphs)" id="idm45085124048080"></a><a data-type="indexterm" data-primary="nodes (in graphs)" data-see="vertices" id="idm45085124047216"></a><a data-type="indexterm" data-primary="entities" data-see="vertices" id="idm45085124046272"></a>
        <a data-type="indexterm" data-primary="edges (in graphs)" id="idm45085124045200"></a><a data-type="indexterm" data-primary="relationships" data-see="edges" id="idm45085124044496"></a><a data-type="indexterm" data-primary="arcs" data-see="edges" id="idm45085124043552"></a>
        A graph consists of two kinds of objects: <em>vertices</em> (also known as <em>nodes</em> or <em>entities</em>) and
        <em>edges</em> (also known as <em>relationships</em> or <em>arcs</em>). Many kinds of data can be modeled as a graph.
        Typical examples include:</p>
        <dl>
        <dt>Social graphs</dt>
        <dd>
        <p>Vertices are people, and edges indicate which people know each other.</p>
        </dd>
        <dt>The web graph</dt>
        <dd>
        <p>Vertices are web pages, and edges indicate HTML links to other pages.</p>
        </dd>
        <dt>Road or rail networks</dt>
        <dd>
        <p>Vertices are junctions, and edges represent the roads or railway lines between them.</p>
        </dd>
        </dl>
        
        <p><a data-type="indexterm" data-primary="PageRank (algorithm)" id="idm45085124035216"></a>
        Well-known algorithms can operate on these graphs: for example, car navigation systems search for
        the shortest path between two points in a road network, and <span class="keep-together">PageRank</span> can be used on the web graph to
        determine the popularity of a web page and thus its ranking in search results.</p>
        
        <p><a data-type="indexterm" data-primary="Facebook" data-secondary="social graphs" id="idm45085124033136"></a>
        In the examples just given, all the vertices in a graph represent the same kind of thing (people, web
        pages, or road junctions, respectively). However, graphs are not limited to such <em>homogeneous</em> data:
        an equally powerful use of graphs is to provide a consistent way of storing completely different
        types of objects in a single datastore. For example, Facebook maintains a single graph with many
        different types of vertices and edges: vertices represent people, locations, events, checkins, and
        comments made by users; edges indicate which people are friends with each other, which checkin
        happened in which location, who commented on which post, who attended which event, and so on
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Bronson2013ud-marker" href="ch02.html#Bronson2013ud">35</a>].</p>
        
        <p><a data-type="indexterm" data-primary="graphs" data-secondary="as data models" data-tertiary="example of graph-structured data" id="idm45085124028640"></a>
        In this section we will use the example shown in <a data-type="xref" href="#fig_datamodels_graph">Figure&nbsp;2-5</a>. It could be taken from a
        social network or a genealogical database: it shows two people, Lucy from Idaho and Alain from
        Beaune, France. They are married and living in London.</p>
        
        <figure><div id="fig_datamodels_graph" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/ddia_0205.png" alt="ddia 0205" width="2880" height="1731">
        <h6><span class="label">Figure 2-5. </span>Example of graph-structured data (boxes represent vertices, arrows represent edges).</h6>
        </div></figure>
        
        <p><a data-type="indexterm" data-primary="Neo4j (database)" data-secondary="graph data model" id="idm45085124023968"></a>
        <a data-type="indexterm" data-primary="Titan (database)" id="idm45085124022672"></a>
        <a data-type="indexterm" data-primary="InfiniteGraph (database)" id="idm45085124021840"></a>
        <a data-type="indexterm" data-primary="Datomic (database)" data-secondary="data model" id="idm45085124021040"></a>
        <a data-type="indexterm" data-primary="AllegroGraph (database)" id="idm45085124019936"></a>
        <a data-type="indexterm" data-primary="Gremlin (graph query language)" id="idm45085124019104"></a>
        There are several different, but related, ways of structuring and querying data in graphs. In this
        section we will discuss the <em>property graph</em> model (implemented by Neo4j, Titan, and InfiniteGraph) and
        the <em>triple-store</em> model (implemented by Datomic, AllegroGraph, and others). We will look at three
        declarative query languages for graphs: Cypher, SPARQL, and Datalog. Similar concepts appear in
        other graph query languages such as Gremlin
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Gremlin2013-marker" href="ch02.html#Gremlin2013">36</a>]
        and graph processing frameworks like Pregel (see <a data-type="xref" href="ch10.html#ch_batch">Chapter&nbsp;10</a>).</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Property Graphs"><div class="sect2" id="idm45085124014096">
        <h2>Property Graphs</h2>
        
        <p><a data-type="indexterm" data-primary="property graphs" id="idm45085124012496"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="as data models" data-tertiary="property graphs" id="idm45085124011664"></a>
        <a data-type="indexterm" data-primary="data models" data-secondary="graph-like models" data-tertiary="property graphs" id="idm45085124010288"></a>
        <a data-type="indexterm" data-primary="vertices (in graphs)" data-secondary="property graph model" id="idm45085124008912"></a>
        In the property graph model, each vertex consists of:</p>
        
        <ul>
        <li>
        <p>A unique identifier</p>
        </li>
        <li>
        <p>A set of outgoing edges</p>
        </li>
        <li>
        <p>A set of incoming edges</p>
        </li>
        <li>
        <p>A collection of properties (key-value pairs)</p>
        </li>
        </ul>
        
        <p><a data-type="indexterm" data-primary="edges (in graphs)" data-secondary="property graph model" id="idm45085124003488"></a>
        Each edge consists of:</p>
        
        <ul>
        <li>
        <p>A unique identifier</p>
        </li>
        <li>
        <p>The vertex at which the edge starts (the <em>tail vertex</em>)</p>
        </li>
        <li>
        <p>The vertex at which the edge ends (the <em>head vertex</em>)</p>
        </li>
        <li>
        <p>A label to describe the kind of relationship between the two vertices</p>
        </li>
        <li>
        <p>A collection of properties (key-value pairs)</p>
        </li>
        </ul>
        
        <p><a data-type="indexterm" data-primary="tail vertex (property graphs)" id="idm45085123996176"></a>
        <a data-type="indexterm" data-primary="head vertex (property graphs)" id="idm45085123995184"></a>
        <a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="representing graphs" id="idm45085123994336"></a>
        You can think of a graph store as consisting of two relational tables, one for vertices and one for
        edges, as shown in <a data-type="xref" href="#fig_graph_sql_schema">Example&nbsp;2-2</a> (this schema uses the PostgreSQL <code>json</code> datatype to
        store the properties of each vertex or edge). The head and tail vertex are stored for each edge; if
        you want the set of incoming or outgoing edges for a vertex, you can query the <code>edges</code> table by
        <code>head_vertex</code> or <code>tail_vertex</code>, respectively.</p>
        <div id="fig_graph_sql_schema" data-type="example">
        <h5><span class="label">Example 2-2. </span>Representing a property graph using a relational schema</h5>
        
        <pre data-type="programlisting" data-code-language="sql"><code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">vertices</code> <code class="p">(</code>
            <code class="n">vertex_id</code>   <code class="nb">integer</code> <code class="k">PRIMARY</code> <code class="k">KEY</code><code class="p">,</code>
            <code class="n">properties</code>  <code class="n">json</code>
        <code class="p">);</code>
        
        <code class="k">CREATE</code> <code class="k">TABLE</code> <code class="n">edges</code> <code class="p">(</code>
            <code class="n">edge_id</code>     <code class="nb">integer</code> <code class="k">PRIMARY</code> <code class="k">KEY</code><code class="p">,</code>
            <code class="n">tail_vertex</code> <code class="nb">integer</code> <code class="k">REFERENCES</code> <code class="n">vertices</code> <code class="p">(</code><code class="n">vertex_id</code><code class="p">),</code>
            <code class="n">head_vertex</code> <code class="nb">integer</code> <code class="k">REFERENCES</code> <code class="n">vertices</code> <code class="p">(</code><code class="n">vertex_id</code><code class="p">),</code>
            <code class="n">label</code>       <code class="nb">text</code><code class="p">,</code>
            <code class="n">properties</code>  <code class="n">json</code>
        <code class="p">);</code>
        
        <code class="k">CREATE</code> <code class="k">INDEX</code> <code class="n">edges_tails</code> <code class="k">ON</code> <code class="n">edges</code> <code class="p">(</code><code class="n">tail_vertex</code><code class="p">);</code>
        <code class="k">CREATE</code> <code class="k">INDEX</code> <code class="n">edges_heads</code> <code class="k">ON</code> <code class="n">edges</code> <code class="p">(</code><code class="n">head_vertex</code><code class="p">);</code></pre></div>
        
        <p>Some important aspects of this model are:</p>
        <ol>
        <li>
        <p>Any vertex can have an edge connecting it with any other vertex. There is no schema that
        restricts which kinds of things can or cannot be associated.</p>
        </li>
        <li>
        <p>Given any vertex, you can efficiently find both its incoming and its outgoing edges, and thus
        <em>traverse</em> the graph—i.e., follow a path through a chain of vertices—both forward and backward.
        (That’s why <a data-type="xref" href="#fig_graph_sql_schema">Example&nbsp;2-2</a> has indexes on both the <code>tail_vertex</code> and <code>head_vertex</code>
        columns.)</p>
        </li>
        <li>
        <p>By using different labels for different kinds of relationships, you can store several different
        kinds of information in a single graph, while still maintaining a clean data model.</p>
        </li>
        
        </ol>
        
        <p>Those features give graphs a great deal of flexibility for data modeling, as illustrated in
        <a data-type="xref" href="#fig_datamodels_graph">Figure&nbsp;2-5</a>. The figure shows a few things that would be difficult to express in a
        traditional relational schema, such as different kinds of regional structures in different countries
        (France has <em>départements</em> and <em>régions</em>, whereas the US has <em>counties</em> and <em>states</em>), quirks of
        history such as a country within a country (ignoring for now the intricacies of sovereign states and
        nations), and varying granularity of data (Lucy’s current residence is specified as a city, whereas
        her place of birth is specified only at the level of a state).</p>
        
        <p>You could imagine extending the graph to also include many other facts about Lucy and Alain, or
        other people. For instance, you could use it to indicate any food allergies they have (by
        introducing a vertex for each allergen, and an edge between a person and an allergen to indicate an
        allergy), and link the allergens with a set of vertices that show which foods contain which
        substances. Then you could write a query to find out what is safe for each person to eat.
        <a data-type="indexterm" data-primary="evolvability" data-secondary="graph-structured data" id="idm45085123880416"></a>
        Graphs are good for evolvability: as you add features to your application, a graph can easily be
        extended to accommodate changes in your application’s data structures.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="The Cypher Query Language"><div class="sect2" id="idm45085124013472">
        <h2>The Cypher Query Language</h2>
        
        <p><a data-type="indexterm" data-primary="Cypher (query language)" id="idm45085123877584"></a>
        <a data-type="indexterm" data-primary="property graphs" data-secondary="Cypher query language" id="idm45085123876528"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="query languages" data-tertiary="Cypher" id="idm45085123875424"></a>
        <a data-type="indexterm" data-primary="query languages" data-secondary="Cypher" id="idm45085123874048"></a>
        <a data-type="indexterm" data-primary="declarative languages" data-secondary="Cypher" id="idm45085123872944"></a>
        <a data-type="indexterm" data-primary="Neo4j (database)" data-secondary="Cypher query language" id="idm45085123871840"></a>
        <em>Cypher</em> is a declarative query language for property graphs, created for the Neo4j graph database
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Neo4j2013-marker" href="ch02.html#Neo4j2013">37</a>]. (It is named after a character in the movie <em>The Matrix</em>
        and is not related to ciphers in cryptography [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="EifremTweet-marker" href="ch02.html#EifremTweet">38</a>].)</p>
        
        <p><a data-type="xref" href="#fig_cypher_create">Example&nbsp;2-3</a> shows the Cypher query to insert the lefthand portion of
        <a data-type="xref" href="#fig_datamodels_graph">Figure&nbsp;2-5</a> into a graph database. The rest of the graph can be added similarly and is
        omitted for readability. Each vertex is given a symbolic name like <code>USA</code> or <code>Idaho</code>, and other parts
        of the query can use those names to create edges between the vertices, using an arrow notation:
        <code>(Idaho) -[:WITHIN]-&gt; (USA)</code> creates an edge labeled <code>WITHIN</code>, with <code>Idaho</code> as the tail node and <code>USA</code>
        as the head node.</p>
        <div id="fig_cypher_create" data-type="example">
        <h5><span class="label">Example 2-3. </span>A subset of the data in <a data-type="xref" href="#fig_datamodels_graph">Figure&nbsp;2-5</a>, represented as a Cypher query</h5>
        
        <pre data-type="programlisting" data-code-language="cypher"><code class="k">CREATE</code><code class="n"></code>
        <code class="n">  (NAmerica:Location {name:</code><code class="s1">'North America'</code><code class="n">, </code><code class="nf">type</code><code class="n">:</code><code class="s1">'continent'</code><code class="n">}),</code>
        <code class="n">  (USA:Location      {name:</code><code class="s1">'United States'</code><code class="n">, </code><code class="nf">type</code><code class="n">:</code><code class="s1">'country'</code><code class="n">  }),</code>
        <code class="n">  (Idaho:Location    {name:</code><code class="s1">'Idaho'</code><code class="n">,         </code><code class="nf">type</code><code class="n">:</code><code class="s1">'state'</code><code class="n">    }),</code>
        <code class="n">  (Lucy:Person       {name:</code><code class="s1">'Lucy'</code><code class="n"> }),</code>
        <code class="n">  (Idaho) -[:WITHIN]-&gt;  (USA)  -[:WITHIN]-&gt; (NAmerica),</code>
        <code class="n">  (Lucy)  -[:BORN_IN]-&gt; (Idaho)</code></pre></div>
        
        <p>When all the vertices and edges of <a data-type="xref" href="#fig_datamodels_graph">Figure&nbsp;2-5</a> are added to the database, we can start
        asking interesting questions: for example, <em>find the names of all the people who emigrated from the
        United States to Europe</em>. To be more precise, here we want to find all the vertices that have a <code>BORN_IN</code> edge to a
        location within the US, and also a <code>LIVING_IN</code> edge to a location within Europe, and return the
        <code>name</code> property of each of those vertices.</p>
        
        <p><a data-type="xref" href="#fig_cypher_query">Example&nbsp;2-4</a> shows how to express that query in Cypher. The same arrow notation is used in a
        <code>MATCH</code> clause to find patterns in the graph: <code>(person) -[:BORN_IN]-&gt; ()</code> matches any two vertices
        that are related by an edge labeled <code>BORN_IN</code>. The tail vertex of that edge is bound to the
        variable <code>person</code>, and the head vertex is left unnamed.</p>
        <div id="fig_cypher_query" data-type="example">
        <h5><span class="label">Example 2-4. </span>Cypher query to find people who emigrated from the US to Europe</h5>
        
        <pre data-type="programlisting" data-code-language="cypher"><code class="k">MATCH</code><code class="n"></code>
        <code class="n">  (person) -[:BORN_IN]-&gt;  () -[:WITHIN*0..]-&gt; (us:Location {name:</code><code class="s1">'United States'</code><code class="n">}),</code>
        <code class="n">  (person) -[:LIVES_IN]-&gt; () -[:WITHIN*0..]-&gt; (eu:Location {name:</code><code class="s1">'Europe'</code><code class="n">})</code>
        <code class="k">RETURN </code><code class="n">person.name</code></pre></div>
        
        <p>The query can be read as follows:</p>
        <blockquote>
        <p>Find any vertex (call it <code>person</code>) that meets <em>both</em> of the
        following conditions:</p>
        <ol>
        <li>
        <p><code>person</code> has an outgoing <code>BORN_IN</code> edge to some vertex. From that vertex, you can follow a chain
        of outgoing <code>WITHIN</code> edges until eventually you reach a vertex of type <code>Location</code>, whose <code>name</code>
        property is equal to <code>"United States"</code>.</p>
        </li>
        <li>
        <p>That same <code>person</code> vertex also has an outgoing <code>LIVES_IN</code> edge. Following that edge, and then a
        chain of outgoing <code>WITHIN</code> edges, you eventually reach a vertex of type <code>Location</code>, whose <code>name</code>
        property is equal to <code>"Europe"</code>.</p>
        </li>
        
        </ol>
        
        <p>For each such <code>person</code> vertex, return the <code>name</code> property.</p></blockquote>
        
        <p>There are several possible ways of executing the query. The description given here suggests that you
        start by scanning all the people in the database, examine each person’s birthplace and residence,
        and return only those people who meet the criteria.</p>
        
        <p>But equivalently, you could start with the two <code>Location</code> vertices and work backward. If there is
        an index on the <code>name</code> property, you can probably efficiently find the two vertices representing the
        US and Europe. Then you can proceed to find all locations (states, regions, cities, etc.) in the US
        and Europe respectively by following all incoming <code>WITHIN</code> edges. Finally, you can look for people
        who can be found through an incoming <code>BORN_IN</code> or <code>LIVES_IN</code> edge at one of the location vertices.</p>
        
        <p>As is typical for a declarative query language, you don’t need to specify such execution details when
        writing the query: the query optimizer automatically chooses the strategy that is predicted to be
        the most efficient, so you can get on with writing the rest of your application.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Graph Queries in SQL"><div class="sect2" id="idm45085123878528">
        <h2>Graph Queries in SQL</h2>
        
        <p><a data-type="indexterm" data-primary="SQL (Structured Query Language)" data-secondary="graph queries in" id="idm45085123742224"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="query languages" data-tertiary="recursive SQL queries" id="idm45085123740928"></a>
        <a data-type="indexterm" data-primary="declarative languages" data-secondary="recursive SQL queries" id="idm45085123739552"></a>
        <a data-type="indexterm" data-primary="query languages" data-secondary="recursive SQL queries" id="idm45085123738448"></a>
        <a data-type="indexterm" data-primary="relational data model" data-secondary="graph queries in SQL" id="idm45085123737344"></a>
        <a data-type="xref" href="#fig_graph_sql_schema">Example&nbsp;2-2</a> suggested that graph data can be represented in a relational database. But
        if we put graph data in a relational structure, can we also query it using SQL?</p>
        
        <p>The answer is yes, but with some difficulty. In a relational database, you usually know in advance
        which joins you need in your query. In a graph query, you may need to traverse a variable number of
        edges before you find the vertex you’re looking for—that is, the number of joins is not fixed in
        advance.</p>
        
        <p>In our example, that happens in the <code>() -[:WITHIN*0..]-&gt; ()</code> rule in the Cypher query. A person’s
        <code>LIVES_IN</code> edge may point at any kind of location: a street, a city, a district, a region, a state,
        etc. A city may be <code>WITHIN</code> a region, a region <code>WITHIN</code> a state, a state <code>WITHIN</code> a country, etc.
        The <code>LIVES_IN</code> edge may point directly at the location vertex you’re looking for, or it may be
        several levels removed in the location hierarchy.</p>
        
        <p>In Cypher, <code>:WITHIN*0..</code> expresses that fact very concisely: it means “follow a <code>WITHIN</code> edge, zero
        or more times.” It is like the <code>*</code> operator in a regular expression.</p>
        
        <p><a data-type="indexterm" data-primary="recursive common table expressions (SQL)" id="idm45085123729232"></a>
        <a data-type="indexterm" data-primary="WITH RECURSIVE syntax (SQL)" id="idm45085123728176"></a>
        <a data-type="indexterm" data-primary="PostgreSQL (database)" data-secondary="recursive query support" id="idm45085123727328"></a>
        <a data-type="indexterm" data-primary="IBM" data-secondary="DB2 (database)" data-tertiary="recursive query support" id="idm45085123726224"></a>
        <a data-type="indexterm" data-primary="Oracle (database)" data-secondary="recursive query support" id="idm45085123724848"></a>
        <a data-type="indexterm" data-primary="SQL Server (database)" data-secondary="recursive query support" id="idm45085123723744"></a>
        <a data-type="indexterm" data-primary="Microsoft" data-secondary="SQL Server" data-see="SQL Server" id="idm45085123722640"></a>
        Since SQL:1999, this idea of variable-length traversal paths in a query can be expressed using
        something called <em>recursive common table expressions</em> (the <code>WITH RECURSIVE</code> syntax).
        <a data-type="xref" href="#fig_graph_sql_query">Example&nbsp;2-5</a> shows the same query—finding the names of people who emigrated from the
        US to Europe—expressed in SQL using this technique (supported in PostgreSQL, IBM DB2, Oracle, and
        SQL Server). However, the syntax is very clumsy in comparison to Cypher.</p>
        <div id="fig_graph_sql_query" data-type="example">
        <h5><span class="label">Example 2-5. </span>The same query as <a data-type="xref" href="#fig_cypher_query">Example&nbsp;2-4</a>, written in SQL using recursive common table expressions</h5>
        
        <pre data-type="programlisting" data-code-language="sql"><code class="k">WITH</code><code> </code><code class="k">RECURSIVE</code><code>
        
          </code><code class="c1">-- in_usa is the set of vertex IDs of all locations within the United States
        </code><code>  </code><code class="n">in_usa</code><code class="p">(</code><code class="n">vertex_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="p">(</code><code>
              </code><code class="k">SELECT</code><code> </code><code class="n">vertex_id</code><code> </code><code class="k">FROM</code><code> </code><code class="n">vertices</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">properties</code><code class="o">-</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="s1">'name'</code><code> </code><code class="o">=</code><code> </code><code class="s1">'United States'</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO4-1" href="#callout_data_models_and_query_languages_CO4-1"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/1.png" alt="1" width="12" height="12"></a><code>
            </code><code class="k">UNION</code><code>
              </code><code class="k">SELECT</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">tail_vertex</code><code> </code><code class="k">FROM</code><code> </code><code class="n">edges</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO4-2" href="#callout_data_models_and_query_languages_CO4-2"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/2.png" alt="2" width="12" height="12"></a><code>
                </code><code class="k">JOIN</code><code> </code><code class="n">in_usa</code><code> </code><code class="k">ON</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">head_vertex</code><code> </code><code class="o">=</code><code> </code><code class="n">in_usa</code><code class="p">.</code><code class="n">vertex_id</code><code>
                </code><code class="k">WHERE</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">label</code><code> </code><code class="o">=</code><code> </code><code class="s1">'within'</code><code>
          </code><code class="p">)</code><code class="p">,</code><code>
        
          </code><code class="c1">-- in_europe is the set of vertex IDs of all locations within Europe
        </code><code>  </code><code class="n">in_europe</code><code class="p">(</code><code class="n">vertex_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="p">(</code><code>
              </code><code class="k">SELECT</code><code> </code><code class="n">vertex_id</code><code> </code><code class="k">FROM</code><code> </code><code class="n">vertices</code><code> </code><code class="k">WHERE</code><code> </code><code class="n">properties</code><code class="o">-</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="s1">'name'</code><code> </code><code class="o">=</code><code> </code><code class="s1">'Europe'</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO4-3" href="#callout_data_models_and_query_languages_CO4-3"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/3.png" alt="3" width="12" height="12"></a><code>
            </code><code class="k">UNION</code><code>
              </code><code class="k">SELECT</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">tail_vertex</code><code> </code><code class="k">FROM</code><code> </code><code class="n">edges</code><code>
                </code><code class="k">JOIN</code><code> </code><code class="n">in_europe</code><code> </code><code class="k">ON</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">head_vertex</code><code> </code><code class="o">=</code><code> </code><code class="n">in_europe</code><code class="p">.</code><code class="n">vertex_id</code><code>
                </code><code class="k">WHERE</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">label</code><code> </code><code class="o">=</code><code> </code><code class="s1">'within'</code><code>
          </code><code class="p">)</code><code class="p">,</code><code>
        
          </code><code class="c1">-- born_in_usa is the set of vertex IDs of all people born in the US
        </code><code>  </code><code class="n">born_in_usa</code><code class="p">(</code><code class="n">vertex_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="p">(</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO4-4" href="#callout_data_models_and_query_languages_CO4-4"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/4.png" alt="4" width="12" height="12"></a><code>
            </code><code class="k">SELECT</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">tail_vertex</code><code> </code><code class="k">FROM</code><code> </code><code class="n">edges</code><code>
              </code><code class="k">JOIN</code><code> </code><code class="n">in_usa</code><code> </code><code class="k">ON</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">head_vertex</code><code> </code><code class="o">=</code><code> </code><code class="n">in_usa</code><code class="p">.</code><code class="n">vertex_id</code><code>
              </code><code class="k">WHERE</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">label</code><code> </code><code class="o">=</code><code> </code><code class="s1">'born_in'</code><code>
          </code><code class="p">)</code><code class="p">,</code><code>
        
          </code><code class="c1">-- lives_in_europe is the set of vertex IDs of all people living in Europe
        </code><code>  </code><code class="n">lives_in_europe</code><code class="p">(</code><code class="n">vertex_id</code><code class="p">)</code><code> </code><code class="k">AS</code><code> </code><code class="p">(</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO4-5" href="#callout_data_models_and_query_languages_CO4-5"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/5.png" alt="5" width="12" height="12"></a><code>
            </code><code class="k">SELECT</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">tail_vertex</code><code> </code><code class="k">FROM</code><code> </code><code class="n">edges</code><code>
              </code><code class="k">JOIN</code><code> </code><code class="n">in_europe</code><code> </code><code class="k">ON</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">head_vertex</code><code> </code><code class="o">=</code><code> </code><code class="n">in_europe</code><code class="p">.</code><code class="n">vertex_id</code><code>
              </code><code class="k">WHERE</code><code> </code><code class="n">edges</code><code class="p">.</code><code class="n">label</code><code> </code><code class="o">=</code><code> </code><code class="s1">'lives_in'</code><code>
          </code><code class="p">)</code><code>
        
        </code><code class="k">SELECT</code><code> </code><code class="n">vertices</code><code class="p">.</code><code class="n">properties</code><code class="o">-</code><code class="o">&gt;</code><code class="o">&gt;</code><code class="s1">'name'</code><code>
        </code><code class="k">FROM</code><code> </code><code class="n">vertices</code><code>
        </code><code class="c1">-- join to find those people who were both born in the US *and* live in Europe
        </code><code class="k">JOIN</code><code> </code><code class="n">born_in_usa</code><code>     </code><code class="k">ON</code><code> </code><code class="n">vertices</code><code class="p">.</code><code class="n">vertex_id</code><code> </code><code class="o">=</code><code> </code><code class="n">born_in_usa</code><code class="p">.</code><code class="n">vertex_id</code><code> </code><a class="co" id="co_data_models_and_query_languages_CO4-6" href="#callout_data_models_and_query_languages_CO4-6"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/6.png" alt="6" width="12" height="12"></a><code>
        </code><code class="k">JOIN</code><code> </code><code class="n">lives_in_europe</code><code> </code><code class="k">ON</code><code> </code><code class="n">vertices</code><code class="p">.</code><code class="n">vertex_id</code><code> </code><code class="o">=</code><code> </code><code class="n">lives_in_europe</code><code class="p">.</code><code class="n">vertex_id</code><code class="p">;</code></pre>
        <dl class="calloutlist">
        <dt><a class="co" id="callout_data_models_and_query_languages_CO4-1" href="#co_data_models_and_query_languages_CO4-1"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/1.png" alt="1" width="12" height="12"></a></dt>
        <dd><p>First find the vertex whose <code>name</code> property has the value <code>"United States"</code>, and make it the first element of the set
        of vertices <code>in_usa</code>.</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO4-2" href="#co_data_models_and_query_languages_CO4-2"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/2.png" alt="2" width="12" height="12"></a></dt>
        <dd><p>Follow all incoming <code>within</code> edges from vertices in the set <code>in_usa</code>, and add them to the same
        set, until all incoming <code>within</code> edges have been visited.</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO4-3" href="#co_data_models_and_query_languages_CO4-3"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/3.png" alt="3" width="12" height="12"></a></dt>
        <dd><p>Do the same starting with the vertex whose <code>name</code> property has the value <code>"Europe"</code>, and build up
        the set of vertices <code>in_europe</code>.</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO4-4" href="#co_data_models_and_query_languages_CO4-4"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/4.png" alt="4" width="12" height="12"></a></dt>
        <dd><p>For each of the vertices in the set <code>in_usa</code>, follow incoming <code>born_in</code> edges to find people
        who were born in some place within the United States.</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO4-5" href="#co_data_models_and_query_languages_CO4-5"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/5.png" alt="5" width="12" height="12"></a></dt>
        <dd><p>Similarly, for each of the vertices in the set <code>in_europe</code>, follow incoming <code>lives_in</code> edges to find people who live in Europe.</p></dd>
        <dt><a class="co" id="callout_data_models_and_query_languages_CO4-6" href="#co_data_models_and_query_languages_CO4-6"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/6.png" alt="6" width="12" height="12"></a></dt>
        <dd><p>Finally, intersect the set of people born in the USA with the set of people living in Europe, by
        joining them.</p></dd>
        </dl></div>
        
        <p>If the same query can be written in 4 lines in one query language but requires 29 lines in
        another, that just shows that different data models are designed to satisfy different use cases.
        It’s important to pick a data model that is suitable for your application.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Triple-Stores and SPARQL"><div class="sect2" id="idm45085123457104">
        <h2>Triple-Stores and SPARQL</h2>
        
        <p><a data-type="indexterm" data-primary="data models" data-secondary="graph-like models" data-tertiary="RDF and triple-stores" id="ix_DMgraphtriple"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="as data models" data-tertiary="RDF and triple-stores" id="ix_graphDMtriple"></a>
        <a data-type="indexterm" data-primary="triple-stores" id="ix_triplest"></a>
        The triple-store model is mostly equivalent to the property graph model, using different words to
        describe the same ideas. It is nevertheless worth discussing, because there are various tools and
        languages for triple-stores that can be valuable additions to your toolbox for building
        applications.</p>
        
        <p><a data-type="indexterm" data-primary="subjects, predicates, and objects (in triple-stores)" id="idm45085123386800"></a>
        In a triple-store, all information is stored in the form of very simple three-part statements:
        (<em>subject</em>, <em>predicate</em>, <em>object</em>). For example, in the triple (<em>Jim</em>, <em>likes</em>, <em>bananas</em>), <em>Jim</em> is
        the subject, <em>likes</em> is the predicate (verb), and <em>bananas</em> is the object.</p>
        
        <p>The subject of a triple is equivalent to a vertex in a graph. The object is one of two things:</p>
        <ol>
        <li>
        <p>A value in a primitive datatype, such as a string or a number. In that case,
        the predicate and object of the triple are equivalent to the key and value of a property on the
        subject vertex. For example, (<em>lucy</em>, <em>age</em>, <em>33</em>) is like a vertex <code>lucy</code> with properties
        <code>{"age":33}</code>.</p>
        </li>
        <li>
        <p>Another vertex in the graph. In that case, the predicate is an edge in the
        graph, the subject is the tail vertex, and the object is the head vertex. For example, in
        (<em>lucy</em>, <em>marriedTo</em>, <em>alain</em>) the subject and object <em>lucy</em> and <em>alain</em> are both vertices, and
        the predicate <em>marriedTo</em> is the label of the edge that connects them.</p>
        </li>
        
        </ol>
        
        <p><a data-type="indexterm" data-primary="Turtle (RDF data format)" id="idm45085123373440"></a>
        <a data-type="indexterm" data-primary="Notation3 (N3)" id="idm45085123372448"></a>
        <a data-type="xref" href="#fig_graph_n3_triples">Example&nbsp;2-6</a> shows the same data as in <a data-type="xref" href="#fig_cypher_create">Example&nbsp;2-3</a>, written as
        triples in a format called <em>Turtle</em>, a subset of <em>Notation3</em> (<em>N3</em>)
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Beckett2011vq-marker" href="ch02.html#Beckett2011vq">39</a>].</p>
        <div id="fig_graph_n3_triples" data-type="example">
        <h5><span class="label">Example 2-6. </span>A subset of the data in <a data-type="xref" href="#fig_datamodels_graph">Figure&nbsp;2-5</a>, represented as Turtle triples</h5>
        
        <pre data-type="programlisting">@prefix : &lt;urn:example:&gt;.
        _:lucy     a       :Person.
        _:lucy     :name   "Lucy".
        _:lucy     :bornIn _:idaho.
        _:idaho    a       :Location.
        _:idaho    :name   "Idaho".
        _:idaho    :type   "state".
        _:idaho    :within _:usa.
        _:usa      a       :Location.
        _:usa      :name   "United States".
        _:usa      :type   "country".
        _:usa      :within _:namerica.
        _:namerica a       :Location.
        _:namerica :name   "North America".
        _:namerica :type   "continent".</pre></div>
        
        <p>In this example, vertices of the graph are written as <code>_:<em>someName</em></code>. The name doesn’t mean anything
        outside of this file; it exists only because we otherwise wouldn’t know which triples refer to the
        same vertex. When the predicate represents an edge, the object is a vertex, as in <code>_:idaho :within
        _:usa</code>.  When the predicate is a property, the object is a string literal, as in <code>_:usa :name
        "United States"</code>.</p>
        
        <p>It’s quite repetitive to repeat the same subject over and over again, but fortunately you can use
        semicolons to say multiple things about the same subject. This makes the Turtle format quite nice
        and readable: see <a data-type="xref" href="#fig_graph_n3_shorthand">Example&nbsp;2-7</a>.</p>
        <div id="fig_graph_n3_shorthand" data-type="example">
        <h5><span class="label">Example 2-7. </span>A more concise way of writing the data in <a data-type="xref" href="#fig_graph_n3_triples">Example&nbsp;2-6</a></h5>
        
        <pre data-type="programlisting">@prefix : &lt;urn:example:&gt;.
        _:lucy     a :Person;   :name "Lucy";          :bornIn _:idaho.
        _:idaho    a :Location; :name "Idaho";         :type "state";   :within _:usa.
        _:usa      a :Location; :name "United States"; :type "country"; :within _:namerica.
        _:namerica a :Location; :name "North America"; :type "continent".</pre></div>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="The semantic web"><div class="sect3" id="idm45085123356880">
        <h3>The semantic web</h3>
        
        <p><a data-type="indexterm" data-primary="semantic web" id="idm45085123355472"></a>
        <a data-type="indexterm" data-primary="Datomic (database)" data-secondary="data model" id="idm45085123354640"></a>
        If you read more about triple-stores, you may get sucked into a maelstrom of articles written about
        the <em>semantic web</em>. The triple-store data model is completely independent of the semantic web—for
        example, Datomic
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Datomic2013-marker" href="ch02.html#Datomic2013">40</a>]
        is a triple-store that does not claim to have anything to do with
        it.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm45085123351264-marker" href="ch02.html#idm45085123351264">vii</a></sup>
        But since the two are so closely linked in many people’s minds, we should discuss them briefly.</p>
        
        <p><a data-type="indexterm" data-primary="RDF (Resource Description Framework)" id="idm45085123349872"></a>
        The semantic web is fundamentally a simple and reasonable idea: websites already publish information
        as text and pictures for humans to read, so why don’t they also publish information as
        machine-readable data for computers to read? The <em>Resource Description Framework</em> (RDF)
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="W3CRDF-marker" href="ch02.html#W3CRDF">41</a>] was intended as a mechanism for different websites
        to publish data in a consistent format, allowing data from different websites to be automatically
        combined into a <em>web of data</em>—a kind of internet-wide “database of everything.”</p>
        
        <p>Unfortunately, the semantic web was overhyped in the early 2000s but so far hasn’t shown any sign
        of being realized in practice, which has made many people cynical about it. It has also suffered
        from a dizzying plethora of acronyms, overly complex standards proposals, and hubris.</p>
        
        <p>However, if you look past those failings, there is also a lot of good work that has come out of the
        semantic web project. Triples can be a good internal data model for applications, even if you have
        no interest in publishing RDF data on the semantic web.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="The RDF data model"><div class="sect3" id="idm45085123344192">
        <h3>The RDF data model</h3>
        
        <p><a data-type="indexterm" data-primary="Jena (RDF framework)" id="idm45085123342912"></a><a data-type="indexterm" data-primary="Apache Jena" data-see="Jena" id="idm45085123342016"></a>
        <a data-type="indexterm" data-primary="XML" data-secondary="encoding RDF data" id="idm45085123340944"></a>
        The Turtle language we used in <a data-type="xref" href="#fig_graph_n3_shorthand">Example&nbsp;2-7</a> is a human-readable format for RDF data.
        Sometimes RDF is also written in an XML format, which does the same thing much more verbosely—see
        <a data-type="xref" href="#fig_graph_rdf_xml">Example&nbsp;2-8</a>. Turtle/N3 is preferable as it is much easier on the eyes, and tools like
        Apache Jena
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Jena2013-marker" href="ch02.html#Jena2013">42</a>]
        can automatically convert between different RDF formats if necessary.</p>
        <div id="fig_graph_rdf_xml" data-type="example">
        <h5><span class="label">Example 2-8. </span>The data of <a data-type="xref" href="#fig_graph_n3_shorthand">Example&nbsp;2-7</a>, expressed using RDF/XML syntax</h5>
        
        <pre data-type="programlisting" data-code-language="xml"><code class="nt">&lt;rdf:RDF</code> <code class="na">xmlns=</code><code class="s">"urn:example:"</code>
            <code class="na">xmlns:rdf=</code><code class="s">"http://www.w3.org/1999/02/22-rdf-syntax-ns#"</code><code class="nt">&gt;</code>
        
          <code class="nt">&lt;Location</code> <code class="na">rdf:nodeID=</code><code class="s">"idaho"</code><code class="nt">&gt;</code>
            <code class="nt">&lt;name&gt;</code>Idaho<code class="nt">&lt;/name&gt;</code>
            <code class="nt">&lt;type&gt;</code>state<code class="nt">&lt;/type&gt;</code>
            <code class="nt">&lt;within&gt;</code>
              <code class="nt">&lt;Location</code> <code class="na">rdf:nodeID=</code><code class="s">"usa"</code><code class="nt">&gt;</code>
                <code class="nt">&lt;name&gt;</code>United States<code class="nt">&lt;/name&gt;</code>
                <code class="nt">&lt;type&gt;</code>country<code class="nt">&lt;/type&gt;</code>
                <code class="nt">&lt;within&gt;</code>
                  <code class="nt">&lt;Location</code> <code class="na">rdf:nodeID=</code><code class="s">"namerica"</code><code class="nt">&gt;</code>
                    <code class="nt">&lt;name&gt;</code>North America<code class="nt">&lt;/name&gt;</code>
                    <code class="nt">&lt;type&gt;</code>continent<code class="nt">&lt;/type&gt;</code>
                  <code class="nt">&lt;/Location&gt;</code>
                <code class="nt">&lt;/within&gt;</code>
              <code class="nt">&lt;/Location&gt;</code>
            <code class="nt">&lt;/within&gt;</code>
          <code class="nt">&lt;/Location&gt;</code>
        
          <code class="nt">&lt;Person</code> <code class="na">rdf:nodeID=</code><code class="s">"lucy"</code><code class="nt">&gt;</code>
            <code class="nt">&lt;name&gt;</code>Lucy<code class="nt">&lt;/name&gt;</code>
            <code class="nt">&lt;bornIn</code> <code class="na">rdf:nodeID=</code><code class="s">"idaho"</code><code class="nt">/&gt;</code>
          <code class="nt">&lt;/Person&gt;</code>
        <code class="nt">&lt;/rdf:RDF&gt;</code></pre></div>
        
        <p>RDF has a few quirks due to the fact that it is designed for internet-wide data exchange. The
        subject, predicate, and object of a triple are often URIs. For example, a predicate might be an URI
        such as <code>&lt;http://my-company.com/namespace#within&gt;</code> or <code>&lt;http://my-company.com/namespace#lives_in&gt;</code>,
        rather than just <code>WITHIN</code> or <code>LIVES_IN</code>. The reasoning behind this design is that you should be able
        to combine your data with someone else’s data, and if they attach a different meaning to the word
        <code>within</code> or <code>lives_in</code>, you won’t get a conflict because their predicates are actually
        <code>&lt;http://other.org/foo#within&gt;</code> and <code>&lt;http://other.org/foo#lives_in&gt;</code>.</p>
        
        <p>The URL <code>&lt;http://my-company.com/namespace&gt;</code> doesn’t necessarily need to resolve to anything—from
        RDF’s point of view, it is simply a namespace. To avoid potential confusion with <code>http://</code> URLs, the
        examples in this section use non-resolvable URIs such as <code>urn:example:within</code>. Fortunately, you can
        just specify this prefix once at the top of the file, and then forget about it.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" class="pagebreak-before" data-pdf-bookmark="The SPARQL query language"><div class="sect3" id="idm45085123238544">
        <h3>The SPARQL query language</h3>
        
        <p><a data-type="indexterm" data-primary="graphs" data-secondary="query languages" data-tertiary="SPARQL" id="ix_graphDMsparql"></a>
        <a data-type="indexterm" data-primary="declarative languages" data-secondary="SPARQL" id="idm45085123234768"></a>
        <a data-type="indexterm" data-primary="query languages" data-secondary="SPARQL" id="idm45085123233664"></a>
        <a data-type="indexterm" data-primary="triple-stores" data-secondary="SPARQL query language" id="idm45085123232560"></a>
        <a data-type="indexterm" data-primary="SPARQL (query language)" id="idm45085123231456"></a>
        <a data-type="indexterm" data-primary="RDF (Resource Description Framework)" data-secondary="querying with SPARQL" id="idm45085123230624"></a>
        <a data-type="indexterm" data-primary="Cypher (query language)" data-secondary="comparison to SPARQL" id="idm45085123229504"></a>
        <em>SPARQL</em> is a query language for triple-stores using the RDF data model
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Harris2013wd-marker" href="ch02.html#Harris2013wd">43</a>].
        (It is an acronym for <em>SPARQL Protocol and RDF Query Language</em>, pronounced “sparkle.”)
        It predates Cypher, and since Cypher’s pattern matching is borrowed from SPARQL, they look quite
        similar [<a data-type="noteref" href="ch02.html#Neo4j2013">37</a>].</p>
        
        <p>The same query as before—finding people who have moved from the US to Europe—is even more concise
        in SPARQL than it is in Cypher (see <a data-type="xref" href="#fig_sparql_query">Example&nbsp;2-9</a>).</p>
        <div id="fig_sparql_query" data-type="example">
        <h5><span class="label">Example 2-9. </span>The same query as <a data-type="xref" href="#fig_cypher_query">Example&nbsp;2-4</a>, expressed in SPARQL</h5>
        
        <pre data-type="programlisting" data-code-language="ruby"><code class="no">PREFIX</code> <code class="p">:</code> <code class="o">&lt;</code><code class="ss">urn</code><code class="p">:</code><code class="ss">example</code><code class="p">:</code><code class="o">&gt;</code>
        
        <code class="no">SELECT</code> <code class="p">?</code><code class="n">personName</code> <code class="no">WHERE</code> <code class="p">{</code>
          <code class="p">?</code><code class="n">person</code> <code class="ss">:name</code> <code class="p">?</code><code class="n">personName</code><code class="o">.</code>
          <code class="p">?</code><code class="n">person</code> <code class="ss">:bornIn</code>  <code class="o">/</code> <code class="ss">:within</code><code class="o">*</code> <code class="o">/</code> <code class="ss">:name</code> <code class="s2">"United States"</code><code class="o">.</code>
          <code class="p">?</code><code class="n">person</code> <code class="ss">:livesIn</code> <code class="o">/</code> <code class="ss">:within</code><code class="o">*</code> <code class="o">/</code> <code class="ss">:name</code> <code class="s2">"Europe"</code><code class="o">.</code>
        <code class="p">}</code></pre></div>
        
        <p>The structure is very similar. The following two expressions are equivalent (variables start with a
        question mark in SPARQL):</p>
        
        <pre data-type="programlisting">(person) -[:BORN_IN]-&gt; () -[:WITHIN*0..]-&gt; (location)   # Cypher
        
        ?person :bornIn / :within* ?location.                   # SPARQL</pre>
        
        <p>Because RDF doesn’t distinguish between properties and edges but just uses predicates for both, you
        can use the same syntax for matching properties. In the following expression, the variable <code>usa</code> is
        bound to any vertex that has a <code>name</code> property whose value is the string <code>"United States"</code>:</p>
        
        <pre data-type="programlisting">(usa {name:'United States'})   # Cypher
        
        ?usa :name "United States".    # SPARQL</pre>
        
        <p>SPARQL is a nice query language—even if the semantic web never happens, it can be a powerful tool
        for applications to use internally.
        <a data-type="indexterm" data-primary="data models" data-secondary="graph-like models" data-tertiary="RDF and triple-stores" data-startref="ix_DMgraphtriple" id="idm45085123116768"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="as data models" data-tertiary="RDF and triple-stores" data-startref="ix_graphDMtriple" id="idm45085123115120"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="query languages" data-tertiary="SPARQL" data-startref="ix_graphDMsparql" id="idm45085123113472"></a>
        <a data-type="indexterm" data-primary="triple-stores" data-startref="ix_triplest" id="idm45085123111824"></a></p>
        <aside data-type="sidebar" epub:type="sidebar" class="pagebreak-before"><div class="sidebar" id="sidebar_graph_codasyl">
        <h5>Graph Databases Compared to the Network Model</h5>
        <p><a data-type="indexterm" data-primary="network model" data-secondary="graph databases versus" id="idm45085123108864"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="as data models" data-tertiary="versus the network model" id="idm45085123107760"></a>
        In <a data-type="xref" href="#sec_datamodels_codasyl">“Are Document Databases Repeating History?”</a> we discussed how CODASYL and the relational model competed to solve
        the problem of many-to-many relationships in IMS. At first glance, CODASYL’s network model looks
        similar to the graph model. Are graph databases the second coming of CODASYL in <span class="keep-together">disguise?</span></p>
        
        <p>No. They differ in several important ways:</p>
        
        <ul>
        <li>
        <p>In CODASYL, a database had a schema that specified which record type could be nested within which
        other record type. In a graph database, there is no such restriction: any vertex can have an edge
        to any other vertex. This gives much greater flexibility for applications to adapt to changing
        requirements.</p>
        </li>
        <li>
        <p><a data-type="indexterm" data-primary="access path (in network model)" id="idm45085123102096"></a>
        In CODASYL, the only way to reach a particular record was to traverse one of the access paths to
        it. In a graph database, you can refer directly to any vertex by its unique ID, or you can use an
        index to find vertices with a particular value.</p>
        </li>
        <li>
        <p>In CODASYL, the children of a record were an ordered set, so the database had to maintain that
        ordering (which had consequences for the storage layout) and applications that inserted new
        records into the database had to worry about the positions of the new records in these sets. In a
        graph database, vertices and edges are not ordered (you can only sort the results when making a
        query).</p>
        </li>
        <li>
        <p>In CODASYL, all queries were imperative, difficult to write and easily broken by changes in the
        schema. In a graph database, you can write your traversal in imperative code if you want to, but
        most graph databases also support high-level, declarative query languages such as Cypher or
        SPARQL.</p>
        </li>
        </ul>
        </div></aside>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="The Foundation: Datalog"><div class="sect2" id="idm45085123456640">
        <h2>The Foundation: Datalog</h2>
        
        <p><a data-type="indexterm" data-primary="data models" data-secondary="graph-like models" data-tertiary="Datalog language" id="ix_DMgraphDatalog"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="query languages" data-tertiary="Datalog" id="ix_graphDMDatalog"></a>
        <a data-type="indexterm" data-primary="declarative languages" data-secondary="Datalog" id="idm45085123093376"></a>
        <a data-type="indexterm" data-primary="query languages" data-secondary="Datalog" id="idm45085123092272"></a>
        <a data-type="indexterm" data-primary="Datalog (query language)" id="ix_Datalog"></a>
        <em>Datalog</em> is a much older language than SPARQL or Cypher, having been studied extensively by academics
        in the 1980s
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Green2013js-marker" href="ch02.html#Green2013js">44</a>,
        <a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Ceri1989ff-marker" href="ch02.html#Ceri1989ff">45</a>,
        <a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Abiteboul1995ug-marker" href="ch02.html#Abiteboul1995ug">46</a>].
        It is less well known among software engineers, but it is nevertheless important, because it
        provides the foundation that later query languages build upon.</p>
        
        <p><a data-type="indexterm" data-primary="Datomic (database)" data-secondary="Datalog query language" id="idm45085123081568"></a>
        <a data-type="indexterm" data-primary="Cascalog (batch processing)" id="idm45085123080496"></a>
        In practice, Datalog is used in a few data systems: for example, it is the query language of Datomic
        [<a data-type="noteref" href="ch02.html#Datomic2013">40</a>], and Cascalog
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="MarzCascalog-marker" href="ch02.html#MarzCascalog">47</a>]
        is a Datalog implementation for querying large datasets in
        Hadoop.<sup xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook"><a data-type="noteref" id="idm45085123076592-marker" href="ch02.html#idm45085123076592">viii</a></sup></p>
        
        <p>Datalog’s data model is similar to the triple-store model, generalized a bit. Instead of writing a
        triple as (<em>subject</em>, <em>predicate</em>, <em>object</em>), we write it as <em>predicate</em>(<em>subject</em>, <em>object</em>).
        <a data-type="xref" href="#fig_datalog_triples">Example&nbsp;2-10</a> shows how to write the data from our example in Datalog.</p>
        <div id="fig_datalog_triples" data-type="example">
        <h5><span class="label">Example 2-10. </span>A subset of the data in <a data-type="xref" href="#fig_datamodels_graph">Figure&nbsp;2-5</a>, represented as Datalog facts</h5>
        
        <pre data-type="programlisting" data-code-language="prolog"><code class="nf">name</code><code class="p">(</code><code class="s-Atom">namerica</code><code class="p">,</code> <code class="s-Atom">'North America'</code><code class="p">).</code>
        <code class="nf">type</code><code class="p">(</code><code class="s-Atom">namerica</code><code class="p">,</code> <code class="s-Atom">continent</code><code class="p">).</code>
        
        <code class="nf">name</code><code class="p">(</code><code class="s-Atom">usa</code><code class="p">,</code> <code class="s-Atom">'United States'</code><code class="p">).</code>
        <code class="nf">type</code><code class="p">(</code><code class="s-Atom">usa</code><code class="p">,</code> <code class="s-Atom">country</code><code class="p">).</code>
        <code class="nf">within</code><code class="p">(</code><code class="s-Atom">usa</code><code class="p">,</code> <code class="s-Atom">namerica</code><code class="p">).</code>
        
        <code class="nf">name</code><code class="p">(</code><code class="s-Atom">idaho</code><code class="p">,</code> <code class="s-Atom">'Idaho'</code><code class="p">).</code>
        <code class="nf">type</code><code class="p">(</code><code class="s-Atom">idaho</code><code class="p">,</code> <code class="s-Atom">state</code><code class="p">).</code>
        <code class="nf">within</code><code class="p">(</code><code class="s-Atom">idaho</code><code class="p">,</code> <code class="s-Atom">usa</code><code class="p">).</code>
        
        <code class="nf">name</code><code class="p">(</code><code class="s-Atom">lucy</code><code class="p">,</code> <code class="s-Atom">'Lucy'</code><code class="p">).</code>
        <code class="nf">born_in</code><code class="p">(</code><code class="s-Atom">lucy</code><code class="p">,</code> <code class="s-Atom">idaho</code><code class="p">).</code></pre></div>
        
        <p><a data-type="indexterm" data-primary="Prolog (language)" data-seealso="Datalog" id="idm45085123068032"></a>
        Now that we have defined the data, we can write the same query as before, as shown in
        <a data-type="xref" href="#fig_datalog_query">Example&nbsp;2-11</a>. It looks a bit different from the equivalent in Cypher or SPARQL, but don’t
        let that put you off. Datalog is a subset of Prolog, which you might have seen before if you’ve
        studied computer science.</p>
        <div id="fig_datalog_query" data-type="example">
        <h5><span class="label">Example 2-11. </span>The same query as <a data-type="xref" href="#fig_cypher_query">Example&nbsp;2-4</a>, expressed in Datalog</h5>
        
        <pre data-type="programlisting" data-code-language="prolog"><code class="nf">within_recursive</code><code class="p">(</code><code class="nv">Location</code><code class="p">,</code> <code class="nv">Name</code><code class="p">)</code> <code class="p">:-</code> <code class="nf">name</code><code class="p">(</code><code class="nv">Location</code><code class="p">,</code> <code class="nv">Name</code><code class="p">).</code>     <code class="cm">/* Rule 1 */</code>
        
        <code class="nf">within_recursive</code><code class="p">(</code><code class="nv">Location</code><code class="p">,</code> <code class="nv">Name</code><code class="p">)</code> <code class="p">:-</code> <code class="nf">within</code><code class="p">(</code><code class="nv">Location</code><code class="p">,</code> <code class="nv">Via</code><code class="p">),</code>    <code class="cm">/* Rule 2 */</code>
                                            <code class="nf">within_recursive</code><code class="p">(</code><code class="nv">Via</code><code class="p">,</code> <code class="nv">Name</code><code class="p">).</code>
        
        <code class="nf">migrated</code><code class="p">(</code><code class="nv">Name</code><code class="p">,</code> <code class="nv">BornIn</code><code class="p">,</code> <code class="nv">LivingIn</code><code class="p">)</code> <code class="p">:-</code> <code class="nf">name</code><code class="p">(</code><code class="nv">Person</code><code class="p">,</code> <code class="nv">Name</code><code class="p">),</code>       <code class="cm">/* Rule 3 */</code>
                                            <code class="nf">born_in</code><code class="p">(</code><code class="nv">Person</code><code class="p">,</code> <code class="nv">BornLoc</code><code class="p">),</code>
                                            <code class="nf">within_recursive</code><code class="p">(</code><code class="nv">BornLoc</code><code class="p">,</code> <code class="nv">BornIn</code><code class="p">),</code>
                                            <code class="nf">lives_in</code><code class="p">(</code><code class="nv">Person</code><code class="p">,</code> <code class="nv">LivingLoc</code><code class="p">),</code>
                                            <code class="nf">within_recursive</code><code class="p">(</code><code class="nv">LivingLoc</code><code class="p">,</code> <code class="nv">LivingIn</code><code class="p">).</code>
        
        <code class="s-Atom">?-</code> <code class="nf">migrated</code><code class="p">(</code><code class="nv">Who</code><code class="p">,</code> <code class="s-Atom">'United States'</code><code class="p">,</code> <code class="s-Atom">'Europe'</code><code class="p">).</code>
        <code class="cm">/* Who = 'Lucy'. */</code></pre></div>
        
        <p><a data-type="indexterm" data-primary="rules (Datalog)" id="idm45085122958112"></a>
        Cypher and SPARQL jump in right away with <code>SELECT</code>, but Datalog takes a small step at a time. We
        define <em>rules</em> that tell the database about new predicates: here, we define two new predicates,
        <code>within_recursive</code> and <code>migrated</code>. These predicates aren’t triples stored in the database, but
        instead they are derived from data or from other rules. Rules can refer to other rules, just like
        functions can call other functions or recursively call themselves. Like this, complex queries can be
        built up a small piece at a time.</p>
        
        <p>In rules, words that start with an uppercase letter are variables, and predicates are matched like
        in Cypher and SPARQL. For example, <code>name(Location, Name)</code> matches the triple
        <code>name(namerica, 'North America')</code> with variable bindings
        <code>Location = namerica</code> and <code>Name = 'North America'</code>.</p>
        
        <p>A rule applies if the system can find a match for <em>all</em> predicates on the righthand side of the
        <code>:-</code> operator. When the rule applies, it’s as though the lefthand side of the <code>:-</code> was added to the
        database (with variables replaced by the values they matched).</p>
        
        <p>One possible way of applying the rules is thus:</p>
        <ol>
        <li>
        <p><code>name(namerica, 'North America')</code> exists in the database, so rule 1
        applies. It generates <code>within_recursive(namerica, 'North America')</code>.</p>
        </li>
        <li>
        <p><code>within(usa, namerica)</code> exists in the database and the previous step generated
        <code>within_recursive(namerica, 'North America')</code>, so rule 2 applies. It generates
        <code>within_recursive(usa, 'North America')</code>.</p>
        </li>
        <li>
        <p><code>within(idaho, usa)</code> exists in the database and the previous step generated
        <code>within_recursive(usa, 'North America')</code>, so rule 2 applies. It generates
        <code>within_recursive(idaho, 'North America')</code>.</p>
        </li>
        
        </ol>
        
        <p>By repeated application of rules 1 and 2, the <code>within_recursive</code> predicate can tell us all the
        locations in North America (or any other location name) contained in our database. This process is
        illustrated in <a data-type="xref" href="#fig_datalog_naive">Figure&nbsp;2-6</a>.</p>
        
        <figure><div id="fig_datalog_naive" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491903063/files/assets/ddia_0206.png" alt="ddia 0206" width="2880" height="922">
        <h6><span class="label">Figure 2-6. </span>Determining that Idaho is in North America, using the Datalog rules from <a data-type="xref" href="#fig_datalog_query">Example&nbsp;2-11</a>.</h6>
        </div></figure>
        
        <p>Now rule 3 can find people who were born in some location <code>BornIn</code> and live in some location
        <code>LivingIn</code>. By querying with <code>BornIn = 'United States'</code> and
        <code>LivingIn = 'Europe'</code>, and leaving the person as a variable <code>Who</code>, we ask
        the Datalog system to find out which values can appear for the variable <code>Who</code>.
        So, finally we get the same answer as in the earlier Cypher and SPARQL queries.</p>
        
        <p>The Datalog approach requires a different kind of thinking to the other query languages discussed in
        this chapter, but it’s a very powerful approach, because rules can be combined and reused in
        different queries. It’s less convenient for simple one-off queries, but it can cope better if your
        data is complex.
        <a data-type="indexterm" data-primary="data models" data-secondary="graph-like models" data-tertiary="Datalog language" data-startref="ix_DMgraphDatalog" id="idm45085122798928"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="query languages" data-tertiary="Datalog" data-startref="ix_graphDMDatalog" id="idm45085122797280"></a>
        <a data-type="indexterm" data-primary="Datalog (query language)" data-startref="ix_Datalog" id="idm45085122795632"></a>
        <a data-type="indexterm" data-primary="graphs" data-secondary="as data models" data-startref="ix_graphDM" id="idm45085122794512"></a>
        <a data-type="indexterm" data-primary="data models" data-secondary="graph-like models" data-startref="ix_DMgraph" id="idm45085122793136"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Summary"><div class="sect1" id="idm45085124054144">
        <h1>Summary</h1>
        
        <p>Data models are a huge subject, and in this chapter we have taken a quick look at a broad variety of
        different models. We didn’t have space to go into all the details of each model, but hopefully the
        overview has been enough to whet your appetite to find out more about the model that best fits your
        application’s requirements.</p>
        
        <p>Historically, data started out being represented as one big tree (the hierarchical model), but that
        wasn’t good for representing many-to-many relationships, so the relational model was invented to
        solve that problem. More recently, developers found that some applications don’t fit well in the
        relational model either. New nonrelational “NoSQL” datastores have diverged in two main
        directions:</p>
        <ol>
        <li>
        <p><em>Document databases</em> target use cases where data comes in self-contained documents and
        relationships between one document and another are rare.</p>
        </li>
        <li>
        <p><em>Graph databases</em> go in the opposite direction, targeting use cases where anything is potentially
        related to everything.</p>
        </li>
        
        </ol>
        
        <p>All three models (document, relational, and graph) are widely used today, and each is good in its
        respective domain. One model can be emulated in terms of another model—for example, graph data can
        be represented in a relational database—but the result is often awkward. That’s why we have
        different systems for different purposes, not a single one-size-fits-all solution.</p>
        
        <p>One thing that document and graph databases have in common is that they typically don’t enforce a
        schema for the data they store, which can make it easier to adapt applications to changing
        requirements. However, your application most likely still assumes that data has a certain structure;
        it’s just a question of whether the schema is explicit (enforced on write) or implicit (assumed on
        read).</p>
        
        <p>Each data model comes with its own query language or framework, and we discussed several examples:
        SQL, MapReduce, MongoDB’s aggregation pipeline, Cypher, SPARQL, and Datalog. We also touched on CSS
        and XSL/XPath, which aren’t database query languages but have interesting parallels.</p>
        
        <p>Although we have covered a lot of ground, there are still many data models left unmentioned. To give
        just a few brief examples:</p>
        
        <ul>
        <li>
        <p><a data-type="indexterm" data-primary="genome analysis" id="idm45085122782272"></a>
        <a data-type="indexterm" data-primary="approximate search" data-see="similarity search" id="idm45085122781440"></a>
        <a data-type="indexterm" data-primary="similarity search" data-secondary="genome data" id="idm45085122780336"></a>
        Researchers working with genome data often need to perform <em>sequence-similarity searches</em>, which
        means taking one very long string (representing a DNA molecule) and matching it against a large
        database of strings that are similar, but not identical. None of the databases described here can
        handle this kind of usage, which is why researchers have written specialized genome database
        software like GenBank [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Benson2007de-marker" href="ch02.html#Benson2007de">48</a>].</p>
        </li>
        <li>
        <p><a data-type="indexterm" data-primary="Large Hadron Collider (LHC)" id="idm45085122774928"></a>
        Particle physicists have been doing Big Data–style large-scale data analysis for decades, and
        projects like the Large Hadron Collider (LHC) now work with hundreds of petabytes! At such a scale
        custom solutions are required to stop the hardware cost from spiraling out of control
        [<a xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="noteref" id="Rademakers2013vu-marker" href="ch02.html#Rademakers2013vu">49</a>].</p>
        </li>
        <li>
        <p><em>Full-text search</em> is arguably a kind of data model that is frequently used alongside databases.
        Information retrieval is a large specialist subject that we won’t cover in great detail in this
        book, but we’ll touch on search indexes in <a data-type="xref" href="ch03.html#ch_storage">Chapter&nbsp;3</a> and <a data-type="xref" href="part03.html#part_systems">Part&nbsp;III</a>.</p>
        </li>
        </ul>
        
        <p>We have to leave it there for now. In the next chapter we will discuss some of the trade-offs that
        come into play when <em>implementing</em> the data models described in this chapter.
        <a data-type="indexterm" data-primary="data models" data-startref="ix_datamod" id="idm45085122767168"></a></p>
        </div></section>
        
        
        
        
        
        
        
        <div data-type="footnotes"><h5>Footnotes</h5><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm45085118944976"><sup><a href="ch02.html#idm45085118944976-marker">i</a></sup> A term borrowed from
        electronics. Every electric circuit has a certain impedance (resistance to alternating current) on
        its inputs and outputs. When you connect one circuit’s output to another one’s input, the power
        transfer across the connection is maximized if the output and input impedances of the two circuits
        match. An impedance mismatch can lead to signal reflections and other troubles.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm45085125394752"><sup><a href="ch02.html#idm45085125394752-marker">ii</a></sup> Literature on the relational model
        distinguishes several different normal forms, but the distinctions are of little practical interest.
        As a rule of thumb, if you’re duplicating values that could be stored in just one place, the schema
        is not normalized.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm45085125384224"><sup><a href="ch02.html#idm45085125384224-marker">iii</a></sup> At the time of
        writing, joins are supported in RethinkDB, not supported in MongoDB, and only supported in
        predeclared views in CouchDB.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm45085125332400"><sup><a href="ch02.html#idm45085125332400-marker">iv</a></sup> Foreign key constraints allow you to
        restrict modifications, but such constraints are not required by the relational model. Even with
        constraints, joins on foreign keys are performed at query time, whereas in CODASYL, the join was
        effectively done at insert time.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm45085125055760"><sup><a href="ch02.html#idm45085125055760-marker">v</a></sup> Codd’s original description of the
        relational model [<a data-type="noteref" href="ch02.html#Codd1970dg">1</a>] actually allowed
        something quite similar to JSON documents within a relational schema. He called it <em>nonsimple
        domains</em>. The idea was that a value in a row doesn’t have to just be a primitive datatype like a
        number or a string, but could also be a nested relation (table)—so you can have an
        arbitrarily nested tree structure as a value, much like the JSON or XML support that was added to
        SQL over 30 years later.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm45085124490624"><sup><a href="ch02.html#idm45085124490624-marker">vi</a></sup> IMS and
        CODASYL both used imperative query APIs. Applications typically used COBOL code to iterate over
        records in the database, one record at a time
        [<a data-type="noteref" href="ch02.html#Stonebraker2005wv">2</a>,
        <a data-type="noteref" href="ch02.html#Knowles1984tm">16</a>].</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm45085123351264"><sup><a href="ch02.html#idm45085123351264-marker">vii</a></sup> Technically, Datomic uses 5-tuples rather
        than triples; the two additional fields are metadata for versioning.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="idm45085123076592"><sup><a href="ch02.html#idm45085123076592-marker">viii</a></sup> Datomic and Cascalog use a Clojure
        S-expression syntax for Datalog. In the following examples we use a Prolog syntax, which is a little
        easier to read, but this makes no functional difference.</p></div><div data-type="footnotes"><h5>References</h5><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Codd1970dg">[<a href="ch02.html#Codd1970dg-marker">1</a>] Edgar F. Codd:
        “<a href="https://www.seas.upenn.edu/~zives/03f/cis550/codd.pdf">A Relational Model of Data for
        Large Shared Data Banks</a>,” <em>Communications of the ACM</em>, volume 13, number
        6, pages 377–387, June 1970.
        <a href="http://dx.doi.org/10.1145/362384.362685">doi:10.1145/362384.362685</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Stonebraker2005wv">[<a href="ch02.html#Stonebraker2005wv-marker">2</a>] Michael Stonebraker and Joseph M. Hellerstein:
        “<a href="http://mitpress2.mit.edu/books/chapters/0262693143chapm1.pdf">What Goes Around Comes Around</a>,”
        in <em>Readings in Database Systems</em>, 4th edition, MIT Press, pages 2–41, 2005.
        ISBN: 978-0-262-69314-1</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="nosql-distilled">[<a href="ch02.html#nosql-distilled-marker">3</a>] Pramod J. Sadalage and
        Martin Fowler: <em>NoSQL Distilled</em>. Addison-Wesley, August 2012. ISBN:
        978-0-321-82662-6</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Evans2009tc">[<a href="ch02.html#Evans2009tc-marker">4</a>] Eric Evans:
        “<a href="https://web.archive.org/web/20190623045155/http://blog.sym-link.com/2009/10/30/nosql_whats_in_a_name.html">NoSQL: What’s in a
        Name?</a>,” <em>blog.sym-link.com</em>, October 30, 2009.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Phillips2012we">[<a href="ch02.html#Phillips2012we-marker">5</a>] James Phillips:
        “<a href="http://blog.couchbase.com/nosql-adoption-survey-surprises">Surprises in Our NoSQL
        Adoption Survey</a>,” <em>blog.couchbase.com</em>, February 8, 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Wagner2010wc">[<a href="ch02.html#Wagner2010wc-marker">6</a>] Michael Wagner:
        <em>SQL/XML:2006 – Evaluierung der Standardkonformität ausgewählter Datenbanksysteme</em>.
        Diplomica Verlag, Hamburg, 2010. ISBN: 978-3-836-64609-3</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="SQLServer2013">[<a href="ch02.html#SQLServer2013-marker">7</a>] “<a href="https://docs.microsoft.com/en-us/sql/relational-databases/xml/xml-data-sql-server?view=sql-server-ver15">XML
        Data (SQL Server)</a>,” SQL Server documentation, <em>docs.microsoft.com</em>, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="PostgreSQL2013">[<a href="ch02.html#PostgreSQL2013-marker">8</a>] “<a href="http://www.postgresql.org/docs/9.3/static/index.html">PostgreSQL
        9.3.1 Documentation</a>,” The PostgreSQL Global Development Group, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="MongoDB2013">[<a href="ch02.html#MongoDB2013-marker">9</a>] “<a href="http://docs.mongodb.org/manual/">The
        MongoDB 2.4 Manual</a>,” MongoDB, Inc., 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="RethinkDB2013">[<a href="ch02.html#RethinkDB2013-marker">10</a>] “<a href="http://www.rethinkdb.com/docs/">RethinkDB
        1.11 Documentation</a>,” <em>rethinkdb.com</em>, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="CouchDB2014_ch2">[<a href="ch02.html#CouchDB2014_ch2-marker">11</a>] “<a href="http://docs.couchdb.org/en/latest/">Apache
        CouchDB 1.6 Documentation</a>,” <em>docs.couchdb.org</em>, 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Qiao2013uv_ch2">[<a href="ch02.html#Qiao2013uv_ch2-marker">12</a>] Lin Qiao, Kapil Surlaker, Shirshanka Das, et al.:
        “<a href="http://www.slideshare.net/amywtang/espresso-20952131">On Brewing Fresh Espresso:
        LinkedIn’s Distributed Data Serving Platform</a>,” at <em>ACM International Conference on Management
        of Data</em> (SIGMOD), June 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Long2000wy">[<a href="ch02.html#Long2000wy-marker">13</a>] Rick Long, Mark Harrington, Robert Hain, and Geoff Nicholls:
        <a href="http://www.redbooks.ibm.com/redbooks/pdfs/sg245352.pdf"><em>IMS Primer</em></a>.
        IBM Redbook SG24-5352-00, IBM International Technical Support Organization, January 2000.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Bartlett2013uo">[<a href="ch02.html#Bartlett2013uo-marker">14</a>] Stephen D. Bartlett:
        “<a href="ftp://public.dhe.ibm.com/software/data/ims/pdf/TCG2013015LI.pdf">IBM’s IMS—Myths, Realities,
        and Opportunities</a>,” The Clipper Group Navigator, TCG2013015LI, July 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Mei2013vz">[<a href="ch02.html#Mei2013vz-marker">15</a>] Sarah Mei:
        “<a href="http://www.sarahmei.com/blog/2013/11/11/why-you-should-never-use-mongodb/">Why You Should Never Use MongoDB</a>,”
        <em>sarahmei.com</em>, November 11, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Knowles1984tm">[<a href="ch02.html#Knowles1984tm-marker">16</a>] J. S. Knowles and D. M. R. Bell:
        “The CODASYL Model,” in <em>Databases—Role and Structure: An Advanced Course</em>, edited by P. M.
        Stocker, P. M. D. Gray, and M. P. Atkinson, pages 19–56, Cambridge University Press, 1984. ISBN:
        978-0-521-25430-4</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Bachman1973hs">[<a href="ch02.html#Bachman1973hs-marker">17</a>] Charles W. Bachman:
        “<a href="http://dl.acm.org/citation.cfm?id=362534">The Programmer as Navigator</a>,”
        <em>Communications of the ACM</em>, volume 16, number 11, pages 653–658, November 1973.
        <a href="http://dx.doi.org/10.1145/355611.362534">doi:10.1145/355611.362534</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Hellerstein2007be">[<a href="ch02.html#Hellerstein2007be-marker">18</a>] Joseph M. Hellerstein, Michael Stonebraker, and James Hamilton:
        “<a href="http://db.cs.berkeley.edu/papers/fntdb07-architecture.pdf">Architecture of a Database System</a>,”
        <em>Foundations and Trends in Databases</em>, volume 1, number 2, pages 141–259, November 2007.
        <a href="http://dx.doi.org/10.1561/1900000002">doi:10.1561/1900000002</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Parikh2013vf">[<a href="ch02.html#Parikh2013vf-marker">19</a>] Sandeep Parikh and Kelly Stirman:
        “<a href="http://blog.mongodb.org/post/65517193370/schema-design-for-time-series-data-in-mongodb">Schema
        Design for Time Series Data in MongoDB</a>,” <em>blog.mongodb.org</em>, October 30, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Fowler2013uq">[<a href="ch02.html#Fowler2013uq-marker">20</a>] Martin Fowler:
        “<a href="http://martinfowler.com/articles/schemaless/">Schemaless Data Structures</a>,”
        <em>martinfowler.com</em>, January 7, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Awadallah2009vi">[<a href="ch02.html#Awadallah2009vi-marker">21</a>] Amr Awadallah:
        “<a href="http://www.slideshare.net/awadallah/schemaonread-vs-schemaonwrite">Schema-on-Read vs.
        Schema-on-Write</a>,” at <em>Berkeley EECS RAD Lab Retreat</em>, Santa Cruz, CA, May 2009.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Odersky2013wz">[<a href="ch02.html#Odersky2013wz-marker">22</a>] Martin Odersky:
        “<a href="http://www.infoq.com/presentations/data-types-issues">The Trouble with Types</a>,”
        at <em>Strange Loop</em>, September 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Irwin2013tb">[<a href="ch02.html#Irwin2013tb-marker">23</a>] Conrad Irwin:
        “<a href="https://speakerdeck.com/conradirwin/mongodb-confessions-of-a-postgresql-lover">MongoDB—Confessions
        of a PostgreSQL Lover</a>,” at <em>HTML5DevConf</em>, October 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Percona2013wb">[<a href="ch02.html#Percona2013wb-marker">24</a>] “<a href="http://www.percona.com/doc/percona-toolkit/2.2/pt-online-schema-change.html">Percona
        Toolkit Documentation: pt-online-schema-change</a>,” Percona Ireland Ltd., 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Keddo2013vj">[<a href="ch02.html#Keddo2013vj-marker">25</a>] Rany Keddo, Tobias Bielohlawek, and Tobias Schmidt:
        “<a href="https://github.com/soundcloud/lhm">Large Hadron Migrator</a>,” SoundCloud, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Noach2016bq">[<a href="ch02.html#Noach2016bq-marker">26</a>] Shlomi Noach:
        “<a href="http://githubengineering.com/gh-ost-github-s-online-migration-tool-for-mysql/">gh-ost:
        GitHub’s Online Schema Migration Tool for MySQL</a>,” <em>githubengineering.com</em>, August 1, 2016.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Corbett2012uz_ch2">[<a href="ch02.html#Corbett2012uz_ch2-marker">27</a>] James C. Corbett, Jeffrey Dean, Michael Epstein, et al.:
        “<a href="https://research.google/pubs/pub39966/">Spanner: Google’s Globally-Distributed Database</a>,”
        at <em>10th USENIX Symposium on Operating System Design and Implementation</em> (OSDI),
        October 2012.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="BurlesonCwtEpWL2">[<a href="ch02.html#BurlesonCwtEpWL2-marker">28</a>] Donald K. Burleson:
        “<a href="http://www.dba-oracle.com/oracle_tip_hash_index_cluster_table.htm">Reduce I/O with Oracle
        Cluster Tables</a>,” <em>dba-oracle.com</em>.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Chang2006ta_ch2">[<a href="ch02.html#Chang2006ta_ch2-marker">29</a>] Fay Chang, Jeffrey Dean, Sanjay Ghemawat, et al.:
        “<a href="https://research.google/pubs/pub27898/">Bigtable: A Distributed Storage System
        for Structured Data</a>,” at <em>7th USENIX Symposium on Operating System Design and
        Implementation</em> (OSDI), November 2006.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Cochrane2013ui">[<a href="ch02.html#Cochrane2013ui-marker">30</a>] Bobbie J. Cochrane and Kathy A. McKnight:
        “<a href="http://www.ibm.com/developerworks/data/library/techarticle/dm-1306nosqlforjson1/">DB2 JSON
        Capabilities, Part 1: Introduction to DB2 JSON</a>,” IBM developerWorks, June 20, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Sutter2005us">[<a href="ch02.html#Sutter2005us-marker">31</a>] Herb Sutter:
        “<a href="http://www.gotw.ca/publications/concurrency-ddj.htm">The Free Lunch Is Over:
        A Fundamental Turn Toward Concurrency in Software</a>,” <em>Dr. Dobb’s Journal</em>,
        volume 30, number 3, pages 202-210, March 2005.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Hellerstein2010uq">[<a href="ch02.html#Hellerstein2010uq-marker">32</a>] Joseph M. Hellerstein:
        “<a href="http://www.eecs.berkeley.edu/Pubs/TechRpts/2010/EECS-2010-90.pdf">The Declarative
        Imperative: Experiences and Conjectures in Distributed Logic</a>,” Electrical Engineering and
        Computer Sciences, University of California at Berkeley, Tech report UCB/EECS-2010-90, June
        2010.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Dean2004ua_ch2">[<a href="ch02.html#Dean2004ua_ch2-marker">33</a>] Jeffrey Dean and Sanjay Ghemawat:
        “<a href="https://research.google/pubs/pub62/">MapReduce: Simplified Data Processing
        on Large Clusters</a>,” at <em>6th USENIX Symposium on Operating System Design and
        Implementation</em> (OSDI), December 2004.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Kerstiens2013ur">[<a href="ch02.html#Kerstiens2013ur-marker">34</a>] Craig Kerstiens:
        “<a href="https://blog.heroku.com/javascript_in_your_postgres">JavaScript in Your Postgres</a>,”
        <em>blog.heroku.com</em>, June 5, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Bronson2013ud">[<a href="ch02.html#Bronson2013ud-marker">35</a>] Nathan Bronson, Zach Amsden, George Cabrera, et al.:
        “<a href="https://www.usenix.org/conference/atc13/technical-sessions/presentation/bronson">TAO:
        Facebook’s Distributed Data Store for the Social Graph</a>,” at
        <em>USENIX Annual Technical Conference</em> (USENIX ATC), June 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Gremlin2013">[<a href="ch02.html#Gremlin2013-marker">36</a>] “<a href="http://tinkerpop.apache.org/docs/3.2.3/reference/">Apache
        TinkerPop3.2.3 Documentation</a>,” <em>tinkerpop.apache.org</em>, October 2016.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Neo4j2013">[<a href="ch02.html#Neo4j2013-marker">37</a>] “<a href="http://docs.neo4j.org/chunked/2.0.0/index.html">The Neo4j Manual v2.0.0</a>,”
        Neo Technology, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="EifremTweet">[<a href="ch02.html#EifremTweet-marker">38</a>] Emil Eifrem:
        <a href="https://twitter.com/emileifrem/status/419107961512804352">Twitter correspondence</a>, January 3, 2014.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Beckett2011vq">[<a href="ch02.html#Beckett2011vq-marker">39</a>] David Beckett and Tim Berners-Lee:
        “<a href="http://www.w3.org/TeamSubmission/turtle/">Turtle – Terse RDF Triple Language</a>,”
        W3C Team Submission, March 28, 2011.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Datomic2013">[<a href="ch02.html#Datomic2013-marker">40</a>] “<a href="http://docs.datomic.com/">Datomic
        Development Resources</a>,” Metadata Partners, LLC, 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="W3CRDF">[<a href="ch02.html#W3CRDF-marker">41</a>] W3C RDF Working Group:
        “<a href="http://www.w3.org/RDF/">Resource Description Framework (RDF)</a>,”
        <em>w3.org</em>, 10 February 2004.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Jena2013">[<a href="ch02.html#Jena2013-marker">42</a>] “<a href="http://jena.apache.org/">Apache Jena</a>,”
        Apache Software Foundation.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Harris2013wd">[<a href="ch02.html#Harris2013wd-marker">43</a>] Steve Harris, Andy Seaborne, and Eric
        Prud’hommeaux: “<a href="http://www.w3.org/TR/sparql11-query/">SPARQL 1.1 Query Language</a>,”
        W3C Recommendation, March 2013.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Green2013js">[<a href="ch02.html#Green2013js-marker">44</a>] Todd J. Green, Shan Shan Huang, Boon Thau Loo, and Wenchao Zhou:
        “<a href="http://blogs.evergreen.edu/sosw/files/2014/04/Green-Vol5-DBS-017.pdf">Datalog and
        Recursive Query Processing</a>,” <em>Foundations and Trends in Databases</em>,
        volume 5, number 2, pages 105–195, November 2013.
        <a href="http://dx.doi.org/10.1561/1900000017">doi:10.1561/1900000017</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Ceri1989ff">[<a href="ch02.html#Ceri1989ff-marker">45</a>] Stefano Ceri, Georg Gottlob, and Letizia Tanca:
        “<a href="https://www.researchgate.net/profile/Letizia_Tanca/publication/3296132_What_you_always_wanted_to_know_about_Datalog_and_never_dared_to_ask/links/0fcfd50ca2d20473ca000000.pdf">What
        You Always Wanted to Know About Datalog (And Never Dared to Ask)</a>,” <em>IEEE
        Transactions on Knowledge and Data Engineering</em>, volume 1, number 1, pages 146–166, March 1989.
        <a href="http://dx.doi.org/10.1109/69.43410">doi:10.1109/69.43410</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Abiteboul1995ug">[<a href="ch02.html#Abiteboul1995ug-marker">46</a>] Serge Abiteboul, Richard Hull, and Victor Vianu:
        <a href="http://webdam.inria.fr/Alice/"><em>Foundations of Databases</em></a>. Addison-Wesley, 1995.
        ISBN: 978-0-201-53771-0, available online at <em>webdam.inria.fr/Alice</em></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="MarzCascalog">[<a href="ch02.html#MarzCascalog-marker">47</a>] Nathan Marz:
        “<a href="https://github.com/nathanmarz/cascalog">Cascalog</a>,” <em>github.com</em>.</p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Benson2007de">[<a href="ch02.html#Benson2007de-marker">48</a>] Dennis A. Benson,
        Ilene Karsch-Mizrachi, David J. Lipman, et al.:
        “<a href="https://academic.oup.com/nar/article/36/suppl_1/D25/2507746">GenBank</a>,”
        <em>Nucleic Acids Research</em>, volume 36, Database issue, pages D25–D30, December 2007.
        <a href="http://dx.doi.org/10.1093/nar/gkm929">doi:10.1093/nar/gkm929</a></p><p xmlns:htmlbook="https://github.com/oreillymedia/HTMLBook" data-type="footnote" id="Rademakers2013vu">[<a href="ch02.html#Rademakers2013vu-marker">49</a>] Fons Rademakers:
        “<a href="https://indico.cern.ch/event/246453/contributions/1566610/attachments/423154/587535/ROOT-BigData-Analysis-London-2013.pdf">ROOT
        for Big Data Analysis</a>,” at <em>Workshop on the Future of Big Data Management</em>,
        London, UK, June 2013.</p></div></div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781491903063/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com