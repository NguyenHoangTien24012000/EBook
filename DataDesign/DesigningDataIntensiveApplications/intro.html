<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="preface" epub:type="preface" data-pdf-bookmark="Preface"><div class="preface" id="preface">
        <h1>Preface</h1>
        
        
        <p>If you have worked in software engineering in recent years, especially in server-side and backend
        systems, you have probably been bombarded with a plethora of buzzwords relating to storage and
        processing of data. NoSQL! Big Data! Web-scale! Sharding! Eventual consistency! ACID! CAP theorem!
        Cloud services! MapReduce! Real-time!</p>
        
        <p>In the last decade we have seen many interesting developments in databases, in distributed systems,
        and in the ways we build applications on top of them. There are various driving forces for these
        developments:</p>
        
        <ul>
        <li>
        <p>Internet companies such as Google, Microsoft, Amazon, Facebook, LinkedIn, Netflix, and Twitter are handling
        huge volumes of data and traffic, forcing them to create new tools that enable them to efficiently
        handle such scale.</p>
        </li>
        <li>
        <p>Businesses need to be agile, test hypotheses cheaply, and respond quickly to new market insights
        by keeping development cycles short and data models flexible.</p>
        </li>
        <li>
        <p>Free and open source software has become very successful and is now preferred to commercial or
        bespoke in-house software in many environments.</p>
        </li>
        <li>
        <p>CPU clock speeds are barely increasing, but multi-core processors are standard, and networks are
        getting faster. This means parallelism is only going to increase.</p>
        </li>
        <li>
        <p>Even if you work on a small team, you can now build systems that are distributed across many
        machines and even multiple geographic regions, thanks to infrastructure as a service (IaaS) such
        as Amazon Web Services.</p>
        </li>
        <li>
        <p>Many services are now expected to be highly available; extended downtime due to outages or
        maintenance is becoming increasingly unacceptable.</p>
        </li>
        </ul>
        
        <p><em>Data-intensive applications</em> are pushing the boundaries of what is possible by making use of these
        technological developments. We call an application <em>data-intensive</em> if data is its primary
        challenge—the quantity of data, the complexity of data, or the speed at which it is changing—as
        opposed to <em>compute-intensive</em>, where CPU cycles are the bottleneck.</p>
        
        <p>The tools and technologies that help data-intensive applications store and process data have been
        rapidly adapting to these changes. New types of database systems (“NoSQL”) have been getting lots of
        attention, but message queues, caches, search indexes, frameworks for batch and stream processing,
        and related technologies are very important too. Many applications use some combination of these.</p>
        
        <p>The buzzwords that fill this space are a sign of enthusiasm for the new possibilities, which is a
        great thing. However, as software engineers and architects, we also need to have a technically
        accurate and precise understanding of the various technologies and their trade-offs if we want to
        build good applications. For that understanding, we have to dig deeper than buzzwords.</p>
        
        <p>Fortunately, behind the rapid changes in technology, there are enduring principles that remain true,
        no matter which version of a particular tool you are using. If you understand those principles,
        you’re in a position to see where each tool fits in, how to make good use of it, and how to avoid
        its pitfalls. That’s where this book comes in.</p>
        
        <p>The goal of this book is to help you navigate the diverse and fast-changing landscape of
        technologies for processing and storing data. This book is not a tutorial for one particular tool,
        nor is it a textbook full of dry theory. Instead, we will look at examples of successful data
        systems: technologies that form the foundation of many popular applications and that have to meet
        scalability, performance, and reliability requirements in production every day.</p>
        
        <p>We will dig into the internals of those systems, tease apart their key algorithms, discuss their
        principles and the trade-offs they have to make. On this journey, we will try to find useful ways of
        <em>thinking about</em> data systems—not just <em>how</em> they work, but also <em>why</em> they work that way, and
        what questions we need to ask.</p>
        
        <p>After reading this book, you will be in a great position to decide which kind of technology is
        appropriate for which purpose, and understand how tools can be combined to form the foundation of a
        good application architecture. You won’t be ready to build your own database storage engine from
        scratch, but fortunately that is rarely necessary. You will, however, develop a good intuition for
        what your systems are doing under the hood so that you can reason about their behavior, make good
        design decisions, and track down any problems that may arise.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Who Should Read This Book?"><div class="sect1" id="idm45085131164704">
        <h1>Who Should Read This Book?</h1>
        
        <p>If you develop applications that have some kind of server/backend for storing or processing data,
        and your applications use the internet (e.g., web applications, mobile apps, or internet-connected
        sensors), then this book is for you.</p>
        
        <p>This book is for software engineers, software architects, and technical managers who love to code.
        It is especially relevant if you need to make decisions about the architecture of the systems you
        work on—for example, if you need to choose tools for solving a given problem and figure out how
        best to apply them. But even if you have no choice over your tools, this book will help you better
        understand their strengths and weaknesses.</p>
        
        <p>You should have some experience building web-based applications or network services, and you should
        be familiar with relational databases and SQL. Any non-relational databases and other data-related
        tools you know are a bonus, but not required. A general understanding of common network protocols
        like TCP and HTTP is helpful. Your choice of programming language or framework makes no difference
        for this book.</p>
        
        <p>If any of the following are true for you, you’ll find this book valuable:</p>
        
        <ul>
        <li>
        <p>You want to learn how to make data systems scalable, for example, to support web or mobile apps
        with millions of users.</p>
        </li>
        <li>
        <p>You need to make applications highly available (minimizing downtime) and operationally robust.</p>
        </li>
        <li>
        <p>You are looking for ways of making systems easier to maintain in the long run, even as they grow
        and as requirements and technologies change.</p>
        </li>
        <li>
        <p>You have a natural curiosity for the way things work and want to know what goes on inside major
        websites and online services. This book breaks down the internals of various databases and data
        processing systems, and it’s great fun to explore the bright thinking that went into their design.</p>
        </li>
        </ul>
        
        <p>Sometimes, when discussing scalable data systems, people make comments along the lines of, “You’re
        not Google or Amazon. Stop worrying about scale and just use a relational database.” There is truth
        in that statement: building for scale that you don’t need is wasted effort and may lock you into an
        inflexible design. In effect, it is a form of premature optimization. However, it’s also important
        to choose the right tool for the job, and different technologies each have their own strengths and
        weaknesses. As we shall see, relational databases are important but not the final word on dealing
        with data.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Scope of This Book"><div class="sect1" id="sec_preface_scope">
        <h1>Scope of This Book</h1>
        
        <p>This book does not attempt to give detailed instructions on how to install or use specific software
        packages or APIs, since there is already plenty of documentation for those things. Instead we
        discuss the various principles and trade-offs that are fundamental to data systems, and we explore
        the different design decisions taken by different products.</p>
        
        <p>In the ebook editions we have included links to the full text of online resources. All links were verified at the time of publication, but unfortunately links tend to break frequently due to the nature of the web. If you come across a broken link, or if you are reading a print copy of this book, you can look up references using a search engine. For academic papers, you can search for the title in Google Scholar to find open-access PDF files. Alternatively, you can find all of the references at <a href="https://github.com/ept/ddia-references"><em class="hyperlink">https://github.com/ept/ddia-references</em></a>, where we maintain up-to-date links.</p>
        
        <p>We look primarily at the <em>architecture</em> of data systems and the ways they are integrated into
        data-intensive applications. This book doesn’t have space to cover deployment, operations, security, management, and other areas—those are complex and important topics, and we wouldn’t do
        them justice by making them superficial side notes in this book. They deserve books of their own.</p>
        
        <p>Many of the technologies described in this book fall within the realm of the <em>Big Data</em> buzzword.
        However, the term “Big Data” is so overused and underdefined that it is not useful in a serious
        engineering discussion. This book uses less ambiguous terms, such as single-node versus distributed
        systems, or online/interactive versus offline/batch processing systems.</p>
        
        <p>This book has a bias toward free and open source software (FOSS), because reading, modifying, and
        executing source code is a great way to understand how something works in detail. Open platforms
        also reduce the risk of vendor lock-in. However, where appropriate, we also discuss proprietary
        software (closed-source software, software as a service, or companies’ in-house software that is
        only described in literature but not released publicly).</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Outline of This Book"><div class="sect1" id="idm45085131171856">
        <h1>Outline of This Book</h1>
        
        <p>This book is arranged into three parts:</p>
        <ol>
        <li>
        <p>In <a data-type="xref" href="part01.html#part_foundations">Part&nbsp;I</a>, we discuss the fundamental ideas that underpin the design of
        data-intensive applications. We start in <a data-type="xref" href="ch01.html#ch_introduction">Chapter&nbsp;1</a> by discussing what we’re actually
        trying to achieve: reliability, scalability, and maintainability; how we need to think about
        them; and how we can achieve them. In <a data-type="xref" href="ch02.html#ch_datamodels">Chapter&nbsp;2</a> we compare several different data
        models and query languages, and see how they are appropriate to different situations. In
        <a data-type="xref" href="ch03.html#ch_storage">Chapter&nbsp;3</a> we talk about storage engines: how databases arrange data on disk so that we
        can find it again efficiently. <a data-type="xref" href="ch04.html#ch_encoding">Chapter&nbsp;4</a> turns to formats for data encoding (serialization)
        and evolution of schemas over time.</p>
        </li>
        <li>
        <p>In <a data-type="xref" href="part02.html#part_distributed_data">Part&nbsp;II</a>, we move from data stored on one machine to data that is
        distributed across multiple machines. This is often necessary for scalability, but brings with it
        a variety of unique challenges. We first discuss replication (<a data-type="xref" href="ch05.html#ch_replication">Chapter&nbsp;5</a>),
        partitioning/sharding (<a data-type="xref" href="ch06.html#ch_partitioning">Chapter&nbsp;6</a>), and transactions (<a data-type="xref" href="ch07.html#ch_transactions">Chapter&nbsp;7</a>). We then
        go into more detail on the problems with distributed systems (<a data-type="xref" href="ch08.html#ch_distributed">Chapter&nbsp;8</a>) and what it
        means to achieve consistency and consensus in a distributed system (<a data-type="xref" href="ch09.html#ch_consistency">Chapter&nbsp;9</a>).</p>
        </li>
        <li>
        <p>In <a data-type="xref" href="part03.html#part_systems">Part&nbsp;III</a>, we discuss systems that derive some datasets from other datasets. Derived
        data often occurs in heterogeneous systems: when there is no one database that can do everything
        well, applications need to integrate several different databases, caches, indexes, and so on. In
        <a data-type="xref" href="ch10.html#ch_batch">Chapter&nbsp;10</a> we start with a batch processing approach to derived data, and we build upon it with stream processing in <a data-type="xref" href="ch11.html#ch_stream">Chapter&nbsp;11</a>. Finally, in <a data-type="xref" href="ch12.html#ch_future">Chapter&nbsp;12</a> we put everything
        together and discuss approaches for building reliable, scalable, and maintainable applications in
        the future.</p>
        </li>
        
        </ol>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="References and Further Reading"><div class="sect1" id="idm45085131345248">
        <h1>References and Further Reading</h1>
        
        <p>Most of what we discuss in this book has already been said elsewhere in some form or another—in
        conference presentations, research papers, blog posts, code, bug trackers, mailing lists, and
        engineering folklore. This book summarizes the most important ideas from many different sources,
        and it includes pointers to the original literature throughout the text. The references at the end
        of each chapter are a great resource if you want to explore an area in more depth, and most of them
        are freely available online.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="O’Reilly Online Learning"><div class="sect1" id="idm45085131343152">
        <h1>O’Reilly Online Learning</h1>
        <div data-type="note" epub:type="note" class="ormenabled"><h6>Note</h6>
        <p>For more than 40 years, <a href="http://oreilly.com" class="orm:hideurl"><em class="hyperlink">O’Reilly Media</em></a> has provided technology and business training, knowledge, and insight to help companies succeed.</p>
        </div>
        
        <p>Our unique network of experts and innovators share their knowledge and expertise through books, articles, and our online learning platform. O’Reilly’s online learning platform gives you on-demand access to live training courses, in-depth learning paths, interactive coding environments, and a vast collection of text and video from O’Reilly and 200+ other publishers. For more information, please visit <a href="http://oreilly.com" class="orm:hideurl"><em>http://oreilly.com</em></a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" class="pagebreak-before" data-pdf-bookmark="How to Contact Us"><div class="sect1" id="idm45085131336976">
        <h1>How to Contact Us</h1>
        
        <p>Please address comments and questions concerning this book to the publisher:</p>
        <ul class="simplelist">
          <li>O’Reilly Media, Inc.</li>
          <li>1005 Gravenstein Highway North</li>
          <li>Sebastopol, CA 95472</li>
          <li>800-998-9938 (in the United States or Canada)</li>
          <li>707-829-0515 (international or local)</li>
          <li>707-829-0104 (fax)</li>
        </ul>
        
        <p>We have a web page for this book, where we list errata, examples, and any additional information. You can access this page at <a href="http://bit.ly/designing-data-intensive-apps"><em class="hyperlink">http://bit.ly/designing-data-intensive-apps</em></a>.</p>
        
        <p>To comment or ask technical questions about this book, send email to <a class="email" href="mailto:bookquestions@oreilly.com"><em>bookquestions@oreilly.com</em></a>.</p>
        
        <p>For news and more information about our books and courses, see our website at <a href="http://www.oreilly.com"><em class="hyperlink">http://www.oreilly.com</em></a>.</p>
        
        <p>Find us on Facebook: <a href="http://facebook.com/oreilly"><em class="hyperlink">http://facebook.com/oreilly</em></a></p>
        
        <p>Follow us on Twitter: <a href="http://twitter.com/oreillymedia"><em class="hyperlink">http://twitter.com/oreillymedia</em></a></p>
        
        <p>Watch us on YouTube: <a href="http://www.youtube.com/oreillymedia"><em class="hyperlink">http://www.youtube.com/oreillymedia</em></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Acknowledgments"><div class="sect1" id="idm45085131334912">
        <h1>Acknowledgments</h1>
        
        <p>This book is an amalgamation and systematization of a large number of other people’s ideas and
        knowledge, combining experience from both academic research and industrial practice. In computing we
        tend to be attracted to things that are new and shiny, but I think we have a huge amount to learn
        from things that have been done before. This book has over 800 references to articles, blog posts,
        talks, documentation, and more, and they have been an invaluable learning resource for me. I am very
        grateful to the authors of this material for sharing their knowledge.</p>
        
        <p>I have also learned a lot from personal conversations, thanks to a large number of people who have
        taken the time to discuss ideas or patiently explain things to me. In particular, I would like to thank
        Joe Adler,
        Ross Anderson,
        Peter Bailis,
        Márton Balassi,
        Alastair Beresford,
        Mark Callaghan,
        Mat Clayton,
        Patrick Collison,
        Sean Cribbs,
        Shirshanka Das,
        Niklas Ekström,
        Stephan Ewen,
        Alan Fekete,
        Gyula Fóra,
        Camille Fournier,
        Andres Freund,
        John Garbutt,
        Seth Gilbert,
        Tom Haggett,
        Pat Helland,
        Joe Hellerstein,
        Jakob Homan,
        Heidi Howard,
        John Hugg,
        Julian Hyde,
        Conrad Irwin,
        Evan Jones,
        Flavio Junqueira,
        Jessica Kerr,
        Kyle Kingsbury,
        Jay Kreps,
        Carl Lerche,
        Nicolas Liochon,
        Steve Loughran,
        Lee Mallabone,
        Nathan Marz,
        Caitie McCaffrey,
        Josie McLellan,
        Christopher Meiklejohn,
        Ian Meyers,
        Neha Narkhede,
        Neha Narula,
        Cathy O’Neil,
        Onora O’Neill,
        Ludovic Orban,
        Zoran Perkov,
        Julia Powles,
        Chris Riccomini,
        Henry Robinson,
        David Rosenthal,
        Jennifer Rullmann,
        Matthew Sackman,
        Martin Scholl,
        Amit Sela,
        Gwen Shapira,
        Greg Spurrier,
        Sam Stokes,
        Ben Stopford,
        Tom Stuart,
        Diana Vasile,
        Rahul Vohra,
        Pete Warden, and
        Brett Wooldridge.</p>
        
        <p>Several more people have been invaluable to the writing of this book by reviewing drafts and
        providing feedback. For these contributions I am particularly indebted to
        Raul Agepati,
        Tyler Akidau,
        Mattias Andersson,
        Sasha Baranov,
        Veena Basavaraj,
        David Beyer,
        Jim Brikman,
        Paul Carey,
        Raul Castro Fernandez,
        Joseph Chow,
        Derek Elkins,
        Sam Elliott,
        Alexander Gallego,
        Mark Grover,
        Stu Halloway,
        Heidi Howard,
        Nicola Kleppmann,
        Stefan Kruppa,
        Bjorn Madsen,
        Sander Mak,
        Stefan Podkowinski,
        Phil Potter,
        Hamid Ramazani,
        Sam Stokes, and
        Ben Summers.
        Of course, I take all responsibility for any remaining errors or unpalatable opinions in this book.</p>
        
        <p>For helping this book become real, and for their patience with my slow writing and unusual requests,
        I am grateful to my editors Marie Beaugureau, Mike Loukides, Ann Spencer, and all the team at
        O’Reilly. For helping find the right words, I thank Rachel Head. For giving me the time and freedom to write in spite of other work commitments, I thank
        Alastair Beresford, Susan Goodhue, Neha Narkhede, and Kevin Scott.</p>
        
        <p>Very special thanks are due to Shabbir Diwan and Edie Freedman, who illustrated with great care the
        maps that accompany the chapters. It’s wonderful that they took on the unconventional idea of
        creating maps, and made them so beautiful and compelling.</p>
        
        <p>Finally, my love goes to my family and friends, without whom I would not have been able to get
        through this writing process that has taken almost four years. You’re the best.</p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781491903063/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com