<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section epub:type="chapter">
        <h2 class="h2b" id="ch15"><span epub:type="pagebreak" id="page_751"></span><span class="pd_ash">Chapter 15</span></h2>
        <p class="chap_ttl">BPF</p>
        <p class="noindent">This chapter describes the BCC and bpftrace tracing front ends for extended BPF. These front ends provide a collection of performance analysis tools, and these tools were used in previous chapters. The BPF technology was introduced in <a href="ch03.xhtml#ch03">Chapter 3</a>, <a href="ch03.xhtml#ch03">Operating System</a>, <a href="ch03.xhtml#ch03lev4sec4">Section 3.4.4</a>, <a href="ch03.xhtml#ch03lev4sec4">Extended BPF</a>. In summary, extended BPF is a kernel execution environment that can provide programmatic capabilities to tracers.</p>
        <p class="noindent">This chapter, along with <a href="ch13.xhtml#ch13">Chapter 13</a>, <a href="ch13.xhtml#ch13">perf</a>, and <a href="ch14.xhtml#ch14">Chapter 14</a>, <a href="ch14.xhtml#ch14">Ftrace</a>, are optional reading for those who wish to learn one or more system tracers in more detail.</p>
        <p class="noindent">Extended BPF tools can be used to answer questions such as:</p>
        <ul class="sq">
        <li><p class="bull">What is the latency of disk I/O, as a histogram?</p></li>
        <li><p class="bull">Is CPU scheduler latency high enough to cause problems?</p></li>
        <li><p class="bull">Are applications suffering file system latency?</p></li>
        <li><p class="bull">What TCP sessions are occurring and with what durations?</p></li>
        <li><p class="bull">What code paths are blocking and for how long?</p></li>
        </ul>
        <p class="noindent">What makes BPF different from other tracers is that it is programmable. It allows user-defined programs to be executed on events, programs that can perform filtering, save and retrieve information, calculate latency, perform in-kernel aggregation and custom summaries, and more. While other tracers may require dumping all events to user space and post-processing them, BPF allows such processing to occur efficiently in kernel context. This makes it practical to create performance tools that would otherwise cost too much overhead for production use.</p>
        <p class="noindent">This chapter has a major section for each recommended front end. Key sections are:</p>
        <ul class="sq">
        <li><p class="bull"><a href="ch15.xhtml#ch15lev1">15.1: BCC</a></p>
        <ul class="sq-i">
        <li><p class="bull"><a href="ch15.xhtml#ch15lev1sec1">15.1.1: Installation</a></p></li>
        <li><p class="bull"><a href="ch15.xhtml#ch15lev1sec2">15.1.2: Tool Coverage</a></p></li>
        <li><p class="bull"><a href="ch15.xhtml#ch15lev1sec3">15.1.3: Single-Purpose Tools</a></p></li>
        <li><p class="bull"><a href="ch15.xhtml#ch15lev1sec4">15.1.4: Multi-Purpose Tools</a></p></li>
        <li><p class="bull"><a href="ch15.xhtml#ch15lev1sec5">15.1.5: One-Liners</a></p></li>
        </ul></li>
        <li><p class="bull"><span epub:type="pagebreak" id="page_752"></span><a href="ch15.xhtml#ch15lev2">15.2: bpftrace</a></p>
        <ul class="sq-i">
        <li><p class="bull"><a href="ch15.xhtml#ch15lev2sec1">15.2.1: Installation</a></p></li>
        <li><p class="bull"><a href="ch15.xhtml#ch15lev2sec2">15.2.2: Tools</a></p></li>
        <li><p class="bull"><a href="ch15.xhtml#ch15lev2sec3">15.2.3: One-Liners</a></p></li>
        <li><p class="bull"><a href="ch15.xhtml#ch15lev2sec4">15.2.4: Programming</a></p></li>
        <li><p class="bull"><a href="ch15.xhtml#ch15lev2sec5">15.2.5: Reference</a></p></li>
        </ul></li>
        </ul>
        <p class="noindent">The differences between BCC and bpftrace may be obvious from their usage in prior chapters: BCC is suited for complex tools, and bpftrace is suited for ad hoc custom programs. Some tools are implemented in both, as shown in <a href="ch15.xhtml#ch15fig01">Figure 15.1</a>.</p>
        <figure class="image-c" id="ch15fig01">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136821694/files/graphics/15fig01.jpg" alt="Images" width="775" height="377">
        <figcaption>
        <p class="title-f"><span class="pd_ashf">Figure 15.1</span> BPF tracing front ends</p>
        </figcaption>
        </figure>
        <p class="noindent">Specific differences between BCC and bpftrace are summarized in <a href="ch15.xhtml#ch15tab01">Table 15.1</a>.</p>
        <figure class="table" id="ch15tab01">
        <figcaption>
        <p class="title-t"><span class="pd_ashf">Table 15.1</span> <strong>BCC versus bpftrace</strong></p>
        </figcaption>
        <table class="all">
        <thead>
        <tr>
        <th class="th"><p class="thead"><strong>Characteristic</strong></p></th>
        <th class="th"><p class="thead"><strong>BCC</strong></p></th>
        <th class="th"><p class="thead"><strong>bpftrace</strong></p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="border"><p class="tab-para">Number of tools by repository</p></td>
        <td class="border"><p class="tab-para">&gt;80 (bcc)</p></td>
        <td class="border"><p class="tab-para">&gt;30 (bpftrace)</p>
        <p class="tab-para">&gt;120 (bpf-perf-tools-book)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">Tool usage</p></td>
        <td class="border"><p class="tab-para">Typically supports complex options (<code>-h</code>, <code>-P PID</code>, etc.) and arguments</p></td>
        <td class="border"><p class="tab-para">Typically simple: no options, and zero or one argument</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">Tool documentation</p></td>
        <td class="border"><p class="tab-para">Man pages, example files</p></td>
        <td class="border"><p class="tab-para">Man pages, example files</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">Programming language</p></td>
        <td class="border"><p class="tab-para">User-space: Python, Lua, C, or C++ Kernel-space: C</p></td>
        <td class="border"><p class="tab-para">bpftrace</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">Programming difficulty</p></td>
        <td class="border"><p class="tab-para">Difficult</p></td>
        <td class="border"><p class="tab-para">Easy</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><span epub:type="pagebreak" id="page_753"></span>Per-event output types</p></td>
        <td class="border"><p class="tab-para">Anything</p></td>
        <td class="border"><p class="tab-para">Text, JSON</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">Summary types</p></td>
        <td class="border"><p class="tab-para">Anything</p></td>
        <td class="border"><p class="tab-para">Counts, min, max, sum, avg, log2 histograms, linear histograms; by zero or more keys</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">Library support</p></td>
        <td class="border"><p class="tab-para">Yes (e.g., Python import)</p></td>
        <td class="border"><p class="tab-para">No</p></td>
        </tr>
        <tr>
        <td><p class="tab-para">Average program length<sup><a id="ch15fn1a" href="ch15.xhtml#ch15fn1">1</a></sup> (no comments)</p></td>
        <td><p class="tab-para">228 lines</p></td>
        <td><p class="tab-para">28 lines</p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="footnote"><sup><a id="ch15fn1" href="ch15.xhtml#ch15fn1a">1</a></sup>Based on the tools provided in the official repository and my BPF book repository.</p>
        <p class="noindent">Both BCC and bpftrace are in use at many companies including Facebook and Netflix. Netflix installs them by default on all cloud instances, and uses them for deeper analysis after cloud-wide monitoring and dashboards, specifically <a href="ch15.xhtml#ch15ref3">[Gregg 18e]</a>:</p>
        <ul class="sq">
        <li><p class="bull"><strong>BCC</strong>: Canned tools are used at the command line to analyze storage I/O, network I/O, and process execution, when needed. Some BCC tools are automatically executed by a graphical performance dashboard system to provide data for scheduler and disk I/O latency heat maps, off-CPU flame graphs, and more. Also, a custom BCC tool is always running as a daemon (based on tcplife(8)) logging network events to cloud storage for flow analysis.</p></li>
        <li><p class="bull"><strong>bpftrace</strong>: Custom bpftrace tools are developed when needed to understand kernel and application pathologies.</p></li>
        </ul>
        <p class="noindent">The following sections explain BCC tools, bpftrace tools, and bpftrace programming.</p>
        <section>
        <h3 class="h3" id="ch15lev1">15.1 BCC</h3>
        <p class="noindent">The BPF Compiler Collection (or “bcc” after the project and package names) is an open-source project containing a large collection of advanced performance analysis tools, as well as a framework for building them. BCC was created by Brenden Blanco; I’ve helped with its development and created many of the tracing tools.</p>
        <p class="noindent">As an example of a BCC tool, biolatency(8) shows the distribution of disk I/O latency as power-of-two histograms, and can break it down by I/O flags:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg753a" id="pg753">Click here to view code image</a></p>
        <pre class="pretab"># <strong>biolatency.py -mF</strong>
        Tracing block device I/O... Hit Ctrl-C to end.
        ^C
        
        flags = Priority-Metadata-Read
             msecs               : count     distribution
                 0 -&gt; 1          : 90       |****************************************|<br>
        <span epub:type="pagebreak" id="page_754"></span>flags = Write
             msecs               : count     distribution
                 0 -&gt; 1          : 24       |****************************************|
                 2 -&gt; 3          : 0        |                                        |
                 4 -&gt; 7          : 8        |*************                           |
        
        flags = ReadAhead-Read
             msecs               : count     distribution
                 0 -&gt; 1          : 3031     |****************************************|
                 2 -&gt; 3          : 10       |                                        |
                 4 -&gt; 7          : 5        |                                        |
                 8 -&gt; 15         : 3        |                                        |</pre>
        <p class="noindent">This output shows a bi-model write distribution, and many I/O with flags “ReadAhead-Read”. This tool uses BPF to summarize the histograms in kernel space for efficiency, so the user-space component only needs to read the already-summarized histograms (the count columns) and print them.</p>
        <p class="noindent">These BCC tools typically have usage messages (<code>-h</code>), man pages, and examples files in the BCC repository:</p>
        <p class="uln"><a href="https://github.com/iovisor/bcc">https://github.com/iovisor/bcc</a></p>
        <p class="noindent">This section summarizes BCC and its single- and multi-purpose performance analysis tools.</p>
        <section>
        <h4 class="h4" id="ch15lev1sec1">15.1.1 Installation</h4>
        <p class="noindent">Packages of BCC are available for many Linux distributions, including Ubuntu, Debian, RHEL, Fedora, and Amazon Linux, making installation trivial. Search for “bcc-tools” or “bpfcc-tools” or “bcc” (package maintainers have named it differently).</p>
        <p class="noindent">You can also build BCC from source. For the latest install and build instructions, check INSTALL.md in the BCC repository [Iovisor 20b]. The INSTALL.md also lists kernel configuration requirements (which include CONFIG_BPF=y, CONFIG_BPF_SYSCALL=y, CONFIG_BPF_EVENTS=y). BCC requires at least Linux 4.4 for some of the tools to work; for most of the tools, 4.9 or newer is required.</p>
        </section>
        <section>
        <h4 class="h4" id="ch15lev1sec2">15.1.2 Tool Coverage</h4>
        <p class="noindent">BCC tracing tools are pictured in <a href="ch15.xhtml#ch15fig02">Figure 15.2</a> (some are grouped using wildcards: e.g., <code>java*</code> is for all tools beginning with “java”).</p>
        <figure class="image-c" id="ch15fig02">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136821694/files/graphics/15fig02.jpg" alt="Images" width="775" height="416">
        <figcaption>
        <p class="title-f"><span class="pd_ashf">Figure 15.2</span> BCC tools</p>
        </figcaption>
        </figure>
        <p class="noindent">Many are single-purpose tools shown with a single arrow head; some are multi-purpose tools listed on the left with a double arrow to show their coverage.</p>
        </section>
        <section>
        <h4 class="h4" id="ch15lev1sec3"><span epub:type="pagebreak" id="page_755"></span>15.1.3 Single-Purpose Tools</h4>
        <p class="noindent">I developed many of these according to the same “do one job and do it well” philosophy as those in perf-tools in <a href="ch14.xhtml#ch14">Chapter 14</a>. This design includes making their default output concise and often just sufficient. You can “just run biolatency” without needing to learn any command line options, and usually get just enough output to solve your problem without clutter. Options typically do exist for customization, such as biolatency(8) <code>-F</code> to breakdown by I/O flags, shown earlier.</p>
        <p class="noindent">A selection of single-purpose tools are described in <a href="ch15.xhtml#ch15tab02">Table 15.2</a>, including their location in this book if present. See the BCC repository for the full list <a href="ch15.xhtml#ch15ref6">[Iovisor 20a]</a>.</p>
        <figure class="table" id="ch15tab02">
        <figcaption>
        <p class="title-t"><span class="pd_ashf">Table 15.2</span> <strong>Selected single-purpose BCC tools</strong></p>
        </figcaption>
        <table class="all">
        <thead>
        <tr>
        <th class="th"><p class="thead"><strong>Tool</strong></p></th>
        <th class="th"><p class="thead"><strong>Description</strong></p></th>
        <th class="th"><p class="thead"><strong>Section</strong></p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="border"><p class="tab-para">biolatency(8)</p></td>
        <td class="border"><p class="tab-para">Summarize block I/O (disk I/O) latency as a histogram</p></td>
        <td class="border"><p class="tab-para"><a href="ch09.xhtml#ch09lev6sec6">9.6.6</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">biotop(8)</p></td>
        <td class="border"><p class="tab-para">Summarize block I/O by process</p></td>
        <td class="border"><p class="tab-para"><a href="ch09.xhtml#ch09lev6sec8">9.6.8</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">biosnoop(8)</p></td>
        <td class="border"><p class="tab-para">Trace block I/O with latency and other details</p></td>
        <td class="border"><p class="tab-para"><a href="ch09.xhtml#ch09lev6sec7">9.6.7</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">bitesize(8)</p></td>
        <td class="border"><p class="tab-para">Summarize block I/O size as process histograms</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">btrfsdist(8)</p></td>
        <td class="border"><p class="tab-para">Summarize btrfs operation latency as histograms</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec13">8.6.13</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">btrfsslower(8)</p></td>
        <td class="border"><p class="tab-para">Trace slow btrfs operations</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec14">8.6.14</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">cpudist(8)</p></td>
        <td class="border"><p class="tab-para">Summarize on- and off-CPU time per process as a histogram</p></td>
        <td class="border"><p class="tab-para"><a href="ch06.xhtml#ch06lev6sec15">6.6.15</a>, <a href="ch16.xhtml#ch16lev1sec7">16.1.7</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">cpuunclaimed(8)</p></td>
        <td class="border"><p class="tab-para">Show CPU that is unclaimed and idle despite demand</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><span epub:type="pagebreak" id="page_756"></span><p class="tab-para">criticalstat(8)</p></td>
        <td class="border"><p class="tab-para">Trace long atomic critical kernel sections</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">dbslower(8)</p></td>
        <td class="border"><p class="tab-para">Trace database slow queries</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">dbstat(8)</p></td>
        <td class="border"><p class="tab-para">Summarize database query latency as a histogram</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">drsnoop(8)</p></td>
        <td class="border"><p class="tab-para">Trace direct memory reclaim events with PID and latency</p></td>
        <td class="border"><p class="tab-para"><a href="ch07.xhtml#ch07lev5sec11">7.5.11</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">execsnoop(8)</p></td>
        <td class="border"><p class="tab-para">Trace new processes via execve(2) syscalls</p></td>
        <td class="border"><p class="tab-para"><a href="ch01.xhtml#ch01lev7sec3">1.7.3</a>, <a href="ch05.xhtml#ch05lev5sec5">5.5.5</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">ext4dist(8)</p></td>
        <td class="border"><p class="tab-para">Summarize ext4 operation latency as histograms</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec13">8.6.13</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">ext4slower(8)</p></td>
        <td class="border"><p class="tab-para">Trace slow ext4 operations</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec14">8.6.14</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">filelife(8)</p></td>
        <td class="border"><p class="tab-para">Trace the lifespan of short-lived files</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">gethostlatency(8)</p></td>
        <td class="border"><p class="tab-para">Trace DNS latency via resolver functions</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">hardinqs(8)</p></td>
        <td class="border"><p class="tab-para">Summarize hardirq event times</p></td>
        <td class="border"><p class="tab-para"><a href="ch06.xhtml#ch06lev6sec19">6.6.19</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">killsnoop(8)</p></td>
        <td class="border"><p class="tab-para">Trace signals issued by the kill(2) syscall</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">klockstat(8)</p></td>
        <td class="border"><p class="tab-para">Summarize kernel mutex lock statistics</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">llcstat(8)</p></td>
        <td class="border"><p class="tab-para">Summarize CPU cache references and misses by process</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">memleak(8)</p></td>
        <td class="border"><p class="tab-para">Show outstanding memory allocations</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">mysqld_qslower(8)</p></td>
        <td class="border"><p class="tab-para">Trace MySQL slow queries</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">nfsdist(8)</p></td>
        <td class="border"><p class="tab-para">Trace slow NFS operations</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec13">8.6.13</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">nfsslower(8)</p></td>
        <td class="border"><p class="tab-para">Summarize NFS operation latency as histograms</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec14">8.6.14</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">offcputime(8)</p></td>
        <td class="border"><p class="tab-para">Summarize off-CPU time by stack trace</p></td>
        <td class="border"><p class="tab-para"><a href="ch05.xhtml#ch05lev5sec3">5.5.3</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">offwaketime(8)</p></td>
        <td class="border"><p class="tab-para">Summarize blocked time by off-CPU stack and waker stack</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">oomkill(8)</p></td>
        <td class="border"><p class="tab-para">Trace the out-of-memory (OOM) killer</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">opensnoop(8)</p></td>
        <td class="border"><p class="tab-para">Trace open(2)-family syscalls</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec10">8.6.10</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">profile(8)</p></td>
        <td class="border"><p class="tab-para">Profile CPU usage using timed sampling of stack traces</p></td>
        <td class="border"><p class="tab-para"><a href="ch05.xhtml#ch05lev5sec2">5.5.2</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">runqlat(8)</p></td>
        <td class="border"><p class="tab-para">Summarize run queue (scheduler) latency as a histogram</p></td>
        <td class="border"><p class="tab-para"><a href="ch06.xhtml#ch06lev6sec16">6.6.16</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">runqlen(8)</p></td>
        <td class="border"><p class="tab-para">Summarize run queue length using timed sampling</p></td>
        <td class="border"><p class="tab-para"><a href="ch06.xhtml#ch06lev6sec17">6.6.17</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">runqslower(8)</p></td>
        <td class="border"><p class="tab-para">Trace long run queue delays</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">syncsnoop(8)</p></td>
        <td class="border"><p class="tab-para">Trace sync(2)-family syscalls</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">syscount(8)</p></td>
        <td class="border"><p class="tab-para">Summarize syscall counts and latencies</p></td>
        <td class="border"><p class="tab-para"><a href="ch05.xhtml#ch05lev5sec6">5.5.6</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">tcplife(8)</p></td>
        <td class="border"><p class="tab-para">Trace TCP sessions and summarize their lifespan</p></td>
        <td class="border"><p class="tab-para"><a href="ch10.xhtml#ch10lev6sec9">10.6.9</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">tcpretrans(8)</p></td>
        <td class="border"><p class="tab-para">Trace TCP retransmits with details including kernel state</p></td>
        <td class="border"><p class="tab-para"><a href="ch10.xhtml#ch10lev6sec11">10.6.11</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">tcptop(8)</p></td>
        <td class="border"><p class="tab-para">Summarize TCP send/recv throughput by host and PID</p></td>
        <td class="border"><p class="tab-para"><a href="ch10.xhtml#ch10lev6sec10">10.6.10</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">wakeuptime(8)</p></td>
        <td class="border"><p class="tab-para">Summarize sleep to wakeup time by waker stack</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">xfsdist(8)</p></td>
        <td class="border"><p class="tab-para">Summarize xfs operation latency as histograms</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec13">8.6.13</a></p></td>
        </tr>
        <tr>
        <td class="border"><span epub:type="pagebreak" id="page_757"></span><p class="tab-para">xfsslower(8)</p></td>
        <td class="border"><p class="tab-para">Trace slow xfs operations</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec14">8.6.14</a></p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">zfsdist(8)</p></td>
        <td class="border"><p class="tab-para">Summarize zfs operation latency as histograms</p></td>
        <td class="border"><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec13">8.6.13</a></p></td>
        </tr>
        <tr>
        <td><p class="tab-para">zfsslower(8)</p></td>
        <td><p class="tab-para">Trace slow zfs operations</p></td>
        <td><p class="tab-para"><a href="ch08.xhtml#ch08lev6sec14">8.6.14</a></p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="noindent">For examples of these, see previous chapters as well as the *_example.txt files in the BCC repository (many of which I also wrote). For the tools not covered in this book, also see <a href="ch15.xhtml#ch15ref4">[Gregg 19]</a>.</p>
        </section>
        <section>
        <h4 class="h4" id="ch15lev1sec4">15.1.4 Multi-Purpose Tools</h4>
        <p class="noindent">The multi-purpose tools are listed on the left of <a href="ch15.xhtml#ch15fig02">Figure 15.2</a>. These support multiple event sources and can perform many roles, similar to perf(1), although this also makes them complex to use. They are described in <a href="ch15.xhtml#ch15tab03">Table 15.3</a>.</p>
        <figure class="table" id="ch15tab03">
        <figcaption>
        <p class="title-t"><span class="pd_ashf">Table 15.3</span> <strong>Multi-purpose perf-tools</strong></p>
        </figcaption>
        <table class="all">
        <thead>
        <tr>
        <th class="th"><p class="thead"><strong>Tool</strong></p></th>
        <th class="th"><p class="thead"><strong>Description</strong></p></th>
        <th class="th"><p class="thead"><strong>Section</strong></p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="border"><p class="tab-para">argdist(8)</p></td>
        <td class="border"><p class="tab-para">Display function parameter values as a histogram or count</p></td>
        <td class="border"><p class="tab-para">15.1.15</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">funccount(8)</p></td>
        <td class="border"><p class="tab-para">Count kernel or user-level function calls</p></td>
        <td class="border"><p class="tab-para">15.1.15</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">funcslower(8)</p></td>
        <td class="border"><p class="tab-para">Trace slow kernel or user-level function calls</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">funclatency(8)</p></td>
        <td class="border"><p class="tab-para">Summarize function latency as a histogram</p></td>
        <td class="border"><p class="tab-para">-</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para">stackcount(8)</p></td>
        <td class="border"><p class="tab-para">Count stack traces that led to an event</p></td>
        <td class="border"><p class="tab-para">15.1.15</p></td>
        </tr>
        <tr>
        <td><p class="tab-para">trace(8)</p></td>
        <td><p class="tab-para">Trace arbitrary functions with filters</p></td>
        <td><p class="tab-para">15.1.15</p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="noindent">To help you remember useful invocations, you can collect one-liners. I have provided some in the next section, similar to my one-liner sections for perf(1) and trace-cmd.</p>
        </section>
        <section>
        <h4 class="h4" id="ch15lev1sec5">15.1.5 One-Liners</h4>
        <p class="noindent">The following one-liners trace system-wide until Ctrl-C is typed, unless otherwise specified. They are grouped by tool.</p>
        <section>
        <h5 class="h5" id="ch15lev3_1">funccount(8)</h5>
        <p class="noindent">Count VFS kernel calls:</p>
        <pre class="preash">funcgraph 'vfs_*'</pre>
        <p class="noindent">Count TCP kernel calls:</p>
        <pre class="preash">funccount 'tcp_*'</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_758"></span>Count TCP send calls per second:</p>
        <pre class="preash">funccount -i 1 'tcp_send*'</pre>
        <p class="noindent">Show the rate of block I/O events per second:</p>
        <pre class="preash">funccount -i 1 't:block:*'</pre>
        <p class="noindent">Show the rate of libc getaddrinfo() (name resolution) per second:</p>
        <pre class="preash">funccount -i 1 c:getaddrinfo</pre>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_2">stackcount(8)</h5>
        <p class="noindent">Count stack traces that created block I/O:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg758-1a" id="pg758-1">Click here to view code image</a></p>
        <pre class="preash">stackcount t:block:block_rq_insert</pre>
        <p class="noindent">Count stack traces that led to sending IP packets, with responsible PID:</p>
        <pre class="preash">stackcount -P ip_output</pre>
        <p class="noindent">Count stack traces that led to the thread blocking and moving off-CPU:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg758-2a" id="pg758-2">Click here to view code image</a></p>
        <pre class="preash">stackcount t:sched:sched_switch</pre>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_3">trace(8)</h5>
        <p class="noindent">Trace the kernel do_sys_open() function with the filename:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg758-3a" id="pg758-3">Click here to view code image</a></p>
        <pre class="preash">trace 'do_sys_open "%s", arg2'</pre>
        <p class="noindent">Trace the return of the kernel function do_sys_open() and print the return value:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg758-4a" id="pg758-4">Click here to view code image</a></p>
        <pre class="preash">trace 'r::do_sys_open "ret: %d", retval'</pre>
        <p class="noindent">Trace the kernel function do_nanosleep() with mode and user-level stacks:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg758-5a" id="pg758-5">Click here to view code image</a></p>
        <pre class="preash">trace -U 'do_nanosleep "mode: %d", arg2'</pre>
        <p class="noindent">Trace authentication requests via the pam library:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg758-6a" id="pg758-6">Click here to view code image</a></p>
        <pre class="preash">trace 'pam:pam_start "%s: %s", arg1, arg2'</pre>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_4">argdist(8)</h5>
        <p class="noindent">Summarize VFS reads by return value (size or error):</p>
        <pre class="preash">argdist -H 'r::vfs_read()'</pre>
        <p class="noindent">Summarize libc read() by return value (size or error) for PID 1005:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg758-7a" id="pg758-7">Click here to view code image</a></p>
        <pre class="preash">argdist -p 1005 -H 'r:c:read()'</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_759"></span>Count syscalls by syscall ID:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg759-1a" id="pg759-1">Click here to view code image</a></p>
        <pre class="preash">argdist.py -C 't:raw_syscalls:sys_enter():int:args-&gt;id'</pre>
        <p class="noindent">Summarize the kernel function tcp_sendmsg() size argument using counts:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg759-2a" id="pg759-2">Click here to view code image</a></p>
        <pre class="preash">argdist -C 'p::tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size):u32:size'</pre>
        <p class="noindent">Summarize tcp_sendmsg() size as a power-of-two histogram:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg759-3a" id="pg759-3">Click here to view code image</a></p>
        <pre class="preash">argdist -H 'p::tcp_sendmsg(struct sock *sk, struct msghdr *msg, size_t size):u32:size'</pre>
        <p class="noindent">Count the libc write() call for PID 181 by file descriptor:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg759-4a" id="pg759-4">Click here to view code image</a></p>
        <pre class="preash">argdist -p 181 -C 'p:c:write(int fd):int:fd'</pre>
        <p class="noindent">Summarize reads by process where latency was &gt;100 μs:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg759-5a" id="pg759-5">Click here to view code image</a></p>
        <pre class="preash">argdist -C 'r::__vfs_read():u32:$PID:$latency &gt; 100000</pre>
        </section>
        </section>
        <section>
        <h4 class="h4" id="ch15lev1sec6">15.1.6 Multi-Tool Example</h4>
        <p class="noindent">As an example of using a multi-tool, the following shows the trace(8) tool tracing the kernel function do_sys_open(), and printing the second argument as a string:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg759-6a" id="pg759-6">Click here to view code image</a></p>
        <pre class="pretab"># <strong>trace 'do_sys_open "%s", arg2'</strong>
        PID     TID     COMM        FUNC             -
        28887   28887   ls          do_sys_open      /etc/ld.so.cache
        28887   28887   ls          do_sys_open      /lib/x86_64-linux-gnu/libselinux.so.1
        28887   28887   ls          do_sys_open      /lib/x86_64-linux-gnu/libc.so.6
        28887   28887   ls          do_sys_open      /lib/x86_64-linux-gnu/libpcre2-8.so.0
        28887   28887   ls          do_sys_open      /lib/x86_64-linux-gnu/libdl.so.2
        28887   28887   ls          do_sys_open      /lib/x86_64-linux-gnu/libpthread.so.0
        28887   28887   ls          do_sys_open      /proc/filesystems
        28887   28887   ls          do_sys_open      /usr/lib/locale/locale-archive
        [...]</pre>
        <p class="noindent">The trace syntax is inspired by printf(3), supporting a format string and arguments. In this case arg2, the second argument, was printed as a string because it contains the filename.</p>
        <p class="noindent">Both trace(8) and argdist(8) support syntax that allows many custom one-liners to be created. bpftrace, covered in the following sections, takes this further, providing a fully fledged language for writing one-line or multi-line programs.</p>
        </section>
        <section>
        <h4 class="h4" id="ch15lev1sec7"><span epub:type="pagebreak" id="page_760"></span>15.1.7 BCC vs. bpftrace</h4>
        <p class="noindent">The differences were summarized at the start of this chapter. BCC is suited for custom and complex tools, which support a variety of arguments, or use a variety of libraries. bpftrace is well suited for one-liners or short tools that accept no arguments, or a single-integer argument. BCC allows the BPF program at the heart of the tracing tool to be developed in C, enabling full control. This comes at the cost of complexity: BCC tools can take ten times as long to develop as bpftrace tools, and can have ten times as many lines of code. Since developing a tool typically requires multiple iterations, I’ve found that it saves time to first develop tools in bpftrace, which is quicker, and then port them to BCC if needed.</p>
        <p class="noindent">The difference between BCC and bpftrace is like the difference between C programming and shell scripting, where BCC is like C programming (some of it <em>is</em> C programming) and bpftrace is like shell scripting. In my daily work I use many pre-built C programs (top(1), vmstat(1), etc.) and develop custom one-off shell scripts. Likewise, I also use many pre-built BCC tools, and develop custom one-off bpftrace tools.</p>
        <p class="noindent">I have provided material in this book to support this usage: many chapters show the BCC tools you can use, and the later sections in this chapter show how you can develop custom bpftrace tools.</p>
        </section>
        <section>
        <h4 class="h4" id="ch15lev1sec8">15.1.8 Documentation</h4>
        <p class="noindent">Tools typically have a usage message to summarize their syntax. For example:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg760a" id="pg760">Click here to view code image</a></p>
        <pre class="pretab"># <strong>funccount -h</strong>
        usage: funccount [-h] [-p PID] [-i INTERVAL] [-d DURATION] [-T] [-r] [-D]
                         pattern
        
        Count functions, tracepoints, and USDT probes
        
        positional arguments:
          pattern               search expression for events
        
        optional arguments:
          -h, --help            show this help message and exit
          -p PID, --pid PID     trace this PID only
          -i INTERVAL, --interval INTERVAL
                                summary interval, seconds
          -d DURATION, --duration DURATION
                                total duration of trace, seconds
          -T, --timestamp       include timestamp on output
          -r, --regexp          use regular expressions. Default is "*" wildcards
                                only.
          -D, --debug           print BPF program before starting (for debugging
                                purposes)
        <span epub:type="pagebreak" id="page_761"></span>examples:
            ./funccount 'vfs_*'             # count kernel fns starting with "vfs"
            ./funccount -r '^vfs.*'         # same as above, using regular expressions
            ./funccount -Ti 5 'vfs_*'       # output every 5 seconds, with timestamps
            ./funccount -d 10 'vfs_*'       # trace for 10 seconds only
            ./funccount -p 185 'vfs_*'      # count vfs calls for PID 181 only
            ./funccount t:sched:sched_fork  # count calls to the sched_fork tracepoint
            ./funccount -p 185 u:node:gc*   # count all GC USDT probes in node, PID 185
            ./funccount c:malloc            # count all malloc() calls in libc
            ./funccount go:os.*             # count all "os.*" calls in libgo
            ./funccount -p 185 go:os.*      # count all "os.*" calls in libgo, PID 185
            ./funccount ./test:read*        # count "read*" calls in the ./test binary</pre>
        <p class="noindent">Every tool also has a man page (man/man8/funccount.8) and an examples file (examples/funccount_example.txt) in the bcc repository. The examples file contains output examples with commentary.</p>
        <p class="noindent">I have also created the following documentation in the BCC repository <a href="ch15.xhtml#ch15ref7">[Iovisor 20b]</a>:</p>
        <ul class="sq">
        <li><p class="bull">Tutorial for end users: docs/tutorial.md</p></li>
        <li><p class="bull">Tutorial for BCC developers: docs/tutorial_bcc_python_developer.md</p></li>
        <li><p class="bull">Reference Guide: docs/reference_guide.md</p></li>
        </ul>
        <p class="noindent"><a href="ch04.xhtml#ch04">Chapter 4</a> in my earlier book focuses on BCC <a href="ch15.xhtml#ch15ref4">[Gregg 19]</a>.</p>
        </section>
        </section>
        <section>
        <h3 class="h3" id="ch15lev2">15.2 bpftrace</h3>
        <p class="noindent">bpftrace is an open-source tracer built upon BPF and BCC, which provides not only a suite of performance analysis tools, but also a high-level language to help you develop new ones. The language has been designed to be simple and easy to learn. It is the awk(1) of tracing, and is based on awk(1). In awk(1), you write a program stanza to process an input line, and with bpftrace you write a program stanza to process an input event. bpftrace was created by Alastair Robertson, and I have become a major contributor.</p>
        <p class="noindent">As an example of bpftrace, the following one-liner shows the distribution of TCP receive message size by process name:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg761a" id="pg761">Click here to view code image</a></p>
        <pre class="pretab"># <strong>bpftrace -e 'kr:tcp_recvmsg /retval &gt;= 0/ { @recv_bytes[comm] = hist(retval); }'</strong>
        Attaching 1 probe...
        ^C
        
        @recv_bytes[sshd]:
        [32, 64)               7 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
        [64, 128)              2 |@@@@@@@@@@@@@@                                      |
        <span epub:type="pagebreak" id="page_762"></span>@recv_bytes[nodejs]:
        [0]                   82 |@@@@@@@@@@@@@@@@@@@@@@@@@@                          |
        [1]                  135 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        |
        [2, 4)               153 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@  |
        [4, 8)                12 |@@@                                                 |
        [8, 16)                6 |@                                                   |
        [16, 32)              32 |@@@@@@@@@@                                          |
        [32, 64)             158 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
        [64, 128)            155 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ |
        [128, 256)            14 |@@@@                                                |</pre>
        <p class="noindent">This output shows nodejs processes that have a bi-modal receive size, with one mode roughly 0 to 4 bytes and another between 32 and 128 bytes.</p>
        <p class="noindent">Using a concise syntax, this bpftrace one-liner has used a kretprobe to instrument tcp_recvmsg(), filtered for when the return value is positive (to exclude negative error codes), and populated a BPF map object called <code>@recv_bytes</code> with a histogram of the return value, saved using the process name (<code>comm</code>) as a key. When Ctrl-C is typed and bpftrace receives the signal (SIGINT) it ends and automatically prints out BPF maps. This syntax is explained in more detail in the following sections.</p>
        <p class="noindent">As well as enabling you to code your own one-liners, bpftrace ships with many ready-to-run tools in its repository:</p>
        <p class="noindent"><a href="https://github.com/iovisor/bpftrace">https://github.com/iovisor/bpftrace</a></p>
        <p class="noindent">This section summarizes bpftrace tools and the bpftrace programming language. This is based on my bpftrace material in <a href="ch15.xhtml#ch15ref4">[Gregg 19]</a>, which explores bpftrace in more depth.</p>
        <section>
        <h4 class="h4" id="ch15lev2sec1">15.2.1 Installation</h4>
        <p class="noindent">Packages of bpftrace are available for many Linux distributions, including Ubuntu, making installation trivial. Search for packages named “bpftrace”; they exist for Ubuntu, Fedora, Gentoo, Debian, OpenSUSE, and CentOS. RHEL 8.2 has bpftrace as a Technology Preview.</p>
        <p class="noindent">Apart from packages, there are also Docker images of bpftrace, bpftrace binaries that require no dependencies other than glibc, and instructions for building bpftrace from source. For documentation on these options see INSTALL.md in the bpftrace repository [Iovisor 20a], which also lists kernel requirements (which include CONFIG_BPF=y, CONFIG_BPF_SYSCALL=y, CONFIG_BPF_EVENTS=y). bpftrace requires Linux 4.9 or newer.</p>
        </section>
        <section>
        <h4 class="h4" id="ch15lev2sec2">15.2.2 Tools</h4>
        <p class="noindent">bpftrace tracing tools are pictured in <a href="ch15.xhtml#ch15fig03">Figure 15.3</a>.</p>
        <figure class="image-c" id="ch15fig03">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136821694/files/graphics/15fig03.jpg" alt="Images" width="775" height="508">
        <figcaption>
        <p class="title-f"><span class="pd_ashf">Figure 15.3</span> bpftrace tools</p>
        </figcaption>
        </figure>
        <p class="noindent">The tools in the bpftrace repository are shown in black. For my prior book, I developed many more bpftrace tools and released them as open source in the bpf-perf-tools-book repository: they are shown in red/gray <a href="ch15.xhtml#ch15ref5">[Gregg 19g]</a>.</p>
        </section>
        <section>
        <h4 class="h4" id="ch15lev2sec3"><span epub:type="pagebreak" id="page_763"></span>15.2.3 One-Liners</h4>
        <p class="noindent">The following one-liners trace system-wide until Ctrl-C is typed, unless otherwise specified. Apart from their intrinsic usefulness, they can also serve as mini-examples of the bpftrace programming language. These are grouped by target. Longer lists of bpftrace one-liners can be found in each resource chapter.</p>
        <section>
        <h5 class="h5" id="ch15lev3_5">CPUs</h5>
        <p class="noindent">Trace new processes with arguments:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg763-1a" id="pg763-1">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'tracepoint:syscalls:sys_enter_execve { join(args-&gt;argv); }'</pre>
        <p class="noindent">Count syscalls by process:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg763-2a" id="pg763-2">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'tracepoint:raw_syscalls:sys_enter { @[pid, comm] = count(); }'</pre>
        <p class="noindent">Sample user-level stacks at 49 Hertz, for PID 189:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg763-3a" id="pg763-3">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'profile:hz:49 /pid == 189/ { @[ustack] = count(); }'</pre>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_6">Memory</h5>
        <p class="noindent">Count process heap expansion (brk()) by code path:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg763-4a" id="pg763-4">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e tracepoint:syscalls:sys_enter_brk { @[ustack, comm] = count(); }</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_764"></span>Count user page faults by user-level stack trace:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-1a" id="pg764-1">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'tracepoint:exceptions:page_fault_user { @[ustack, comm] =
            count(); }'</pre>
        <p class="noindent">Count vmscan operations by tracepoint:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-2a" id="pg764-2">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'tracepoint:vmscan:* { @[probe]++; }'</pre>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_7">File Systems</h5>
        <p class="noindent">Trace files opened via openat(2) with process name:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-3a" id="pg764-3">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 't:syscalls:sys_enter_openat { printf("%s %s\n", comm,
            str(args-&gt;filename)); }'</pre>
        <p class="noindent">Show the distribution of read() syscall read bytes (and errors):</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-4a" id="pg764-4">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'tracepoint:syscalls:sys_exit_read { @ = hist(args-&gt;ret); }'</pre>
        <p class="noindent">Count VFS calls:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-5a" id="pg764-5">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'kprobe:vfs_* { @[probe] = count(); }'</pre>
        <p class="noindent">Count ext4 tracepoint calls:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-6a" id="pg764-6">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'tracepoint:ext4:* { @[probe] = count(); }'</pre>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_8">Disk</h5>
        <p class="noindent">Summarize block I/O size as a histogram:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-7a" id="pg764-7">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 't:block:block_rq_issue { @bytes = hist(args-&gt;bytes); }'</pre>
        <p class="noindent">Count block I/O request user stack traces:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-8a" id="pg764-8">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 't:block:block_rq_issue { @[ustack] = count(); }'</pre>
        <p class="noindent">Count block I/O type flags:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-9a" id="pg764-9">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 't:block:block_rq_issue { @[args-&gt;rwbs] = count(); }'</pre>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_9">Networking</h5>
        <p class="noindent">Count socket accept(2)s by PID and process name:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-10a" id="pg764-10">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 't:syscalls:sys_enter_accept* { @[pid, comm] = count(); }'</pre>
        <p class="noindent">Count socket send/receive bytes by on-CPU PID and process name:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg764-11a" id="pg764-11">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'kr:sock_sendmsg,kr:sock_recvmsg /retval &gt; 0/ {
            @[pid, comm] = sum(retval); }'</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_765"></span>TCP send bytes as a histogram:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-1a" id="pg765-1">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'k:tcp_sendmsg { @send_bytes = hist(arg2); }'</pre>
        <p class="noindent">TCP receive bytes as a histogram:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-2a" id="pg765-2">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'kr:tcp_recvmsg /retval &gt;= 0/ { @recv_bytes = hist(retval); }'</pre>
        <p class="noindent">UDP send bytes as a histogram:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-3a" id="pg765-3">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'k:udp_sendmsg { @send_bytes = hist(arg2); }'</pre>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_10">Applications</h5>
        <p class="noindent">Sum malloc() requested bytes by user stack trace (high overhead):</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-4a" id="pg765-4">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'u:/lib/x86_64-linux-gnu/libc-2.27.so:malloc { @[ustack(5)] =
            sum(arg0); }'</pre>
        <p class="noindent">Trace kill() signals showing sender process name, target PID, and signal number:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-5a" id="pg765-5">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 't:syscalls:sys_enter_kill { printf("%s -&gt; PID %d SIG %d\n",
            comm, args-&gt;pid, args-&gt;sig); }'</pre>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_11">Kernel</h5>
        <p class="noindent">Count system calls by syscall function:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-6a" id="pg765-6">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'tracepoint:raw_syscalls:sys_enter {
            @[ksym(*(kaddr("sys_call_table") + args-&gt;id * 8))] = count(); }'</pre>
        <p class="noindent">Count kernel function calls starting with “attach”:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-7a" id="pg765-7">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'kprobe:attach* { @[probe] = count(); }'</pre>
        <p class="noindent">Frequency count the third argument to vfs_write() (the size):</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-8a" id="pg765-8">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'kprobe:vfs_write { @[arg2] = count(); }'</pre>
        <p class="noindent">Time the kernel function vfs_read() and summarize as a histogram:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-9a" id="pg765-9">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'k:vfs_read { @ts[tid] = nsecs; } kr:vfs_read /@ts[tid]/ {
            @ = hist(nsecs - @ts[tid]); delete(@ts[tid]); }'</pre>
        <p class="noindent">Count context switch stack traces:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-10a" id="pg765-10">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 't:sched:sched_switch { @[kstack, ustack, comm] = count(); }'</pre>
        <p class="noindent">Sample kernel-level stacks at 99 Hertz, excluding idle:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg765-11a" id="pg765-11">Click here to view code image</a></p>
        <pre class="preash">bpftrace -e 'profile:hz:99 /pid/ { @[kstack] = count(); }'</pre>
        </section>
        </section>
        <section>
        <h4 class="h4" id="ch15lev2sec4"><span epub:type="pagebreak" id="page_766"></span>15.2.4 Programming</h4>
        <p class="noindent">This section provides a short guide to using bpftrace and programming in the bpftrace language. The format of this section was inspired by the original paper for awk <a href="ch15.xhtml#ch15ref1">[Aho 78]</a><a href="ch15.xhtml#ch15ref2">[Aho 88]</a>, which covered that language in six pages. The bpftrace language itself is inspired by both awk and C, and by tracers including DTrace and SystemTap.</p>
        <p class="noindent">The following is an example of bpftrace programming: It measures the time in the vfs_read() kernel function and prints the time, in microseconds, as a histogram.</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg766a" id="pg766">Click here to view code image</a></p>
        <pre class="pretab">#!/usr/local/bin/bpftrace
        
        // this program times vfs_read()
        
        kprobe:vfs_read
        {
                @start[tid] = nsecs;
        }
        
        kretprobe:vfs_read
        /@start[tid]/
        {
                $duration_us = (nsecs - @start[tid]) / 1000;
                @us = hist($duration_us);
                delete(@start[tid]);
        }</pre>
        <p class="noindent">The following sections explain the components of this tool, and can be treated as a tutorial. <a href="ch15.xhtml#ch15lev2sec5">Section 15.2.5</a>, <a href="ch15.xhtml#ch15lev2sec5">Reference</a>, is a reference guide summary including probe types, tests, operators, variables, functions, and map types.</p>
        <section>
        <h5 class="h5" id="ch15lev3_12">1. Usage</h5>
        <p class="noindent">The command</p>
        <pre class="pretab">bpftrace -e program</pre>
        <p class="noindent">will execute the program, instrumenting any events that it defines. The program will run until Ctrl-C, or until it explicitly calls <code>exit()</code>. A bpftrace program run as a <code>-e</code> argument is termed a <em>one-liner</em>. Alternatively, the program can be saved to a file and executed using:</p>
        <pre class="pretab">bpftrace file.bt</pre>
        <p class="noindent">The .bt extension is not necessary, but is helpful for later identification. By placing an interpreter line at the top of the file<sup><a id="ch15fn2a" href="ch15.xhtml#ch15fn2">2</a></sup></p>
        <p class="footnote"><sup><a id="ch15fn2" href="ch15.xhtml#ch15fn2a">2</a></sup>Some people prefer using #!/usr/bin/env bpftrace, so that bpftrace can be found from $PATH. However, env(1) comes with various problems, and its usage in other projects has been reverted.</p>
        <pre class="pretab"><span epub:type="pagebreak" id="page_767"></span>#!/usr/local/bin/bpftrace</pre>
        <p class="noindent">the file can be made executable (<code>chmod a+x file.bt</code>) and run like any other program:</p>
        <pre class="pretab">./file.bt</pre>
        <p class="noindent">bpftrace must be executed by the root user (super-user).<sup><a id="ch15fn3a" href="ch15.xhtml#ch15fn3">3</a></sup> For some environments, the root shell may be used to execute the program directly, whereas other environments may have a preference for running privileged commands via sudo(1):</p>
        <pre class="pretab">sudo ./file.bt</pre>
        <p class="footnote"><sup><a id="ch15fn3" href="ch15.xhtml#ch15fn3a">3</a></sup>bpftrace checks for UID 0; a future update may check for specific privileges.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_13">2. Program Structure</h5>
        <p class="noindent">A bpftrace program is a series of probes with associated actions:</p>
        <pre class="pretab">probes { actions }
        probes { actions }
        ...</pre>
        <p class="noindent">When the probes fire, the associated action is executed. An optional filter expression can be included before the action:</p>
        <pre class="pretab">probes /filter/ { actions }</pre>
        <p class="noindent">The action only fires if the filter expression is true. This resembles the awk(1) program structure:</p>
        <pre class="pretab">/pattern/ { actions }</pre>
        <p class="noindent">awk(1) programming is also similar to bpftrace programming: Multiple action blocks can be defined, and they may execute in any order, triggered when their pattern, or probe + filter expression, is true.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_14">3. Comments</h5>
        <p class="noindent">For bpftrace program files, single-line comments can be added with a “<code>//</code>” prefix:</p>
        <pre class="pretab">// this is a comment</pre>
        <p class="noindent">These comments will not be executed. Multi-line comments use the same format as those in C:</p>
        <pre class="pretab">/*
         * This is a
         * multi-line comment.
         */</pre>
        <p class="noindent">This syntax can also be used for partial-line comments (e.g., <code>/* comment */</code>).</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_15"><span epub:type="pagebreak" id="page_768"></span>4. Probe Format</h5>
        <p class="noindent">A probe begins with a probe type name and then a hierarchy of colon-delimited identifiers:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg768-1a" id="pg768-1">Click here to view code image</a></p>
        <pre class="pretab">type:identifier1[:identifier2[...]]</pre>
        <p class="noindent">The hierarchy is defined by the probe type. Consider these two examples:</p>
        <pre class="pretab">kprobe:vfs_read
        uprobe:/bin/bash:readline</pre>
        <p class="noindent">The kprobe probe type instruments kernel function calls, and only needs one identifier: the kernel function name. The uprobe probe type instruments user-level function calls, and needs both the path to the binary and the function name.</p>
        <p class="noindent">Multiple probes can be specified with comma separators to execute the same actions. For example:</p>
        <pre class="pretab">probe1,probe2,... { actions }</pre>
        <p class="noindent">There are two special probe types that require no additional identifiers: BEGIN and END fire for the beginning and the end of the bpftrace program (just like awk(1)). For example, to print an informational message when tracing begins:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg768-2a" id="pg768-2">Click here to view code image</a></p>
        <pre class="pretab">BEGIN { printf("Tracing. Hit Ctrl-C to end.\n"); }</pre>
        <p class="noindent">To learn more about the probe types and their usage, see <a href="ch15.xhtml#ch15lev2sec5">Section 15.2.5</a>, <a href="ch15.xhtml#ch15lev2sec5">Reference</a>, under the heading 1. Probe Types.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_16">5. Probe Wildcards</h5>
        <p class="noindent">Some probe types accept wildcards. The probe</p>
        <pre class="pretab">kprobe:vfs_*</pre>
        <p class="noindent">will instrument all kprobes (kernel functions) that begin with “vfs_”.</p>
        <p class="noindent">Instrumenting too many probes may cost unnecessary performance overhead. To avoid hitting this by accident, bpftrace has a tunable maximum number of probes it will enable, set via the BPFTRACE_MAX_PROBES environment variable (it currently defaults to 512<sup><a id="ch15fn4a" href="ch15.xhtml#ch15fn4">4</a></sup>).</p>
        <p class="footnote"><sup><a id="ch15fn4" href="ch15.xhtml#ch15fn4a">4</a></sup>More than 512 currently makes bpftrace slow to start up and shut down, as it instruments them one by one. Future kernel work is planned to batch probe instrumentation. At that point, this limit can be greatly increased, or even removed.</p>
        <p class="noindent">You can test your wildcards before using them by running <code>bpftrace -l</code> to list the matched probes:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg768-4a" id="pg768-4">Click here to view code image</a></p>
        <pre class="pretab"># <strong>bpftrace -l 'kprobe:vfs_*'</strong>
        kprobe:vfs_fallocate
        kprobe:vfs_truncate
        <span epub:type="pagebreak" id="page_769"></span>kprobe:vfs_open
        kprobe:vfs_setpos
        kprobe:vfs_llseek
        […]
        bpftrace -l 'kprobe:vfs_*' | wc -l
        56</pre>
        <p class="noindent">This matched 56 probes. The probe name is in quotes to prevent unintended shell expansion.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_17">6. Filters</h5>
        <p class="noindent">Filters are Boolean expressions that gate whether an action is executed. The filter</p>
        <pre class="pretab">/pid == 123/</pre>
        <p class="noindent">will execute the action only if the pid built-in (process ID) is equal to 123.</p>
        <p class="noindent">If a test is not specified</p>
        <pre class="pretab">/pid/</pre>
        <p class="noindent">the filter will check that the contents are non-zero (<code>/pid/</code> is the same as <code>/pid != 0/</code>). Filters can be combined with Boolean operators, such as logical AND (<code>&amp;&amp;</code>). For example:</p>
        <pre class="pretab">/pid &gt; 100 &amp;&amp; pid &lt; 1000/</pre>
        <p class="noindent">This requires that both expressions evaluate to “true.”</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_18">7. Actions</h5>
        <p class="noindent">An action can be a single statement or multiple statements separated by semicolons:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg769-01a" id="pg769-01">Click here to view code image</a></p>
        <pre class="pretab">{ action one; action two; action three }</pre>
        <p class="noindent">The final statement may also have a semicolon appended. The statements are written in the bpftrace language, which is similar to the C language, and can manipulate variables and execute bpftrace function calls. For example, the action</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg769-02a" id="pg769-02">Click here to view code image</a></p>
        <pre class="pretab">{ $x = 42; printf("$x is %d", $x); }</pre>
        <p class="noindent">sets a variable, <code>$x</code>, to 42, and then prints it using <code>printf()</code>. For a summary of other available function calls, see <a href="ch15.xhtml#ch15lev2sec5">Section 15.2.5</a>, <a href="ch15.xhtml#ch15lev2sec5">Reference</a>, under headings 4. Functions and 5. Map Functions.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_19"><span epub:type="pagebreak" id="page_770"></span>8. Hello, World!</h5>
        <p class="noindent">You should now understand the following basic program, which prints “Hello, World!” when bpftrace begins running:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg770-1a" id="pg770-1">Click here to view code image</a></p>
        <pre class="pretab"># bpftrace -e 'BEGIN { printf("Hello, World!\n"); }'
        Attaching 1 probe...
        Hello, World!
        ^C</pre>
        <p class="noindent">As a file, it could be formatted as:</p>
        <pre class="pretab">#!/usr/local/bin/bpftrace
        
        BEGIN
        {
                printf("Hello, World!\n");
        }</pre>
        <p class="noindent">Spanning multiple lines with an indented action block is not necessary, but it improves readability.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_20">9 Functions</h5>
        <p class="noindent">In addition to <code>printf()</code> for printing formatted output, other built-in functions include:</p>
        <ul class="sq">
        <li><p class="bull"><strong><code>exit()</code></strong>: Exits bpftrace</p></li>
        <li><p class="bull"><strong><code>str(char *)</code></strong>: Returns a string from a pointer</p></li>
        <li><p class="bull"><strong><code>system(format[, arguments ...])</code></strong>: Runs a command at the shell</p></li>
        </ul>
        <p class="noindent">The action</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg770-2a" id="pg770-2">Click here to view code image</a></p>
        <pre class="pretab">printf("got: %llx %s\n", $x, str($x)); exit();</pre>
        <p class="noindent">will print the <code>$x</code> variable as a hex integer, and then treat it as a NULL-terminated character array pointer (char *) and print it as a string, and then exit.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_21">10 Variables</h5>
        <p class="noindent">There are three variable types: built-ins, scratch, and maps.</p>
        <p class="noindent"><strong>Built-in variables</strong> are pre-defined and provided by bpftrace, and are usually read-only sources of information. They include <code>pid</code> for the process id, <code>comm</code> for the process name, <code>nsecs</code> for a timestamp in nanoseconds, and <code>curtask</code> for the address of the current thread’s task_struct.</p>
        <p class="noindent"><strong>Scratch variables</strong> can be used for temporary calculations and have the prefix “<code>$</code>”. Their name and type is set on their first assignment. The statements:</p>
        <p class="codelink"><span epub:type="pagebreak" id="page_771"></span><a href="ch15_images.xhtml#pg771-1a" id="pg771-1">Click here to view code image</a></p>
        <pre class="pretab">$x = 1;
        $y = “hello”;
        $z = (struct task_struct *)curtask;</pre>
        <p class="noindent">declare <code>$x</code> as an integer, <code>$y</code> as a string, and <code>$z</code> as a pointer to a struct task_struct. These variables can only be used in the action block in which they were assigned. If variables are referenced without an assignment, bpftrace prints an error (which can help you catch typos).</p>
        <p class="noindent"><strong>Map variables</strong> use the BPF map storage object and have the prefix “<code>@</code>”. They can be used for global storage, passing data between actions. The program:</p>
        <pre class="pretab">probe1 { @a = 1; }
        probe2 { $x = @a; }</pre>
        <p class="noindent">assigns 1 to <code>@a</code> when probe1 fires, then assigns <code>@a</code> to <code>$x</code> when probe2 fires. If probe1 fired first and then probe2, <code>$x</code> would be set to 1; otherwise 0 (uninitialized).</p>
        <p class="noindent">A key can be provided with one or more elements, using maps as a hash table (an associative array). The statement</p>
        <pre class="pretab">@start[tid] = nsecs;</pre>
        <p class="noindent">is frequently used: the <code>nsecs</code> built-in is assigned to a map named <code>@start</code> and keyed on <code>tid</code>, the current thread ID. This allows threads to store custom timestamps that won’t be overwritten by other threads.</p>
        <pre class="pretab">@path[pid, $fd] = str(arg0);</pre>
        <p class="noindent">is an example of a multi-key map, one using both the <code>pid</code> builtin and the <code>$fd</code> variable as keys.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_22">11 Map Functions</h5>
        <p class="noindent">Maps can be assigned to special functions. These functions store and print data in custom ways. The assignment</p>
        <pre class="pretab">@x = count();</pre>
        <p class="noindent">counts events, and when printed will print the count. This uses a per-CPU map, and <code>@x</code> becomes a special object of type count. The following statement also counts events:</p>
        <pre class="pretab">@x++;</pre>
        <p class="noindent">However, this uses a global CPU map, instead of a per-CPU map, to provide <code>@x</code> as an integer. This global integer type is sometimes necessary for some programs that require an integer and not a count, but bear in mind that there may be a small error margin due to concurrent updates.</p>
        <p class="noindent"><span epub:type="pagebreak" id="page_772"></span>The assignment</p>
        <pre class="pretab">@y = sum($x);</pre>
        <p class="noindent">sums the <code>$x</code> variable, and when printed will print the total. The assignment</p>
        <pre class="pretab">@z = hist($x);</pre>
        <p class="noindent">stores <code>$x</code> in a power-of-two histogram, and when printed will print bucket counts and an ASCII histogram.</p>
        <p class="noindent">Some map functions operate directly on a map. For example:</p>
        <pre class="pretab">print(@x);</pre>
        <p class="noindent">will print the <code>@x</code> map. This can be used, for example, to print map contents on an interval event. This is not used often because, for convenience, all maps are automatically printed when bpftrace terminates.<sup><a id="ch15fn5a" href="ch15.xhtml#ch15fn5">5</a></sup></p>
        <p class="footnote"><sup><a id="ch15fn5" href="ch15.xhtml#ch15fn5a">5</a></sup>There is also less overhead in printing maps when bpftrace terminates, as at runtime the maps are experiencing updates, which can slow down the map walk routine.</p>
        <p class="noindent">Some map functions operate on a map key. For example:</p>
        <pre class="pretab">delete(@start[tid]);</pre>
        <p class="noindent">deletes the key-value pair from the <code>@start</code> map where the key is <code>tid</code>.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_23">12. Timing vfs_read()</h5>
        <p class="noindent">You have now learned the syntax needed to understand a more involved and practical example. This program, vfsread.bt, times the vfs_read kernel function and prints out a histogram of its duration in microseconds (us):</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg772a" id="pg772">Click here to view code image</a></p>
        <pre class="pretab">#!/usr/local/bin/bpftrace
        
        // this program times vfs_read()
        
        kprobe:vfs_read
        {
                @start[tid] = nsecs;
        }
        
        kretprobe:vfs_read
        /@start[tid]/
        {
                $duration_us = (nsecs - @start[tid]) / 1000;
        <span epub:type="pagebreak" id="page_773"></span>        @us = hist($duration_us);
                delete(@start[tid]);
        }</pre>
        <p class="noindent">This times the duration of the vfs_read() kernel function by instrumenting its start using a kprobe and storing a timestamp in a <code>@start</code> hash keyed on thread ID, and then instrumenting its end by using a kretprobe and calculating the delta as: now - start. A filter is used to ensure that the start time was recorded; otherwise, the delta calculation becomes bogus for vfs_read() calls that were in progress when tracing begins, as the end is seen but not the start (the delta would become: now - 0).</p>
        <p class="noindent">Sample output:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg773-1a" id="pg773-1">Click here to view code image</a></p>
        <pre class="pretab"># <strong>bpftrace vfsread.bt</strong>
        Attaching 2 probes...
        ^C
        
        @us:
        [0]                   23 |@                                                   |
        [1]                  138 |@@@@@@@@@                                           |
        [2, 4)               538 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@               |
        [4, 8)               744 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|
        [8, 16)              641 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@        |
        [16, 32)             122 |@@@@@@@@                                            |
        [32, 64)              13 |                                                    |
        [64, 128)             17 |@                                                   |
        [128, 256)             2 |                                                    |
        [256, 512)             0 |                                                    |
        [512, 1K)              1 |                                                    |</pre>
        <p class="noindent">The program ran until Ctrl-C was entered; then it printed this output and terminated. This histogram map was named “us” as a way to include units with the output, since the map name is printed out. By giving maps meaningful names like “bytes” and “latency_ns” you can annotate the output and make it self-explanatory.</p>
        <p class="noindent">This script can be customized as needed. Consider changing the <code>hist()</code> assignment line to:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg773-2a" id="pg773-2">Click here to view code image</a></p>
        <pre class="pretab">@us[pid, comm] = hist($duration_us);</pre>
        <p class="noindent">This stores one histogram per process ID and process name pair. With traditional system tools, like iostat(1) and vmstat(1), the output is fixed and cannot be easily customized. But with bpftrace, the metrics you see can be further broken down into parts and enhanced with metrics from other probes until you have the answers you need.</p>
        <p class="noindent">See <a href="ch08.xhtml#ch08">Chapter 8</a>, <a href="ch08.xhtml#ch08">File Systems</a>, <a href="ch08.xhtml#ch08lev6sec15">Section 8.6.15</a>, <a href="ch08.xhtml#ch08lev6sec15">BPFtrace</a>, heading VFS Latency Tracing, for an extended example that breaks down vfs_read() latency by type: file system, socket, etc.</p>
        </section>
        </section>
        <section>
        <h4 class="h4" id="ch15lev2sec5"><span epub:type="pagebreak" id="page_774"></span>15.2.5 Reference</h4>
        <p class="noindent">The following is a summary of the main components of bpftrace programming: probe types, flow control, variables, functions, and map functions.</p>
        <section>
        <h5 class="h5" id="ch15lev3_24">1. Probe Types</h5>
        <p class="noindent"><a href="ch15.xhtml#ch15tab04">Table 15.4</a> lists available probe types. Many of these also have a shortcut alias, which help create shorter one-liners.</p>
        <figure class="table" id="ch15tab04">
        <figcaption>
        <p class="title-t"><span class="pd_ashf">Table 15.4</span> <strong>bpftrace probe types</strong></p>
        </figcaption>
        <table class="all">
        <thead>
        <tr>
        <th class="th"><p class="thead"><strong>Type</strong></p></th>
        <th class="th"><p class="thead"><strong>Shortcut</strong></p></th>
        <th class="th"><p class="thead"><strong>Description</strong></p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="border"><p class="tab-para"><code>tracepoint</code></p></td>
        <td class="border"><p class="tab-para"><code>t</code></p></td>
        <td class="border"><p class="tab-para">Kernel static instrumentation points</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>usdt</code></p></td>
        <td class="border"><p class="tab-para"><code>U</code></p></td>
        <td class="border"><p class="tab-para">User-level statically defined tracing</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>kprobe</code></p></td>
        <td class="border"><p class="tab-para"><code>k</code></p></td>
        <td class="border"><p class="tab-para">Kernel dynamic function instrumentation</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>kretprobe</code></p></td>
        <td class="border"><p class="tab-para"><code>kr</code></p></td>
        <td class="border"><p class="tab-para">Kernel dynamic function return instrumentation</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>kfunc</code></p></td>
        <td class="border"><p class="tab-para"><code>f</code></p></td>
        <td class="border"><p class="tab-para">Kernel dynamic function instrumentation (BPF based)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>kretfunc</code></p></td>
        <td class="border"><p class="tab-para"><code>fr</code></p></td>
        <td class="border"><p class="tab-para">Kernel dynamic function return instrumentation (BPF based)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>uprobe</code></p></td>
        <td class="border"><p class="tab-para"><code>u</code></p></td>
        <td class="border"><p class="tab-para">User-level dynamic function instrumentation</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>uretprobe</code></p></td>
        <td class="border"><p class="tab-para"><code>ur</code></p></td>
        <td class="border"><p class="tab-para">User-level dynamic function return instrumentation</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>software</code></p></td>
        <td class="border"><p class="tab-para"><code>s</code></p></td>
        <td class="border"><p class="tab-para">Kernel software-based events</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>hardware</code></p></td>
        <td class="border"><p class="tab-para"><code>h</code></p></td>
        <td class="border"><p class="tab-para">Hardware counter-based instrumentation</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>watchpoint</code></p></td>
        <td class="border"><p class="tab-para"><code>w</code></p></td>
        <td class="border"><p class="tab-para">Memory watchpoint instrumentation</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>profile</code></p></td>
        <td class="border"><p class="tab-para"><code>p</code></p></td>
        <td class="border"><p class="tab-para">Timed sampling across all CPUs</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>interval</code></p></td>
        <td class="border"><p class="tab-para"><code>i</code></p></td>
        <td class="border"><p class="tab-para">Timed reporting (from one CPU)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>BEGIN</code></p></td>
        <td class="border"><p class="tab-para">&nbsp;</p></td>
        <td class="border"><p class="tab-para">Start of bpftrace</p></td>
        </tr>
        <tr>
        <td><p class="tab-para"><code>END</code></p></td>
        <td><p class="tab-para">&nbsp;</p></td>
        <td><p class="tab-para">End of bpftrace</p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="noindent">Most of these probe types are interfaces to existing kernel technologies. <a href="ch04.xhtml#ch04">Chapter 4</a> explains how these technologies work: kprobes, uprobes, tracepoints, USDT, and PMCs (used by the hardware probe type). The kfunc/kretfunc probe type is a new low-overhead interface based on eBPF trampolines and BTF.</p>
        <p class="noindent">Some probes may fire frequently, such as for scheduler events, memory allocations, and network packets. To reduce overhead, try to solve your problems by using less-frequent events wherever possible. If you are unsure about probe frequency, you can measure it using bpftrace. For example, counting vfs_read() kprobe calls for one second only:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg774a" id="pg774">Click here to view code image</a></p>
        <pre class="pretab"># <strong>bpftrace -e 'k:vfs_read { @ = count(); } interval:s:1 { exit(); }'</strong></pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_775"></span>I chose a short duration to minimize the overhead cost, in case it was significant. What I would consider high or low frequency depends on your CPU speed, count, and headroom, and the cost of the probe instrumentation. As a rough guide for the computers of today, I would consider less than 100k kprobe or tracepoint events per second to be low frequency.</p>
        <section>
        <h6 class="h6">Probe Arguments</h6>
        <p class="noindent">Each probe type provides different types of arguments for further context on events. For example, tracepoints provide the fields from the format file using their field names in an <code>args</code> data structure. For example, the following instruments the syscalls:sys_enter_read tracepoint and uses the <code>args-&gt;count</code> argument to record a histogram of the count argument (requested size):</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg775-1a" id="pg775-1">Click here to view code image</a></p>
        <pre class="pretab">bpftrace -e 'tracepoint:syscalls:sys_enter_read { @req_bytes = hist(args-&gt;count); }'</pre>
        <p class="noindent">These fields can be listed from the format file in /sys or from bpftrace using <code>-lv</code>:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg775-2a" id="pg775-2">Click here to view code image</a></p>
        <pre class="pretab"># <strong>bpftrace -lv 'tracepoint:syscalls:sys_enter_read'</strong>
        tracepoint:syscalls:sys_enter_read
            int __syscall_nr;
            unsigned int fd;
            char * buf;
            size_t count;</pre>
        <p class="noindent">See the online “bpftrace Reference Guide” for a description of each probe type and its arguments <a href="ch15.xhtml#ch15ref8">[Iovisor 20c]</a>.</p>
        </section>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_25">2. Flow Control</h5>
        <p class="noindent">There are three types of tests in bpftrace: filters, ternary operators, and if statements. These tests conditionally change the flow of the program based on Boolean expressions, which support those shown in <a href="ch15.xhtml#ch15tab05">Table 15.5</a>.</p>
        <figure class="table" id="ch15tab05">
        <figcaption>
        <p class="title-t"><span class="pd_ashf">Table 15.5</span> <strong>bpftrace Boolean expressions</strong></p>
        </figcaption>
        <table class="all">
        <thead>
        <tr>
        <th class="th"><p class="thead"><strong>Expression</strong></p></th>
        <th class="th"><p class="thead"><strong>Description</strong></p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>==</code></strong></p></td>
        <td class="border"><p class="tab-para">Equal to</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>!=</code></strong></p></td>
        <td class="border"><p class="tab-para">Not equal to</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>&gt;</code></strong></p></td>
        <td class="border"><p class="tab-para">Greater than</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>&lt;</code></strong></p></td>
        <td class="border"><p class="tab-para">Less than</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>&gt;=</code></strong></p></td>
        <td class="border"><p class="tab-para">Greater than or equal to</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>&lt;=</code></strong></p></td>
        <td class="border"><p class="tab-para">Less than or equal to</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>&amp;&amp;</code></strong></p></td>
        <td class="border"><p class="tab-para">And</p></td>
        </tr>
        <tr>
        <td><p class="tab-para"><strong><code>||</code></strong></p></td>
        <td><p class="tab-para">Inclusive or</p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="noindent">Expressions may be grouped using parentheses.</p>
        <section>
        <h6 class="h6"><span epub:type="pagebreak" id="page_776"></span>Filter</h6>
        <p class="noindent">Introduced earlier, these gate whether an action is executed. Format:</p>
        <pre class="pretab">probe /filter/ { action }</pre>
        <p class="noindent">Boolean operators may be used. The filter <code>/pid == 123/</code> only executes the action if the <code>pid</code> built-in equals 123.</p>
        </section>
        <section>
        <h6 class="h6">Ternary Operators</h6>
        <p class="noindent">A ternary operator is a three-element operator composed of a test and two outcomes. Format:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg776-1a" id="pg776-1">Click here to view code image</a></p>
        <pre class="pretab">test ? true_statement : false_statement</pre>
        <p class="noindent">As an example, you can use a ternary operator to find the absolute value of <code>$x</code>:</p>
        <pre class="pretab">$abs = $x &gt;= 0 ? $x : - $x;</pre>
        </section>
        <section>
        <h6 class="h6">If Statements</h6>
        <p class="noindent">If statements have the following syntax:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg776-2a" id="pg776-2">Click here to view code image</a></p>
        <pre class="pretab">if (test) { true_statements }
        if (test) { true_statements } else { false_statements }</pre>
        <p class="noindent">One use case is with programs that perform different actions on IPv4 than on IPv6. For example (for simplicity, this ignores families other than IPv4 and IPv6):</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg776-3a" id="pg776-3">Click here to view code image</a></p>
        <pre class="pretab">if ($inet_family == $AF_INET) {
            // IPv4
            ...
        } else {
            // assume IPv6
            ...
        }</pre>
        <p class="noindent"><code>else if</code> statements are supported since bpftrace v0.10.0.<sup><a id="ch15fn6a" href="ch15.xhtml#ch15fn6">6</a></sup></p>
        <p class="footnote"><sup><a id="ch15fn6" href="ch15.xhtml#ch15fn6a">6</a></sup>Thanks Daniel Xu (PR#1211).</p>
        </section>
        <section>
        <h6 class="h6">Loops</h6>
        <p class="noindent">bpftrace supports unrolled loops using <code>unroll()</code>. For Linux 5.3 and later kernels, <code>while()</code> loops are also supported<sup><a id="ch15fn7a" href="ch15.xhtml#ch15fn7">7</a></sup>:</p>
        <p class="footnote"><sup><a id="ch15fn7" href="ch15.xhtml#ch15fn7a">7</a></sup>Thanks Bas Smit for adding the bpftrace logic (PR#1066).</p>
        <pre class="pretab"><span epub:type="pagebreak" id="page_777"></span>while (test) {
            statements
        }</pre>
        <p class="noindent">This uses the kernel BPF loop support added in Linux 5.3.</p>
        </section>
        <section>
        <h6 class="h6">Operators</h6>
        <p class="noindent">An earlier section listed Boolean operators for use in tests. bpftrace also supports the operators shown in <a href="ch15.xhtml#ch15tab06">Table 15.6</a>.</p>
        <figure class="table" id="ch15tab06">
        <figcaption>
        <p class="title-t"><span class="pd_ashf">Table 15.6</span> <strong>bpftrace operators</strong></p>
        </figcaption>
        <table class="all">
        <thead>
        <tr>
        <th class="th"><p class="thead"><strong>Operator</strong></p></th>
        <th class="th"><p class="thead"><strong>Description</strong></p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="border"><p class="tab-para"><code>=</code></p></td>
        <td class="border"><p class="tab-para">Assignment</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>+</code></strong>, <strong><code>-</code></strong>, <strong><code>*</code></strong>, <strong><code>/</code></strong></p></td>
        <td class="border"><p class="tab-para">Addition, subtraction, multiplication, division (integers only)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>++</code></strong>, <strong><code>--</code></strong></p></td>
        <td class="border"><p class="tab-para">Auto-increment, auto-decrement</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>&amp;</code></strong>, <strong><code>|</code></strong>, <strong><code>^</code></strong></p></td>
        <td class="border"><p class="tab-para">Binary and, binary or, binary exclusive or</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>!</code></p></td>
        <td class="border"><p class="tab-para">Logical not</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><strong><code>&lt;&lt;</code></strong>, <strong><code>&gt;&gt;</code></strong></p></td>
        <td class="border"><p class="tab-para">Logical shift left, logical shift right</p></td>
        </tr>
        <tr>
        <td><p class="tab-para"><strong><code>+=</code></strong>, <strong><code>-=</code></strong>, <strong><code>*=</code></strong>, <strong><code>/=</code></strong>, <strong><code>%=</code></strong>, <strong><code>&amp;=</code></strong>, <strong><code>^=</code></strong>, <strong><code>&lt;&lt;=</code></strong>, <strong><code>&gt;&gt;=</code></strong></p></td>
        <td><p class="tab-para">Compound operators</p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="noindent">These operators were modeled after similar operators in the C programming language.</p>
        </section>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_26">3. Variables</h5>
        <p class="noindent">The built-in variables provided by bpftrace are usually for read-only access of information. Important built-in variables are listed in <a href="ch15.xhtml#ch15tab07">Table 15.7</a>.</p>
        <figure class="table" id="ch15tab07">
        <figcaption>
        <p class="title-t"><span class="pd_ashf">Table 15.7</span> <strong>bpftrace selected built-in variables</strong></p>
        </figcaption>
        <table class="all">
        <thead>
        <tr>
        <th class="th"><p class="thead"><strong>Built-in Variable</strong></p></th>
        <th class="th"><p class="thead"><strong>Type</strong></p></th>
        <th class="th"><p class="thead"><strong>Description</strong></p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="border"><p class="tab-para"><code>pid</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">Process ID (kernel tgid)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>tid</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">Thread ID (kernel pid)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>uid</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">User ID</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>username</code></p></td>
        <td class="border"><p class="tab-para">string</p></td>
        <td class="border"><p class="tab-para">Username</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>nsecs</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">Timestamp, in nanoseconds</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>elapsed</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">Timestamp, in nanoseconds, since bpftrace initialization</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>cpu</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">Processor ID</p></td>
        </tr>
        <tr>
        <td class="border"><span epub:type="pagebreak" id="page_778"></span><p class="tab-para"><code>comm</code></p></td>
        <td class="border"><p class="tab-para">string</p></td>
        <td class="border"><p class="tab-para">Process name</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>kstack</code></p></td>
        <td class="border"><p class="tab-para">string</p></td>
        <td class="border"><p class="tab-para">Kernel stack trace</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>ustack</code></p></td>
        <td class="border"><p class="tab-para">string</p></td>
        <td class="border"><p class="tab-para">User-level stack trace</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>arg0, ..., argN</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">Arguments to some probe types</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>args</code></p></td>
        <td class="border"><p class="tab-para">struct</p></td>
        <td class="border"><p class="tab-para">Arguments to some probe types</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>sarg0, ..., sargN</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">Stack-based arguments to some probe types</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>retval</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">Return value for some probe types</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>func</code></p></td>
        <td class="border"><p class="tab-para">string</p></td>
        <td class="border"><p class="tab-para">Name of the traced function</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>probe</code></p></td>
        <td class="border"><p class="tab-para">string</p></td>
        <td class="border"><p class="tab-para">Full name of the current probe</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>curtask</code></p></td>
        <td class="border"><p class="tab-para">struct/integer</p></td>
        <td class="border"><p class="tab-para">Kernel task_struct (either as a task_struct or an unsigned 64-bit integer, depending on the availability of type info)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>cgroup</code></p></td>
        <td class="border"><p class="tab-para">integer</p></td>
        <td class="border"><p class="tab-para">Default cgroup v2 ID for the current process (for comparisons with cgroupid())</p></td>
        </tr>
        <tr>
        <td><p class="tab-para"><code>$1, ..., $N</code></p></td>
        <td><p class="tab-para">int, char *</p></td>
        <td><p class="tab-para">Positional parameters for the bpftrace program</p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="noindent">All integers are currently uint64. These variables all refer to the currently running thread, probe, function, and CPU when the probe fires.</p>
        <p class="noindent">Various builtins have been demonstrated earlier in this chapter: <code>retval</code>, <code>comm</code>, <code>tid</code>, and <code>nsecs</code>. See the online “bpftrace Reference Guide” for the full and updated list of built-in variables <a href="ch15.xhtml#ch15ref8">[Iovisor 20c]</a>.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_27">4. Functions</h5>
        <p class="noindent"><a href="ch15.xhtml#ch15tab08">Table 15.8</a> lists selected built-in functions for various tasks. Some of these have been used in earlier examples, such as <code>printf()</code>.</p>
        <figure class="table" id="ch15tab08">
        <figcaption>
        <p class="title-t"><span class="pd_ashf">Table 15.8</span> <strong>bpftrace selected built-in functions</strong></p>
        </figcaption>
        <table class="all">
        <thead>
        <tr>
        <th class="th"><p class="thead"><strong>Function</strong></p></th>
        <th class="th"><p class="thead"><strong>Description</strong></p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="border"><p class="tab-para"><code>printf(char *fmt [, ...])</code></p></td>
        <td class="border"><p class="tab-para">Prints formatted</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>time(char *fmt)</code></p></td>
        <td class="border"><p class="tab-para">Prints formatted time</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>join(char *arr[])</code></p></td>
        <td class="border"><p class="tab-para">Prints the array of strings, joined by a space character</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>str(char *s [, int len])</code></p></td>
        <td class="border"><p class="tab-para">Returns the string from the pointer s, with an optional length limit</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>buf(void *d [, int length])</code></p></td>
        <td class="border"><p class="tab-para">Returns a hexadecimal string version of the data pointer</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>strncmp(char *s1, char *s2, int length)</code></p></td>
        <td class="border"><p class="tab-para">Compares two strings up to length characters</p></td>
        </tr>
        <tr>
        <td class="border"><span epub:type="pagebreak" id="page_779"></span><p class="tab-para"><code>sizeof(expression)</code></p></td>
        <td class="border"><p class="tab-para">Returns the size of the expression or data type</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>kstack([int limit])</code></p></td>
        <td class="border"><p class="tab-para">Returns a kernel stack up to <em>limit</em> frames deep</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>ustack([int limit])</code></p></td>
        <td class="border"><p class="tab-para">Returns a user stack up to <em>limit</em> frames deep</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>ksym(void *p)</code></p></td>
        <td class="border"><p class="tab-para">Resolves the kernel address and returns the string symbol</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>usym(void *p)</code></p></td>
        <td class="border"><p class="tab-para">Resolves the user-space address and returns the string symbol</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>kaddr(char *name)</code></p></td>
        <td class="border"><p class="tab-para">Resolves the kernel symbol name to an address</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>uaddr(char *name)</code></p></td>
        <td class="border"><p class="tab-para">Resolves the user-space symbol name to an address</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>reg(char *name)</code></p></td>
        <td class="border"><p class="tab-para">Returns the value stored in the named register</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>ntop([int af,] int addr)</code></p></td>
        <td class="border"><p class="tab-para">Returns a string representation of an IPv4/IPv6 address.</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>cgroupid(char *path)</code></p></td>
        <td class="border"><p class="tab-para">Returns a cgroup ID for the given path (/sys/fs/cgroup/...)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>system(char *fmt [, ...])</code></p></td>
        <td class="border"><p class="tab-para">Executes a shell command</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>cat(char *filename)</code></p></td>
        <td class="border"><p class="tab-para">Prints the contents of a file</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>signal(char[] sig | u32 sig)</code></p></td>
        <td class="border"><p class="tab-para">Sends a signal to the current task (e.g., SIGTERM)</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>override(u64 rc)</code></p></td>
        <td class="border"><p class="tab-para">Overrides a kprobe return value<sup><a id="ch15fn8a" href="ch15.xhtml#ch15fn8">8</a></sup></p></td>
        </tr>
        <tr>
        <td><p class="tab-para"><code>exit()</code></p></td>
        <td><p class="tab-para">Exits bpftrace</p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="footnote"><sup><a id="ch15fn8" href="ch15.xhtml#ch15fn8a">8</a></sup>WARNING: Only use this if you know what you are doing: a small mistake could panic or corrupt the kernel.</p>
        <p class="noindent">Some of these functions are asynchronous: The kernel queues the event, and a short time later it is processed in user space. The asynchronous functions are <code>printf()</code>, <code>time()</code>, <code>cat()</code>, <code>join()</code>, and <code>system()</code>. The functions <code>kstack()</code>, <code>ustack()</code>, <code>ksym()</code>, and <code>usym()</code> record addresses synchronously, but do symbol translation asynchronously.</p>
        <p class="noindent">As an example, the following uses both the <code>printf()</code> and <code>str()</code> functions to show the filename of openat(2) syscalls:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg779a" id="pg779">Click here to view code image</a></p>
        <pre class="pretab"># <strong>bpftrace -e 't:syscalls:sys_enter_open { printf("%s %s\n", comm,</strong>
            <strong>str(args-&gt;filename)); }'</strong>
        Attaching 1 probe...
        top /etc/ld.so.cache
        top /lib/x86_64-linux-gnu/libprocps.so.7
        top /lib/x86_64-linux-gnu/libtinfo.so.6
        top /lib/x86_64-linux-gnu/libc.so.6
        [...]</pre>
        <p class="noindent">See the online “bpftrace Reference Guide” for the full and updated list of functions <a href="ch15.xhtml#ch15ref8">[Iovisor 20c]</a>.</p>
        </section>
        <section>
        <h5 class="h5" id="ch15lev3_28"><span epub:type="pagebreak" id="page_780"></span>5. Map Functions</h5>
        <p class="noindent">Maps are special hash table storage objects from BPF that can be used for different purposes—for example, as hash tables to store key/value pairs or for statistical summaries. bpftrace provides built-in functions for map assignment and manipulation, mostly for supporting statistical summary maps. The most important map functions are listed in <a href="ch15.xhtml#ch15tab09">Table 15.9</a>.</p>
        <figure class="table" id="ch15tab09">
        <figcaption>
        <p class="title-t"><span class="pd_ashf">Table 15.9</span> <strong>bpftrace selected map functions</strong></p>
        </figcaption>
        <table class="all">
        <thead>
        <tr>
        <th class="th"><p class="thead"><strong>Function</strong></p></th>
        <th class="th"><p class="thead"><strong>Description</strong></p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="border"><p class="tab-para"><code>count()</code></p></td>
        <td class="border"><p class="tab-para">Counts occurrences</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>sum(int n)</code></p></td>
        <td class="border"><p class="tab-para">Sums the value</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>avg(int n)</code></p></td>
        <td class="border"><p class="tab-para">Averages the value</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>min(int n)</code></p></td>
        <td class="border"><p class="tab-para">Records the minimum value</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>max(int n)</code></p></td>
        <td class="border"><p class="tab-para">Records the maximum value</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>stats(int n)</code></p></td>
        <td class="border"><p class="tab-para">Returns the count, average, and total</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>hist(int n)</code></p></td>
        <td class="border"><p class="tab-para">Prints a power-of-two histogram of values</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>lhist(int n, const int min, const int max, int step)</code></p></td>
        <td class="border"><p class="tab-para">Prints a linear histogram of values</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>delete(@m[key])</code></p></td>
        <td class="border"><p class="tab-para">Deletes the map key/value pair</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>print(@m [, top [, div]])</code></p></td>
        <td class="border"><p class="tab-para">Prints the map, with optional limits and a divisor</p></td>
        </tr>
        <tr>
        <td class="border"><p class="tab-para"><code>clear(@m)</code></p></td>
        <td class="border"><p class="tab-para">Deletes all keys from the map</p></td>
        </tr>
        <tr>
        <td><p class="tab-para"><code>zero(@m)</code></p></td>
        <td><p class="tab-para">Sets all map values to zero</p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="noindent">Some of these functions are asynchronous: The kernel queues the event, and a short time later it is processed in user space. The asynchronous actions are <code>print()</code>, <code>clear()</code>, and <code>zero()</code>. Bear this delay in mind when you are writing programs.</p>
        <p class="noindent">As another example of using a map function, the following uses <code>lhist()</code> to create a linear histogram of syscall read(2) sizes by process name, with a step size of one so that each file descriptor number can be seen independently:</p>
        <p class="codelink"><a href="ch15_images.xhtml#pg780a" id="pg780">Click here to view code image</a></p>
        <pre class="pretab"># <strong>bpftrace -e 'tracepoint:syscalls:sys_enter_read {</strong>
            <strong>@fd[comm] = lhist(args-&gt;fd, 0, 100, 1); }'</strong>
        Attaching 1 probe...
        ^C
        [...]
        @fd[sshd]:
        [4, 5)                22 |                                                    |
        [5, 6)                 0 |                                                    |
        [6, 7)                 0 |                                                    |
        <span epub:type="pagebreak" id="page_781"></span>[7, 8)                 0 |                                                    |
        [8, 9)                 0 |                                                    |
        [9, 10)                0 |                                                    |
        [10, 11)               0 |                                                    |
        [11, 12)               0 |                                                    |
        [12, 13)            7760 |@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@|</pre>
        <p class="noindent">The output shows that on this system sshd processes were typically reading from file descriptor 12. The output uses set notation, where “<code>[</code>” means &gt;= and “<code>)</code>” means &lt; (aka a bounded left-closed, right-open interval).</p>
        <p class="noindent">See the online “bpftrace Reference Guide” for the full and updated list of map functions <a href="ch15.xhtml#ch15ref8">[Iovisor 20c]</a>.</p>
        </section>
        </section>
        <section>
        <h4 class="h4" id="ch15lev2sec6">15.2.6 Documentation</h4>
        <p class="noindent">There is more bpftrace in prior chapters of this book, in the following sections:</p>
        <ul class="sq">
        <li><p class="bull"><a href="ch05.xhtml#ch05">Chapter 5</a>, <a href="ch05.xhtml#ch05">Applications</a>, <a href="ch05.xhtml#ch05lev5sec7">Section 5.5.7</a></p></li>
        <li><p class="bull"><a href="ch06.xhtml#ch06">Chapter 6</a>, <a href="ch06.xhtml#ch06">CPUs</a>, <a href="ch06.xhtml#ch06lev6sec20">Section 6.6.20</a></p></li>
        <li><p class="bull"><a href="ch07.xhtml#ch07">Chapter 7</a>, <a href="ch07.xhtml#ch07">Memory</a>, <a href="ch07.xhtml#ch07lev5sec13">Section 7.5.13</a></p></li>
        <li><p class="bull"><a href="ch08.xhtml#ch08">Chapter 8</a>, <a href="ch08.xhtml#ch08">File Systems</a>, <a href="ch08.xhtml#ch08lev6sec15">Section 8.6.15</a></p></li>
        <li><p class="bull"><a href="ch09.xhtml#ch09">Chapter 9</a>, <a href="ch09.xhtml#ch09">Disks</a>, <a href="ch09.xhtml#ch09lev6sec11">Section 9.6.11</a></p></li>
        <li><p class="bull"><a href="ch10.xhtml#ch10">Chapter 10</a>, <a href="ch10.xhtml#ch10">Network</a>, <a href="ch10.xhtml#ch10lev6sec12">Section 10.6.12</a></p></li>
        </ul>
        <p class="noindent">There are also bpftrace examples in <a href="ch04.xhtml#ch04">Chapter 4</a>, <a href="ch04.xhtml#ch04">Observability Tools</a>, and <a href="ch11.xhtml#ch11">Chapter 11</a>, <a href="ch11.xhtml#ch11">Cloud Computing</a>.</p>
        <p class="noindent">In the bpftrace repository I have also created the following documentation:</p>
        <ul class="sq">
        <li><p class="bull">Reference Guide: docs/reference_guide.md <a href="ch15.xhtml#ch15ref8">[Iovisor 20c]</a></p></li>
        <li><p class="bull">Tutorial docs/tutorial_one_liners.md <a href="ch15.xhtml#ch15ref9">[Iovisor 20d]</a></p></li>
        </ul>
        <p class="noindent">For much more on bpftrace, please refer to my earlier book <em>BPF Performance Tools</em> <a href="ch15.xhtml#ch15ref4">[Gregg 19]</a> where <a href="ch05.xhtml#ch05">Chapter 5</a>, <a href="ch05.xhtml#ch05">bpftrace</a>, explores the programming language with many examples, and later chapters provide more bpftrace programs for the analysis of different targets.</p>
        <p class="noindent">Note that some bpftrace capabilities described in <a href="ch15.xhtml#ch15ref4">[Gregg 19]</a> as “planned” have since been added to bpftrace and are included in this chapter. They are: while() loops, else-if statements, signal(), override(), and watchpoint events. Other additions that have been added to bpftrace are the kfunc probe type, buf(), and sizeof(). Check the release notes in the bpftrace repository for future additions, although not many more are planned: bpftrace already has enough capabilities for the 120+ published bpftrace tools.</p>
        </section>
        </section>
        <section>
        <h3 class="h3" id="ch15lev3"><span epub:type="pagebreak" id="page_782"></span>15.3 References</h3>
        <p class="ref" id="ch15ref1"><strong>[Aho 78]</strong> Aho, A. V., Kernighan, B. W., and Weinberger, P. J., “Awk: A Pattern Scanning and Processing Language (Second Edition),” <em>Unix 7th Edition man pages</em>, 1978. Online at <a href="http://plan9.bell-labs.com/7thEdMan/index.html">http://plan9.bell-labs.com/7thEdMan/index.html</a>.</p>
        <p class="ref" id="ch15ref2"><strong>[Aho 88]</strong> Aho, A. V., Kernighan, B. W., and Weinberger, P. J., <em>The AWK Programming Language</em>, Addison Wesley, 1988.</p>
        <p class="ref" id="ch15ref3"><strong>[Gregg 18e]</strong> Gregg, B., “YOW! 2018 Cloud Performance Root Cause Analysis at Netflix,” <a href="http://www.brendangregg.com/blog/2019-04-26/yow2018-cloud-performance-netflix.html">http://www.brendangregg.com/blog/2019-04-26/yow2018-cloud-performance-netflix.html</a>, 2018.</p>
        <p class="ref" id="ch15ref4"><strong>[Gregg 19]</strong> Gregg, B., <em>BPF Performance Tools: Linux System and Application Observability</em>, Addison-Wesley, 2019.</p>
        <p class="ref" id="ch15ref5"><strong>[Gregg 19g]</strong> Gregg, B., “BPF Performance Tools (book): Tools,” <a href="http://www.brendangregg.com/bpf-performance-tools-book.html#tools">http://www.brendangregg.com/bpf-performance-tools-book.html#tools</a>, 2019.</p>
        <p class="ref" id="ch15ref6"><strong>[Iovisor 20a]</strong> “bpftrace: High-level Tracing Language for Linux eBPF,” <a href="https://github.com/iovisor/bpftrace">https://github.com/iovisor/bpftrace</a>, last updated 2020.</p>
        <p class="ref" id="ch15ref7"><strong>[Iovisor 20b]</strong> “BCC - Tools for BPF-based Linux IO Analysis, Networking, Monitoring, and More,” <a href="https://github.com/iovisor/bcc">https://github.com/iovisor/bcc</a>, last updated 2020.</p>
        <p class="ref" id="ch15ref8"><strong>[Iovisor 20c]</strong> “bpftrace Reference Guide,” <a href="https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md">https://github.com/iovisor/bpftrace/blob/master/docs/reference_guide.md</a>, last updated 2020.</p>
        <p class="ref" id="ch15ref9"><strong>[Iovisor 20d]</strong> Gregg, B., et al., “The bpftrace One-Liner Tutorial,” <a href="https://github.com/iovisor/bpftrace/blob/master/docs/tutorial_one_liners.md">https://github.com/iovisor/bpftrace/blob/master/docs/tutorial_one_liners.md</a>, last updated 2020.</p>
        </section>
        </section>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780136821694/files/9780136821656.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com