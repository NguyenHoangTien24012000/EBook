<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div class="chapter" title="Chapter&nbsp;11.&nbsp;SOLID Principles"><div class="titlepage"><div><div><h1 class="title"><a id="ch11"></a>Chapter&nbsp;11.&nbsp;SOLID Principles</h1></div></div></div><p>Designing software is a tricky task. Often an application grows following the user's needs, and if it is poorly designed, sooner or later we will face troubles. The SOLID principles can help us to design better applications. They allow us to detect points of weakness and to write robust, flexible, and maintainable code. Even though SOLID principles were born for classical OOP languages, they can be applied to JavaScript language as well.</p><p>In this chapter, we will explore the SOLID principles by discussing the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Single Responsibility Principle</li><li class="listitem" style="list-style-type: disc">Open/Closed Principle</li><li class="listitem" style="list-style-type: disc">Liskov Substitution Principle</li><li class="listitem" style="list-style-type: disc">Interface Segregation Principle</li><li class="listitem" style="list-style-type: disc">Dependency Inversion Principle</li></ul></div><div class="section" title="Principle of OOP design"><div class="titlepage"><div><div><h1 class="title"><a id="ch11lvl1sec69"></a>Principle of OOP design</h1></div></div></div><p>When we discussed the Object-Oriented Programming principles in <span><a class="link" href="ch02.html" title="Chapter&nbsp;2.&nbsp;Diving into OOP Principles">Chapter 2</a></span><span class="emphasis"><em>, Diving into OOP Principles</em></span> we introduced association, aggregation, composition, encapsulation, inheritance, and polymorphism. These principles are the foundations of any language that can be defined as object oriented. Therefore, they are the basic principles without which we can not say that we are applying the OOP model.</p><p>However, the simple principles of OOP are not enough to guarantee us the creation of robust and easily maintainable applications. They simply provide us with tools that allow us to model a problem using abstractions we call objects. The robustness, maintainability, and flexibility of an application mainly depends on how we design it, decide to put together its components, and use the principles of OOP.</p><p>According to Robert C. Martin, one of the co-authors of the Agile Manifesto, there are three characteristics of bad design to be avoided:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Rigidity</strong></span>: This is the difficulty of modifying an application because any change involves too many parts of the system</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Fragility</strong></span>: This is the generation of bugs in a part of an application due to changes in other parts of it</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Immobility</strong></span>: This is the inability to use a component in another software because it is too dependent on the current application</li></ul></div><p>In order to avoid these issues, Martin suggests some design principles commonly known as SOLID.</p><p>SOLID is a mnemonic acronym that refers to a set of five principles at the base of a good software design:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Single Responsibility Principle</li><li class="listitem" style="list-style-type: disc">Open/Closed Principle</li><li class="listitem" style="list-style-type: disc">Liskov Substitution Principle</li><li class="listitem" style="list-style-type: disc">Interface Segregation Principle</li><li class="listitem" style="list-style-type: disc">Dependency Inversion Principle</li></ul></div><p>The application of these principles helps us to identify potential situations that put the design of our applications at risk.</p><p>Although, in general, these principles are related to the context of classical Object-Oriented Programming and refer to classes, types, and interfaces, the underlying concepts are also applicable to a dynamically typed and prototype-based language such as JavaScript. Let's start to analyze these principles and to learn how to apply them in the development of our applications one by one.</p></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781785889103/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com