<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div epub:type="chapter" role="doc-chapter"><div class="ChapterContextInformation"><div class="ContextInformation" id="b978-1-4842-7107-0_3"><div class="ChapterCopyright">©&nbsp;The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature&nbsp;2021</div><span class="ContextInformationAuthorEditorNames">P. D. Crutcher et al.</span><span class="ContextInformationBookTitles"><span class="BookTitle">Essential Computer Science</span></span><span class="ChapterDOI"><a href="https://doi.org/10.1007/978-1-4842-7107-0_3">https://doi.org/10.1007/978-1-4842-7107-0_3</a></span></div></div><!--Begin Abstract--><div class="MainTitleSection"><h1 class="ChapterTitle" lang="en">3.&nbsp;Algorithm and Data Structure</h1></div><div class="AuthorGroup"><div class="AuthorNames"><span class="Author"><span class="AuthorName">Paul&nbsp;D.&nbsp;Crutcher</span><sup><a href="#Aff4">1</a>&nbsp;<span class="ContactIcon">&nbsp;</span></sup>, </span><span class="Author"><span class="AuthorName">Neeraj&nbsp;Kumar&nbsp;Singh</span><sup><a href="#Aff5">2</a></sup> and </span><span class="Author"><span class="AuthorName">Peter&nbsp;Tiegs</span><sup><a href="#Aff6">3</a></sup></span></div><div class="Affiliations"><div class="Affiliation" id="Aff4"><span class="AffiliationNumber">(1)</span><div class="AffiliationText">Welches, OR, USA</div></div><div class="Affiliation" id="Aff5"><span class="AffiliationNumber">(2)</span><div class="AffiliationText">Bangalore, Karnataka, India</div></div><div class="Affiliation" id="Aff6"><span class="AffiliationNumber">(3)</span><div class="AffiliationText">Hillsboro, OR, USA</div></div><div class="ClearBoth">&nbsp;</div></div></div><!--End Abstract--><div class="Fulltext"><p class="Para" id="Par2">Now that we’ve discussed computer hardware and how to program it to achieve desired purpose, we will discuss how to make programs efficient by leveraging well-known algorithms and data structures for managing logic and data, respectively.</p><section class="Section1 RenderAsSection1" id="Sec1"><h2 class="Heading">What Is an Algorithm</h2><p class="Para" id="Par3">The dictionary defines an <span id="ITerm1">algorithm</span> as a step-by-step procedure for solving a problem or accomplishing some end. In other words, an algorithm is a technique that can be used and communicated to accomplish your goal. Algorithms are not unique to computers. You probably use algorithms every day. The <span id="ITerm2">mathematical technique</span> of carrying the one or borrowing from the tens place for addition and subtraction is an algorithm that humans can learn. There is usually more than one algorithm to accomplish your goal. For instance, one algorithm for division is to count the number of times you subtract the divisor from the dividend; this count is the quotient. This is different than finding the largest number the divisor can be multiplied by to be less than the most significant bits of the dividend and then subtracting that value from the dividend to get a new dividend, which is the method most of us learned in school.</p><p class="Para" id="Par4">Algorithms can be encoded in any programming language for computers. It should be noted that algorithms for humans are not necessarily optimal for computers to accomplish the same end. This is also true for different computing architectures; an algorithm for a general-purpose CPU will not be the best algorithm for a GPU (Graphics Processing <span id="ITerm3">Unit</span>), or quantum computer. In the next section, we will examine how to evaluate algorithms and what trade-offs are made to find the right algorithm for what you need to accomplish.</p></section><section class="Section1 RenderAsSection1" id="Sec2"><h2 class="Heading">Good and <em class="EmphasisTypeItalic ">Not So Good</em> Algorithm</h2><p class="Para" id="Par5">Knowing that there are likely multiple algorithms for accomplishing what you want to do, how do we judge what is a good algorithm? What are the factors that we look at? Can we use math to compare algorithms?</p><p class="Para" id="Par6">One thing that should not be overlooked, but is hard to compare critically, is the readability of a particular algorithm. Most of the software that you write professionally will be viewed and likely maintained by others. Choosing an algorithm that can be read, and more easily maintained, to learn what goal you originally set out to accomplish can be a better choice than the most efficient algorithm. Choosing well-known algorithms can help readability, because there can be plenty of documentation about those algorithms and they can be recognized. Of course, explicitly stating the goal you are seeking to accomplish in source code comments can help.</p><section class="Section2 RenderAsSection2" id="Sec3"><h3 class="Heading">Time/Space Complexity</h3><p class="Para" id="Par7">One of the main <span id="ITerm4">areas</span> where we make trade-offs when selecting or creating algorithms is between the amount of memory, or space, that the algorithm takes and the amount of time it takes to finish.</p></section><section class="Section2 RenderAsSection2" id="Sec4"><h3 class="Heading">Asymptotic Notation</h3><div class="Para" id="Par8"><span id="ITerm5">Asymptotic notation</span><span id="ITerm6">

</span> is a method of writing the complexity of an algorithm in time based on the number of inputs into the algorithm. We cannot simply say that because algorithm 1 will take 7 seconds and algorithm 2 will take 5 seconds, algorithm 2 is better. Asymptotic notation helps by eliminating differences in individual computing machines and programming languages. Taking a closer look at those times, we need to specify the number “n” for the number of items that the algorithm will process to have a realistic measure of its performance to compare against other implementations. For simplicity, let us say n = 100. For algorithm 1, let us say the time it takes to run is 3 + .04n; similarly algorithm 2 takes 0.0005(n^2) seconds to run. As we can see in the graph (Figure <span class="InternalRef"><a href="#Fig1">3-1</a></span>), there is a crossover point in the number of items where algorithm 1 outperforms <span id="ITerm7">algorithm</span> 2.<figure class="Figure" id="Fig1"><div class="MediaObject" id="MO1"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig1_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig1_HTML.jpg" style="width:35.62em" width="1425" height="1063"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-1</span><p class="SimplePara">Runtime Comparison Example</p></div></figcaption></figure></div><p class="Para" id="Par9">These numbers are on the same computer. If we do analysis on an older computer, we find that algorithm 1 takes 5 + 0.4n or 45 seconds and algorithm 2 takes .005(n^2) or 50 seconds. We will simplify our algorithm by removing constants from the time to <span id="ITerm8">allow</span> for differences in computing machines and programming languages. This is called Big-Oh notation as the function for the time an algorithm runs asymptotically approaches the highest degree of the polynomial of n. We will write analysis O(n) for algorithm 1 and O(n^2) for algorithm 2.</p><p class="Para" id="Par10">With Big-Oh expressions, we generally want to consider “tightness” of the upper bound. While it is correct to say that an algorithm with a time function 3 + 0.4n is O(n), it is a stronger statement to simply say that this algorithm is O(n).</p><div class="Para" id="Par11"><span id="ITerm9">Big-Oh notation</span><span id="ITerm10">


</span> is a consistent method for comparing and discussing algorithms across multiple computing machines and programing languages. Table <span class="InternalRef"><a href="#Tab1">3-1</a></span> is a table of Big-Oh expressions and their informal names.<div class="Table" id="Tab1"><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Table 3-1</span><p class="SimplePara">Big-Oh Common Names</p></div></div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Big-Oh</p></th><th style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Name</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">O(1)</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Constant</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">O(log n)</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Logarithmic</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">O(n)</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Linear</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">O(n log n)</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">n log n</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">O(n<sup>2</sup>)</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Quadratic</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">O(n<sup>3</sup>)</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Cubic</p></td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">O(2<sup>n</sup>)</p></td><td style="text-align: left;"><p class="SimplePara">Exponential</p></td></tr></tbody></table></div></div></section></section><section class="Section1 RenderAsSection1" id="Sec5"><h2 class="Heading">Fundamental Data Structures and Algorithms</h2><p class="Para" id="Par12">Now that we have examined what an algorithm is and how we can compare them, we will look at common data structures that hold our data. We will also look at common algorithmic techniques using these data structures.</p><section class="Section2 RenderAsSection2" id="Sec6"><h3 class="Heading">Store (Data Structure)</h3><p class="Para" id="Par13">There are <span id="ITerm11">several</span> structures that can store data. Each of these structures has different advantages, and algorithms may be able to utilize different data structures more efficiently than others.</p><section class="Section3 RenderAsSection3" id="Sec7"><h4 class="Heading">Stack</h4><div class="Para" id="Par14">A <span id="ITerm12">stack</span> is a data structure that reflects the metaphor of a stack of plates. When using a stack, an algorithm operates only on the “top” item in the stack. When that item is operated on, it is removed or “popped” off the stack. A data item may also be “pushed” onto a stack. Because data is only operated on or removed from the “top” of the stack, a stack is sometimes referred to as a FILO (First In, Last Out) or LIFO (Last In, First Out). See Figure <span class="InternalRef"><a href="#Fig2">3-2</a></span>.<figure class="Figure" id="Fig2"><div class="MediaObject" id="MO2"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig2_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig2_HTML.jpg" style="width:33.58em" width="1343" height="752"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-2</span><p class="SimplePara">Stack <span id="ITerm13">Example</span></p></div></figcaption></figure></div></section><section class="Section3 RenderAsSection3" id="Sec8"><h4 class="Heading">Queue</h4><div class="Para" id="Par15">A <span id="ITerm14">queue</span> is another data structure. As you can imagine, a queue also acts like a line to an event. Data items in a queue are added at the “back” of the queue and processed at the “front” of the queue. Queues can vary in length, allowing them to be used as a buffer. Queues are also referred to as FIFOs (First In, First Out). See Figure <span class="InternalRef"><a href="#Fig3">3-3</a></span>.<figure class="Figure" id="Fig3"><div class="MediaObject" id="MO3"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig3_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig3_HTML.jpg" style="width:32.5em" width="1300" height="1004"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-3</span><p class="SimplePara">Queue <span id="ITerm15">Example</span></p></div></figcaption></figure></div></section><section class="Section3 RenderAsSection3" id="Sec9"><h4 class="Heading">Tree</h4><div class="Para" id="Par16">A <span id="ITerm16">tree</span> is another data structure that allows for multiple branches. Data items or nodes are attached to the trunk, which has one or more items attached to it as branches. Each branch can have one or more branches attached to it. Nodes without branches attached to them are referred to as leaf nodes, or simply leaves. See Figure <span class="InternalRef"><a href="#Fig4">3-4</a></span>.<figure class="Figure" id="Fig4"><div class="MediaObject" id="MO4"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig4_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig4_HTML.jpg" style="width:32.48em" width="1299" height="346"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-4</span><p class="SimplePara">Tree <span id="ITerm17">Example</span></p></div></figcaption></figure></div></section><section class="Section3 RenderAsSection3" id="Sec10"><h4 class="Heading">Graph</h4><div class="Para" id="Par17">A graph is a <span id="ITerm18">data</span> structure where nodes or data items are connected via edges to other nodes. The edges may contain data about the relationship to the nodes. A directed graph is a graph data structure where all the edges have a common direction. A tree can be thought of as a directed graph. See Figure <span class="InternalRef"><a href="#Fig5">3-5</a></span>.<figure class="Figure" id="Fig5"><div class="MediaObject" id="MO5"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig5_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig5_HTML.jpg" style="width:32.5em" width="1300" height="555"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-5</span><p class="SimplePara"><span id="ITerm19">Graph</span> Example</p></div></figcaption></figure></div></section><section class="Section3 RenderAsSection3" id="Sec11"><h4 class="Heading">Linked List</h4><div class="Para" id="Par18">A linked list is <span id="ITerm20">another</span> data structure where each node or data item is linked to (connected with one or two) other data items in a chain. A doubly linked list is a list where each node contains a link to both the next node and the previous node. Data items can be inserted into a linked list by connecting to the new data item. Some of the other data structures such as the queue and the stack can be implemented as linked lists. See Figure <span class="InternalRef"><a href="#Fig6">3-6</a></span>.<figure class="Figure" id="Fig6"><div class="MediaObject" id="MO6"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig6_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig6_HTML.jpg" style="width:35.62em" width="1425" height="829"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-6</span><p class="SimplePara">Doubly <span id="ITerm21">Linked</span> List Example</p></div></figcaption></figure></div></section><section class="Section3 RenderAsSection3" id="Sec12"><h4 class="Heading">Array</h4><div class="Para" id="Par19">An array is a fixed-size set of data, where each data node is referred to <span id="ITerm22">by</span> a coordinate system. In a single-dimensional array, this value is called the index and typically starts at zero for the first node. In a two-dimensional array, or grid, a node has two coordinates like x and y; and in a three-dimensional array, like a cube, it has three, like x, y, and z. Arrays can have more dimensions than three if needed. Data in an array can be accessed from any position in the array at any time. A sparse array is an array that does not have meaningful data in every position. See Figure <span class="InternalRef"><a href="#Fig7">3-7</a></span>.<figure class="Figure" id="Fig7"><div class="MediaObject" id="MO7"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig7_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig7_HTML.jpg" style="width:12.5em" width="500" height="649"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-7</span><p class="SimplePara">Array <span id="ITerm23">Example</span></p></div></figcaption></figure></div></section><section class="Section3 RenderAsSection3" id="Sec13"><h4 class="Heading">Dictionary</h4><div class="Para" id="Par20">One more data structure is a <span id="ITerm24">dictionary</span>, sometimes referred to as a hash table. Similar to an array, in a dictionary, the data nodes are referred to by a key or index. Unlike an array, this index is not integer values. Instead, a hashing algorithm is run to find a unique value for each data node, and that is used as the key to look up the data node. Like an array, data can be accessed from any node in the hash table at any time. See Figure <span class="InternalRef"><a href="#Fig8">3-8</a></span>.<figure class="Figure" id="Fig8"><div class="MediaObject" id="MO8"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig8_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig8_HTML.jpg" style="width:32.5em" width="1300" height="793"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-8</span><p class="SimplePara">Dictionary <span id="ITerm25">Example</span></p></div></figcaption></figure></div></section><section class="Section3 RenderAsSection3" id="Sec14"><h4 class="Heading">Making Use of the Data: Searching, Sorting</h4><p class="Para" id="Par21">Two of the most common things to do with the data in these <span id="ITerm26">data structures</span> are to search through the data for a specific item and to sort the data in some fashion. There are different sorting and searching algorithms that can be used on the data. Sorting is often done as part of searching as it can be easier to find an item with the data structure sorted. Depending on the type of data structure, different algorithms will perform better or worse.</p><div class="Para" id="Par22">The first sorting algorithm that we will look at is the bubble sort (Listing <span class="InternalRef"><a href="#PC1">3-1</a></span>). In this algorithm, the items are sorted into order with the priority items “bubbling” to the top of the data structure. If we have a linked list, call it <span class="EmphasisFontCategoryNonProportional ">I</span>, we will start with the first item (<span class="EmphasisFontCategoryNonProportional ">i[0]</span>) in the list and compare it to the next item (<span class="EmphasisFontCategoryNonProportional ">i[1]</span>). We then compare <span class="EmphasisFontCategoryNonProportional ">i[0]</span> and <span class="EmphasisFontCategoryNonProportional ">i[1];</span> if <span class="EmphasisFontCategoryNonProportional ">i[1]</span> is before <span class="EmphasisFontCategoryNonProportional ">i[0],</span> then we swap <span class="EmphasisFontCategoryNonProportional ">i[0]</span> with <span class="EmphasisFontCategoryNonProportional ">i[1]</span>. Then we proceed to compare the new <span class="EmphasisFontCategoryNonProportional ">i[1]</span> with <span class="EmphasisFontCategoryNonProportional ">i[2];</span> if <span class="EmphasisFontCategoryNonProportional ">i[2]</span> needs to swap with <span class="EmphasisFontCategoryNonProportional ">i[1],</span> then we swap. If the items are in the right order, we do not swap but proceed to the next item to <span id="ITerm27">compare</span>.<div class="ProgramCode" id="PC1"><div class="LineGroup"><div class="FixedLine">&nbsp;1 def bubble(NUMBER_LIST):</div><div class="FixedLine">&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;print(NUMBER_LIST)#Display the unsorted list</div><div class="FixedLine">&nbsp;3&nbsp;&nbsp;&nbsp;&nbsp;swap_counter = 0 #Set a counter for the number of swaps 4</div><div class="FixedLine">&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;for idx in range(0, len(NUMBER_LIST)):#Loop through list</div><div class="FixedLine">&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos = idx #Set the item to compare</div><div class="FixedLine">&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap_pos = pos - 1 #Set the item to swap if needed</div><div class="FixedLine">&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Loop through the items to compare</div><div class="FixedLine">&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while swap_pos &gt;= 0: #Loop through the unsorted list</div><div class="FixedLine">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Check to see if you need to swap</div><div class="FixedLine">11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if NUMBER_LIST[swap_pos] &gt; NUMBER_LIST[pos]:</div><div class="FixedLine">12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Swap positions</div><div class="FixedLine">13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NUMBER_LIST[pos], NUMBER_LIST[swap_pos] =</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NUMBER_LIST[swap_pos], NUMBER_LIST[pos]</div><div class="FixedLine">14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Increment the swap counter to show the work</div><div class="FixedLine">15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap_counter = swap_counter +1</div><div class="FixedLine">16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(NUMBER_LIST) # Display the current list</div><div class="FixedLine">17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Move to the next swap item</div><div class="FixedLine">17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;swap_pos = swap_pos -1</div><div class="FixedLine">18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Move to the next item to compare</div><div class="FixedLine">19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pos = pos -1</div><div class="FixedLine">20</div><div class="FixedLine">21&nbsp;&nbsp;&nbsp;&nbsp;#Display the number of swaps</div><div class="FixedLine">22&nbsp;&nbsp;&nbsp;&nbsp;print("SWAPS:", swap_counter)</div></div><div class="LineGroup"><div class="FixedLine"><strong class="EmphasisTypeBold ">Python console output</strong></div><div class="FixedLine">&gt;&gt;&gt; bubble.bubble([90,87,82,43,3,5])</div><div class="FixedLine">[90, 87, 82, 43, 3, 5]</div><div class="FixedLine">[87, 90, 82, 43, 3, 5]</div><div class="FixedLine">[87, 82, 90, 43, 3, 5]</div><div class="FixedLine">[82, 87, 90, 43, 3, 5]</div><div class="FixedLine">[82, 87, 43, 90, 3, 5]</div><div class="FixedLine">[82, 43, 87, 90, 3, 5]</div><div class="FixedLine">[43, 82, 87, 90, 3, 5]</div><div class="FixedLine">[43, 82, 87, 3, 90, 5]</div><div class="FixedLine">[43, 82, 3, 87, 90, 5]</div><div class="FixedLine">[43, 3, 82, 87, 90, 5]</div><div class="FixedLine">[3, 43, 82, 87, 90, 5]</div><div class="FixedLine">[3, 43, 82, 87, 5, 90]</div><div class="FixedLine">[3, 43, 82, 5, 87, 90]</div><div class="FixedLine">[3, 43, 5, 82, 87, 90]</div><div class="FixedLine">[3, 5, 43, 82, 87, 90]</div><div class="FixedLine">[3, 5, 43, 82, 87, 90]</div><div class="FixedLine">SWAPS: 14</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 3-1</span><p class="SimplePara">Bubble Sort Algorithm in Python</p></div></div></div></div><p class="Para" id="Par23">If we do a <span id="ITerm28">Big-Oh analysis</span> of this, then we can see this is O(n<sup>2</sup>), with the worst case being having to compare every element with every other element.</p><div class="Para" id="Par24">Selection sort is the next sorting algorithm we will look at (Listing <span class="InternalRef"><a href="#PC2">3-2</a></span>). In this algorithm, we will compare the first item to the rest of the items and select the smallest item and swap those items. We then proceed with the next item and select the next smallest item and swap them. We proceed until we have iterated through each item in the array. Selection sort is also O(n<sup>2</sup>).<div class="ProgramCode" id="PC2"><div class="LineGroup"><div class="FixedLine">&nbsp;1 def selection(number_list):</div><div class="FixedLine">&nbsp;2&nbsp;&nbsp;&nbsp;print(number_list)#Display the unsorted list</div><div class="FixedLine">&nbsp;3&nbsp;&nbsp;&nbsp;iter_count = 0 #set a counter for the iterations</div><div class="FixedLine">&nbsp;4 5&nbsp;&nbsp;&nbsp;#Loop through the each item on the list</div><div class="FixedLine">&nbsp;6&nbsp;&nbsp;&nbsp;for i in range(0, len(number_list)):</div><div class="FixedLine">&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_index = i #Set the current min value in the list</div><div class="FixedLine">&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Loop through the remaining unsorted list</div><div class="FixedLine">&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j in range(i+1, len(number_list)):</div><div class="FixedLine">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Compare the current item with the current minimum</div><div class="FixedLine">11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if number_list[j] &lt; number_list[min_index]:</div><div class="FixedLine">12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#If the current item is smaller</div><div class="FixedLine">13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#make it the new minimum</div><div class="FixedLine">14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;min_index = j</div><div class="FixedLine">15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Swap the new minimum with the</div><div class="FixedLine">16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#current value in the list</div><div class="FixedLine">17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;number_list[i], number_list[min_index] = number_list[min_index], number_list[i]</div><div class="FixedLine">18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Increment the count of swaps</div><div class="FixedLine">19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;iter_count = iter_count +1</div><div class="FixedLine">20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(number_list): #Display the current list</div><div class="FixedLine">21&nbsp;&nbsp;&nbsp;&nbsp;#Display the number of iterations</div><div class="FixedLine">22&nbsp;&nbsp;&nbsp;&nbsp;print("Iterations: ", iter_count)</div></div><div class="LineGroup"><div class="FixedLine"><strong class="EmphasisTypeBold ">Python console output</strong></div><div class="FixedLine">&gt;&gt;&gt; selection.selection([90, 87, 82, 43, 3, 5])</div><div class="FixedLine">[90, 87, 82, 43, 3, 5]</div><div class="FixedLine">[5, 90, 87, 82, 43, 3]</div><div class="FixedLine">[5, 3, 90, 87, 82, 43]</div><div class="FixedLine">[5, 3, 43, 90, 87, 82]</div><div class="FixedLine">[5, 3, 43, 82, 90, 87]</div><div class="FixedLine">[5, 3, 43, 82, 87, 90]</div><div class="FixedLine">[5, 3, 43, 82, 87, 90]</div><div class="FixedLine">Iterations:&nbsp;&nbsp;15</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 3-2</span><p class="SimplePara">Selection Sort Algorithm in Python</p></div></div></div></div></section></section></section><section class="Section1 RenderAsSection1" id="Sec15"><h2 class="Heading">Problem Solving Techniques</h2><p class="Para" id="Par25">We have examined how we analyze and compare algorithms. And we have looked at how we can structure our data. Now we will look at common techniques for solving problems.</p><section class="Section2 RenderAsSection2" id="Sec16"><h3 class="Heading">Recursion</h3><p class="Para" id="Par26">A <span id="ITerm29">recursive algorithm</span> is an algorithm where the function calls itself. Recursive functions, or methods, can be very efficient and easy to understand. The following is an example of a very simple recursive algorithm (Listing <span class="InternalRef"><a href="#PC3">3-3</a></span>) to calculate the Fibonacci sequence. In the Fibonacci sequence, the current value is defined as the sum of the previous two values F(N) = F(N – 1) + F(N – 2). Also the first two values F(1) and F(0) are predefined to 1 and 0, respectively. For example, to calculate the value of F(3), we need to first calculate the F(2) and F(1). To calculate F(2), we need to calculate F(1) and F(0).</p><div class="Para" id="Par27">F(1) is 1 and F(0) is 0 so that makes F(2) = 1 + 0 or 1. To finish calculating F(3), we add F(2) + F(1) or 1 + 1. Therefore, F(3) is 2.<div class="ProgramCode" id="PC3"><div class="LineGroup"><div class="FixedLine">def fibonacci(value):</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;if value == 0:#Set F(0) to 0</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retval = value</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;elif value == 1:#Set F(1) to 1</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retval = value</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;else: #Otherwise calculate the value of F(N)</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Recursively call the fibonacci function on the</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#previous value. Then call fibonacci function on the</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#value before that.</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Set the current value to the sum of those two values</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;retval = fibonacci(value-1) + fibonacci(value-2)</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;return retval</div></div><div class="LineGroup"><div class="FixedLine">def fibonacci_list(max):</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;for i in range(0, max):</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Display the current Fibonacci value</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(fibonacci(i))</div></div><div class="LineGroup"><div class="FixedLine"><strong class="EmphasisTypeBold ">Python console output</strong></div><div class="FixedLine">&gt;&gt;&gt; fibonacci.fibonacci_list(5)</div><div class="FixedLine">0</div><div class="FixedLine">1</div><div class="FixedLine">1</div><div class="FixedLine">2</div><div class="FixedLine">3</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 3-3</span><p class="SimplePara">Recursive Fibonacci Algorithm</p></div></div></div></div></section><section class="Section2 RenderAsSection2" id="Sec17"><h3 class="Heading">Divide and Conquer</h3><p class="Para" id="Par28">Divide and <span id="ITerm30">conquer</span> is a technique where the data is divided and each smaller portion is operated on.</p><div class="Para" id="Par29">The merge sort algorithm (Listing <span class="InternalRef"><a href="#PC4">3-4</a></span>) is a good example of both recursion and divide and conquer algorithms. The basic part of the merge sort algorithm splits a list into two separate equal halves. Those halves are then sorted. Once you have two sorted halves, you simply compare the first items in each list and add the smaller to the next position in a new list. To get each half sorted, you can call the merge sort algorithm on each half.<div class="ProgramCode" id="PC4"><div class="LineGroup"><div class="FixedLine">&nbsp;1 def merge(number_list):</div><div class="FixedLine">&nbsp;2&nbsp;&nbsp;&nbsp;#Check if the list is longer than one element</div><div class="FixedLine">&nbsp;3&nbsp;&nbsp;&nbsp;if len(number_list) &gt; 1:</div><div class="FixedLine">&nbsp;4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Find the middle of the list</div><div class="FixedLine">&nbsp;5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;half_idx = int(len(number_list)/2)</div><div class="FixedLine">&nbsp;6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Create a list with front half of the list</div><div class="FixedLine">&nbsp;7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_a = number_list[:half_idx]</div><div class="FixedLine">&nbsp;8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Create a list with the back half of the list</div><div class="FixedLine">&nbsp;9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;list_b = number_list[half_idx:]</div><div class="FixedLine">10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Recursively call this merge function</div><div class="FixedLine">11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#to sort the first half</div><div class="FixedLine">12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted_a = merge(list_a)</div><div class="FixedLine">13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Recursively call this merge function</div><div class="FixedLine">14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#to sort the second half</div><div class="FixedLine">15&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted_b = merge(list_b)</div><div class="FixedLine">16&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Init an empty list to insert the sorted values</div><div class="FixedLine">17&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted_list = []</div><div class="FixedLine">18&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Set a flag to indicate both lists are inserted</div><div class="FixedLine">19&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done = False</div><div class="FixedLine">20&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while not done: #Iterate on the lists until done</div><div class="FixedLine">21&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Compare the first item of each list</div><div class="FixedLine">22&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if sorted_a[0] &lt; sorted_b[0]:</div><div class="FixedLine">23&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#When the first list item is smaller</div><div class="FixedLine">24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# insert into the sorted list</div><div class="FixedLine">25&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted_list.append(sorted_a.pop(0))</div><div class="FixedLine">26&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:</div><div class="FixedLine">27&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#When the second list item is smaller</div><div class="FixedLine">28&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# insert into the sorted list</div><div class="FixedLine">29&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted_list.append(sorted_b.pop(0))</div><div class="FixedLine">30&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if len(sorted_a) == 0:</div><div class="FixedLine">31&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#When the first list is empty add the</div><div class="FixedLine">32&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# remainder of the second list to the</div><div class="FixedLine">33&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# sorted list</div><div class="FixedLine">34&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted_list = sorted_list + sorted_b</div><div class="FixedLine">35&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Set the done flag to end the loop</div><div class="FixedLine">36&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done = True</div><div class="FixedLine">37&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elif len(sorted_b) == 0:</div><div class="FixedLine">38&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#When the first list is empty add the</div><div class="FixedLine">39&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# remainder of the second list to the</div><div class="FixedLine">40&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;# sorted list</div><div class="FixedLine">41&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted_list = sorted_list + sorted_a</div><div class="FixedLine">42&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#Set the done flag to end the loop</div><div class="FixedLine">43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done = True</div><div class="FixedLine">44&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(sorted_list)</div><div class="FixedLine">45&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else:# If the list is only one element it is sorted</div><div class="FixedLine">46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sorted_list = number_list</div><div class="FixedLine">47</div><div class="FixedLine">48</div><div class="FixedLine">49&nbsp;&nbsp;&nbsp;&nbsp;return(sorted_list)</div><div class="FixedLine"><strong class="EmphasisTypeBold ">Python console output</strong></div><div class="FixedLine">&gt;&gt;&gt; merge.merge([90, 87, 82,43,3,5])</div><div class="FixedLine">[82, 87]</div><div class="FixedLine">[82, 87, 90]</div><div class="FixedLine">[3, 5]</div><div class="FixedLine">[3, 5, 43]</div><div class="FixedLine">[3, 5, 43, 82, 87, 90]</div><div class="FixedLine">[3, 5, 43, 82, 87, 90]<span id="ITerm31">

</span></div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 3-4</span><p class="SimplePara">Merge Sort Divide and Conquer Algorithm in Python</p></div></div></div></div></section><section class="Section2 RenderAsSection2" id="Sec18"><h3 class="Heading">Brute Force</h3><p class="Para" id="Par30">A <span id="ITerm32">brute force algorithm</span> is just as it sounds, doing the most obvious thing with the data operating on each data item individually. In some situations, especially with smaller data sets, this can be the quickest way to solve the problems, but in general, this is a costly way O() ) to perform a function.</p></section><section class="Section2 RenderAsSection2" id="Sec19"><h3 class="Heading">Greedy Algorithms</h3><p class="Para" id="Par31">A <span id="ITerm33">greedy algorithm</span> is an algorithm that makes a locally optimal decision. This can, in some cases, lead to locally optimized implementations vs. the best globally optimized solution. Greedy algorithms include the Huffman coding algorithm for data compression and the <span id="ITerm34">Dijkstra algorithm</span> for search in a tree.</p></section></section><section class="Section1 RenderAsSection1" id="Sec20"><h2 class="Heading">Class of Problems</h2><p class="Para" id="Par32">Many algorithms can be solved in polynomial time where the Big-Oh expression can be written as a polynomial. These are considered tractable problems. There is also the set of problems that cannot be solved in polynomial time. These are considered intractable. However, within the set of intractable problems are a set of problems that can verify possible answers in polynomial time. These are referred to as <span id="ITerm35">nondeterministic polynomial</span>, or NP, problems. Finding a prime number is an example of this type of problem.</p><section class="Section2 RenderAsSection2" id="Sec21"><h3 class="Heading">NP-Complete and NP-Hard Problems</h3><p class="Para" id="Par33">Within the set of <span id="ITerm36">NP problems</span> are the set of problems no one knows how to solve in less than exponential time known as NP-complete.</p><p class="Para" id="Par34">One common example of an <span id="ITerm37">NP-complete problem</span> is the traveling salesman problem, where we want to find the shortest path for a salesman to navigate a set of cities connected by routes of different lengths. Checking the length of a route and comparing it to other routes is polynomial, but finding the shortest route requires going through all possible combinations.</p><p class="Para" id="Par35">In addition to NP problems are another set of problems that are defined as NP-hard. These problems are as hard as or harder than any NP problems. This set of problems are called <span id="ITerm38">NP-hard problems</span>. If these problems are found to be solvable in polynomial time, that would imply that all NP problems are actually solvable in polynomial time. This is not believed to be the case.</p></section></section><section class="Section1 RenderAsSection1" id="Sec22"><h2 class="Heading">Databases</h2><p class="Para" id="Par36">So far in this chapter, we have looked at data structures and algorithms that have been operating on data in system memory (e.g., RAM). Now we will look at database systems that can persistently store and recover the data. A <span id="ITerm39">database</span> is simply an organized set of data that is stored apart from the program that will utilize that data.</p><section class="Section2 RenderAsSection2" id="Sec23"><h3 class="Heading">Persistence and Volume</h3><p class="Para" id="Par37">We <span id="ITerm40">separate</span> data out from the software into a database for various reasons. One reason is the persistence of data. If you have software that doesn’t, somehow, “save” its resulting data, that data would not be available after the software is run, as it was only in system memory, which will be reused by other programs once your program is done. This storage, or persistence, of data also provides some other advantages. It allows multiple different software applications to access the same data. Many database systems allow for multiple applications to access the data concurrently.</p><p class="Para" id="Par38">The other reason to store the data separate from the software is that it allows the software to operate on much larger volumes of data than can be contained in the RAM. A database system can provide parts of the data to the software at a time so that software can work on <span id="ITerm41">this</span> smaller sets of data.</p></section><section class="Section2 RenderAsSection2" id="Sec24"><h3 class="Heading">Fundamental Requirements: ACID</h3><p class="Para" id="Par39">As the <span id="ITerm42">volume</span> of data gets larger, and there is more concurrent access (from multiple concurrently running applications) to the data, a database must make sure that it meets the requirements of ACID (Atomicity, Consistency, Isolation, and Durability).</p><p class="Para" id="Par40">Atomicity means that an update happens to the database as a single, atomic event, so there are no partial updates. Say, for instance, I have a simple database of a name, street address, and zip code. And I need to update a record because someone moved to a new city. A nonatomic update might be to update the zip code without updating the street address, followed by an update of the street address. This would lead to a point in time where the data in the database is incorrect (only partially updated). In contrast, an atomic update, or commit, would update the record with both the new street address and zip code at the same time, so the database is never incorrect.</p><p class="Para" id="Par41">Consistency <span id="ITerm43">means</span> that in the event of a failure, for instance, an update failure, the database stays consistent with a known good state; this is usually the previous state of the database. For example, in our previous example, we may want to update all the names to make sure they are capitalized. If there is a failure after the third record is updated, then the transaction will roll back to the previous state, where none of the names are capitalized.</p><p class="Para" id="Par42"><span id="ITerm44">Isolation</span> means that if there are multiple concurrent updates to the database, each transaction must not be intermixed with any other transaction. The two previous examples for updating one record (a person moved) and updating all the records to make sure that names are capitalized must be isolated. In this case, all the names get updated first, and then the one record is updated with a new street address and zip code. This is important for data consistency and durability. If we needed to roll back a transaction and both sets of changes were intermixed, we would not be able to clearly go back to a known good state.</p><p class="Para" id="Par43"><span id="ITerm45">Durability</span> is like consistency; it means that in the event of a failure of the underlying database system, when the database system restarts, it is able to pick up where it left off and complete the transaction. For example, in the previous example, say that after the third record gets updated, the operating system forces a reboot. When the operating system comes back up, the database system must complete the transaction starting at exactly the fourth record.</p></section><section class="Section2 RenderAsSection2" id="Sec25"><h3 class="Heading">Brief History of Database System Evolution</h3><p class="Para" id="Par44">In 1970 Edgar F. Codd wrote a paper describing relational database systems. Prior to the publication of Codd’s paper, companies had started to develop database systems based on other models, but by the late 1970s, the relational database model had become prevalent. IBM produced the first prototype relational database with SQL in 1976. The Oracle <span id="ITerm46">Database</span> was the first commercial database that implemented the model and featured SQL, the Structured Query Language. Oracle was released in 1977, prior to IBM’s release of SQL/DS in 1981, despite IBM having a head start. Also, in 1981, dBase II, considered the first relational database for PCs, was released for personal computers. Oracle became the primary database used in the enterprise as well as the Internet until the release of the open source database MySQL in 1995. On the PC side, many solutions were released over the next decade with Microsoft Access becoming the de facto standard relational database on the PC in 1993.</p></section><section class="Section2 RenderAsSection2" id="Sec26"><h3 class="Heading">Most Prominent Current Database Systems</h3><p class="Para" id="Par45">Today, Oracle remains one of the most prominent relational database <span id="ITerm47">systems</span>. In addition, the open source community has brought several solutions to prominent usage. MySQL still is in use but is joined by PostgreSQL and SQLite as to the very common open source relational database solutions. On the commercial side, Microsoft SQL Server has also risen to prominence in its <span id="ITerm48">usages</span>.</p></section><section class="Section2 RenderAsSection2" id="Sec27"><h3 class="Heading">Relational Data and SQL</h3><div class="Para" id="Par46"><span id="ITerm49">Relational data</span> is based on set theory and the relationships between sets. Sets can be combined in a union. This means a new set is formed that contains all the data elements that are in the sets combined. A new set, for instance, may be formed from the differences of sets; this would be a set of all of the data elements that are unique between the sets. Furthermore, another set can be formed from the intersection of two sets. This is where a new set is formed from all the elements that are common between the two sets. See Figure <span class="InternalRef"><a href="#Fig9">3-9</a></span>.<figure class="Figure" id="Fig9"><div class="MediaObject" id="MO9"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig9_HTML.png" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig9_HTML.png" style="width:22.5em" width="900" height="521"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-9</span><p class="SimplePara">Set Operations Example</p></div></figcaption></figure></div><div class="Para" id="Par47">SQL is a standard language to describe these relationships between sets of data to extract meaningful data from a relational <span id="ITerm50">database</span>. For example (Figure <span class="InternalRef"><a href="#Fig10">3-10</a></span>), a SQL statement <span class="EmphasisFontCategoryNonProportional ">SELECT (id, name, zipcode) FROM people_table WHERE (zipcode IS '97124')</span> forms a set containing the value 97124 and then intersects that data with the set of zip codes in the table. This new intersected set of records will have the same set of fields as the original table but only contain the values for those that match the zip code 97124.<figure class="Figure" id="Fig10"><div class="MediaObject" id="MO10"><img alt="../images/503707_1_En_3_Chapter/503707_1_En_3_Fig10_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_3_Chapter/503707_1_En_3_Fig10_HTML.jpg" style="width:35.62em" width="1425" height="818"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 3-10</span><p class="SimplePara"><span id="ITerm51">SQL Statement Actions</span></p></div></figcaption></figure></div><p class="Para" id="Par48">SQL syntax allows for a rich group of set relationships described in a machine-translatable language that approximates natural language.</p><section class="Section3 RenderAsSection3" id="Sec28"><h4 class="Heading">Structured Data/Unstructured Data</h4><p class="Para" id="Par49">Relational databases mostly have structured data, data that is organized into rows and columns. This structured organization makes it easy to interact with the data using SQL and the set relations. The definition of this structure is called a <span id="ITerm52">schema</span>. As you can imagine, however, much of the data that we have in the world is not so easily structured. <span id="ITerm53">Unstructured data</span> is data that cannot easily be organized into rows and columns, such as natural language text. This rise in unstructured data has also led to an increase in databases that do not follow the same constraints of relational databases.</p></section></section><section class="Section2 RenderAsSection2" id="Sec29"><h3 class="Heading">NoSQL</h3><p class="Para" id="Par50">NoSQL or Not Only <span id="ITerm54">SQL</span> is a collective name of a growing set of databases that apply different data structures besides tables of rows and columns used in relational databases.</p><p class="Para" id="Par51">With the rise of the Internet and service-oriented architectures, one of the key points of integrating the data from multiple applications shifted from the relational database and SQL to service access. This allowed developers to create a closer mapping of the data structures used in the application to the data stored in the database. Now developers could have a much more natural connection between the data that is being stored and the data that is being used.</p><section class="Section3 RenderAsSection3" id="Sec30"><h4 class="Heading">Examples of NoSQL Databases</h4><p class="Para" id="Par52">We will look at some common examples of NoSQL databases.</p></section><section class="Section3 RenderAsSection3" id="Sec31"><h4 class="Heading">Graph DB: Neo4j</h4><p class="Para" id="Par53">Neo4j is a native graph database where the data is stored and its relationship to other data is also stored. A record is stored as a node in a graph data structure, and additional relationship records are stored with information about how various nodes are related (connected) to each other.</p><p class="Para" id="Par54"><span id="ITerm55">Neo4j</span><span id="ITerm56">

</span> can be schema-less with nodes having different fields as needed. Neo4j also has its own query language called Cypher.</p></section><section class="Section3 RenderAsSection3" id="Sec32"><h4 class="Heading">Column Family DB: Bigtable and Cassandra</h4><p class="Para" id="Par55"><span id="ITerm57">Bigtable</span> is a proprietary wide-column family database from Google. Bigtable is designed to specifically handle exceptionally large sets of data.</p><p class="Para" id="Par56">Like Bigtable, <span id="ITerm58">Cassandra</span> is an open source column family database from Apache. A column family database organizes the data into rows and columns. A column is the primary data entity. A column is made up of a name and a value with the name acting as a key in a key-value pair. A row is an arbitrary group of columns with a row key. A column family is a group of rows with some column keys in common. Cassandra is a schema-free database in that rows do not have to have the same columns. Cassandra also has its own query language CQL.</p></section><section class="Section3 RenderAsSection3" id="Sec33"><h4 class="Heading">Document DB: CouchDB and MongoDB</h4><p class="Para" id="Par57"><span id="ITerm59">CouchDB</span> is a document database from an open source project that is part of the Apache group. Each piece of data is considered a document with its own set of fields.</p><p class="Para" id="Par58"><span id="ITerm60">MongoDB</span> is another open source project that is a document database. It stores records as JSON (JavaScript Object Notation) documents. Each document can have its own set of attributes so it can be schema-free. Both CouchDB and MongoDB have their own mechanisms for querying the data.</p></section></section></section><section class="Section1 RenderAsSection1" id="Sec34"><h2 class="Heading">Summary</h2><p class="Para" id="Par59">As we have seen throughout this chapter, there are many considerations when working with data. The selection algorithm, data structures, and database for persistent storage should be chosen thoughtfully so that the software can be developed in the most effective way.</p></section><section class="Section1 RenderAsSection1" id="Sec35"><h2 class="Heading">References and Further Reading</h2><div class="Para" id="Par60">
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par61">Thomas Cormen. <em class="EmphasisTypeItalic ">Introduction to Algorithms, Third Edition</em>. MIT Press, 2009</p></li><li><p class="Para" id="Par62">Avi Silberschatz. <em class="EmphasisTypeItalic ">Database System Concepts</em>. McGraw-Hill Education, 2010</p></li><li><p class="Para" id="Par63">Alfred V. Aho and Jeffery D. Ullman. <em class="EmphasisTypeItalic ">Foundations of Computer Science</em>. Computer Science Press, 1992</p></li><li><p class="Para" id="Par64">Mukesh Negi. <em class="EmphasisTypeItalic ">Fundamentals of Database Management System</em>. BPB Publications, 2019</p></li><li><p class="Para" id="Par65">Pramod Sadalage and Martin Fowler. <em class="EmphasisTypeItalic ">NoSQL Distilled: A Brief Guide to the Emerging World of Polyglot Persistence</em>. Addison-Wesley Professional, 2013</p></li></ul></div>
</div></section></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781484271070/files/css/springer_epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com