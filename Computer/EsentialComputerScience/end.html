<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div epub:type="backmatter"><div class="BookBackmatter"><aside aria-labelledby="App1Heading" class="Appendix" id="App1"><div epub:type="appendix" role="doc-appendix"><section class="Section1 RenderAsSection1" id="Sec1"><h2 class="Heading" id="App1Heading">Appendix A: Software Development Lifecycle</h2><div class="Para" id="Par1">Whether you are working on a one-person project or as part of a complex multitiered project with multiple teams, you should understand the software development lifecycle. Each phase of the lifecycle has a purpose that will help you write better software. The following phases can be applied to both agile and waterfall project management practices (Figure <span class="InternalRef"><a href="#Fig1">A-1</a></span>). The waterfall method is the method where each phase is completed before the work on the next phase begins, like a pool of water that fills up and then spills over falling into the next pool. The agile or iterative method is where software is developed partially, evaluated, and then incrementally adjusted until it is sufficient. This is considered agile because at each iteration the project can change direction to better serve the users; in the waterfall method, the project would have to start over from the beginning. The formality of the artifacts and collateral that are produced by each phase will vary by industry and requirements of the projects you may find yourself working on. It is also important to remember that these phases are not strictly linear. You may find that you do some planning, some analysis, and some design before completing any one of those phases. Equally important is to remember that every software project is different and these lifecycle stages are guidelines.<figure class="Figure" id="Fig1"><div class="MediaObject" id="MO1"><img alt="../images/503707_1_En_BookBackmatter_Fig1_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_BookBackmatter_Fig1_HTML.jpg" style="width:35.57em" width="1423" height="908"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure A-1</span><p class="SimplePara">Software Development Lifecycle <span id="ITerm1">Phases

</span>
</p></div></figcaption></figure>
</div><section class="Section2 RenderAsSection2" id="Sec2"><h3 class="Heading">Planning</h3><p class="Para" id="Par2">The planning <span id="ITerm2">phase

</span> is used to determine what software you will create. In planning, you think about what you want the software to do and begin thinking about how you want to do the implementation. Once you have some coherent thoughts on this, start writing those thoughts down. Planning is important for all software development projects, even those using agile methodologies. The detail and length of planning should be determined by the amount of formality needed by the software and/or the industry the software is being targeted to. For instance, planning on an agile project may occur briefly to define what a minimal viable product (MVP) should be for a given iteration. Likewise, on a project for a medical imaging device, much more detailed and rigorous planning may be required.</p><p class="Para" id="Par3">One important point about planning is that the original plan is rarely what the result will be. It is impossible to predict the future, and plan for every possible change that will affect the plan. There is certainly a point of diminishing returns on <span id="ITerm3">planning

</span>. Planning will not reveal every possible thing that could occur for your project, nor will everything in the plan materialize. The key to planning is understanding the project and then adjusting to the things that happen in later stages of the lifecycle, without breaking.</p></section><section class="Section2 RenderAsSection2" id="Sec3"><h3 class="Heading">Analysis</h3><p class="Para" id="Par4">In the analysis <span id="ITerm4">phase

</span>, you will define use cases and decompose the problem into logical blocks to help you understand the system, to the best of your ability. Use cases help you focus on how the software will be used; this helps define what the software does and what the users need and prevents creating software that will not be useful. In this phase, you would compare possible algorithms for use in you project, leveraging Big-Oh analysis. This is where you should also develop an understanding of the type and amount of data that your program will be processing. During the analysis phase, you should consider any constraints such as security requirements, usability, cost, feature trade-offs, and long-term support. For instance, if your software will be used over a network, the analysis phase is when you should analyze the network throughput, latency, and frequency requirements for your solution.</p><p class="Para" id="Par5">The analysis phase may include creating prototypes to better understand the problem. It is important to remember that this is not the implantation phase. Prototypes should be used to understand the problem better and how to approach it. The code that is written as prototypes may not (and probably should not) be included in the implementations.</p></section><section class="Section2 RenderAsSection2" id="Sec4"><h3 class="Heading">Architecture and Design</h3><p class="Para" id="Par6">The <span id="ITerm5">design

</span> of the software is how all the various parts fit together into a consistent whole solution to the problem. Typically we build a solution architecture that lays out the components of a software and how/where they interact. There are at least two interaction areas to cover during the architecture and design phase. First is defining how people will interact with the solution. Second is defining the <span id="ITerm6">application programming interfaces (APIs)
</span>
<span id="ITerm7">


</span> that define how the components interact with each other. Some software may not have a significant human interaction component, but all software will need to define interfaces (APIs) for access and control.</p><p class="Para" id="Par7">It’s a good idea to do user interface mockups during this phase, to show how a user will interact with the system. If the software is sufficiently complex, various diagrams should be created to help fully understand the design of the software so it can be implemented. A block or object diagram can show how the various components in the software are related to each other. A sequence diagram can show the order that the components communicate with each other and how they interact with each other. A “paper” prototype, mockups, or wireframe diagrams can show what a user might see as they interact with the software. Finally, an API spec should be defined during the design phase to clearly communicate how to interact with the software. The API spec is a key output of the design phase, and it can act as a contract between the components.</p></section><section class="Section2 RenderAsSection2" id="Sec5"><h3 class="Heading">Implementation</h3><p class="Para" id="Par8">The implementation <span id="ITerm8">phase

</span> is where you actually write the software that will address the problems you are trying to solve. You should already have a plan for the implementation and have analyzed the problem to understand the data and algorithms you need. Don’t jump into implementation, even on an agile project, without at least some thought and discussion on the architecture and design. It is, of course, possible to jump straight into implementation, and for the simplest of <span id="ITerm9">solutions

</span>, that might be ok. But even simple projects will benefit from a lightweight application of planning, analysis, and design.</p><p class="Para" id="Par9">The technologies and programing languages for your implementation may already be determined for you as constraints of the environment or business. If not, use what you learned in the analysis phase to choose your technology stack.</p></section><section class="Section2 RenderAsSection2" id="Sec6"><h3 class="Heading">Test</h3><p class="Para" id="Par10">
<span id="ITerm10">Testing

</span> your software is important to demonstrate that you have indeed solved the problem (verification) and that you have not introduced any new problems or so-called “bugs” (validation).</p><p class="Para" id="Par11">With the practice of <span id="ITerm11">test-driven development (TDD)
</span>, the test phase and the implementation phase are combined. In TDD, a test is written that will fail until the software is implemented to pass the test. Then the next test and the next part of the implementation are created and so on. More commonly tests are created after the implementation is complete.</p><p class="Para" id="Par12">Most tests should be written so that they can be run automatically. There is likely some level of testing that cannot be easily automated. These tests should still be documented like a checklist so that the procedure to run these tests can be repeated.</p><p class="Para" id="Par13">The goals of testing are to discover errors in the software that can have adverse effects on users and data, for instance. Testing can also prove that the software does what is expected. Coverage is a concept in testing that measures how much of the software is covered during testing. Only the simplest of software can have every possible input tested, so coverage helps us discuss how much of the software is tested, which can help build confidence that the software is valid. There are different types of coverage metrics we can measure to indicate how much of the software is covered. The most common coverage measurement is line coverage. Line coverage measures how many lines or <span id="ITerm12">statements

</span> of the software are executed during testing. Another common coverage measurement is branch coverage, which measures how many paths through the code are covered.</p><p class="Para" id="Par14">Test results and coverage measurements provide us with a sense of assurance that the software we develop will work for the users of the software.</p></section><section class="Section2 RenderAsSection2" id="Sec7"><h3 class="Heading">Deploy</h3><p class="Para" id="Par15">The deployment <span id="ITerm13">phase

</span> is when the software is made available for use. There are many types of software deployment. For boxed software deployment, it is preparing the final (compiled) software for inclusion with installer software on a disk. With the growth of the Internet, this mechanism for deployment is not very common anymore. More commonly new deployments are available for download from the Internet, either through an application store or as OS- and language-specific packages. It should also be noted that a lot of software that is written today is never distributed publicly; it’s used inside of companies to automate and/or solve specific business problems.</p><p class="Para" id="Par16">Not only are there many methods to deploy software; software gets deployed in a variety of cadences. Some software is deployed multiple times a day, some once a year, and some only once. Despite the variety of deployment mechanisms and cadences, there are common things you should be aware of when deploying software, such as software licensing, virus scans, and security checks.</p><p class="Para" id="Par17">The first key to deployment is to understand what audience or audiences you are targeting. This will determine the type of packaging or installer you need to prepare. Once you know your packaging format, consider automating the mechanism of delivering the package of software to your audience. The second key to deployment to consider is a checklist of actions that need to be completed before deployment. These actions should include items such as making sure whatever license you release your software under matches the license of the ingredient software used in the making of your solution. Of course, you should verify that your tests have run and are successful. The checklist you define will depend on what your audience needs or desires.</p><p class="Para" id="Par18">Much like testing and test-driven development, <span id="ITerm14">continuous integration and continuous deployment (CI/CD)
</span> brings deployment into the implementation phase.</p></section><section class="Section2 RenderAsSection2" id="Sec8"><h3 class="Heading">Maintenance</h3><p class="Para" id="Par19">Last but certainly not least is the maintenance phase. This is when you change the <span id="ITerm15">software

</span> to maintain over time. Maintaining software is a much more common activity than creating new software. While maintaining software, you need to be able to identify what parts of the source code need to change (analyze), make changes (design and implementation), test those changes (test), and deploy the new version of the software (deploy). At times, especially when dealing with software that you did not write, this can be difficult. There are some simple actions you can take in other phases to simplify the maintenance phase. In the design phase, you can design the blocks to have very clear, singular purposes. You can also make sure that certain behaviors are only in one block of software. In the implementation phase, you can follow the design as best as possible. Also, during the implementation, comment your code with information about what you are doing and why you are doing it. Consider these comments as a letter to a future maintainer. Having automated tests from the test phase can help prove that any changes during maintenance have not created new issues.</p><p class="Para" id="Par20">The software development lifecycle for your project will be unique, whether it is closer to the waterfall model, highly iterative, or something in between. This framework of phases should help you manage a broader set of activities, beyond just writing the code.</p></section></section></div></aside><aside aria-labelledby="App2Heading" class="Appendix" id="App2"><div epub:type="appendix" role="doc-appendix"><section class="Section1 RenderAsSection1" id="Sec9"><h2 class="Heading" id="App2Heading">Appendix B: Software Engineering Practices</h2><p class="Para" id="Par21">There are many practices for the various phases and types of software development beyond writing the code. Here we will cover some common software engineering practices, including tools and techniques that you can apply to your software project.</p><section class="Section2 RenderAsSection2" id="Sec10"><h3 class="Heading">Planning and Management Practices: Agile</h3><p class="Para" id="Par22">
<span id="ITerm16">Agile practices


</span>, practices that attempt to follow the guidance of the Agile Manifesto (<span class="ExternalRef"><a href="https://agilemanifesto.org/"><span class="RefSource">
<span class="EmphasisFontCategoryNonProportional ">https://agilemanifesto.org/</span>
</span></a></span>), have become a dominant approach to software development. Agile practices start with the concept of a minimal viable product or MVP. The MVP is a version of software that provides the minimum capabilities for users to use and developers to learn from.</p><section class="Section3 RenderAsSection3" id="Sec11"><h4 class="Heading">Scrum</h4><p class="Para" id="Par23">
<span id="ITerm17">Scrum
</span>
<span id="ITerm18">



</span> is one of the most common agile practices for organizing work. In a nutshell, the scrum practice is focused on the short daily scrum meeting like a rugby scrum, or American football huddle. In the scrum or huddle, the team coordinates on the work for the day and then breaks out and does the work.</p><p class="Para" id="Par24">The work that the team needs to do is divided into small completable segments, called <span id="ITerm19">stories


</span>. Those stories are organized into an ordered list called a backlog. The ordered list of stories is then divided into groups that a scrum team can complete in a fixed time segment. This time segment can be any length, but at the end of each time segment, there should be a viable/usable software. The time segments are called sprints or iterations. They are called sprints to remind the team that they are short and will finish. They are called iterations because after one is complete, small adjustments can be made and then you start again. These iterations commonly range from one week to one month, with two weeks being the most common.</p><p class="Para" id="Par25">Scum recommends three ceremonies in addition to the scrum or huddle. First, before the beginning of each iteration, the team confirms what stories the team will be completing in that iteration. The team will use the ordered backlog and, if available, feedback from previous iterations to determine what should be done to have a viable/usable software product at the end of the sprint. This is called the planning ceremony. The second ceremony scrum recommends is the review. This happens at the end of the sprint and is where the team reviews the software that they created with their stakeholders and users of the software, if that is possible. Any feedback from the review should be added to the backlog and taken into consideration for future iterations. A retrospective, also conducted at the end of a sprint, is the third ceremony. In the retrospective, the team examines how they are working and looks for areas to improve. Any feedback the team has will again be used to plan future iterations.</p><p class="Para" id="Par26">Scrum also recommends three roles to coordinate the work. The most important role is the team. The team is all the developers in the scrum. Next is the product owner or PO. The product owner’s main responsibility is to represent the stakeholders for the team and manage the backlog of work. Finally, there is the coach; this person’s responsibility is to enable the team to work effectively. The coach will organize the ceremonies and help the team implement any of the feedback from the retrospectives. The coach was previously referred to as the scrum master, but that term has fallen out of favor.</p><p class="Para" id="Par27">While scrum can be effective and is often a developer’s first introduction to agile practices, there are some constraints to the practice. First, scrum does not specifically outline how the work is broken into stories. It does not cover <span id="ITerm20">requirements


</span>, analysis, or design; in some ways, it assumes that those are already complete. Second, scrum does not cover how the work will be implemented, validated, or deployed. There are other agile practices that cover these areas such as test-driven development, paired programming, and <span id="ITerm21">continuous integration and deployment (CI/CD)
</span>. Third, scrum works a specific team size of from five to nine people. Fewer people than that, and all of the ceremonies are not really required; more people than that, and the ceremonies are not sufficient.</p></section><section class="Section3 RenderAsSection3" id="Sec12"><h4 class="Heading">Kanban</h4><p class="Para" id="Par28">
<span id="ITerm22">Kanban
</span>
<span id="ITerm23">



</span> is another agile practice for organizing work. The Kanban process was originally developed by Toyota in Japan for automotive manufacturing. Kanban means a signboard in Japanese. The original Kanban practice used a card or sign that traveled with the work until the work was completed; then the card was returned to the board. If no cards were available on the board, then work was stalled somewhere in the process, and the team could focus on that area until work was completed and a card returned. Cards were intentionally limited to reduce the amount of uncompleted work in progress. For agile software, this principle of WIP (work in progress) limits can be applied to the development of software. An individual or team can have a WIP limit and start work up to that point and then focus on completing that work.</p><p class="Para" id="Par29">Kanban is like scrum in that work is organized into small compliable segments and then organized into a backlog. Also, like scrum, Kanban does not cover how work will be implemented, validated, or deployed.</p><p class="Para" id="Par30">Kanban differs from scrum in that instead of fixed time segments like iterations, it has a fixed amount of work in progress. Kanban works well when the work items are of similar scale. Kanban can also scale down to a smaller team size or even an individual. It can scale down because Kanban does not have the concepts of the various scrum ceremonies or dedicated roles.</p></section><section class="Section3 RenderAsSection3" id="Sec13"><h4 class="Heading">Analysis and Design</h4><p class="Para" id="Par31">As noted in the preceding, neither scrum nor Kanban specifically covers the <span id="ITerm24">analysis


</span> and design phases of a project. This has led to the incorrect belief that analysis, architecture, and design are not needed for agile projects. Instead, those practices assume that analysis, architecture, and design have happened to create the backlog. If that is not the case, then you might consider inserting this work as work items or stories into the backlog and have that work as part of the regular work the team does. Another approach is having dedicated time periods such as every third sprint to analyze and design the upcoming work to load into the backlog. Another approach that could work with a larger team is to have one team responsible for doing the analysis and design and feeding the backlog through their own agile processes.</p></section><section class="Section3 RenderAsSection3" id="Sec14"><h4 class="Heading">Scaling Agile Practices</h4><p class="Para" id="Par32">Both the practices of scrum and Kanban work well for small teams; however, those <span id="ITerm25">practices


</span> become problematic as the number of people on the team and the number of teams working on the project scale up. There are a few recommendations about how to approach scaling up agile practices such as Scrum of Scrums or the <span id="ITerm26">Scaled Agile Framework (SAFe)
</span>. The key to scaling agile practices up is to constantly keep agility in mind – being able to quickly change direction and get back up to speed.</p></section></section><section class="Section2 RenderAsSection2" id="Sec15"><h3 class="Heading">Documentation</h3><p class="Para" id="Par33">Documenting your software project is an important way to communicate to the future. In the future, there may be different developers or maintainers of the software. Ideally there will be future users of the software. Questions such as why does it work this way or how do I do this should be found in the documentation, without direct contact to you or the development team.</p><section class="Section3 RenderAsSection3" id="Sec16"><h4 class="Heading">Requirements, Design, and Architecture</h4><p class="Para" id="Par34">Documenting<span id="ITerm27">



</span> the requirements, the design, and the architecture is a way to record and communicate what you learned during the design and analysis phases. This is to inform the developer(s) on what to develop.</p><p class="Para" id="Par35">The formality of writing requirements and design will vary by the type and scope of projects. This formality could be as informal as writing a user story in the form “A user desires some outcome, because of some reason.” A fully specified safety-centric software system where every known possibility is documented will require more formality in its requirements.</p><p class="Para" id="Par36">We find that for most projects, using the Cockburn use case template is a highly effective way of capturing and communicating the requirements. The template helps to guide the requirement creation, and it helps avoid specifying design and implementation details into the requirement.</p><p class="Para" id="Par37">Implementation details, like how to interface with a system and what components make up a system, can be documented in the design and architecture. Design and architecture will typically have illustrations in addition to text. These documents should inform the developers of the project how the software should work within itself and with the world.</p><p class="Para" id="Par38">Over time the requirements will change, the design will grow, and the architecture will morph. It is important to remember that these documents should also be able to change via controlled practices.</p></section><section class="Section3 RenderAsSection3" id="Sec17"><h4 class="Heading">Comments and Code</h4><p class="Para" id="Par39">The <span id="ITerm28">code


</span> itself is a document about what is implemented. Comments in the code should be limited to adding context and not a retelling of what is in the code. This context will be helpful to maintainers of the code.</p><p class="Para" id="Par40">Well-written code is code that acts as its own documentation. Meaningful variable and function names can help code be its own documentation. However, source code is limited in expressiveness compared to natural languages. When this additional expressiveness is needed, it is a good time to write additional comments around that code.</p></section><section class="Section3 RenderAsSection3" id="Sec18"><h4 class="Heading">User</h4><p class="Para" id="Par41">
<span id="ITerm29">User


</span> documentation can take multiple forms: web pages, online help, or even console output. This documentation should provide a road map to your software and guide the users to accomplish what they desire.</p></section></section><section class="Section2 RenderAsSection2" id="Sec19"><h3 class="Heading">Testing</h3><p class="Para" id="Par42">Testing your software is done to both validate and verify your software. Verification is proving that your software behaves as expected, and validation is proving that your software does not behave in unexpected ways.</p><section class="Section3 RenderAsSection3" id="Sec20"><h4 class="Heading">Phases and Categories of Testing and Goals</h4><p class="Para" id="Par43">
<span id="ITerm30">Testing

</span> your software can be done with various goals and at different phases of the software lifecycle.</p><section class="Section4 RenderAsSection4" id="Sec21"><h5 class="Heading">Algorithm Testing, Unit Testing, Integration Testing, and the Like</h5><p class="Para" id="Par44">
<span id="ITerm31">Algorithm testing
</span>
<span id="ITerm32">


</span> is typically done early in the lifecycle. Algorithm testing is used to test a selected algorithm with a sample data set that your software will be using. This is used to profile and understand whether the algorithm will be the best match for the data.</p><p class="Para" id="Par45">
<span id="ITerm33">Unit testing
</span> is done throughout the development of the software. It is often tied into the continuous integration system. Continuous integration is the practice of building and testing your software on every commit to an SCM (source control management) system, which we discuss in more detail in this chapter. Unit testing is when you test the software at the smallest unit possible. This could be a single function, or class in object-oriented programming. The goal of unit testing is to validate the units of software work with a variety of inputs. Having unit tests with sufficient coverage is helpful during the maintenance phase, because it allows a unit of software to be improved while demonstrating that the inputs and outputs are not negatively changed.</p><p class="Para" id="Par46">If unit testing is focused on individual software units, then integration testing is focused on testing how those units work together. Integration testing has a primary goal of verifying that the software does what it is expected to do when all of the pieces come together. It also has a validation role in that it will help identify any adverse interactions between various units of the software.</p><p class="Para" id="Par47">There are other types of testing to be aware of, such as exploratory testing, performance testing, and user acceptance testing. Exploratory testing is where a user specifically “explores” to find issues that have not been found through the other types of testing that are done regularly. Performance testing is looking to record the performance in time or memory of your software. User acceptance testing is testing whether a user will accept the software deliverable.</p></section></section><section class="Section3 RenderAsSection3" id="Sec22"><h4 class="Heading">Test-Driven Development</h4><p class="Para" id="Par48">
<span id="ITerm34">Test-driven development (TDD)
</span>
<span id="ITerm35">


</span> is the discipline of developing your tests first, before you write any of the production code, and then writing the production code to make the tests pass. This is a particularly useful practice, especially for unit tests. It can keep the test coverage high for your software. It can also help enforce a good modular design, by making it difficult to have cross-dependencies given the goal of always having to pass tests. Despite all these benefits, it is not practiced as much as it could be. TDD requires a fairly complete knowledge of what the software should do, which is not always possible. It also is sometimes difficult to get over the hurdle of writing the tests first when the value to the users comes from the production software, trading the immediate satisfaction of writing the production code first to the delayed satisfaction of writing tests first.</p></section></section><section class="Section2 RenderAsSection2" id="Sec23"><h3 class="Heading">Developing for Debug</h3><p class="Para" id="Par49">
<span id="ITerm36">Debugging
</span>
<span id="ITerm37">


</span> is typically the exploration of the software to find the root cause of a defect or bug in the software. A debugger is software that will allow a developer to step through the code, one line at a time. This brings the computer speed down to the speed of the developer, so they can observe the effects of each line being executed. For source line debugging, it is best to have the source code available when you are debugging the software. If you do not have the source code, debug symbols are the next best thing. Debug symbols provide source-level information to a debugger without providing the full source code. There are situations where developers will need to debug without the benefit of source code or symbols. When you are developing software, there are activities you can do to support debug for the future engineers needing to debug your software.</p><section class="Section3 RenderAsSection3" id="Sec24"><h4 class="Heading">Asserts and Exceptions</h4><p class="Para" id="Par50">
<span id="ITerm38">Asserts and exceptions
</span>
<span id="ITerm39">


</span> are program language constructs that can be used to support debugging. An assertion will act as a checkpoint on some fact in the source code, like the value of a variable. An assertion is typically implemented with an assert keyword, which will typically stop the execution of the software, if the assertion is false. Adding assertions to your code will help prove that the data you expect is available. Assertions are typically automatically removed when the code is compiled in an optimization. And assertions that evaluate false actually halt the program, so assertions should be used with caution.</p><p class="Para" id="Par51">Exceptions are like assertions. Exceptions will check for an event that is not expected to occur. When an exception occurs, an exception handler in your code can catch the exception. Once an exception is caught, it can be raised up the stack for another exception handler to deal with, or it can be handled immediately. A raised exception will provide data about where a defect originates from. For debugging, unhandled exceptions are defects that need to be addressed. Adding code to raise exceptions is a good technique for making your code more debugger-friendly.</p></section><section class="Section3 RenderAsSection3" id="Sec25"><h4 class="Heading">Logging and Tracing</h4><p class="Para" id="Par52">Two other practices that help make your code more debugger-friendly are logging and <span id="ITerm40">tracing

</span>. Logging is recording events that occur in the software to an external file, for instance, so a human or machine can go back and follow the events of software execution. Tracing is using logs or live data to observe the behavior of the software while it is running.</p><p class="Para" id="Par53">Most modern languages have built-in support for logging. It is a good practice to use these logging frameworks whenever possible. Using a logging framework will help distinguish between messages intended for the logs and messages intended for active users. When adding logging to your software, you need to strike a balance between how precise or frequent you want your log messages to be and the number of messages in the log. Remember that logging takes compute time and that if there is too much information in the log, it may hide meaningful events.</p></section></section><section class="Section2 RenderAsSection2" id="Sec26"><h3 class="Heading">Source Control Management</h3><p class="Para" id="Par54">
<span id="ITerm41">Source control management (SCM)

</span> is the practice of managing the source code of your software. This practice includes managing the directory structure of the source code, maintaining a history of revisions of the code, and versioning the code.</p><section class="Section3 RenderAsSection3" id="Sec27"><h4 class="Heading">Purpose and Mechanism</h4><p class="Para" id="Par55">Source code <span id="ITerm42">management

</span> gives the developer or development team confidence to proceed with development knowing that they can go back to a previous revision of the source code, should they need too. A fundamental purpose of SCM is to preserve the progression of the source code development.</p><p class="Para" id="Par56">SCM systems allow for branches of the software to exist simultaneously, so different revisions of source code can be compared or merged. This allows a team of developers to operate safely, in their own environment, without impacting each other with moment-to-moment changes. When your code branch is ready, you use SCM to integrate the branch to a trunk or mainline of the source code.</p><div class="Para" id="Par57">SCM systems typically have the same common concepts (Table <span class="InternalRef"><a href="#Tab1">B-1</a></span>), although different tools may call these concepts by different terms.<div class="Table" id="Tab1"><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Table B-1</span><p class="SimplePara">Common SCM Terms</p></div></div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Term</p></th><th style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Definition</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Workspace</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">The directory structure on a development machine for the source code of software.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Revision</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">A single incremental change of the source code.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Branch</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">A line of revisions that are derived from a single point in the past.</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Mainline</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">The branch of the code that is where the integration of various branches occurs. Sometimes called trunk.</p></td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">Version</p></td><td style="text-align: left;"><p class="SimplePara">A specific revision that has meaning or value.</p></td></tr></tbody></table></div>
</div><p class="Para" id="Par58">Imagine using SCM for a small team. For example, a developer will check out a <span id="ITerm43">workspace

</span>. The workspace will define the directory structure of the source code on the developer's system. As the developer makes changes to the source code, they will commit this code to the SCM system creating a revision. The developer may be creating multiple revisions on a branch. They will then want to share their revisions with the rest of the team by merging their revisions into the mainline. On the mainline, the development team will define the next version by linearly selecting the head revision on the mainline.</p><p class="Para" id="Par59">For another example, a bug is discovered in the recent version and needs to be fixed. In this case, a developer will check out a workspace based on that previous version. Then they will create a branch to fix the code. As they fix the code, the developer will create revisions by progressively committing their code to the SCM system. They can compare their revisions to the revisions on another branch to identify changes or even to help discover the root cause of the bug. Once they have fixed the bug, they can again merge into the mainline and create another version.</p><p class="Para" id="Par60">Both examples are somewhat simplified and mix concepts from multiple SCM <span id="ITerm44">tools

</span>. Each SCM tool will have its own process and workflow. SCM tools can generally be split into two categories: centralized and distributed. A centralized SCM system maintains in a single location a definitive list of revisions and versions. This has an advantage of maintaining linearity of the software and explicit control of a version. A distributed SCM system does not require a central system to maintain the distributions but allows multiple systems to maintain individual history and then add history of revisions from another node in the SCM system. This has the advantage of allowing the full capabilities of an SCM system while being disconnected from the team, but the linearity of the revisions is not guaranteed.</p></section><section class="Section3 RenderAsSection3" id="Sec28"><h4 class="Heading">Tools</h4><p class="Para" id="Par61">There are many source code management tools. Each tool has its own unique differences. In the following, we will review two of the most common tools that demonstrate the centralized and distributed SCM systems.</p><section class="Section4 RenderAsSection4" id="Sec29"><h5 class="Heading">Perforce Helix</h5><p class="Para" id="Par62">
<span id="ITerm45">Perforce Helix
</span>
<span id="ITerm46">


</span> is a good example of a centralized version control system for SCM. It allows developers to define their workspace from the various branches in the overall source code tree. By being a centralized system, it can enforce that revisions are committed in a linear order and can maintain that order. One area where Perforce Helix stands out is how it handles source assets that are not text, such as large binary files like game assets.</p></section><section class="Section4 RenderAsSection4" id="Sec30"><h5 class="Heading">Git</h5><p class="Para" id="Par63">
<span id="ITerm47">Git
</span>
<span id="ITerm48">


</span> has become the industry de facto SCM. It is an example of a distributed revision control system. Git maintains a repository history of revisions locally within the workspace. To interact with another instance of the Git repository, a developer can push changes to the other instance or pull and merge changes from that other instance. Because Git does not have a centralized location, other solutions like GitHub have been put in place to act as a central instance of the repository. Other processes have emerged around Git to help define definitive versions such as having merge or pull request as a gate to a mainline branch and using tags to capture the linear progression for versions.</p></section></section></section><section class="Section2 RenderAsSection2" id="Sec31"><h3 class="Heading">Build Optimizations and Tools</h3><p class="Para" id="Par64">Build tools coordinate the compilation and linking of the source code into usable software.</p><section class="Section3 RenderAsSection3" id="Sec32"><h4 class="Heading">Purpose and Mechanism</h4><p class="Para" id="Par65">Originally source <span id="ITerm49">code


</span> had to be first compiled into object files one at a time, and then all those object files had to be linked together into an executable or library. As software got larger and larger, a tool to coordinate the effort of compiling and linking many files together became necessary. This is the basis of what a build tool does.</p><p class="Para" id="Par66">Adding to the complexity of compiling source code into object files, some of those object files depended on other object files to exist before they could be linked together. And in this case, some of those upstream object files were needed for more than one downstream object file. Managing this collection of object file dependencies is another piece of what the build tool does. Build tools will typically enable a declaration of dependencies and will make sure that the dependencies are satisfied before attempting to compile and link a file. Most build tools will optimize the satisfaction of dependencies by first checking if they exist and then creating them only once, if it does not exist.</p><p class="Para" id="Par67">Scripted or interpreted languages like Python, Ruby, and JavaScript don’t need to compile the source code into object files. Scripted languages can still benefit from build tools that manage the dependencies and create packages and other collateral.</p><p class="Para" id="Par68">Another <span id="ITerm50">thing


</span> a build tool does is manage configuration parameters for multiple configurations to inform the compiler and linker how to behave. This allows the object files and software to have multiple configurations, such as debug instances or even support for multiple operating system instances.</p><p class="Para" id="Par69">This ability to coordinate multiple tools like a compiler and a linker led build tools to be used to coordinate additional tools that are expected in a modern software project like unit test runners, security checkers, and document generators.</p><p class="Para" id="Par70">Build tools will typically have their own source file to define the configurations and parameters. The configuration file will usually list targets that will be the output of some action and the dependencies that need to be satisfied before the output can be created. Typically build tools also allow a developer to define the tools and parameters to call to create the output. Make and most modern build tools also have default rules for doing the basics of compiling and linking object files.</p></section><section class="Section3 RenderAsSection3" id="Sec33"><h4 class="Heading">Tools</h4><p class="Para" id="Par71">There are a lot of build tools available. Some are specific to a language, and many modern languages such as Go and Rust have a build tool distributed with the language. Some build tools are fully declarative, meaning that all the possible options and dependencies are defined in the configuration files. Most build tools are primarily declarative with limited scripting ability for loops and conditional statements. Another category of build tools are generators, like Cmake and GNU Autotools, which use data to configure and generate a build script. Then this build script can be called by another build tool.</p><section class="Section4 RenderAsSection4" id="Sec34"><h5 class="Heading">Make</h5><p class="Para" id="Par72">
<span id="ITerm51">Make


</span> is one of the older build tools. There are multiple implementations of make that have mostly the same feature set; the most common make is GNU make. The make configuration file is called the Makefile. Make provides a declarative syntax for defining targets and dependencies. Each target line starts with the target followed by a space-separated list of dependencies on a single line. The commands to create the target are the subsequent lines, tab indented, under the target line. Typically, these lines are shell commands that make use of the underlying command shell. By default, the targets are expected to be files that are created on the file system; however, a target can have a <span class="EmphasisFontCategoryNonProportional ">.phony</span> decorator added to it so that make knows the target can be satisfied even if no output file is created. This allows for an easy name like ALL or drivers to be applied to a list of dependencies instead of the direct output, such as <span class="EmphasisFontCategoryNonProportional ">my_cool_program.exe</span>.</p></section><section class="Section4 RenderAsSection4" id="Sec35"><h5 class="Heading">Gradle</h5><p class="Para" id="Par73">
<span id="ITerm52">Gradle
</span>
<span id="ITerm53">



</span> is a more modern build tool that is built on top of the Groovy language and its <span id="ITerm54">Java Virtual Machine (JVM)
</span>. Gradle configurations are written in a domain-specific language designed for builds. Like make, Gradle can define targets and dependencies. Unlike make, these targets do not have to be files that are created. Gradle remembers what targets have been satisfied in a build cache. Gradle can even share this build cache between multiple systems on a network making it easier to split the build work to improve build time. The commands to satisfy the targets do not have to be shell commands; they can be methods in Groovy.</p></section><section class="Section4 RenderAsSection4" id="Sec36"><h5 class="Heading">Cmake and Ninja</h5><p class="Para" id="Par74">Cmake<span id="ITerm55">



</span> takes a different approach than Gradle or make. Instead of defining the build targets and commands directly in the CMakefile, Cmake defines a script for generating the targets and commands for another build tool. This provides the ability to consistently model the targets and dependencies for your software project and then generate equivalent logic for multiple systems, such as different integrated development environments or different implementations of make.</p><p class="Para" id="Par75">
<span id="ITerm56">Ninja
</span>
<span id="ITerm57">



</span> is a modern build tool like make. It is intended to be highly performant and minimal compared to build systems like Gradle. Cmake generates Ninja build files, a common practice, with the rich syntax being handled by Cmake and the performant build done by Ninja.</p></section></section></section><section class="Section2 RenderAsSection2" id="Sec37"><h3 class="Heading">Continuous Integration and Continuous Delivery</h3><p class="Para" id="Par76">Continuous integration (CI) is the <span id="ITerm58">practice

</span> of building and testing your software on every commit to an SCM system. Continuous delivery builds on the concept of continuous integration to deliver the software to users automatically, typically when the software is merged to the mainline in the SCM system. The term continuous integration was coined by Martin Fowler in 2000.</p><section class="Section3 RenderAsSection3" id="Sec38"><h4 class="Heading">Purpose and Mechanism</h4><p class="Para" id="Par77">Prior to the practice of continuous integration, when a new version of the <span id="ITerm59">software

</span> needed to be built and tested, all the various branches and different developers' work would come together for integration in a so-called “big-bang.” A build would be attempted, and if not successful, engineers would have to find the reasons. This could be caused by code conflict or even incompatible code between engineers. Once the initial work to resolve the conflicts and any side effects would be resolved and the build be complete, then testing could begin. All of this is very painful and time consuming, hence the moniker “big-bang.” If this integration testing found issues, then the code needed to be changed and any side effects again resolved, and the process would start again. Historically this process could take days or even weeks. So we want to avoid big-bangs.</p><p class="Para" id="Par78">Continuous integration addresses this “big-bang” integration problem by <span id="ITerm60">shrinking

</span> integrations into a continuous stream of micro-integration events. In the practice of continuous integration, developers push their changes regularly, ideally daily, to be integrated to a mainline in the SCM system, using build tools that automatically build and validate (through unit testing, for instance) the new integrated version. If this build does not work, the developer can see that within hours and make corrections in the small amount of code that they worked on, instead of digging through everybody’s code in the “big-bang” integration style. If the build is successful, then automated unit tests and integration tests can be run. Again, if the tests fail, there is only a small amount of code that could have introduced the failure, so the developer can easily find and fix their code.</p><p class="Para" id="Par79">Continuous integration systems wait for source code to be pushed to the SCM system and activate when there is a change. The CI system will either monitor the SCM system or be triggered by an event on the SCM system. At that point, the CI system will check out the code and invoke the build tool automatically, and then the CI system will run the tests. Typically, the CI system will report on the status of the build so the developer and the team can review the results.</p><p class="Para" id="Par80">Continuous deployment utilizes the same CI systems for deployment or delivery activities. After the source code is integrated, built, and tested, the CI system can be triggered to automatically deploy the software. The deployment may require additional steps or stages such as more testing, checking security scans, packaging the software for install, and copying it to a location to either run online or download to install on a local system.</p></section><section class="Section3 RenderAsSection3" id="Sec39"><h4 class="Heading">Tools</h4><p class="Para" id="Par81">Like build tools and SCM systems, there are a lot of options for CI/CD systems. They define the stages and steps to integrate and deploy the software. CI/CD systems also define how the tools will interact with the SCM systems.</p><section class="Section4 RenderAsSection4" id="Sec40"><h5 class="Heading">Jenkins</h5><p class="Para" id="Par82">
<span id="ITerm61">Jenkins
</span>
<span id="ITerm62">


</span> is one of the oldest CI/CD systems. It is still the most popular CI/CD system. Jenkins provides a lot of flexibility in how it can be configured and deployed. Originally Jenkins enabled a wide variety of plugins to expand the configuration interface for defining the rules for your software’s CI and CD. Jenkins also provides a scripted, domain-specific language and a declarative syntax, both based on Groovy, to define the CI/CD pipeline. Jenkins is typically installed on-premises, but there are online and commercial offerings. When Jenkins is installed on your premises, you need to provide your own compute capacity for build and testing.</p></section><section class="Section4 RenderAsSection4" id="Sec41"><h5 class="Heading">CircleCI</h5><p class="Para" id="Par83">
<span id="ITerm63">CircleCI
</span>
<span id="ITerm64">


</span> is a popular Software as a Service (SaaS) CI/CD system. It provides an online tool to create a CI/CD pipeline and the compute resources for compilation and testing. CircleCI provides a simple UI for defining the connection to the SCM system and a YAML-based declarative syntax for defining the pipeline.</p></section><section class="Section4 RenderAsSection4" id="Sec42"><h5 class="Heading">GitLab CI/CD</h5><p class="Para" id="Par84">
<span id="ITerm65">GitLab CI/CD
</span>
<span id="ITerm66">


</span> is an example of a CI/CD system that is built into the SCM system. The GitLab CI/CD system is available wherever the GitLab SCM system is installed. Because GitLab CI/CD is integrated with the SCM system, it requires minimal configuration to connect to the source code. For configuring the CI/CD pipeline, GitLab uses a YAML-based declarative syntax. Using the GitLab SaaS solution provides both the CI/CD system interface and the compute capacity for build and test. Using GitLab with your own environment requires you to provide your own compute capacity. Despite GitLab CI/CD being associated with the GitLab SCM solution, GitLab CI/CD can work with a variety of Git solutions including GitHub.</p></section></section></section></section></div></aside><aside aria-labelledby="App3Heading" class="Appendix" id="App3"><div epub:type="appendix" role="doc-appendix"><section class="Section1 RenderAsSection1" id="Sec43"><h2 class="Heading" id="App3Heading">Appendix C: ACPI System States</h2><p class="Para" id="Par85">Power optimization of computer systems has become very important. There are many governing bodies (like the California Energy Commission) that mandate a certain level of power efficiency in computing devices. In a computer system, there are multiple pieces of hardware and software that all need to be in sync. Therefore, a mechanism is needed for these pieces to pass information around. The <span id="ITerm67">Advanced Configuration and Power Interface Special Interest Group (ACPI SIG)
</span> developed such a standard, named after the group, ACPI.</p><p class="Para" id="Par86">ACPI<span id="ITerm68">


</span> provides an open standard that system firmware (BIOS) and operating systems use to discover, configure, and carry out system-specific operations. ACPI replaces the multiple earlier standards like <span id="ITerm69">Advanced Power Management (APM)
</span>, MultiProcessor Specification, and the Plug and Play (PnP) BIOS Specification. ACPI defines a hardware abstraction interface across system firmware, computer hardware components, and operating systems. ACPI is the key element in <span id="ITerm70">operating system–directed configuration and power management (OSPM)
</span>. In 2013, the ACPI SIG agreed to transfer the specification to the UEFI Forum, which now owns the specification.</p><div class="Para" id="Par87">ACPI defines standard operating states for systems, devices, and processors, among other things. Figure <span class="InternalRef"><a href="#Fig2">C-1</a></span> shows the various states defined by ACPI and transitions between them. In the following sections, we talk about these states and explain what they all mean.<figure class="Figure" id="Fig2"><div class="MediaObject" id="MO2"><img alt="../images/503707_1_En_BookBackmatter_Fig2_HTML.png" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_BookBackmatter_Fig2_HTML.png" style="width:35.32em" width="1413" height="825"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure C-1</span><p class="SimplePara">Global and System Power States and Transitions</p></div></figcaption></figure>
</div><section class="Section2 RenderAsSection2" id="Sec44"><h3 class="Heading">Global and System States</h3><p class="Para" id="Par88">ACPI defines four global states and six system states. The global states are marked G0–G3, while the system states are marked as S0–S5. It must be noted, however, that some motherboard documents reference S6, which is not an ACPI-defined state. If you come across this, you can safely map this to G3.</p><p class="Para" id="Par89">ACPI <span id="ITerm71">defines

</span> a mechanism to transition the system between the working state (G0) and the sleeping state (G1) or the soft-off state (G2). During transitions between the working and sleeping states, the operating system will maintain your context, so you don’t lose information on such transitions. ACPI defines the level of the G1 sleeping state by defining the system attributes of four types of ACPI sleeping states (S1, S2, S3, and S4). Each sleeping state is defined to allow implementations to trade-off cost, power, and wake latencies:</p><div class="Para" id="Par90">
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div class="Para" id="Par91">G0/S0: In the G0 state, work is being performed by the OS/application software and the hardware. The CPU or any particular hardware device could be in any one of the defined power states (more on the device and CPU power states in a later section); however, some work will be taking place in the system.<div class="OrderedList"><ol><li class="ListItem"><div class="ItemNumber">a.</div><div class="ItemContent"><p class="Para" id="Par92">S0: System is in a fully working state.</p></div><div class="ClearBoth">&nbsp;</div></li></ol></div>
</div></li></ul></div>
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><div class="Para" id="Par93">G1: In the G1 <span id="ITerm72">state

</span>, the system is assumed to be doing no work. Prior to entering the G1 state, OSPM will place devices in a device power state compatible with the system sleeping state to be entered; if a device is enabled to wake the system, then OSPM will place these devices into the lowest D<em class="EmphasisTypeItalic ">x</em> state from which the device supports wake.<div class="OrderedList"><ol><li class="ListItem"><div class="ItemNumber">a.</div><div class="ItemContent"><p class="Para" id="Par94">S1: The S1 state is defined as a low wake latency sleeping state. In this state, the entire system context is preserved with the exception of CPU caches. Before entering S1, OSPM will flush the system caches.</p></div><div class="ClearBoth">&nbsp;</div></li><li class="ListItem"><div class="ItemNumber">b.</div><div class="ItemContent"><p class="Para" id="Par95">S2: The S2 state is defined as a low wake latency sleep state. This state is similar to the S1 sleeping state where any context except for system memory may be lost.</p></div><div class="ClearBoth">&nbsp;</div></li><li class="ListItem"><div class="ItemNumber">c.</div><div class="ItemContent"><p class="Para" id="Par96">S3: Commonly referred to as Standby, Sleep, or <span id="ITerm73">Suspend to RAM (STR)
</span>
<span id="ITerm74">


</span>. The S3 state is defined as a low wake latency sleep state. From the software viewpoint, this state is functionally the same as the S2 state. The operational difference is that some power resources that may have been left ON in the S2 state may not be available to the S3 state. As such, some devices may be in a lower-power state when the system is in the S3 state than when the system is in the S2 state. Similarly, some device wake events can function in S2 but not S3.</p></div><div class="ClearBoth">&nbsp;</div></li><li class="ListItem"><div class="ItemNumber">d.</div><div class="ItemContent"><p class="Para" id="Par97">S4: Also known as Hibernation or Suspend to Disk. The S4 sleeping state is the lowest-power, longest wake latency sleeping state supported by ACPI. In order to reduce power to a minimum, it is assumed that the hardware platform has powered off all devices. Because this is a sleeping state, the platform context is maintained. Depending on how the transition into the S4 sleeping state occurs, the responsibility for maintaining system context changes between OSPM and BIOS. To preserve context, in this state all content of the main memory is saved to non-volatile memory such as a hard drive and is powered down. The contents of RAM are restored on resume. All hardware is in the off state and maintains no context.</p></div><div class="ClearBoth">&nbsp;</div></li></ol></div>
</div></li></ul></div>
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par98">G2/S5: Also referred to as Soft Off. In G2/S5, all hardware is in the off state and maintains no context. OSPM places the platform in the S5, soft-off, state to achieve a logical <span id="ITerm75">off

</span>. The S5 state is not a sleeping state (it is a G2 state), and no context is saved by OSPM or hardware, but power may still be applied to parts of the platform in this state, and as such, it is not safe to take the system apart. Also, from a hardware perspective, the S4 and S5 states are nearly identical. When initiated, the hardware will sequence the system to a state similar to the off state. The hardware has no responsibility for maintaining any system context (memory or I/O); however, it does allow a transition to the S0 state due to a power button press or a remote start.</p></li><li><p class="Para" id="Par99">G3: Mechanical Off. Same as S5. Additionally, the power supply is isolated. The computer's power has been totally removed via a mechanical switch, and no electrical current is running through. This is the only state that the system can be worked on without damaging the hardware.</p></li></ul></div>
</div></section><section class="Section2 RenderAsSection2" id="Sec45"><h3 class="Heading">Device States</h3><div class="Para" id="Par100">In addition to global and system <span id="ITerm76">states

</span>, ACPI defines various device states ranging from D0 to D3. The exact definition or meaning of specific device states depends on the device class. A device class describes a type of device – for example, audio, storage, network, and so on:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par101">D0: This state is assumed to be the highest level of functionality and power consumption. The device is completely active and responsive and is expected to remember all relevant contexts.</p></li><li><p class="Para" id="Par102">D1: Many device classes may not support D1. In general, D1 is expected to save less power and preserve more device context than D2. D1 may cause the device to lose some context.</p></li><li><p class="Para" id="Par103">D2: Many device classes may not support D2. In general, D2 is <span id="ITerm77">expected

</span> to save more power and preserve less device context than D1 or D0. D2 may cause the device to lose some context.</p></li><li><p class="Para" id="Par104">D3 Hot: Devices in the D3 Hot state are required to be software enumerable. In general, D3 Hot is expected to save more power and optionally preserve device context. If device context is lost when this state is entered, the OS software will reinitialize the device when transitioning back to D0.</p></li><li><p class="Para" id="Par105">D3 Cold: Power has been fully removed from the device. The device context is lost when this state is entered, so the OS software will have to fully reinitialize the device when powering it back on. Devices in this state have the longest restore times.</p></li></ul></div>
</div></section><section class="Section2 RenderAsSection2" id="Sec46"><h3 class="Heading">Processor States</h3><div class="Para" id="Par106">ACPI defines the power state of system processors while in the G0 working state as being either active (executing) or sleeping (not executing). Processor power states are <span id="ITerm78">designated

</span> as C0, C1, C2, C3, … Cn. The C0 power state is an active power state where the CPU executes instructions. The C1–Cn power states are processor sleeping states where the processor consumes less power and dissipates less heat than leaving the processor in the C0 state. While in a sleeping state, the processor does not execute any instructions. Each processor sleeping state has a latency associated with entering and exiting that corresponds to the power savings. In general, the longer the entry/exit latency, the greater the power savings is for the state. To conserve power, OSPM places the processor into one of its supported sleeping states when idle. While in the C0 state, ACPI allows the performance of the processor to be altered through a defined “throttling” process and through transitions into multiple performance states (P states). A <span id="ITerm79">diagram

</span> of processor power states (not to be confused with performance states) is provided in Figure <span class="InternalRef"><a href="#Fig3">C-2</a></span>.<figure class="Figure" id="Fig3"><div class="MediaObject" id="MO3"><img alt="../images/503707_1_En_BookBackmatter_Fig3_HTML.png" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_BookBackmatter_Fig3_HTML.png" style="width:35.62em" width="1425" height="954"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure C-2</span><p class="SimplePara">Processor Power States</p></div></figcaption></figure>
</div><p class="Para" id="Par107">In summary, one of the main goals of OSPM is to save power/energy when the workload allows it, and detecting inactivity and putting the devices and the system (if possible) in their low-power states forms the heart of power management software.</p></section></section></div></aside><aside aria-labelledby="App4Heading" class="Appendix" id="App4"><div epub:type="appendix" role="doc-appendix"><section class="Section1 RenderAsSection1" id="Sec47"><h2 class="Heading" id="App4Heading">Appendix D: System Boot Flow</h2><p class="Para" id="Par108">When we press the power button on our computing device, we are well aware that the system goes through a bootup process. The boot process culminates with the system being ready for use. But what happens during the boot process is not very well understood widely. In this chapter, we will strive to resolve that.</p><div class="Para" id="Par109">As shown in Figure <span class="InternalRef"><a href="#Fig4">D-1</a></span>, there are four main boot phases on IA devices. The first <span id="ITerm80">phase
</span> is system hardware bring-up/power-on, which is primarily hardwired to bring up the foundation for software components to get started and take over. Then the BIOS (aka system firmware) phase is responsible for basic initialization and bring-up of system hardware enabling things to pass to the next stage, where the boot loader loads the OS into memory and then begins OS initialization. This last phase takes care of initialization of critical parts of the HW and SW system before making itself available to the user.<figure class="Figure" id="Fig4"><div class="MediaObject" id="MO4"><img alt="../images/503707_1_En_BookBackmatter_Fig4_HTML.png" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_BookBackmatter_Fig4_HTML.png" style="width:35.62em" width="1425" height="217"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure D-1</span><p class="SimplePara">High-Level System Boot Flow</p></div></figcaption></figure>
</div><p class="Para" id="Par110">On receiving a “Power Good” signal, CPUs are hardwired to start fetching and executing at a predefined location (address), which is called the “Reset Vector.” The Reset Vector points to BIOS code. So, when the CPU is out of reset and starts fetching code from the “Reset Vector,” it happens to be BIOS code, which is how BIOS code gets the control and starts executing. Keep in mind that before control comes to CPU and BIOS code, there are a few system hardware- and firmware-related initializations and configurations that happen.</p><p class="Para" id="Par111">BIOS discovers, enumerates, and initializes the HW devices present. After that it runs <span id="ITerm81">power-on self-test (POST)
</span>. The POST is responsible for validating the sanity of fundamental hardware components. One of the fundamental hardware components in the system happens to be memory. BIOS has a component specialized for memory initialization called the <span id="ITerm82">Memory Reference Code (MRC)
</span>. Another of BIOS’s responsibility is to prepare the hardware configuration and memory map and pass those to the OS, in the form of tables. The format and mechanism of information exchange is defined by a standard body, <span id="ITerm83">Unified Extensible Firmware Interface (UEFI)
</span>. Today, most BIOS is UEFI spec compliant. BIOS also adheres to the ACPI specification in passing platform resource(s) information to the OS.</p><p class="Para" id="Par112">If all goes well, BIOS now identifies a bootable disk and reads the <span id="ITerm84">master boot record (MBR)
</span>
<span id="ITerm85">

</span> of that disk. The MBR is located in the first sector of the bootable media (could be hard drive, flash, solid-state device, etc.).</p><p class="Para" id="Par113">The MBR is 512 bytes in size. It has three components: primary boot loader information in the first 446 bytes, partition table in the next 64 bytes, and MBR validation check in the last 2 bytes.</p><p class="Para" id="Par114">The primary boot loader in the MBR will attempt to locate an active (bootable) partition in the media’s partition table. If such a partition is found, the boot sector of that partition is loaded in memory, and then the control jumps to that. Each operating system has its own boot sector format. The boot sector has a small program that locates the OS loader, reads that into memory, and launches that.</p><p class="Para" id="Par115">The OS loader loads essential system drivers that are required to read data from the disk and initializes the system to the point where the kernel can begin execution.</p><p class="Para" id="Par116">After OS loading, the OS initialization phase starts. In the OS initialization phase, first, the kernel initialization and plug-and-play activity happen. After that, relevant services are started, and the user interface (could be a command line shell or a full-blown graphical user interface) is presented and the system is now ready for use.</p></section></div></aside><div class="Index" epub:type="index" id="Ind1" role="doc-index"><div class="Headings"><div class="Heading">Index</div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">A</div></div><div class="IndexEntry"><div class="PrimaryIE">Access control</div><div class="SecondaryIE">availability</div><div class="SecondaryIE">CA</div><div class="SecondaryIE">certificate chains</div><div class="SecondaryIE">confidentiality</div><div class="SecondaryIE">cryptography</div><div class="SecondaryIE">digital signature</div><div class="SecondaryIE">integrity</div><div class="SecondaryIE">nonces</div><div class="SecondaryIE">random numbers</div><div class="SecondaryIE">salts</div><div class="SecondaryIE">security</div></div><div class="IndexEntry"><div class="PrimaryIE">Acknowledgement (ACK)</div></div><div class="IndexEntry"><div class="PrimaryIE">Advanced Configuration and Power Interface (ACPI)</div><div class="SecondaryIE">definition</div><div class="SecondaryIE">device states</div><div class="SecondaryIE">global/system states</div><div class="SecondaryIE">processor states</div></div><div class="IndexEntry"><div class="PrimaryIE">Advanced Configuration and Power Interface Special Interest Group (ACPI SIG)</div></div><div class="IndexEntry"><div class="PrimaryIE">Advanced Encryption Standard (AES)</div></div><div class="IndexEntry"><div class="PrimaryIE">Advanced Micro Devices (AMD)</div></div><div class="IndexEntry"><div class="PrimaryIE">Advanced Power Management (APM)</div></div><div class="IndexEntry"><div class="PrimaryIE">Algorithm</div><div class="SecondaryIE">asymptotic notation</div><div class="SecondaryIE">Big-Oh notation</div><div class="SecondaryIE">data structure</div><div class="TertiaryIE">array</div><div class="TertiaryIE">dictionary</div><div class="TertiaryIE">graph</div><div class="TertiaryIE">linked list</div><div class="TertiaryIE">queue</div><div class="TertiaryIE">searching/sorting</div><div class="TertiaryIE">stack</div><div class="TertiaryIE">tree</div><div class="SecondaryIE">time/space</div></div><div class="IndexEntry"><div class="PrimaryIE">Algorithm testing</div></div><div class="IndexEntry"><div class="PrimaryIE">ALOHAnet</div></div><div class="IndexEntry"><div class="PrimaryIE">Amazon Web Services (AWS)</div></div><div class="IndexEntry"><div class="PrimaryIE">Antivirus (AV) scanners</div></div><div class="IndexEntry"><div class="PrimaryIE">Application programming interface (API)</div></div><div class="IndexEntry"><div class="PrimaryIE">ARPANET</div></div><div class="IndexEntry"><div class="PrimaryIE">Artificial intelligence (AI)</div></div><div class="IndexEntry"><div class="PrimaryIE">Artificial neural networks</div><div class="SecondaryIE">ADALINE</div><div class="SecondaryIE">MADALINE</div></div><div class="IndexEntry"><div class="PrimaryIE">Asserts and exceptions</div></div><div class="IndexEntry"><div class="PrimaryIE">Asymmetric key cryptography</div></div><div class="IndexEntry"><div class="PrimaryIE">Asymptotic notation</div></div><div class="IndexEntry"><div class="PrimaryIE">Availability</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">B</div></div><div class="IndexEntry"><div class="PrimaryIE">Base pointer</div></div><div class="IndexEntry"><div class="PrimaryIE">Big-Oh analysis</div></div><div class="IndexEntry"><div class="PrimaryIE">Big-Oh notation</div></div><div class="IndexEntry"><div class="PrimaryIE">Bigtable</div></div><div class="IndexEntry"><div class="PrimaryIE">Biometric authentication</div></div><div class="IndexEntry"><div class="PrimaryIE">Border Gateway Protocol (BGP)</div></div><div class="IndexEntry"><div class="PrimaryIE">Brute force algorithm</div></div><div class="IndexEntry"><div class="PrimaryIE">Bulletin board systems (BBSs)</div></div><div class="IndexEntry"><div class="PrimaryIE">Buses</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">C</div></div><div class="IndexEntry"><div class="PrimaryIE">Cascading Style Sheets (CSS)</div></div><div class="IndexEntry"><div class="PrimaryIE">Cassandra</div></div><div class="IndexEntry"><div class="PrimaryIE">Central processing unit (CPU)</div><div class="SecondaryIE">blocks</div><div class="SecondaryIE">controlling flow</div><div class="SecondaryIE">decode/execute/store</div><div class="SecondaryIE">fetch</div><div class="SecondaryIE">Flynn’s taxonomy</div><div class="SecondaryIE">instruction pipeline</div><div class="SecondaryIE">stack</div></div><div class="IndexEntry"><div class="PrimaryIE">Certificate authorities (CAs)</div></div><div class="IndexEntry"><div class="PrimaryIE">ciphertext</div></div><div class="IndexEntry"><div class="PrimaryIE">CircleCI</div></div><div class="IndexEntry"><div class="PrimaryIE">Client-server architecture</div></div><div class="IndexEntry"><div class="PrimaryIE">Cloud computing</div><div class="SecondaryIE">benefits</div><div class="TertiaryIE">availability</div><div class="TertiaryIE">cost</div><div class="TertiaryIE">performance</div><div class="TertiaryIE">productivity</div><div class="TertiaryIE">reliability</div><div class="TertiaryIE">scalability</div><div class="TertiaryIE">use/maintenance</div><div class="TertiaryIE">velocity</div><div class="SecondaryIE">containers</div><div class="TertiaryIE">benefits</div><div class="TertiaryIE">capabilities/tools</div><div class="TertiaryIE">definition</div><div class="TertiaryIE">production environment</div><div class="TertiaryIE">
<em class="EmphasisTypeItalic ">vs</em>. VMs</div><div class="SecondaryIE">definition</div><div class="SecondaryIE">deployment configurations</div><div class="TertiaryIE">hybrid clouds</div><div class="TertiaryIE">ideal cloud</div><div class="TertiaryIE">private cloud</div><div class="TertiaryIE">public clouds</div><div class="SecondaryIE">Docker</div><div class="SecondaryIE">illustration</div><div class="SecondaryIE">interface/mechanism</div><div class="SecondaryIE">interoperability</div><div class="SecondaryIE">Kubernetes</div><div class="SecondaryIE">and ML</div><div class="SecondaryIE">portability</div></div><div class="IndexEntry"><div class="PrimaryIE">Cloud computing models</div><div class="SecondaryIE">comparison</div><div class="SecondaryIE">IaaS</div><div class="SecondaryIE">PaaS</div><div class="SecondaryIE">SaaS</div><div class="SecondaryIE">serverless</div></div><div class="IndexEntry"><div class="PrimaryIE">Cloud service customers (CSCs)</div></div><div class="IndexEntry"><div class="PrimaryIE">Cloud service providers (CSPs)</div><div class="SecondaryIE">considerations, choosing</div><div class="SecondaryIE">switching</div><div class="TertiaryIE">business dynamics change</div><div class="TertiaryIE">CSCs</div><div class="TertiaryIE">ecosystem change</div><div class="TertiaryIE">privacy change</div><div class="TertiaryIE">regulatory change</div><div class="TertiaryIE">usage/pricing change</div></div><div class="IndexEntry"><div class="PrimaryIE">Command line interface (CLI)</div></div><div class="IndexEntry"><div class="PrimaryIE">Communication security</div><div class="SecondaryIE">IPSec</div><div class="SecondaryIE">TLS</div><div class="SecondaryIE">VPN</div></div><div class="IndexEntry"><div class="PrimaryIE">Compiler</div></div><div class="IndexEntry"><div class="PrimaryIE">Computer security</div></div><div class="IndexEntry"><div class="PrimaryIE">Computer system</div><div class="SecondaryIE">CPU</div><div class="SecondaryIE">I/O operations</div><div class="SecondaryIE">main memory/secondary storage</div></div><div class="IndexEntry"><div class="PrimaryIE">Confidentiality</div></div><div class="IndexEntry"><div class="PrimaryIE">Containers</div></div><div class="IndexEntry"><div class="PrimaryIE">Continuous integration and continuous deployment (CI/CD)</div><div class="SecondaryIE">CircleCI</div><div class="SecondaryIE">definition</div><div class="SecondaryIE">GitLab</div><div class="SecondaryIE">Jenkins</div><div class="SecondaryIE">purpose/mechanism</div></div><div class="IndexEntry"><div class="PrimaryIE">Conventional machine intelligence</div></div><div class="IndexEntry"><div class="PrimaryIE">CouchDB</div></div><div class="IndexEntry"><div class="PrimaryIE">Cryptographic algorithms</div></div><div class="IndexEntry"><div class="PrimaryIE">Cryptographically secure random numbers</div></div><div class="IndexEntry"><div class="PrimaryIE">Cryptography</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">D</div></div><div class="IndexEntry"><div class="PrimaryIE">Darknet</div></div><div class="IndexEntry"><div class="PrimaryIE">Database</div><div class="SecondaryIE">ACID</div><div class="SecondaryIE">history</div><div class="SecondaryIE">persistence/volume</div><div class="SecondaryIE">systems</div></div><div class="IndexEntry"><div class="PrimaryIE">Data hazard</div></div><div class="IndexEntry"><div class="PrimaryIE">Data synchronization</div></div><div class="IndexEntry"><div class="PrimaryIE">Data-to-hash relationship</div></div><div class="IndexEntry"><div class="PrimaryIE">Deadlock</div></div><div class="IndexEntry"><div class="PrimaryIE">Debugging</div></div><div class="IndexEntry"><div class="PrimaryIE">Deep learning</div></div><div class="IndexEntry"><div class="PrimaryIE">Diffie-Hellman Key Establishment Protocol (DHKP)</div></div><div class="IndexEntry"><div class="PrimaryIE">Digital Millennium Copyright Act (DMCA)</div></div><div class="IndexEntry"><div class="PrimaryIE">Digital Rights Management (DRM)</div></div><div class="IndexEntry"><div class="PrimaryIE">Digital signatures</div></div><div class="IndexEntry"><div class="PrimaryIE">Dijkstra algorithm</div></div><div class="IndexEntry"><div class="PrimaryIE">Direct Memory Access (DMA)</div></div><div class="IndexEntry"><div class="PrimaryIE">Distributed systems</div><div class="SecondaryIE">client server</div><div class="SecondaryIE">FTP</div><div class="SecondaryIE">HTTP</div><div class="SecondaryIE">N-tiered</div><div class="SecondaryIE">peer-to-peer</div><div class="SecondaryIE">WWW</div></div><div class="IndexEntry"><div class="PrimaryIE">Divide and conquer technique</div></div><div class="IndexEntry"><div class="PrimaryIE">Docker</div></div><div class="IndexEntry"><div class="PrimaryIE">Domain Name Service (DNS)</div></div><div class="IndexEntry"><div class="PrimaryIE">Durability</div></div><div class="IndexEntry"><div class="PrimaryIE">Dynamic Host Configuration Protocol (DHCP)</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">E</div></div><div class="IndexEntry"><div class="PrimaryIE">Electronic Numerical Integrator and Computer (ENIAC)</div></div><div class="IndexEntry"><div class="PrimaryIE">Elliptic Curve Cryptography (ECC)</div></div><div class="IndexEntry"><div class="PrimaryIE">Enterprise service buses (ESBs)</div></div><div class="IndexEntry"><div class="PrimaryIE">Extended stack pointer (ESP)</div></div><div class="IndexEntry"><div class="PrimaryIE">Ethernet</div></div><div class="IndexEntry"><div class="PrimaryIE">Executable and Linkable Format (ELF)</div></div><div class="IndexEntry"><div class="PrimaryIE">Extensible Markup Language (XML)</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">F</div></div><div class="IndexEntry"><div class="PrimaryIE">Fast Identity Online (FIDO)</div></div><div class="IndexEntry"><div class="PrimaryIE">File systems</div><div class="SecondaryIE">access control</div><div class="SecondaryIE">access process</div><div class="SecondaryIE">access/protection</div><div class="SecondaryIE">applications</div><div class="SecondaryIE">concurrency/cleanup control</div><div class="SecondaryIE">directory namespace</div></div><div class="IndexEntry"><div class="PrimaryIE">File transfer (FTP) protocol</div></div><div class="IndexEntry"><div class="PrimaryIE">Finish (FIN) message</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">G</div></div><div class="IndexEntry"><div class="PrimaryIE">Gateway</div></div><div class="IndexEntry"><div class="PrimaryIE">General-purpose computing device</div></div><div class="IndexEntry"><div class="PrimaryIE">get_capacity method</div></div><div class="IndexEntry"><div class="PrimaryIE">Git</div></div><div class="IndexEntry"><div class="PrimaryIE">GitLab CI/CD</div></div><div class="IndexEntry"><div class="PrimaryIE">Google Compute Engine (GCE)</div></div><div class="IndexEntry"><div class="PrimaryIE">Gradle</div></div><div class="IndexEntry"><div class="PrimaryIE">Graphics Processing Units (GPUs)</div></div><div class="IndexEntry"><div class="PrimaryIE">Greedy algorithm</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">H</div></div><div class="IndexEntry"><div class="PrimaryIE">Hashing</div></div><div class="IndexEntry"><div class="PrimaryIE">Heterogeneous networks</div></div><div class="IndexEntry"><div class="PrimaryIE">Higher-order functions</div></div><div class="IndexEntry"><div class="PrimaryIE">Hosts</div></div><div class="IndexEntry"><div class="PrimaryIE">HyperText Markup Language (HTML)</div></div><div class="IndexEntry"><div class="PrimaryIE">Hypertext Transfer Protocol (HTTP)</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">I</div></div><div class="IndexEntry"><div class="PrimaryIE">Input and output (I/O) operations</div></div><div class="IndexEntry"><div class="PrimaryIE">Information technology (IT)</div></div><div class="IndexEntry"><div class="PrimaryIE">Infrastructure as a Service (IaaS)</div></div><div class="IndexEntry"><div class="PrimaryIE">Instruction set architecture (ISA)</div></div><div class="IndexEntry"><div class="PrimaryIE">Integrity</div></div><div class="IndexEntry"><div class="PrimaryIE">Internet Protocol (IP)</div></div><div class="IndexEntry"><div class="PrimaryIE">Interface Message Processors (IMPs)</div></div><div class="IndexEntry"><div class="PrimaryIE">Inter-Integrated Circuit (I2C)</div></div><div class="IndexEntry"><div class="PrimaryIE">International Conference on Computer and Communications (ICCC)</div></div><div class="IndexEntry"><div class="PrimaryIE">International Organization for Standardization (ISO)</div></div><div class="IndexEntry"><div class="PrimaryIE">Internet Corporation for Assigned Names and Numbers (ICANN)</div></div><div class="IndexEntry"><div class="PrimaryIE">Internet of Things (IoT)</div></div><div class="IndexEntry"><div class="PrimaryIE">Internet Protocol (IP)</div></div><div class="IndexEntry"><div class="PrimaryIE">Internet Protocol Security (IPSec)</div></div><div class="IndexEntry"><div class="PrimaryIE">Interpreter</div></div><div class="IndexEntry"><div class="PrimaryIE">Inter-process communication (IPC)</div><div class="SecondaryIE">message memory method</div><div class="SecondaryIE">shared memory method</div></div><div class="IndexEntry"><div class="PrimaryIE">I/O management</div><div class="SecondaryIE">devices</div><div class="SecondaryIE">subsystem</div><div class="TertiaryIE">ACPI</div><div class="TertiaryIE">block devices</div><div class="TertiaryIE">character devices</div><div class="TertiaryIE">DMA</div><div class="TertiaryIE">instruction</div><div class="TertiaryIE">MMIO</div><div class="TertiaryIE">performance</div><div class="TertiaryIE">polled <em class="EmphasisTypeItalic ">vs.</em> interrupt</div><div class="SecondaryIE">synchronization</div></div><div class="IndexEntry"><div class="PrimaryIE">Isolation</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">J</div></div><div class="IndexEntry"><div class="PrimaryIE">JavaScript Object Notation (JSON)</div></div><div class="IndexEntry"><div class="PrimaryIE">Java Virtual Machine (JVM)</div></div><div class="IndexEntry"><div class="PrimaryIE">Jenkins</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">K</div></div><div class="IndexEntry"><div class="PrimaryIE">Kanban</div></div><div class="IndexEntry"><div class="PrimaryIE">Kubernetes</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">L</div></div><div class="IndexEntry"><div class="PrimaryIE">Linker</div></div><div class="IndexEntry"><div class="PrimaryIE">Loader</div></div><div class="IndexEntry"><div class="PrimaryIE">Local area network (LAN)</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">M</div></div><div class="IndexEntry"><div class="PrimaryIE">Machine learning (ML)</div><div class="SecondaryIE">
<em class="EmphasisTypeItalic ">vs</em>. AI</div><div class="SecondaryIE">cloud computing</div><div class="SecondaryIE">
<em class="EmphasisTypeItalic ">vs</em>. conventional machine intelligence</div><div class="SecondaryIE">
<em class="EmphasisTypeItalic ">vs</em>. deep learning</div><div class="SecondaryIE">definition</div><div class="SecondaryIE">frameworks</div><div class="SecondaryIE">parts</div><div class="TertiaryIE">models</div><div class="TertiaryIE">prediction/inference</div><div class="TertiaryIE">training</div><div class="SecondaryIE">reinforcement learning</div><div class="SecondaryIE">representation</div><div class="SecondaryIE">semi-supervised learning</div><div class="SecondaryIE">supervised learning</div><div class="SecondaryIE">unsupervised learning</div><div class="SecondaryIE">uses</div></div><div class="IndexEntry"><div class="PrimaryIE">Machine Learning as a Service (MLaaS)</div></div><div class="IndexEntry"><div class="PrimaryIE">Malicious software</div></div><div class="IndexEntry"><div class="PrimaryIE">Malware</div><div class="SecondaryIE">authorization</div><div class="SecondaryIE">data at rest</div><div class="SecondaryIE">data at use</div><div class="SecondaryIE">kernel</div></div><div class="IndexEntry"><div class="PrimaryIE">Master boot record (MBR)</div></div><div class="IndexEntry"><div class="PrimaryIE">Mathematical technique</div></div><div class="IndexEntry"><div class="PrimaryIE">Media access control (MAC)</div></div><div class="IndexEntry"><div class="PrimaryIE">Memory management</div><div class="SecondaryIE">address binding</div><div class="SecondaryIE">IPC</div><div class="SecondaryIE">logical <em class="EmphasisTypeItalic ">vs.</em> physical address</div><div class="SecondaryIE">requirements</div></div><div class="IndexEntry"><div class="PrimaryIE">Memory-mapped I/O (MMIO)</div></div><div class="IndexEntry"><div class="PrimaryIE">Memory Reference Code (MRC)</div></div><div class="IndexEntry"><div class="PrimaryIE">Message passing method</div></div><div class="IndexEntry"><div class="PrimaryIE">Microservice architecture</div></div><div class="IndexEntry"><div class="PrimaryIE">Model-View-Controller (MVC)</div></div><div class="IndexEntry"><div class="PrimaryIE">Model-View-Presentation (MVP)</div></div><div class="IndexEntry"><div class="PrimaryIE">Model-View-View-Model (MVVM)</div></div><div class="IndexEntry"><div class="PrimaryIE">MongoDB</div></div><div class="IndexEntry"><div class="PrimaryIE">Mosaic</div></div><div class="IndexEntry"><div class="PrimaryIE">Multicast DNS (mDNS)</div></div><div class="IndexEntry"><div class="PrimaryIE">Multi-cloud model</div></div><div class="IndexEntry"><div class="PrimaryIE">Multiple instruction, single data (MISD)</div></div><div class="IndexEntry"><div class="PrimaryIE">Multiple services</div></div><div class="IndexEntry"><div class="PrimaryIE">Mutex</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">N</div></div><div class="IndexEntry"><div class="PrimaryIE">National Center of Supercomputing Applications (NCSA)</div></div><div class="IndexEntry"><div class="PrimaryIE">National Institute of Standards and Technology (NIST)</div></div><div class="IndexEntry"><div class="PrimaryIE">Neo4j</div></div><div class="IndexEntry"><div class="PrimaryIE">Network Address Translation (NAT)</div></div><div class="IndexEntry"><div class="PrimaryIE">Network protocols</div></div><div class="IndexEntry"><div class="PrimaryIE">Neural networks</div></div><div class="IndexEntry"><div class="PrimaryIE">Neurons</div></div><div class="IndexEntry"><div class="PrimaryIE">Ninja</div></div><div class="IndexEntry"><div class="PrimaryIE">Nonces</div></div><div class="IndexEntry"><div class="PrimaryIE">Nondeterministic polynomial</div></div><div class="IndexEntry"><div class="PrimaryIE">Non-volatile memory</div></div><div class="IndexEntry"><div class="PrimaryIE">Not Only SQL (NoSQL) databases</div><div class="SecondaryIE">Neo4j</div></div><div class="IndexEntry"><div class="PrimaryIE">NP-complete problem</div></div><div class="IndexEntry"><div class="PrimaryIE">NP-hard problems</div></div><div class="IndexEntry"><div class="PrimaryIE">NP problems</div></div><div class="IndexEntry"><div class="PrimaryIE">N-tiered architecture</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">O</div></div><div class="IndexEntry"><div class="PrimaryIE">Object-oriented programming</div></div><div class="IndexEntry"><div class="PrimaryIE">Open Container Initiative</div></div><div class="IndexEntry"><div class="PrimaryIE">Open Shortest Path First (OSPF)</div></div><div class="IndexEntry"><div class="PrimaryIE">Open Systems Interconnection (OSI)</div></div><div class="IndexEntry"><div class="PrimaryIE">Operating system–directed configuration and power management (OSPM)</div></div><div class="IndexEntry"><div class="PrimaryIE">Operating System (OS)</div><div class="SecondaryIE">approach</div><div class="SecondaryIE">built</div><div class="SecondaryIE">categories</div><div class="SecondaryIE">complex/multiprocessor systems</div><div class="SecondaryIE">definition</div><div class="SecondaryIE">multitasking/multifunction software</div><div class="SecondaryIE">multiuser system</div><div class="SecondaryIE">purpose</div><div class="SecondaryIE">requirements/solutions</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">P, Q</div></div><div class="IndexEntry"><div class="PrimaryIE">Parallel programming</div></div><div class="IndexEntry"><div class="PrimaryIE">Peer-to-peer architecture</div></div><div class="IndexEntry"><div class="PrimaryIE">Perforce Helix</div></div><div class="IndexEntry"><div class="PrimaryIE">Peripheral Component Interconnect Express (PCIe) protocol</div></div><div class="IndexEntry"><div class="PrimaryIE">Personally Identifiable Information (PII)</div></div><div class="IndexEntry"><div class="PrimaryIE">Plaintext</div></div><div class="IndexEntry"><div class="PrimaryIE">Platform as a Service (PaaS)</div></div><div class="IndexEntry"><div class="PrimaryIE">POP instruction</div></div><div class="IndexEntry"><div class="PrimaryIE">Power-on self-test (POST)</div></div><div class="IndexEntry"><div class="PrimaryIE">printf function</div></div><div class="IndexEntry"><div class="PrimaryIE">Process Control Block (PCB)</div></div><div class="IndexEntry"><div class="PrimaryIE">Programming</div><div class="SecondaryIE">definition</div><div class="SecondaryIE">language</div><div class="TertiaryIE">compile/link/load</div><div class="TertiaryIE">Hello, World</div><div class="TertiaryIE">high-level</div><div class="TertiaryIE">machine languages</div><div class="SecondaryIE">paradigms</div><div class="TertiaryIE">declarative programming</div><div class="TertiaryIE">GPUs</div><div class="TertiaryIE">imperative programming</div><div class="TertiaryIE">interpreter</div><div class="TertiaryIE">machine learning</div><div class="TertiaryIE">object-oriented programming</div></div><div class="IndexEntry"><div class="PrimaryIE">Protocols</div></div><div class="IndexEntry"><div class="PrimaryIE">Pseudorandom numbers</div></div><div class="IndexEntry"><div class="PrimaryIE">Pure function</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">R</div></div><div class="IndexEntry"><div class="PrimaryIE">Random numbers</div></div><div class="IndexEntry"><div class="PrimaryIE">Read-only memory (ROM)</div></div><div class="IndexEntry"><div class="PrimaryIE">Recursive algorithm</div></div><div class="IndexEntry"><div class="PrimaryIE">Registers</div></div><div class="IndexEntry"><div class="PrimaryIE">Reinforcement learning</div></div><div class="IndexEntry"><div class="PrimaryIE">Relational data</div></div><div class="IndexEntry"><div class="PrimaryIE">Resource Stateless Transfer (ReST)</div></div><div class="IndexEntry"><div class="PrimaryIE">Routers</div></div><div class="IndexEntry"><div class="PrimaryIE">Routing Information Protocol (RIP)</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">S</div></div><div class="IndexEntry"><div class="PrimaryIE">Salts</div></div><div class="IndexEntry"><div class="PrimaryIE">Scaled Agile Framework (SAFe)</div></div><div class="IndexEntry"><div class="PrimaryIE">Scheduling</div><div class="SecondaryIE">context switching</div><div class="SecondaryIE">criteria</div><div class="SecondaryIE">PCB</div><div class="SecondaryIE">process</div><div class="SecondaryIE">process states</div><div class="SecondaryIE">program/process basics</div><div class="SecondaryIE">thread</div></div><div class="IndexEntry"><div class="PrimaryIE">Schema</div></div><div class="IndexEntry"><div class="PrimaryIE">Script kiddies</div></div><div class="IndexEntry"><div class="PrimaryIE">Scrum</div></div><div class="IndexEntry"><div class="PrimaryIE">Secure boot</div></div><div class="IndexEntry"><div class="PrimaryIE">Secure programing</div></div><div class="IndexEntry"><div class="PrimaryIE">Secure Sockets Layer (SSL)</div></div><div class="IndexEntry"><div class="PrimaryIE">Semaphore</div></div><div class="IndexEntry"><div class="PrimaryIE">Semi-supervised learning</div></div><div class="IndexEntry"><div class="PrimaryIE">Service-orientated architecture (SOA)</div></div><div class="IndexEntry"><div class="PrimaryIE">Single instruction, multiple data (SIMD)</div></div><div class="IndexEntry"><div class="PrimaryIE">Software as a service (SaaS)</div></div><div class="IndexEntry"><div class="PrimaryIE">Software development lifecycle</div><div class="SecondaryIE">analysis</div><div class="SecondaryIE">architecture/design</div><div class="SecondaryIE">deployment</div><div class="SecondaryIE">implementation</div><div class="SecondaryIE">maintenance</div><div class="SecondaryIE">phases</div><div class="SecondaryIE">planning</div><div class="SecondaryIE">testing</div></div><div class="IndexEntry"><div class="PrimaryIE">Software engineering</div><div class="SecondaryIE">agile practices</div><div class="TertiaryIE">analysis/design</div><div class="TertiaryIE">definition</div><div class="TertiaryIE">Kanban</div><div class="TertiaryIE">scaling</div><div class="TertiaryIE">scrum</div><div class="SecondaryIE">build optimization</div><div class="TertiaryIE">CMake/Ninja</div><div class="TertiaryIE">gradle</div><div class="TertiaryIE">Make</div><div class="TertiaryIE">purpose/mechanism</div><div class="SecondaryIE">debugging</div><div class="SecondaryIE">documentation</div><div class="TertiaryIE">comments/code</div><div class="TertiaryIE">requirements/design/architecture</div><div class="TertiaryIE">user</div><div class="SecondaryIE">testing</div></div><div class="IndexEntry"><div class="PrimaryIE">Solid-state drive (SSD)</div></div><div class="IndexEntry"><div class="PrimaryIE">Source control management (SCM)</div><div class="SecondaryIE">definition</div><div class="SecondaryIE">purpose/mechanism</div><div class="SecondaryIE">tools</div></div><div class="IndexEntry"><div class="PrimaryIE">SQL Statement Actions</div></div><div class="IndexEntry"><div class="PrimaryIE">Stateful protocols</div></div><div class="IndexEntry"><div class="PrimaryIE">Stateless protocols</div></div><div class="IndexEntry"><div class="PrimaryIE">Static libraries</div></div><div class="IndexEntry"><div class="PrimaryIE">Subnets</div></div><div class="IndexEntry"><div class="PrimaryIE">Supervised learning</div></div><div class="IndexEntry"><div class="PrimaryIE">Suspend to RAM (STR)</div></div><div class="IndexEntry"><div class="PrimaryIE">Symmetric encryption algorithms</div></div><div class="IndexEntry"><div class="PrimaryIE">Synchronization (SYN)</div></div><div class="IndexEntry"><div class="PrimaryIE">System architecture</div></div><div class="IndexEntry"><div class="PrimaryIE">System boot flow</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">T</div></div><div class="IndexEntry"><div class="PrimaryIE">Telnet</div></div><div class="IndexEntry"><div class="PrimaryIE">TensorFlow</div></div><div class="IndexEntry"><div class="PrimaryIE">Test-driven development (TDD)</div></div><div class="IndexEntry"><div class="PrimaryIE">Threads</div></div><div class="IndexEntry"><div class="PrimaryIE">Top-level domain (TLD)</div></div><div class="IndexEntry"><div class="PrimaryIE">Transmission Control Protocol (TCP)</div></div><div class="IndexEntry"><div class="PrimaryIE">Transport Layer Security (TLS)</div></div><div class="IndexEntry"><div class="PrimaryIE">True random numbers (TRNs)</div></div><div class="IndexEntry"><div class="PrimaryIE">Trusted execution environments (TEEs)</div><div class="SecondaryIE">secure boot</div><div class="SecondaryIE">secure I/O</div></div><div class="IndexEntry"><div class="PrimaryIE">Turing Test</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">U</div></div><div class="IndexEntry"><div class="PrimaryIE">Unified Extensible Firmware Interface (UEFI)</div></div><div class="IndexEntry"><div class="PrimaryIE">Unit testing</div></div><div class="IndexEntry"><div class="PrimaryIE">Universal Resource Locator (URL)</div></div><div class="IndexEntry"><div class="PrimaryIE">Unstructured data</div></div><div class="IndexEntry"><div class="PrimaryIE">Unsupervised learning</div></div><div class="IndexEntry"><div class="PrimaryIE">User Datagram Protocol (UDP)</div></div><div class="IndexEntry"><div class="PrimaryIE">User interface (UI)</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">V</div></div><div class="IndexEntry"><div class="PrimaryIE">Virtual Machine Monitors (VMM)</div></div><div class="IndexEntry"><div class="PrimaryIE">Virtual machines (VMs)</div></div><div class="IndexEntry"><div class="PrimaryIE">Virtual Private Networks (VPNs)</div></div><div class="IndexEntry"><div class="PrimaryIE">Volatile memory</div></div><div class="IndexEntry"><div class="PrimaryIE">von Neumann architecture</div></div><div class="IndexEntry"><div class="PrimaryIE">Vulnerability patches</div></div></div><div class="IndexDiv"><div class="Headings"><div class="Heading">W, X, Y, Z</div></div><div class="IndexEntry"><div class="PrimaryIE">Web application</div><div class="SecondaryIE">back end</div><div class="SecondaryIE">CSS</div><div class="SecondaryIE">front end</div><div class="SecondaryIE">HTML</div><div class="SecondaryIE">three-tiered architecture</div></div><div class="IndexEntry"><div class="PrimaryIE">Windows Driver Framework (WDF)</div></div><div class="IndexEntry"><div class="PrimaryIE">World Wide Web Consortium (W3C)</div></div><div class="IndexEntry"><div class="PrimaryIE">World Wide Web (WWW)</div></div><div class="IndexEntry"><div class="PrimaryIE">WriteConsoleA function</div></div></div></div></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781484271070/files/css/springer_epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com