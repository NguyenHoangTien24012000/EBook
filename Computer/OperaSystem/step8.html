<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h1 class="chapnum"><a id="chap6"></a>CHAPTER <i>6</i></h1>
        <h1 class="chaptitle">CPU Scheduling</h1>
        <p class="text"><a id="page_261"></a>CPU scheduling is the basis of multiprogrammed operating systems. By switching the CPU among processes, the operating system can make the computer more productive. In this chapter, we introduce basic CPU-scheduling concepts and present several CPU-scheduling algorithms. We also consider the problem of selecting an algorithm for a particular system.</p>
        <p class="text-indent">In <a href="11_chapter04.html#chap4">Chapter 4</a>, we introduced threads to the process model. On operating systems that support them, it is kernel-level threads—not processes—that are in fact being scheduled by the operating system. However, the terms “process scheduling” and “thread scheduling” are often used interchangeably. In this chapter, we use <b><i>process scheduling</i></b> when discussing general scheduling concepts and <b><i>thread scheduling</i></b> to refer to thread-specific ideas.</p>
        <div class="bgbox">
        <p class="boxtitle1">CHAPTER OBJECTIVES</p>
        <ul style="list-style-type:disc;">
        <li>To introduce CPU scheduling, which is the basis for multiprogrammed operating systems.</li>
        <li>To describe various CPU-scheduling algorithms.</li>
        <li>To discuss evaluation criteria for selecting a CPU-scheduling algorithm for a particular system.</li>
        <li>To examine the scheduling algorithms of several operating systems.</li>
        </ul>
        </div>
        <h2 class="subtitle"><a id="sec6.1"></a>6.1 Basic Concepts</h2>
        <p class="text">In a single-processor system, only one process can run at a time. Others must wait until the CPU is free and can be rescheduled. The objective of multiprogramming is to have some process running at all times, to maximize CPU utilization. The idea is relatively simple. A process is executed until it must wait, typically for the completion of some I/O request. In a simple computer system, the CPU then just sits idle. All this waiting time is wasted; no useful work is accomplished. With multiprogramming, we try to use this time productively. Several processes are kept in memory at one time. When <a id="page_262"></a>one process has to wait, the operating system takes the CPU away from that process and gives the CPU to another process. This pattern continues. Every time one process has to wait, another process can take over use of the CPU.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f001.jpg" alt="image" class="imgepub" width="291" height="529"></p>
        <p class="caption"><a id="fig6.1"></a><b>Figure 6.1</b> Alternating sequence of CPU and I/O bursts.</p>
        <p class="text-indent">Scheduling of this kind is a fundamental operating-system function. Almost all computer resources are scheduled before use. The CPU is, of course, one of the primary computer resources. Thus, its scheduling is central to operating-system design.</p>
        <h3 class="subtitle"><a id="sec6.1.1"></a>6.1.1 CPU–I/O Burst Cycle</h3>
        <p class="text">The success of CPU scheduling depends on an observed property of processes: process execution consists of a <b>cycle</b> of CPU execution and I/O wait. Processes alternate between these two states. Process execution begins with a <b>CPU burst</b>. That is followed by an <b>I/O burst</b>, which is followed by another CPU burst, then another I/O burst, and so on. Eventually, the final CPU burst ends with a system request to terminate execution (<a href="13_chapter06.html#fig6.1">Figure 6.1</a>).</p>
        <p class="text-indent">The durations of CPU bursts have been measured extensively. Although they vary greatly from process to process and from computer to computer, they tend to have a frequency curve similar to that shown in <a href="13_chapter06.html#fig6.2">Figure 6.2</a>. The curve is generally characterized as exponential or hyperexponential, with a large number of short CPU bursts and a small number of long CPU bursts. <a id="page_263"></a>An I/O-bound program typically has many short CPU bursts. A CPU-bound program might have a few long CPU bursts. This distribution can be important in the selection of an appropriate CPU-scheduling algorithm.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f002.jpg" alt="image" class="imgepub" width="616" height="410"></p>
        <p class="caption"><a id="fig6.2"></a><b>Figure 6.2</b> Histogram of CPU-burst durations.</p>
        <h3 class="subtitle"><a id="sec6.1.2"></a>6.1.2 CPU Scheduler</h3>
        <p class="text">Whenever the CPU becomes idle, the operating system must select one of the processes in the ready queue to be executed. The selection process is carried out by the <b>short-term scheduler</b>, or CPU scheduler. The scheduler selects a process from the processes in memory that are ready to execute and allocates the CPU to that process.</p>
        <p class="text-indent">Note that the ready queue is not necessarily a first-in, first-out (FIFO) queue. As we shall see when we consider the various scheduling algorithms, a ready queue can be implemented as a FIFO queue, a priority queue, a tree, or simply an unordered linked list. Conceptually, however, all the processes in the ready queue are lined up waiting for a chance to run on the CPU. The records in the queues are generally process control blocks (PCBs) of the processes.</p>
        <h3 class="subtitle"><a id="sec6.1.3"></a>6.1.3 Preemptive Scheduling</h3>
        <p class="text">CPU-scheduling decisions may take place under the following four circumstances:</p>
        <ol style="list-style-type:decimal;">
        <li>When a process switches from the running state to the waiting state (for example, as the result of an I/O request or an invocation of <span class="inlinecode">wait()</span> for the termination of a child process)</li>
        <li><a id="page_264"></a>When a process switches from the running state to the ready state (for example, when an interrupt occurs)</li>
        <li>When a process switches from the waiting state to the ready state (for example, at completion of I/O)</li>
        <li>When a process terminates</li>
        </ol>
        <p class="text">For situations 1 and 4, there is no choice in terms of scheduling. A new process (if one exists in the ready queue) must be selected for execution. There is a choice, however, for situations 2 and 3.</p>
        <p class="text-indent">When scheduling takes place only under circumstances 1 and 4, we say that the scheduling scheme is <b>nonpreemptive</b> or <b>cooperative</b>. Otherwise, it is <b>preemptive</b>. Under nonpreemptive scheduling, once the CPU has been allocated to a process, the process keeps the CPU until it releases the CPU either by terminating or by switching to the waiting state. This scheduling method was used by Microsoft Windows 3.x. Windows 95 introduced preemptive scheduling, and all subsequent versions of Windows operating systems have used preemptive scheduling. The Mac OS X operating system for the Macintosh also uses preemptive scheduling; previous versions of the Macintosh operating system relied on cooperative scheduling. Cooperative scheduling is the only method that can be used on certain hardware platforms, because it does not require the special hardware (for example, a timer) needed for preemptive scheduling.</p>
        <p class="text-indent">Unfortunately, preemptive scheduling can result in race conditions when data are shared among several processes. Consider the case of two processes that share data. While one process is updating the data, it is preempted so that the second process can run. The second process then tries to read the data, which are in an inconsistent state. This issue was explored in detail in <a href="12_chapter05.html#chap5">Chapter 5</a>.</p>
        <p class="text-indent">Preemption also affects the design of the operating-system kernel. During the processing of a system call, the kernel may be busy with an activity on behalf of a process. Such activities may involve changing important kernel data (for instance, I/O queues). What happens if the process is preempted in the middle of these changes and the kernel (or the device driver) needs to read or modify the same structure? Chaos ensues. Certain operating systems, including most versions of UNIX, deal with this problem by waiting either for a system call to complete or for an I/O block to take place before doing a context switch. This scheme ensures that the kernel structure is simple, since the kernel will not preempt a process while the kernel data structures are in an inconsistent state. Unfortunately, this kernel-execution model is a poor one for supporting real-time computing where tasks must complete execution within a given time frame. In <a href="13_chapter06.html#sec6.6">Section 6.6</a>, we explore scheduling demands of real-time systems.</p>
        <p class="text-indent">Because interrupts can, by definition, occur at any time, and because they cannot always be ignored by the kernel, the sections of code affected by interrupts must be guarded from simultaneous use. The operating system needs to accept interrupts at almost all times. Otherwise, input might be lost or output overwritten. So that these sections of code are not accessed concurrently by several processes, they disable interrupts at entry and reenable interrupts at exit. It is important to note that sections of code that disable interrupts do not occur very often and typically contain few instructions.</p>
        <h3 class="subtitle"><a id="sec6.1.4"></a>6.1.4 Dispatcher</h3>
        <p class="text"><a id="page_265"></a>Another component involved in the CPU-scheduling function is the <b>dispatcher</b>. The dispatcher is the module that gives control of the CPU to the process selected by the short-term scheduler. This function involves the following:</p>
        <ul style="list-style-type:disc;">
        <li>Switching context</li>
        <li>Switching to user mode</li>
        <li>Jumping to the proper location in the user program to restart that program</li>
        </ul>
        <p class="text">The dispatcher should be as fast as possible, since it is invoked during every process switch. The time it takes for the dispatcher to stop one process and start another running is known as the <b>dispatch latency</b>.</p>
        <h2 class="subtitle"><a id="sec6.2"></a>6.2 Scheduling Criteria</h2>
        <p class="text">Different CPU-scheduling algorithms have different properties, and the choice of a particular algorithm may favor one class of processes over another. In choosing which algorithm to use in a particular situation, we must consider the properties of the various algorithms.</p>
        <p class="text-indent">Many criteria have been suggested for comparing CPU-scheduling algorithms. Which characteristics are used for comparison can make a substantial difference in which algorithm is judged to be best. The criteria include the following:</p>
        <ul style="list-style-type:disc;">
        <li><b>CPU utilization</b>. We want to keep the CPU as busy as possible. Conceptually, CPU utilization can range from 0 to 100 percent. In a real system, it should range from 40 percent (for a lightly loaded system) to 90 percent (for a heavily loaded system).</li>
        <li><b>Throughput</b>. If the CPU is busy executing processes, then work is being done. One measure of work is the number of processes that are completed per time unit, called <b>throughput</b>. For long processes, this rate may be one process per hour; for short transactions, it may be ten processes per second.</li>
        <li><b>Turnaround time</b>. From the point of view of a particular process, the important criterion is how long it takes to execute that process. The interval from the time of submission of a process to the time of completion is the turnaround time. Turnaround time is the sum of the periods spent waiting to get into memory, waiting in the ready queue, executing on the CPU, and doing I/O.</li>
        <li><b>Waiting time</b>. The CPU-scheduling algorithm does not affect the amount of time during which a process executes or does I/O. It affects only the amount of time that a process spends waiting in the ready queue. Waiting time is the sum of the periods spent waiting in the ready queue.</li>
        <li><b>Response time</b>. In an interactive system, turnaround time may not be the best criterion. Often, a process can produce some output fairly early and can continue computing new results while previous results are being <a id="page_266"></a>output to the user. Thus, another measure is the time from the submission of a request until the first response is produced. This measure, called response time, is the time it takes to start responding, not the time it takes to output the response. The turnaround time is generally limited by the speed of the output device.</li>
        </ul>
        <p class="text-indent">It is desirable to maximize CPU utilization and throughput and to minimize turnaround time, waiting time, and response time. In most cases, we optimize the average measure. However, under some circumstances, we prefer to optimize the minimum or maximum values rather than the average. For example, to guarantee that all users get good service, we may want to minimize the maximum response time.</p>
        <p class="text-indent">Investigators have suggested that, for interactive systems (such as desktop systems), it is more important to minimize the variance in the response time than to minimize the average response time. A system with reasonable and predictable response time may be considered more desirable than a system that is faster on the average but is highly variable. However, little work has been done on CPU-scheduling algorithms that minimize variance.</p>
        <p class="text-indent">As we discuss various CPU-scheduling algorithms in the following section, we illustrate their operation. An accurate illustration should involve many processes, each a sequence of several hundred CPU bursts and I/O bursts. For simplicity, though, we consider only one CPU burst (in milliseconds) per process in our examples. Our measure of comparison is the average waiting time. More elaborate evaluation mechanisms are discussed in <a href="13_chapter06.html#sec6.8">Section 6.8</a>.</p>
        <h2 class="subtitle"><a id="sec6.3"></a>6.3 Scheduling Algorithms</h2>
        <p class="text">CPU scheduling deals with the problem of deciding which of the processes in the ready queue is to be allocated the CPU. There are many different CPU-scheduling algorithms. In this section, we describe several of them.</p>
        <h3 class="subtitle"><a id="sec6.3.1"></a>6.3.1 First-Come, First-Served Scheduling</h3>
        <p class="text">By far the simplest CPU-scheduling algorithm is the <b>first-come, first-served (FCFS)</b> scheduling algorithm. With this scheme, the process that requests the CPU first is allocated the CPU first. The implementation of the FCFS policy is easily managed with a FIFO queue. When a process enters the ready queue, its PCB is linked onto the tail of the queue. When the CPU is free, it is allocated to the process at the head of the queue. The running process is then removed from the queue. The code for FCFS scheduling is simple to write and understand.</p>
        <p class="text-indent">On the negative side, the average waiting time under the FCFS policy is often quite long. Consider the following set of processes that arrive at time 0, with the length of the CPU burst given in milliseconds:</p>
        <table class="bodytable">
        <colgroup>
        <col width="50%">
        <col width="50%">
        </colgroup>
        <thead>
        <tr>
        <td class="tabularhead"><span class="underline">Process</span></td>
        <td class="tabularhead"><span class="underline">Burst Time</span></td>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>1</sub></td>
        <td class="tabularentry" align="center">24</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>2</sub></td>
        <td class="tabularentry" align="center">3</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>3</sub></td>
        <td class="tabularentry" align="center">3</td>
        </tr>
        </tbody>
        </table>
        <p class="text-indent"><a id="page_267"></a>If the processes arrive in the order <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, <i>P</i><sub>3</sub>, and are served in FCFS order, we get the result shown in the following <b>Gantt chart</b>, which is a bar chart that illustrates a particular schedule, including the start and finish times of each of the participating processes:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p267-001.jpg" alt="image" class="imgepub" width="622" height="69"></p>
        <p class="text">The waiting time is 0 milliseconds for process <i>P</i><sub>1</sub>, 24 milliseconds for process <i>P</i><sub>2</sub>, and 27 milliseconds for process <i>P</i><sub>3</sub>. Thus, the average waiting time is (0 + 24 + 27)/3 = 17 milliseconds. If the processes arrive in the order <i>P</i><sub>2</sub>, <i>P</i><sub>3</sub>, <i>P</i><sub>1</sub>, however, the results will be as shown in the following Gantt chart:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p267-002.jpg" alt="image" class="imgepub" width="622" height="69"></p>
        <p class="text">The average waiting time is now (6 + 0 + 3)/3 = 3 milliseconds. This reduction is substantial. Thus, the average waiting time under an FCFS policy is generally not minimal and may vary substantially if the processes' CPU burst times vary greatly.</p>
        <p class="text-indent">In addition, consider the performance of FCFS scheduling in a dynamic situation. Assume we have one CPU-bound process and many I/O-bound processes. As the processes flow around the system, the following scenario may result. The CPU-bound process will get and hold the CPU. During this time, all the other processes will finish their I/O and will move into the ready queue, waiting for the CPU. While the processes wait in the ready queue, the I/O devices are idle. Eventually, the CPU-bound process finishes its CPU burst and moves to an I/O device. All the I/O-bound processes, which have short CPU bursts, execute quickly and move back to the I/O queues. At this point, the CPU sits idle. The CPU-bound process will then move back to the ready queue and be allocated the CPU. Again, all the I/O processes end up waiting in the ready queue until the CPU-bound process is done. There is a <b>convoy effect</b> as all the other processes wait for the one big process to get off the CPU. This effect results in lower CPU and device utilization than might be possible if the shorter processes were allowed to go first.</p>
        <p class="text-indent">Note also that the FCFS scheduling algorithm is nonpreemptive. Once the CPU has been allocated to a process, that process keeps the CPU until it releases the CPU, either by terminating or by requesting I/O. The FCFS algorithm is thus particularly troublesome for time-sharing systems, where it is important that each user get a share of the CPU at regular intervals. It would be disastrous to allow one process to keep the CPU for an extended period.</p>
        <h3 class="subtitle"><a id="sec6.3.2"></a>6.3.2 Shortest-Job-First Scheduling</h3>
        <p class="text">A different approach to CPU scheduling is the <b>shortest-job-first (SJF)</b> scheduling algorithm. This algorithm associates with each process the length of the process's next CPU burst. When the CPU is available, it is assigned to the <a id="page_268"></a>process that has the smallest next CPU burst. If the next CPU bursts of two processes are the same, FCFS scheduling is used to break the tie. Note that a more appropriate term for this scheduling method would be the <b><i>shortest-next-CPU-burst</i></b> algorithm, because scheduling depends on the length of the next CPU burst of a process, rather than its total length. We use the term SJF because most people and textbooks use this term to refer to this type of scheduling.</p>
        <p class="text-indent">As an example of SJF scheduling, consider the following set of processes, with the length of the CPU burst given in milliseconds:</p>
        <table class="bodytable">
        <colgroup>
        <col width="50%">
        <col width="50%">
        </colgroup>
        <thead>
        <tr>
        <td class="tabularhead"><span class="underline">Process</span></td>
        <td class="tabularhead"><span class="underline">Burst Time</span></td>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>1</sub></td>
        <td class="tabularentry" align="center">6</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>2</sub></td>
        <td class="tabularentry" align="center">8</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>3</sub></td>
        <td class="tabularentry" align="center">7</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>4</sub></td>
        <td class="tabularentry" align="center">3</td>
        </tr>
        </tbody>
        </table>
        <p class="text">Using SJF scheduling, we would schedule these processes according to the following Gantt chart:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p268-001.jpg" alt="image" class="imgepub" width="622" height="69"></p>
        <p class="text">The waiting time is 3 milliseconds for process <i>P</i><sub>1</sub>, 16 milliseconds for process <i>P</i><sub>2</sub>, 9 milliseconds for process <i>P</i><sub>3</sub>, and 0 milliseconds for process <i>P</i><sub>4</sub>. Thus, the average waiting time is (3 + 16 + 9 + 0)/4 = 7 milliseconds. By comparison, if we were using the FCFS scheduling scheme, the average waiting time would be 10.25 milliseconds.</p>
        <p class="text-indent">The SJF scheduling algorithm is provably optimal, in that it gives the minimum average waiting time for a given set of processes. Moving a short process before a long one decreases the waiting time of the short process more than it increases the waiting time of the long process. Consequently, the average waiting time decreases.</p>
        <p class="text-indent">The real difficulty with the SJF algorithm is knowing the length of the next CPU request. For long-term (job) scheduling in a batch system, we can use the process time limit that a user specifies when he submits the job. In this situation, users are motivated to estimate the process time limit accurately, since a lower value may mean faster response but too low a value will cause a time-limit-exceeded error and require resubmission. SJF scheduling is used frequently in long-term scheduling.</p>
        <p class="text-indent">Although the SJF algorithm is optimal, it cannot be implemented at the level of short-term CPU scheduling. With short-term scheduling, there is no way to know the length of the next CPU burst. One approach to this problem is to try to approximate SJF scheduling. We may not know the length of the next CPU burst, but we may be able to predict its value. We expect that the next CPU burst will be similar in length to the previous ones. By computing an approximation of the length of the next CPU burst, we can pick the process with the shortest predicted CPU burst.</p>
        <p class="text-indent">The next CPU burst is generally predicted as an <b>exponential average</b> of the measured lengths of previous CPU bursts. We can define the exponential <a id="page_269"></a>average with the following formula. Let <i>t<sub>n</sub></i> be the length of the <i>n</i>th CPU burst, and let τ<sub><i>n</i>+1</sub> be our predicted value for the next CPU burst. Then, for α, 0 ≤ α ≤ 1, define</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f003.jpg" alt="image" class="imgepub" width="549" height="393"></p>
        <p class="caption"><a id="fig6.3"></a><b>Figure 6.3</b> Prediction of the length of the next CPU burst.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p269-001.jpg" alt="image" class="imgepub" width="184" height="19"></p>
        <p class="text">The value of <i>t<sub>n</sub></i> contains our most recent information, while τ<sub><i>n</i></sub> stores the past history. The parameter α controls the relative weight of recent and past history in our prediction. If α = 0, then τ<sub><i>n</i>+1</sub> = <i>τ<sub>n</sub></i>, and recent history has no effect (current conditions are assumed to be transient). If α = 1, then τ<sub><i>n</i>+1</sub> = <i>t<sub>n</sub></i>, and only the most recent CPU burst matters (history is assumed to be old and irrelevant). More commonly, α = 1/2, so recent history and past history are equally weighted. The initial τ<sub>0</sub> can be defined as a constant or as an overall system average. <a href="13_chapter06.html#fig6.3">Figure 6.3</a> shows an exponential average with α = 1/2 and τ<sub>0</sub> = 10.</p>
        <p class="text-indent">To understand the behavior of the exponential average, we can expand the formula for τ<sub><i>n</i>+1</sub> by substituting for τ<sub><i>n</i></sub> to find</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p269-002.jpg" alt="image" class="imgepub" width="566" height="26"></p>
        <p class="text">Typically, α is less than 1. As a result, (1 − α) is also less than 1, and each successive term has less weight than its predecessor.</p>
        <p class="text-indent">The SJF algorithm can be either preemptive or nonpreemptive. The choice arises when a new process arrives at the ready queue while a previous process is still executing. The next CPU burst of the newly arrived process may be shorter than what is left of the currently executing process. A preemptive SJF algorithm will preempt the currently executing process, whereas a nonpreemptive SJF algorithm will allow the currently running process to finish its CPU burst. Preemptive SJF scheduling is sometimes called <b>shortest-remaining-time-first</b> scheduling.</p>
        <p class="text-indent"><a id="page_270"></a>As an example, consider the following four processes, with the length of the CPU burst given in milliseconds:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p270-001.jpg" alt="image" class="imgepub" width="318" height="119"></p>
        <p class="text">If the processes arrive at the ready queue at the times shown and need the indicated burst times, then the resulting preemptive SJF schedule is as depicted in the following Gantt chart:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p270-002.jpg" alt="image" class="imgepub" width="623" height="69"></p>
        <p class="text">Process <i>P</i><sub>1</sub> is started at time 0, since it is the only process in the queue. Process <i>P</i><sub>2</sub> arrives at time 1. The remaining time for process <i>P</i><sub>1</sub> (7 milliseconds) is larger than the time required by process <i>P</i><sub>2</sub> (4 milliseconds), so process <i>P</i><sub>1</sub> is preempted, and process <i>P</i><sub>2</sub> is scheduled. The average waiting time for this example is [(10 − 1) + (1 − 1) + (17 − 2) + (5 − 3)]/4 = 26/4 = 6.5 milliseconds. Nonpreemptive SJF scheduling would result in an average waiting time of 7.75 milliseconds.</p>
        <h3 class="subtitle"><a id="sec6.3.3"></a>6.3.3 Priority Scheduling</h3>
        <p class="text">The SJF algorithm is a special case of the general <b>priority-scheduling</b> algorithm. A priority is associated with each process, and the CPU is allocated to the process with the highest priority. Equal-priority processes are scheduled in FCFS order. An SJF algorithm is simply a priority algorithm where the priority (<i>p</i>) is the inverse of the (predicted) next CPU burst. The larger the CPU burst, the lower the priority, and vice versa.</p>
        <p class="text-indent">Note that we discuss scheduling in terms of <b><i>high</i></b> priority and <b><i>low</i></b> priority. Priorities are generally indicated by some fixed range of numbers, such as 0 to 7 or 0 to 4,095. However, there is no general agreement on whether 0 is the highest or lowest priority. Some systems use low numbers to represent low priority; others use low numbers for high priority. This difference can lead to confusion. In this text, we assume that low numbers represent high priority.</p>
        <p class="text-indent">As an example, consider the following set of processes, assumed to have arrived at time 0 in the order <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, …, <i>P</i><sub>5</sub>, with the length of the CPU burst given in milliseconds:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p270-003.jpg" alt="image" class="imgepub" width="275" height="144"></p>
        <p class="text"><a id="page_271"></a>Using priority scheduling, we would schedule these processes according to the following Gantt chart:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p271-001.jpg" alt="image" class="imgepub" width="623" height="69"></p>
        <p class="text">The average waiting time is 8.2 milliseconds.</p>
        <p class="text-indent">Priorities can be defined either internally or externally. Internally defined priorities use some measurable quantity or quantities to compute the priority of a process. For example, time limits, memory requirements, the number of open files, and the ratio of average I/O burst to average CPU burst have been used in computing priorities. External priorities are set by criteria outside the operating system, such as the importance of the process, the type and amount of funds being paid for computer use, the department sponsoring the work, and other, often political, factors.</p>
        <p class="text-indent">Priority scheduling can be either preemptive or nonpreemptive. When a process arrives at the ready queue, its priority is compared with the priority of the currently running process. A preemptive priority scheduling algorithm will preempt the CPU if the priority of the newly arrived process is higher than the priority of the currently running process. A nonpreemptive priority scheduling algorithm will simply put the new process at the head of the ready queue.</p>
        <p class="text-indent">A major problem with priority scheduling algorithms is <b>indefinite blocking</b>, or <b>starvation</b>. A process that is ready to run but waiting for the CPU can be considered blocked. A priority scheduling algorithm can leave some low-priority processes waiting indefinitely. In a heavily loaded computer system, a steady stream of higher-priority processes can prevent a low-priority process from ever getting the CPU. Generally, one of two things will happen. Either the process will eventually be run (at 2 <small>A.M</small>. Sunday, when the system is finally lightly loaded), or the computer system will eventually crash and lose all unfinished low-priority processes. (Rumor has it that when they shut down the IBM 7094 at MIT in 1973, they found a low-priority process that had been submitted in 1967 and had not yet been run.)</p>
        <p class="text-indent">A solution to the problem of indefinite blockage of low-priority processes is <b>aging</b>. Aging involves gradually increasing the priority of processes that wait in the system for a long time. For example, if priorities range from 127 (low) to 0 (high), we could increase the priority of a waiting process by 1 every 15 minutes. Eventually, even a process with an initial priority of 127 would have the highest priority in the system and would be executed. In fact, it would take no more than 32 hours for a priority-127 process to age to a priority-0 process.</p>
        <h3 class="subtitle"><a id="sec6.3.4"></a>6.3.4 Round-Robin Scheduling</h3>
        <p class="text">The <b>round-robin (RR)</b> scheduling algorithm is designed especially for time-sharing systems. It is similar to FCFS scheduling, but preemption is added to enable the system to switch between processes. A small unit of time, called a <b>time quantum</b> or <b>time slice</b>, is defined. A time quantum is generally from 10 to 100 milliseconds in length. The ready queue is treated as a circular queue. <a id="page_272"></a>The CPU scheduler goes around the ready queue, allocating the CPU to each process for a time interval of up to 1 time quantum.</p>
        <p class="text-indent">To implement RR scheduling, we again treat the ready queue as a FIFO queue of processes. New processes are added to the tail of the ready queue. The CPU scheduler picks the first process from the ready queue, sets a timer to interrupt after 1 time quantum, and dispatches the process.</p>
        <p class="text-indent">One of two things will then happen. The process may have a CPU burst of less than 1 time quantum. In this case, the process itself will release the CPU voluntarily. The scheduler will then proceed to the next process in the ready queue. If the CPU burst of the currently running process is longer than 1 time quantum, the timer will go off and will cause an interrupt to the operating system. A context switch will be executed, and the process will be put at the tail of the ready queue. The CPU scheduler will then select the next process in the ready queue.</p>
        <p class="text-indent">The average waiting time under the RR policy is often long. Consider the following set of processes that arrive at time 0, with the length of the CPU burst given in milliseconds:</p>
        <table class="bodytable">
        <colgroup>
        <col width="50%">
        <col width="50%">
        </colgroup>
        <thead>
        <tr>
        <td class="tabularhead"><span class="underline">Process</span></td>
        <td class="tabularhead"><span class="underline">Burst Time</span></td>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>1</sub></td>
        <td class="tabularentry" align="center">24</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>2</sub></td>
        <td class="tabularentry" align="center">3</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>3</sub></td>
        <td class="tabularentry" align="center">3</td>
        </tr>
        </tbody>
        </table>
        <p class="text">If we use a time quantum of 4 milliseconds, then process <i>P</i><sub>1</sub> gets the first 4 milliseconds. Since it requires another 20 milliseconds, it is preempted after the first time quantum, and the CPU is given to the next process in the queue, process <i>P</i><sub>2</sub>. Process <i>P</i><sub>2</sub> does not need 4 milliseconds, so it quits before its time quantum expires. The CPU is then given to the next process, process <i>P</i><sub>3</sub>. Once each process has received 1 time quantum, the CPU is returned to process <i>P</i><sub>1</sub> for an additional time quantum. The resulting RR schedule is as follows:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p272-001.jpg" alt="image" class="imgepub" width="630" height="69"></p>
        <p class="text">Let's calculate the average waiting time for this schedule. <i>P</i><sub>1</sub> waits for 6 milliseconds (10 - 4), <i>P</i><sub>2</sub> waits for 4 milliseconds, and <i>P</i><sub>3</sub> waits for 7 milliseconds. Thus, the average waiting time is 17/3 = 5.66 milliseconds.</p>
        <p class="text-indent">In the RR scheduling algorithm, no process is allocated the CPU for more than 1 time quantum in a row (unless it is the only runnable process). If a process's CPU burst exceeds 1 time quantum, that process is preempted and is put back in the ready queue. The RR scheduling algorithm is thus preemptive.</p>
        <p class="text-indent">If there are <i>n</i> processes in the ready queue and the time quantum is <i>q</i>, then each process gets 1/<i>n</i> of the CPU time in chunks of at most <i>q</i> time units. Each process must wait no longer than (<i>n</i> − 1) × <i>q</i> time units until its next time quantum. For example, with five processes and a time quantum of 20 milliseconds, each process will get up to 20 milliseconds every 100 milliseconds.</p>
        <p class="text-indent">The performance of the RR algorithm depends heavily on the size of the time quantum. At one extreme, if the time quantum is extremely large, the RR policy <a id="page_273"></a>is the same as the FCFS policy. In contrast, if the time quantum is extremely small (say, 1 millisecond), the RR approach can result in a large number of context switches. Assume, for example, that we have only one process of 10 time units. If the quantum is 12 time units, the process finishes in less than 1 time quantum, with no overhead. If the quantum is 6 time units, however, the process requires 2 quanta, resulting in a context switch. If the time quantum is 1 time unit, then nine context switches will occur, slowing the execution of the process accordingly (<a href="13_chapter06.html#fig6.4">Figure 6.4</a>).</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f004.jpg" alt="image" class="imgepub" width="577" height="236"></p>
        <p class="caption"><a id="fig6.4"></a><b>Figure 6.4</b> How a smaller time quantum increases context switches.</p>
        <p class="text-indent">Thus, we want the time quantum to be large with respect to the context-switch time. If the context-switch time is approximately 10 percent of the time quantum, then about 10 percent of the CPU time will be spent in context switching. In practice, most modern systems have time quanta ranging from 10 to 100 milliseconds. The time required for a context switch is typically less than 10 microseconds; thus, the context-switch time is a small fraction of the time quantum.</p>
        <p class="text-indent">Turnaround time also depends on the size of the time quantum. As we can see from <a href="13_chapter06.html#fig6.5">Figure 6.5</a>, the average turnaround time of a set of processes does not necessarily improve as the time-quantum size increases. In general, the average turnaround time can be improved if most processes finish their next CPU burst in a single time quantum. For example, given three processes of 10 time units each and a quantum of 1 time unit, the average turnaround time is 29. If the time quantum is 10, however, the average turnaround time drops to 20. If context-switch time is added in, the average turnaround time increases even more for a smaller time quantum, since more context switches are required.</p>
        <p class="text-indent">Although the time quantum should be large compared with the context-switch time, it should not be too large. As we pointed out earlier, if the time quantum is too large, RR scheduling degenerates to an FCFS policy. A rule of thumb is that 80 percent of the CPU bursts should be shorter than the time quantum.</p>
        <h3 class="subtitle"><a id="sec6.3.5"></a>6.3.5 Multilevel Queue Scheduling</h3>
        <p class="text">Another class of scheduling algorithms has been created for situations in which processes are easily classified into different groups. For example, a <a id="page_274"></a>common division is made between <b>foreground</b> (interactive) processes and <b>background</b> (batch) processes. These two types of processes have different response-time requirements and so may have different scheduling needs. In addition, foreground processes may have priority (externally defined) over background processes.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f005.jpg" alt="image" class="imgepub" width="506" height="420"></p>
        <p class="caption"><a id="fig6.5"></a><b>Figure 6.5</b> How turnaround time varies with the time quantum.</p>
        <p class="text-indent">A <b>multilevel queue</b> scheduling algorithm partitions the ready queue into several separate queues (<a href="13_chapter06.html#fig6.6">Figure 6.6</a>). The processes are permanently assigned to one queue, generally based on some property of the process, such as memory size, process priority, or process type. Each queue has its own scheduling algorithm. For example, separate queues might be used for foreground and background processes. The foreground queue might be scheduled by an RR algorithm, while the background queue is scheduled by an FCFS algorithm.</p>
        <p class="text-indent">In addition, there must be scheduling among the queues, which is commonly implemented as fixed-priority preemptive scheduling. For example, the foreground queue may have absolute priority over the background queue.</p>
        <p class="text-indent">Let's look at an example of a multilevel queue scheduling algorithm with five queues, listed below in order of priority:</p>
        <ol style="list-style-type:decimal;">
        <li>System processes</li>
        <li>Interactive processes</li>
        <li>Interactive editing processes</li>
        <li>Batch processes</li>
        <li>Student processes</li>
        </ol>
        <p class="center"><a id="page_275"></a><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f006.jpg" alt="image" class="imgepub" width="556" height="364"></p>
        <p class="caption"><a id="fig6.6"></a><b>Figure 6.6</b> Multilevel queue scheduling.</p>
        <p class="text">Each queue has absolute priority over lower-priority queues. No process in the batch queue, for example, could run unless the queues for system processes, interactive processes, and interactive editing processes were all empty. If an interactive editing process entered the ready queue while a batch process was running, the batch process would be preempted.</p>
        <p class="text-indent">Another possibility is to time-slice among the queues. Here, each queue gets a certain portion of the CPU time, which it can then schedule among its various processes. For instance, in the foreground–background queue example, the foreground queue can be given 80 percent of the CPU time for RR scheduling among its processes, while the background queue receives 20 percent of the CPU to give to its processes on an FCFS basis.</p>
        <h3 class="subtitle"><a id="sec6.3.6"></a>6.3.6 Multilevel Feedback Queue Scheduling</h3>
        <p class="text">Normally, when the multilevel queue scheduling algorithm is used, processes are permanently assigned to a queue when they enter the system. If there are separate queues for foreground and background processes, for example, processes do not move from one queue to the other, since processes do not change their foreground or background nature. This setup has the advantage of low scheduling overhead, but it is inflexible.</p>
        <p class="text-indent">The <b>multilevel feedback queue</b> scheduling algorithm, in contrast, allows a process to move between queues. The idea is to separate processes according to the characteristics of their CPU bursts. If a process uses too much CPU time, it will be moved to a lower-priority queue. This scheme leaves I/O-bound and interactive processes in the higher-priority queues. In addition, a process that waits too long in a lower-priority queue may be moved to a higher-priority queue. This form of aging prevents starvation.</p>
        <p class="text-indent">For example, consider a multilevel feedback queue scheduler with three queues, numbered from 0 to 2 (<a href="13_chapter06.html#fig6.7">Figure 6.7</a>). The scheduler first executes all <a id="page_276"></a>processes in queue 0. Only when queue 0 is empty will it execute processes in queue 1. Similarly, processes in queue 2 will be executed only if queues 0 and 1 are empty. A process that arrives for queue 1 will preempt a process in queue 2. A process in queue 1 will in turn be preempted by a process arriving for queue 0.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f007.jpg" alt="image" class="imgepub" width="410" height="249"></p>
        <p class="caption"><a id="fig6.7"></a><b>Figure 6.7</b> Multilevel feedback queues.</p>
        <p class="text-indent">A process entering the ready queue is put in queue 0. A process in queue 0 is given a time quantum of 8 milliseconds. If it does not finish within this time, it is moved to the tail of queue 1. If queue 0 is empty, the process at the head of queue 1 is given a quantum of 16 milliseconds. If it does not complete, it is preempted and is put into queue 2. Processes in queue 2 are run on an FCFS basis but are run only when queues 0 and 1 are empty.</p>
        <p class="text-indent">This scheduling algorithm gives highest priority to any process with a CPU burst of 8 milliseconds or less. Such a process will quickly get the CPU, finish its CPU burst, and go off to its next I/O burst. Processes that need more than 8 but less than 24 milliseconds are also served quickly, although with lower priority than shorter processes. Long processes automatically sink to queue 2 and are served in FCFS order with any CPU cycles left over from queues 0 and 1.</p>
        <p class="text-indent">In general, a multilevel feedback queue scheduler is defined by the following parameters:</p>
        <ul style="list-style-type:disc;">
        <li>The number of queues</li>
        <li>The scheduling algorithm for each queue</li>
        <li>The method used to determine when to upgrade a process to a higher-priority queue</li>
        <li>The method used to determine when to demote a process to a lower-priority queue</li>
        <li>The method used to determine which queue a process will enter when that process needs service</li>
        </ul>
        <p class="text">The definition of a multilevel feedback queue scheduler makes it the most general CPU-scheduling algorithm. It can be configured to match a specific system under design. Unfortunately, it is also the most complex algorithm, <a id="page_277"></a>since defining the best scheduler requires some means by which to select values for all the parameters.</p>
        <h2 class="subtitle"><a id="sec6.4"></a>6.4 Thread Scheduling</h2>
        <p class="text">In <a href="11_chapter04.html#chap4">Chapter 4</a>, we introduced threads to the process model, distinguishing between <b><i>user-level</i></b> and <b><i>kernel-level</i></b> threads. On operating systems that support them, it is kernel-level threads—not processes—that are being scheduled by the operating system. User-level threads are managed by a thread library, and the kernel is unaware of them. To run on a CPU, user-level threads must ultimately be mapped to an associated kernel-level thread, although this mapping may be indirect and may use a lightweight process (LWP). In this section, we explore scheduling issues involving user-level and kernel-level threads and offer specific examples of scheduling for Pthreads.</p>
        <h3 class="subtitle"><a id="sec6.4.1"></a>6.4.1 Contention Scope</h3>
        <p class="text">One distinction between user-level and kernel-level threads lies in how they are scheduled. On systems implementing the many-to-one (<a href="11_chapter04.html#sec4.3.1">Section 4.3.1</a>) and many-to-many (<a href="11_chapter04.html#sec4.3.3">Section 4.3.3</a>) models, the thread library schedules user-level threads to run on an available LWP. This scheme is known as <b>process-contention scope (PCS)</b>, since competition for the CPU takes place among threads belonging to the same process. (When we say the thread library <i>schedules</i> user threads onto available LWPs, we do not mean that the threads are actually running on a CPU. That would require the operating system to schedule the kernel thread onto a physical CPU.) To decide which kernel-level thread to schedule onto a CPU, the kernel uses <b>system-contention scope (SCS)</b>. Competition for the CPU with SCS scheduling takes place among all threads in the system. Systems using the one-to-one model (<a href="11_chapter04.html#sec4.3.2">Section 4.3.2</a>), such as Windows, Linux, and Solaris, schedule threads using only SCS.</p>
        <p class="text-indent">Typically, PCS is done according to priority—the scheduler selects the runnable thread with the highest priority to run. User-level thread priorities are set by the programmer and are not adjusted by the thread library, although some thread libraries may allow the programmer to change the priority of a thread. It is important to note that PCS will typically preempt the thread currently running in favor of a higher-priority thread; however, there is no guarantee of time slicing (<a href="13_chapter06.html#sec6.3.4">Section 6.3.4</a>) among threads of equal priority.</p>
        <h3 class="subtitle"><a id="sec6.4.2"></a>6.4.2 Pthread Scheduling</h3>
        <p class="text">We provided a sample POSIX Pthread program in <a href="11_chapter04.html#sec4.4.1">Section 4.4.1</a>, along with an introduction to thread creation with Pthreads. Now, we highlight the POSIX Pthread API that allows specifying PCS or SCS during thread creation. Pthreads identifies the following contention scope values:</p>
        <ul style="list-style-type:disc;">
        <li>PTHREAD_SCOPE_PROCESS schedules threads using PCS scheduling.</li>
        <li>PTHREAD_SCOPE_SYSTEM schedules threads using SCS scheduling.</li>
        </ul>
        <p class="text-indent"><a id="page_278"></a>On systems implementing the many-to-many model, the PTHREAD_SCOPE_PROCESS policy schedules user-level threads onto available LWPs. The number of LWPs is maintained by the thread library, perhaps using scheduler activations (<a href="11_chapter04.html#sec4.6.5">Section 4.6.5</a>). The PTHREAD_SCOPE_SYSTEM scheduling policy will create and bind an LWP for each user-level thread on many-to-many systems, effectively mapping threads using the one-to-one policy.</p>
        <p class="text-indent">The Pthread IPC provides two functions for getting—and setting—the contention scope policy:</p>
        <ul style="list-style-type:disc;">
        <li><span class="inlinecode">pthread_attr_setscope(pthread_attr_t *attr, int scope)</span></li>
        <li><span class="inlinecode">pthread_attr_getscope(pthread_attr_t *attr, int *scope)</span></li>
        </ul>
        <p class="text">The first parameter for both functions contains a pointer to the attribute set for the thread. The second parameter for the <span class="inlinecode">pthread_attr_setscope()</span> function is passed either the PTHREAD_SCOPE_SYSTEM or the PTHREAD_SCOPE_PROCESS value, indicating how the contention scope is to be set. In the case of <span class="inlinecode">pthread_attr_getscope()</span>, this second parameter contains a pointer to an <span class="inlinecode">int</span> value that is set to the current value of the contention scope. If an error occurs, each of these functions returns a nonzero value.</p>
        <p class="text-indent">In <a href="13_chapter06.html#fig6.8">Figure 6.8</a>, we illustrate a Pthread scheduling API. The program first determines the existing contention scope and sets it to PTHREAD_SCOPE_SYSTEM. It then creates five separate threads that will run using the SCS scheduling policy. Note that on some systems, only certain contention scope values are allowed. For example, Linux and Mac OS X systems allow only PTHREAD_SCOPE_SYSTEM.</p>
        <h2 class="subtitle"><a id="sec6.5"></a>6.5 Multiple-Processor Scheduling</h2>
        <p class="text">Our discussion thus far has focused on the problems of scheduling the CPU in a system with a single processor. If multiple CPUs are available, <b>load sharing</b> becomes possible—but scheduling problems become correspondingly more complex. Many possibilities have been tried; and as we saw with single-processor CPU scheduling, there is no one best solution.</p>
        <p class="text-indent">Here, we discuss several concerns in multiprocessor scheduling. We concentrate on systems in which the processors are identical—homogeneous—in terms of their functionality. We can then use any available processor to run any process in the queue. Note, however, that even with homogeneous multiprocessors, there are sometimes limitations on scheduling. Consider a system with an I/O device attached to a private bus of one processor. Processes that wish to use that device must be scheduled to run on that processor.</p>
        <h3 class="subtitle"><a id="sec6.5.1"></a>6.5.1 Approaches to Multiple-Processor Scheduling</h3>
        <p class="text">One approach to CPU scheduling in a multiprocessor system has all scheduling decisions, I/O processing, and other system activities handled by a single processor—the master server. The other processors execute only user code. This <b>asymmetric multiprocessing</b> is simple because only one processor accesses the system data structures, reducing the need for data sharing.</p>
        <p class="center"><a id="page_279"></a><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f008.jpg" alt="image" class="imgepub" width="583" height="936"></p>
        <p class="caption"><a id="fig6.8"></a><b>Figure 6.8</b> Pthread scheduling API.</p>
        <p class="text-indent">A second approach uses <b>symmetric multiprocessing (SMP)</b>, where each processor is self-scheduling. All processes may be in a common ready queue, or each processor may have its own private queue of ready processes. Regardless, <a id="page_280"></a>scheduling proceeds by having the scheduler for each processor examine the ready queue and select a process to execute. As we saw in <a href="12_chapter05.html#chap5">Chapter 5</a>, if we have multiple processors trying to access and update a common data structure, the scheduler must be programmed carefully. We must ensure that two separate processors do not choose to schedule the same process and that processes are not lost from the queue. Virtually all modern operating systems support SMP, including Windows, Linux, and Mac OS X. In the remainder of this section, we discuss issues concerning SMP systems.</p>
        <h3 class="subtitle"><a id="sec6.5.2"></a>6.5.2 Processor Affinity</h3>
        <p class="text">Consider what happens to cache memory when a process has been running on a specific processor. The data most recently accessed by the process populate the cache for the processor. As a result, successive memory accesses by the process are often satisfied in cache memory. Now consider what happens if the process migrates to another processor. The contents of cache memory must be invalidated for the first processor, and the cache for the second processor must be repopulated. Because of the high cost of invalidating and repopulating caches, most SMP systems try to avoid migration of processes from one processor to another and instead attempt to keep a process running on the same processor. This is known as <b>processor affinity</b>—that is, a process has an affinity for the processor on which it is currently running.</p>
        <p class="text-indent">Processor affinity takes several forms. When an operating system has a policy of attempting to keep a process running on the same processor—but not guaranteeing that it will do so—we have a situation known as <b>soft affinity</b>. Here, the operating system will attempt to keep a process on a single processor, but it is possible for a process to migrate between processors. In contrast, some systems provide system calls that support <b>hard affinity</b>, thereby allowing a process to specify a subset of processors on which it may run. Many systems provide both soft and hard affinity. For example, Linux implements soft affinity, but it also provides the <span class="inlinecode">sched_setaffinity()</span> system call, which supports hard affinity.</p>
        <p class="text-indent">The main-memory architecture of a system can affect processor affinity issues. <a href="13_chapter06.html#fig6.9">Figure 6.9</a> illustrates an architecture featuring non-uniform memory access (NUMA), in which a CPU has faster access to some parts of main memory than to other parts. Typically, this occurs in systems containing combined CPU and memory boards. The CPUs on a board can access the memory on that board faster than they can access memory on other boards in the system. If the operating system's CPU scheduler and memory-placement algorithms work together, then a process that is assigned affinity to a particular CPU can be allocated memory on the board where that CPU resides. This example also shows that operating systems are frequently not as cleanly defined and implemented as described in operating-system textbooks. Rather, the “solid lines” between sections of an operating system are frequently only “dotted lines,” with algorithms creating connections in ways aimed at optimizing performance and reliability.</p>
        <h3 class="subtitle"><a id="sec6.5.3"></a>6.5.3 Load Balancing</h3>
        <p class="text">On SMP systems, it is important to keep the workload balanced among all processors to fully utilize the benefits of having more than one processor. <a id="page_281"></a>Otherwise, one or more processors may sit idle while other processors have high workloads, along with lists of processes awaiting the CPU. <b>Load balancing</b> attempts to keep the workload evenly distributed across all processors in an SMP system. It is important to note that load balancing is typically necessary only on systems where each processor has its own private queue of eligible processes to execute. On systems with a common run queue, load balancing is often unnecessary, because once a processor becomes idle, it immediately extracts a runnable process from the common run queue. It is also important to note, however, that in most contemporary operating systems supporting SMP, each processor does have a private queue of eligible processes.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f009.jpg" alt="image" class="imgepub" width="534" height="285"></p>
        <p class="caption"><a id="fig6.9"></a><b>Figure 6.9</b> NUMA and CPU scheduling.</p>
        <p class="text-indent">There are two general approaches to load balancing: <b>push migration</b> and <b>pull migration</b>. With push migration, a specific task periodically checks the load on each processor and—if it finds an imbalance—evenly distributes the load by moving (or pushing) processes from overloaded to idle or less-busy processors. Pull migration occurs when an idle processor pulls a waiting task from a busy processor. Push and pull migration need not be mutually exclusive and are in fact often implemented in parallel on load-balancing systems. For example, the Linux scheduler (described in <a href="13_chapter06.html#sec6.7.1">Section 6.7.1</a>) and the ULE scheduler available for FreeBSD systems implement both techniques.</p>
        <p class="text-indent">Interestingly, load balancing often counteracts the benefits of processor affinity, discussed in <a href="13_chapter06.html#sec6.5.2">Section 6.5.2</a>. That is, the benefit of keeping a process running on the same processor is that the process can take advantage of its data being in that processor's cache memory. Either pulling or pushing a process from one processor to another removes this benefit. As is often the case in systems engineering, there is no absolute rule concerning what policy is best. Thus, in some systems, an idle processor always pulls a process from a non-idle processor. In other systems, processes are moved only if the imbalance exceeds a certain threshold.</p>
        <h3 class="subtitle"><a id="sec6.5.4"></a>6.5.4 Multicore Processors</h3>
        <p class="text">Traditionally, SMP systems have allowed several threads to run concurrently by providing multiple physical processors. However, a recent practice in computer <a id="page_282"></a>hardware has been to place multiple processor cores on the same physical chip, resulting in a <b>multicore processor</b>. Each core maintains its architectural state and thus appears to the operating system to be a separate physical processor. SMP systems that use multicore processors are faster and consume less power than systems in which each processor has its own physical chip.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f010.jpg" alt="image" class="imgepub" width="569" height="136"></p>
        <p class="caption"><a id="fig6.10"></a><b>Figure 6.10</b> Memory stall.</p>
        <p class="text-indent">Multicore processors may complicate scheduling issues. Let's consider how this can happen. Researchers have discovered that when a processor accesses memory, it spends a significant amount of time waiting for the data to become available. This situation, known as a <b>memory stall</b>, may occur for various reasons, such as a cache miss (accessing data that are not in cache memory). <a href="13_chapter06.html#fig6.10">Figure 6.10</a> illustrates a memory stall. In this scenario, the processor can spend up to 50 percent of its time waiting for data to become available from memory. To remedy this situation, many recent hardware designs have implemented multithreaded processor cores in which two (or more) hardware threads are assigned to each core. That way, if one thread stalls while waiting for memory, the core can switch to another thread. <a href="13_chapter06.html#fig6.11">Figure 6.11</a> illustrates a dual-threaded processor core on which the execution of thread 0 and the execution of thread 1 are interleaved. From an operating-system perspective, each hardware thread appears as a logical processor that is available to run a software thread. Thus, on a dual-threaded, dual-core system, four logical processors are presented to the operating system. The UltraSPARC T3 CPU has sixteen cores per chip and eight hardware threads per core. From the perspective of the operating system, there appear to be 128 logical processors.</p>
        <p class="text-indent">In general, there are two ways to multithread a processing core <b>coarse-grained</b> and <b>fine-grained</b> multithreading. With coarse-grained multithreading, a thread executes on a processor until a long-latency event such as a memory stall occurs. Because of the delay caused by the long-latency event, the processor must switch to another thread to begin execution. However, the cost of switching between threads is high, since the instruction pipeline must <a id="page_283"></a>be flushed before the other thread can begin execution on the processor core. Once this new thread begins execution, it begins filling the pipeline with its instructions. Fine-grained (or interleaved) multithreading switches between threads at a much finer level of granularity—typically at the boundary of an instruction cycle. However, the architectural design of fine-grained systems includes logic for thread switching. As a result, the cost of switching between threads is small.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f011.jpg" alt="image" class="imgepub" width="570" height="136"></p>
        <p class="caption"><a id="fig6.11"></a><b>Figure 6.11</b> Multithreaded multicore system.</p>
        <p class="text-indent">Notice that a multithreaded multicore processor actually requires two different levels of scheduling. On one level are the scheduling decisions that must be made by the operating system as it chooses which software thread to run on each hardware thread (logical processor). For this level of scheduling, the operating system may choose any scheduling algorithm, such as those described in <a href="13_chapter06.html#sec6.3">Section 6.3</a>. A second level of scheduling specifies how each core decides which hardware thread to run. There are several strategies to adopt in this situation. The UltraSPARC T3, mentioned earlier, uses a simple round-robin algorithm to schedule the eight hardware threads to each core. Another example, the Intel Itanium, is a dual-core processor with two hardware-managed threads per core. Assigned to each hardware thread is a dynamic <i>urgency</i> value ranging from 0 to 7, with 0 representing the lowest urgency and 7 the highest. The Itanium identifies five different events that may trigger a thread switch. When one of these events occurs, the thread-switching logic compares the urgency of the two threads and selects the thread with the highest urgency value to execute on the processor core.</p>
        <h2 class="subtitle"><a id="sec6.6"></a>6.6 Real-Time CPU Scheduling</h2>
        <p class="text">CPU scheduling for real-time operating systems involves special issues. In general, we can distinguish between soft real-time systems and hard real-time systems. <b>Soft real-time systems</b> provide no guarantee as to when a critical real-time process will be scheduled. They guarantee only that the process will be given preference over noncritical processes. <b>Hard real-time systems</b> have stricter requirements. A task must be serviced by its deadline; service after the deadline has expired is the same as no service at all. In this section, we explore several issues related to process scheduling in both soft and hard real-time operating systems.</p>
        <h3 class="subtitle"><a id="sec6.6.1"></a>6.6.1 Minimizing Latency</h3>
        <p class="text">Consider the event-driven nature of a real-time system. The system is typically waiting for an event in real time to occur. Events may arise either in software—as when a timer expires—or in hardware—as when a remote-controlled vehicle detects that it is approaching an obstruction. When an event occurs, the system must respond to and service it as quickly as possible. We refer to <b>event latency</b> as the amount of time that elapses from when an event occurs to when it is serviced (<a href="13_chapter06.html#fig6.12">Figure 6.12</a>).</p>
        <p class="text-indent">Usually, different events have different latency requirements. For example, the latency requirement for an antilock brake system might be 3 to 5 milliseconds. That is, from the time a wheel first detects that it is sliding, the system controlling the antilock brakes has 3 to 5 milliseconds to respond to and control <a id="page_284"></a>the situation. Any response that takes longer might result in the automobile's veering out of control. In contrast, an embedded system controlling radar in an airliner might tolerate a latency period of several seconds.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f012.jpg" alt="image" class="imgepub" width="356" height="232"></p>
        <p class="caption"><a id="fig6.12"></a><b>Figure 6.12</b> Event latency.</p>
        <p class="text-indent">Two types of latencies affect the performance of real-time systems:</p>
        <ol style="list-style-type:decimal;">
        <li>Interrupt latency</li>
        <li>Dispatch latency</li>
        </ol>
        <p class="text-indent"><b>Interrupt latency</b> refers to the period of time from the arrival of an interrupt at the CPU to the start of the routine that services the interrupt. When an interrupt occurs, the operating system must first complete the instruction it is executing and determine the type of interrupt that occurred. It must then save the state of the current process before servicing the interrupt using the specific interrupt service routine (ISR). The total time required to perform these tasks is the interrupt latency (<a href="13_chapter06.html#fig6.13">Figure 6.13</a>). Obviously, it is crucial for real-time <a id="page_285"></a>operating systems to minimize interrupt latency to ensure that real-time tasks receive immediate attention. Indeed, for hard real-time systems, interrupt latency must not simply be minimized, it must be bounded to meet the strict requirements of these systems.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f013.jpg" alt="image" class="imgepub" width="391" height="365"></p>
        <p class="caption"><a id="fig6.13"></a><b>Figure 6.13</b> Interrupt latency.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f014.jpg" alt="image" class="imgepub" width="556" height="405"></p>
        <p class="caption"><a id="fig6.14"></a><b>Figure 6.14</b> Dispatch latency.</p>
        <p class="text-indent">One important factor contributing to interrupt latency is the amount of time interrupts may be disabled while kernel data structures are being updated. Real-time operating systems require that interrupts be disabled for only very short periods of time.</p>
        <p class="text-indent">The amount of time required for the scheduling dispatcher to stop one process and start another is known as dispatch latency. Providing real-time tasks with immediate access to the CPU mandates that real-time operating systems minimize this latency as well. The most effective technique for keeping dispatch latency low is to provide preemptive kernels.</p>
        <p class="text-indent">In <a href="13_chapter06.html#fig6.14">Figure 6.14</a>, we diagram the makeup of dispatch latency. The <b>conflict phase</b> of dispatch latency has two components:</p>
        <ol style="list-style-type:decimal;">
        <li>Preemption of any process running in the kernel</li>
        <li>Release by low-priority processes of resources needed by a high-priority process</li>
        </ol>
        <p class="text-indent">As an example, in Solaris, the dispatch latency with preemption disabled is over a hundred milliseconds. With preemption enabled, it is reduced to less than a millisecond.</p>
        <h3 class="subtitle"><a id="sec6.6.2"></a>6.6.2 Priority-Based Scheduling</h3>
        <p class="text">The most important feature of a real-time operating system is to respond immediately to a real-time process as soon as that process requires the CPU. <a id="page_286"></a>As a result, the scheduler for a real-time operating system must support a priority-based algorithm with preemption. Recall that priority-based scheduling algorithms assign each process a priority based on its importance; more important tasks are assigned higher priorities than those deemed less important. If the scheduler also supports preemption, a process currently running on the CPU will be preempted if a higher-priority process becomes available to run.</p>
        <p class="text-indent">Preemptive, priority-based scheduling algorithms are discussed in detail in <a href="13_chapter06.html#sec6.3.3">Section 6.3.3</a>, and <a href="13_chapter06.html#sec6.7">Section 6.7</a> presents examples of the soft real-time scheduling features of the Linux, Windows, and Solaris operating systems. Each of these systems assigns real-time processes the highest scheduling priority. For example, Windows has 32 different priority levels. The highest levels—priority values 16 to 31—are reserved for real-time processes. Solaris and Linux have similar prioritization schemes.</p>
        <p class="text-indent">Note that providing a preemptive, priority-based scheduler only guarantees soft real-time functionality. Hard real-time systems must further guarantee that real-time tasks will be serviced in accord with their deadline requirements, and making such guarantees requires additional scheduling features. In the remainder of this section, we cover scheduling algorithms appropriate for hard real-time systems.</p>
        <p class="text-indent">Before we proceed with the details of the individual schedulers, however, we must define certain characteristics of the processes that are to be scheduled. First, the processes are considered <b>periodic</b>. That is, they require the CPU at constant intervals (periods). Once a periodic process has acquired the CPU, it has a fixed processing time <i>t</i>, a deadline <i>d</i> by which it must be serviced by the CPU, and a period <i>p</i>. The relationship of the processing time, the deadline, and the period can be expressed as 0 ≤ <i>t</i> ≤ <i>d</i> ≤ <i>p</i>. The <b>rate</b> of a periodic task is 1/<i>p</i>. <a href="13_chapter06.html#fig6.15">Figure 6.15</a> illustrates the execution of a periodic process over time. Schedulers can take advantage of these characteristics and assign priorities according to a process's deadline or rate requirements.</p>
        <p class="text-indent">What is unusual about this form of scheduling is that a process may have to announce its deadline requirements to the scheduler. Then, using a technique known as an <b>admission-control</b> algorithm, the scheduler does one of two things. It either admits the process, guaranteeing that the process will complete on time, or rejects the request as impossible if it cannot guarantee that the task will be serviced by its deadline.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f015.jpg" alt="image" class="imgepub" width="605" height="173"></p>
        <p class="caption"><a id="fig6.15"></a><b>Figure 6.15</b> Periodic task.</p>
        <p class="center"><a id="page_287"></a><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f016.jpg" alt="image" class="imgepub" width="534" height="94"></p>
        <p class="caption"><a id="fig6.16"></a><b>Figure 6.16</b> Scheduling of tasks when <i>P</i><sub>2</sub> has a higher priority than <i>P</i><sub>1</sub>.</p>
        <h3 class="subtitle"><a id="sec6.6.3"></a>6.6.3 Rate-Monotonic Scheduling</h3>
        <p class="text">The <b>rate-monotonic</b> scheduling algorithm schedules periodic tasks using a static priority policy with preemption. If a lower-priority process is running and a higher-priority process becomes available to run, it will preempt the lower-priority process. Upon entering the system, each periodic task is assigned a priority inversely based on its period. The shorter the period, the higher the priority; the longer the period, the lower the priority. The rationale behind this policy is to assign a higher priority to tasks that require the CPU more often. Furthermore, rate-monotonic scheduling assumes that the processing time of a periodic process is the same for each CPU burst. That is, every time a process acquires the CPU, the duration of its CPU burst is the same.</p>
        <p class="text-indent">Let's consider an example. We have two processes, <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub>. The periods for <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub> are 50 and 100, respectively—that is, <i>p</i><sub>1</sub> = 50 and <i>p</i><sub>2</sub> = 100. The processing times are <i>t</i><sub>1</sub> = 20 for <i>P</i><sub>1</sub> and <i>t</i><sub>2</sub> = 35 for <i>P</i><sub>2</sub>. The deadline for each process requires that it complete its CPU burst by the start of its next period.</p>
        <p class="text-indent">We must first ask ourselves whether it is possible to schedule these tasks so that each meets its deadlines. If we measure the CPU utilization of a process <i>P<sub>i</sub></i> as the ratio of its burst to its period—<i>t<sub>i</sub>/p<sub>i</sub></i> —the CPU utilization of <i>P</i><sub>1</sub> is 20/50 = 0.40 and that of <i>P</i><sub>2</sub> is 35<i>/</i>100 = 0.35, for a total CPU utilization of 75 percent. Therefore, it seems we can schedule these tasks in such a way that both meet their deadlines and still leave the CPU with available cycles.</p>
        <p class="text-indent">Suppose we assign <i>P</i><sub>2</sub> a higher priority than <i>P</i><sub>1</sub>. The execution of <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub> in this situation is shown in <a href="13_chapter06.html#fig6.16">Figure 6.16</a>. As we can see, <i>P</i><sub>2</sub> starts execution first and completes at time 35. At this point, <i>P</i><sub>1</sub> starts; it completes its CPU burst at time 55. However, the first deadline for <i>P</i><sub>1</sub> was at time 50, so the scheduler has caused <i>P</i><sub>1</sub> to miss its deadline.</p>
        <p class="text-indent">Now suppose we use rate-monotonic scheduling, in which we assign <i>P</i><sub>1</sub> a higher priority than <i>P</i><sub>2</sub> because the period of <i>P</i><sub>1</sub> is shorter than that of <i>P</i><sub>2</sub>. The execution of these processes in this situation is shown in <a href="13_chapter06.html#fig6.17">Figure 6.17</a>. <i>P</i><sub>1</sub> starts first and completes its CPU burst at time 20, thereby meeting its first deadline. <i>P</i><sub>2</sub> starts running at this point and runs until time 50. At this time, it is preempted by <i>P</i><sub>1</sub>, although it still has 5 milliseconds remaining in its CPU burst. <i>P</i><sub>1</sub> completes its CPU burst at time 70, at which point the scheduler resumes <a id="page_288"></a><i>P</i><sub>2</sub>. <i>P</i><sub>2</sub> completes its CPU burst at time 75, also meeting its first deadline. The system is idle until time 100, when <i>P</i><sub>1</sub> is scheduled again.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f017.jpg" alt="image" class="imgepub" width="607" height="87"></p>
        <p class="caption"><a id="fig6.17"></a><b>Figure 6.17</b> Rate-monotonic scheduling.</p>
        <p class="text-indent">Rate-monotonic scheduling is considered optimal in that if a set of processes cannot be scheduled by this algorithm, it cannot be scheduled by any other algorithm that assigns static priorities. Let's next examine a set of processes that cannot be scheduled using the rate-monotonic algorithm.</p>
        <p class="text-indent">Assume that process <i>P</i><sub>1</sub> has a period of <i>p</i><sub>1</sub> = 50 and a CPU burst of <i>t</i><sub>1</sub> = 25. For <i>P</i><sub>2</sub>, the corresponding values are <i>p</i><sub>2</sub> = 80 and <i>t</i><sub>2</sub> = 35. Rate-monotonic scheduling would assign process <i>P</i><sub>1</sub> a higher priority, as it has the shorter period. The total CPU utilization of the two processes is (25<i>/</i>50)+(35<i>/</i>80) = 0.94, and it therefore seems logical that the two processes could be scheduled and still leave the CPU with 6 percent available time. <a href="13_chapter06.html#fig6.18">Figure 6.18</a> shows the scheduling of processes <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub>. Initially, <i>P</i><sub>1</sub> runs until it completes its CPU burst at time 25. Process <i>P</i><sub>2</sub> then begins running and runs until time 50, when it is preempted by <i>P</i><sub>1</sub>. At this point, <i>P</i><sub>2</sub> still has 10 milliseconds remaining in its CPU burst. Process <i>P</i><sub>1</sub> runs until time 75; consequently, <i>P</i><sub>2</sub> misses the deadline for completion of its CPU burst at time 80.</p>
        <p class="text-indent">Despite being optimal, then, rate-monotonic scheduling has a limitation: CPU utilization is bounded, and it is not always possible fully to maximize CPU resources. The worst-case CPU utilization for scheduling <i>N</i> processes is</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p288-001.jpg" alt="image" class="imgepub" width="100" height="22"></p>
        <p class="text">With one process in the system, CPU utilization is 100 percent, but it falls to approximately 69 percent as the number of processes approaches infinity. With two processes, CPU utilization is bounded at about 83 percent. Combined CPU utilization for the two processes scheduled in <a href="13_chapter06.html#fig6.16">Figure 6.16</a> and <a href="13_chapter06.html#fig6.17">Figure 6.17</a> is 75 percent; therefore, the rate-monotonic scheduling algorithm is guaranteed to schedule them so that they can meet their deadlines. For the two processes scheduled in <a href="13_chapter06.html#fig6.18">Figure 6.18</a>, combined CPU utilization is approximately 94 percent; therefore, rate-monotonic scheduling cannot guarantee that they can be scheduled so that they meet their deadlines.</p>
        <h3 class="subtitle"><a id="sec6.6.4"></a>6.6.4 Earliest-Deadline-First Scheduling</h3>
        <p class="text"><b>Earliest-deadline-first (EDF)</b> scheduling dynamically assigns priorities according to deadline. The earlier the deadline, the higher the priority; the later the deadline, the lower the priority. Under the EDF policy, when a process becomes runnable, it must announce its deadline requirements to the system. Priorities may have to be adjusted to reflect the deadline of the newly runnable process. Note how this differs from rate-monotonic scheduling, where priorities are fixed.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f018.jpg" alt="image" class="imgepub" width="645" height="94"></p>
        <p class="caption"><a id="fig6.18"></a><b>Figure 6.18</b> Missing deadlines with rate-monotonic scheduling.</p>
        <p class="center"><a id="page_289"></a><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f019.jpg" alt="image" class="imgepub" width="644" height="94"></p>
        <p class="caption"><a id="fig6.19"></a><b>Figure 6.19</b> Earliest-deadline-first scheduling.</p>
        <p class="text-indent">To illustrate EDF scheduling, we again schedule the processes shown in <a href="13_chapter06.html#fig6.18">Figure 6.18</a>, which failed to meet deadline requirements under rate-monotonic scheduling. Recall that <i>P</i><sub>1</sub> has values of <i>p</i><sub>1</sub> = 50 and <i>t</i><sub>1</sub> = 25 and that <i>P</i><sub>2</sub> has values of <i>p</i><sub>2</sub> = 80 and <i>t</i><sub>2</sub> = 35. The EDF scheduling of these processes is shown in <a href="13_chapter06.html#fig6.19">Figure 6.19</a>. Process <i>P</i><sub>1</sub> has the earliest deadline, so its initial priority is higher than that of process <i>P</i><sub>2</sub>. Process <i>P</i><sub>2</sub> begins running at the end of the CPU burst for <i>P</i><sub>1</sub>. However, whereas rate-monotonic scheduling allows <i>P</i><sub>1</sub> to preempt <i>P</i><sub>2</sub> at the beginning of its next period at time 50, EDF scheduling allows process <i>P</i><sub>2</sub> to continue running. <i>P</i><sub>2</sub> now has a higher priority than <i>P</i><sub>1</sub> because its next deadline (at time 80) is earlier than that of <i>P</i><sub>1</sub> (at time 100). Thus, both <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub> meet their first deadlines. Process <i>P</i><sub>1</sub> again begins running at time 60 and completes its second CPU burst at time 85, also meeting its second deadline at time 100. <i>P</i><sub>2</sub> begins running at this point, only to be preempted by <i>P</i><sub>1</sub> at the start of its next period at time 100. <i>P</i><sub>2</sub> is preempted because <i>P</i><sub>1</sub> has an earlier deadline (time 150) than <i>P</i><sub>2</sub> (time 160). At time 125, <i>P</i><sub>1</sub> completes its CPU burst and <i>P</i><sub>2</sub> resumes execution, finishing at time 145 and meeting its deadline as well. The system is idle until time 150, when <i>P</i><sub>1</sub> is scheduled to run once again.</p>
        <p class="text-indent">Unlike the rate-monotonic algorithm, EDF scheduling does not require that processes be periodic, nor must a process require a constant amount of CPU time per burst. The only requirement is that a process announce its deadline to the scheduler when it becomes runnable. The appeal of EDF scheduling is that it is theoretically optimal—theoretically, it can schedule processes so that each process can meet its deadline requirements and CPU utilization will be 100 percent. In practice, however, it is impossible to achieve this level of CPU utilization due to the cost of context switching between processes and interrupt handling.</p>
        <h3 class="subtitle"><a id="sec6.6.5"></a>6.6.5 Proportional Share Scheduling</h3>
        <p class="text"><b>Proportional share</b> schedulers operate by allocating <i>T</i> shares among all applications. An application can receive <i>N</i> shares of time, thus ensuring that the application will have <i>N/T</i> of the total processor time. As an example, assume that a total of <i>T</i> = 100 shares is to be divided among three processes, <i>A</i>, <i>B</i>, and <i>C</i>. <i>A</i> is assigned 50 shares, <i>B</i> is assigned 15 shares, and <i>C</i> is assigned 20 shares. This scheme ensures that <i>A</i> will have 50 percent of total processor time, <i>B</i> will have 15 percent, and <i>C</i> will have 20 percent.</p>
        <p class="text-indent">Proportional share schedulers must work in conjunction with an admission-control policy to guarantee that an application receives its allocated shares of time. An admission-control policy will admit a client requesting a particular number of shares only if sufficient shares are available. In our current example, we have allocated 50 + 15 + 20 = 85 shares of the total of <a id="page_290"></a>100 shares. If a new process <i>D</i> requested 30 shares, the admission controller would deny <i>D</i> entry into the system.</p>
        <h3 class="subtitle"><a id="sec6.6.6"></a>6.6.6 POSIX Real-Time Scheduling</h3>
        <p class="text">The POSIX standard also provides extensions for real-time computing—POSIX.1b. Here, we cover some of the POSIX API related to scheduling real-time threads. POSIX defines two scheduling classes for real-time threads:</p>
        <ul style="list-style-type:disc;">
        <li>SCHED_FIFO</li>
        <li>SCHED_RR</li>
        </ul>
        <p class="text-indent">SCHED_FIFO schedules threads according to a first-come, first-served policy using a FIFO queue as outlined in <a href="13_chapter06.html#sec6.3.1">Section 6.3.1</a>. However, there is no time slicing among threads of equal priority. Therefore, the highest-priority real-time thread at the front of the FIFO queue will be granted the CPU until it terminates or blocks. SCHED_RR uses a round-robin policy. It is similar to SCHED_FIFO except that it provides time slicing among threads of equal priority. POSIX provides an additional scheduling class—SCHED_OTHER—but its implementation is undefined and system specific; it may behave differently on different systems.</p>
        <p class="text-indent">The POSIX API specifies the following two functions for getting and setting the scheduling policy:</p>
        <ul style="list-style-type:disc;">
        <li><span class="inlinecode">pthread_attr_getsched_policy(pthread_attr_t *attr, int *policy)</span></li>
        <li><span class="inlinecode">pthread_attr_setsched_policy(pthread_attr_t *attr, int policy)</span></li>
        </ul>
        <p class="text">The first parameter to both functions is a pointer to the set of attributes for the thread. The second parameter is either (1) a pointer to an integer that is set to the current scheduling policy (for <span class="inlinecode">pthread_attr_getsched_policy()</span>) or (2) an integer value (SCHED_FIFO, SCHED_RR, or SCHED_OTHER) for the <span class="inlinecode">pthread_attr_setsched_policy()</span> function. Both functions return nonzero values if an error occurs.</p>
        <p class="text-indent">In <a href="13_chapter06.html#fig6.20">Figure 6.20</a>, we illustrate a POSIX Pthread program using this API. This program first determines the current scheduling policy and then sets the scheduling algorithm to SCHED_FIFO.</p>
        <h2 class="subtitle"><a id="sec6.7"></a>6.7 Operating-System Examples</h2>
        <p class="text">We turn next to a description of the scheduling policies of the Linux, Windows, and Solaris operating systems. It is important to note that we use the term <b><i>process scheduling</i></b> in a general sense here. In fact, we are describing the scheduling of <b><i>kernel threads</i></b> with Solaris and Windows systems and of <b><i>tasks</i></b> with the Linux scheduler.</p>
        <h3 class="subtitle"><a id="sec6.7.1"></a>6.7.1 Example: Linux Scheduling</h3>
        <p class="text">Process scheduling in Linux has had an interesting history. Prior to Version 2.5, the Linux kernel ran a variation of the traditional UNIX scheduling algorithm. <a id="page_291"></a><a id="page_292"></a>However, as this algorithm was not designed with SMP systems in mind, it did not adequately support systems with multiple processors. In addition, it resulted in poor performance for systems with a large number of runnable processes. With Version 2.5 of the kernel, the scheduler was overhauled to include a scheduling algorithm—known as <i>O</i>(1)—that ran in constant time regardless of the number of tasks in the system. The <i>O</i>(1) scheduler also provided increased support for SMP systems, including processor affinity and load balancing between processors. However, in practice, although the <i>O</i>(1) scheduler delivered excellent performance on SMP systems, it led to poor response times for the interactive processes that are common on many desktop computer systems. During development of the 2.6 kernel, the scheduler was again revised; and in release 2.6.23 of the kernel, the <b><i>Completely Fair Scheduler</i></b> (CFS) became the default Linux scheduling algorithm.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f020.jpg" alt="image" class="imgepub" width="592" height="957"></p>
        <p class="caption"><a id="fig6.20"></a><b>Figure 6.20</b> POSIX real-time scheduling API.</p>
        <p class="text-indent">Scheduling in the Linux system is based on <b>scheduling classes</b>. Each class is assigned a specific priority. By using different scheduling classes, the kernel can accommodate different scheduling algorithms based on the needs of the system and its processes. The scheduling criteria for a Linux server, for example, may be different from those for a mobile device running Linux. To decide which task to run next, the scheduler selects the highest-priority task belonging to the highest-priority scheduling class. Standard Linux kernels implement two scheduling classes: (1) a default scheduling class using the CFS scheduling algorithm and (2) a real-time scheduling class. We discuss each of these classes here. New scheduling classes can, of course, be added.</p>
        <p class="text-indent">Rather than using strict rules that associate a relative priority value with the length of a time quantum, the CFS scheduler assigns a proportion of CPU processing time to each task. This proportion is calculated based on the <b>nice value</b> assigned to each task. Nice values range from −20 to +19, where a numerically lower nice value indicates a higher relative priority. Tasks with lower nice values receive a higher proportion of CPU processing time than tasks with higher nice values. The default nice value is 0. (The term <b><i>nice</i></b> comes from the idea that if a task increases its nice value from, say, 0 to +10, it is being nice to other tasks in the system by lowering its relative priority.) CFS doesn't use discrete values of time slices and instead identifies a <b>targeted latency</b>, which is an interval of time during which every runnable task should run at least once. Proportions of CPU time are allocated from the value of targeted latency. In addition to having default and minimum values, targeted latency can increase if the number of active tasks in the system grows beyond a certain threshold.</p>
        <p class="text-indent">The CFS scheduler doesn't directly assign priorities. Rather, it records how long each task has run by maintaining the <b>virtual run time</b> of each task using the per-task variable <span class="inlinecode">vruntime</span>. The virtual run time is associated with a decay factor based on the priority of a task: lower-priority tasks have higher rates of decay than higher-priority tasks. For tasks at normal priority (nice values of 0), virtual run time is identical to actual physical run time. Thus, if a task with default priority runs for 200 milliseconds, its <span class="inlinecode">vruntime</span> will also be 200 milliseconds. However, if a lower-priority task runs for 200 milliseconds, its <span class="inlinecode">vruntime</span> will be higher than 200 milliseconds. Similarly, if a higher-priority task runs for 200 milliseconds, its <span class="inlinecode">vruntime</span> will be less than 200 milliseconds. To decide which task to run next, the scheduler simply selects the task that has the smallest <span class="inlinecode">vruntime</span> value. In addition, a higher-priority task that becomes available to run can preempt a lower-priority task.</p>
        <div class="bgbox">
        <p class="boxtitle"><b><i>CFS PERFORMANCE</i></b></p>
        <p class="text"><a id="page_293"></a>The Linux CFS scheduler provides an efficient algorithm for selecting which task to run next. Each runnable task is placed in a red-black tree—a balanced binary search tree whose key is based on the value of <span class="inlinecode">vruntime</span>. This tree is shown below:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p293-001.jpg" alt="image" class="imgepub" width="545" height="287"></p>
        <p class="text-indent">When a task becomes runnable, it is added to the tree. If a task on the tree is not runnable (for example, if it is blocked while waiting for I/O), it is removed. Generally speaking, tasks that have been given less processing time (smaller values of <span class="inlinecode">vruntime</span>) are toward the left side of the tree, and tasks that have been given more processing time are on the right side. According to the properties of a binary search tree, the leftmost node has the smallest key value, which for the sake of the CFS scheduler means that it is the task with the highest priority. Because the red-black tree is balanced, navigating it to discover the leftmost node will require <i>O</i>(<i>lgN</i>) operations (where <i>N</i> is the number of nodes in the tree). However, for efficiency reasons, the Linux scheduler caches this value in the variable <span class="inlinecode">rb_leftmost</span>, and thus determining which task to run next requires only retrieving the cached value.</p>
        </div>
        <p class="text-indent">Let's examine the CFS scheduler in action: Assume that two tasks have the same nice values. One task is I/O-bound and the other is CPU-bound. Typically, the I/O-bound task will run only for short periods before blocking for additional I/O, and the CPU-bound task will exhaust its time period whenever it has an opportunity to run on a processor. Therefore, the value of <span class="inlinecode">vruntime</span> will eventually be lower for the I/O-bound task than for the CPU-bound task, giving the I/O-bound task higher priority than the CPU-bound task. At that point, if the CPU-bound task is executing when the I/O-bound task becomes eligible to run (for example, when I/O the task is waiting for becomes available), the I/O-bound task will preempt the CPU-bound task.</p>
        <p class="text-indent">Linux also implements real-time scheduling using the POSIX standard as described in <a href="13_chapter06.html#sec6.6.6">Section 6.6.6</a>. Any task scheduled using either the SCHED_FIFO or the SCHED_RR real-time policy runs at a higher priority than normal (non-real-time) <a id="page_294"></a>tasks. Linux uses two separate priority ranges, one for real-time tasks and a second for normal tasks. Real-time tasks are assigned static priorities within the range of 0 to 99, and normal (i.e. non real-time) tasks are assigned priorities from 100 to 139. These two ranges map into a global priority scheme wherein numerically lower values indicate higher relative priorities. Normal tasks are assigned a priority based on their nice values, where a value of −20 maps to priority 100 and a nice value of +19 maps to 139. This scheme is shown in <a href="13_chapter06.html#fig6.21">Figure 6.21</a>.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f021.jpg" alt="image" class="imgepub" width="623" height="142"></p>
        <p class="caption"><a id="fig6.21"></a><b>Figure 6.21</b> Scheduling priorities on a Linux system.</p>
        <h3 class="subtitle"><a id="sec6.7.2"></a>6.7.2 Example: Windows Scheduling</h3>
        <p class="text">Windows schedules threads using a priority-based, preemptive scheduling algorithm. The Windows scheduler ensures that the highest-priority thread will always run. The portion of the Windows kernel that handles scheduling is called the <b>dispatcher</b>. A thread selected to run by the dispatcher will run until it is preempted by a higher-priority thread, until it terminates, until its time quantum ends, or until it calls a blocking system call, such as for I/O. If a higher-priority real-time thread becomes ready while a lower-priority thread is running, the lower-priority thread will be preempted. This preemption gives a real-time thread preferential access to the CPU when the thread needs such access.</p>
        <p class="text-indent">The dispatcher uses a 32-level priority scheme to determine the order of thread execution. Priorities are divided into two classes. The <b>variable class</b> contains threads having priorities from 1 to 15, and the <b>real-time class</b> contains threads with priorities ranging from 16 to 31. (There is also a thread running at priority 0 that is used for memory management.) The dispatcher uses a queue for each scheduling priority and traverses the set of queues from highest to lowest until it finds a thread that is ready to run. If no ready thread is found, the dispatcher will execute a special thread called the <b>idle thread</b>.</p>
        <p class="text-indent">There is a relationship between the numeric priorities of the Windows kernel and the Windows API. The Windows API identifies the following six priority classes to which a process can belong:</p>
        <ul style="list-style-type:disc;">
        <li>IDLE_PRIORITY_CLASS</li>
        <li>BELOW_NORMAL_PRIORITY_CLASS</li>
        <li>NORMAL_PRIORITY_CLASS</li>
        <li>ABOVE_NORMAL_PRIORITY_CLASS</li>
        <li><a id="page_295"></a>HIGH_PRIORITY_CLASS</li>
        <li>REALTIME_PRIORITY_CLASS</li>
        </ul>
        <p class="text">Processes are typically members of the NORMAL_PRIORITY_CLASS. A process belongs to this class unless the parent of the process was a member of the IDLE_PRIORITY_CLASS or unless another class was specified when the process was created. Additionally, the priority class of a process can be altered with the <span class="inlinecode">SetPriorityClass()</span> function in the Windows API. Priorities in all classes except the REALTIME_PRIORITY_CLASS are variable, meaning that the priority of a thread belonging to one of these classes can change.</p>
        <p class="text-indent">A thread within a given priority classes also has a relative priority. The values for relative priorities include:</p>
        <ul style="list-style-type:disc;">
        <li>IDLE</li>
        <li>LOWEST</li>
        <li>BELOW_NORMAL</li>
        <li>NORMAL</li>
        <li>ABOVE_NORMAL</li>
        <li>HIGHEST</li>
        <li>TIME_CRITICAL</li>
        </ul>
        <p class="text-indent">The priority of each thread is based on both the priority class it belongs to and its relative priority within that class. This relationship is shown in <a href="13_chapter06.html#fig6.22">Figure 6.22</a>. The values of the priority classes appear in the top row. The left column contains the values for the relative priorities. For example, if the relative priority of a thread in the ABOVE_NORMAL_PRIORITY_CLASS is NORMAL, the numeric priority of that thread is 10.</p>
        <p class="text-indent">Furthermore, each thread has a base priority representing a value in the priority range for the class to which the thread belongs. By default, the base <a id="page_296"></a>priority is the value of the NORMAL relative priority for that class. The base priorities for each priority class are as follows:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f022.jpg" alt="image" class="imgepub" width="615" height="250"></p>
        <p class="caption"><a id="fig6.22"></a><b>Figure 6.22</b> Windows thread priorities.</p>
        <ul style="list-style-type:disc;">
        <li>REALTIME_PRIORITY_CLASS—24</li>
        <li>HIGH_PRIORITY_CLASS—13</li>
        <li>ABOVE_NORMAL_PRIORITY_CLASS—10</li>
        <li>NORMAL_PRIORITY_CLASS—8</li>
        <li>BELOW_NORMAL_PRIORITY_CLASS—6</li>
        <li>IDLE_PRIORITY_CLASS—4</li>
        </ul>
        <p class="text">The initial priority of a thread is typically the base priority of the process the thread belongs to, although the <span class="inlinecode">SetThreadPriority()</span> function in the Windows API can also be used to modify a thread's the base priority.</p>
        <p class="text-indent">When a thread's time quantum runs out, that thread is interrupted. If the thread is in the variable-priority class, its priority is lowered. The priority is never lowered below the base priority, however. Lowering the priority tends to limit the CPU consumption of compute-bound threads. When a variable-priority thread is released from a wait operation, the dispatcher boosts the priority. The amount of the boost depends on what the thread was waiting for. For example, a thread waiting for keyboard I/O would get a large increase, whereas a thread waiting for a disk operation would get a moderate one. This strategy tends to give good response times to interactive threads that are using the mouse and windows. It also enables I/O-bound threads to keep the I/O devices busy while permitting compute-bound threads to use spare CPU cycles in the background. This strategy is used by several time-sharing operating systems, including UNIX. In addition, the window with which the user is currently interacting receives a priority boost to enhance its response time.</p>
        <p class="text-indent">When a user is running an interactive program, the system needs to provide especially good performance. For this reason, Windows has a special scheduling rule for processes in the NORMAL_PRIORITY_CLASS. Windows distinguishes between the <b>foreground process</b> that is currently selected on the screen and the <b>background processes</b> that are not currently selected. When a process moves into the foreground, Windows increases the scheduling quantum by some factor—typically by 3. This increase gives the foreground process three times longer to run before a time-sharing preemption occurs.</p>
        <p class="text-indent">Windows 7 introduced <b>user-mode scheduling (UMS)</b>, which allows applications to create and manage threads independently of the kernel. Thus, an application can create and schedule multiple threads without involving the Windows kernel scheduler. For applications that create a large number of threads, scheduling threads in user mode is much more efficient than kernel-mode thread scheduling, as no kernel intervention is necessary.</p>
        <p class="text-indent">Earlier versions of Windows provided a similar feature known as <b>fibers</b>, which allowed several user-mode threads (fibers) to be mapped to a single kernel thread. However, fibers were of limited practical use. A fiber was unable to make calls to the Windows API because all fibers had to share the thread environment block (TEB) of the thread on which they were running. This <a id="page_297"></a>presented a problem if a Windows API function placed state information into the TEB for one fiber, only to have the information overwritten by a different fiber. UMS overcomes this obstacle by providing each user-mode thread with its own thread context.</p>
        <p class="text-indent">In addition, unlike fibers, UMS is not intended to be used directly by the programmer. The details of writing user-mode schedulers can be very challenging, and UMS does not include such a scheduler. Rather, the schedulers come from programming language libraries that build on top of UMS. For example, Microsoft provides <b>Concurrency Runtime</b> (ConcRT), a concurrent programming framework for C++ that is designed for task-based parallelism (<a href="11_chapter04.html#sec4.2">Section 4.2</a>) on multicore processors. ConcRT provides a user-mode scheduler together with facilities for decomposing programs into tasks, which can then be scheduled on the available processing cores. Further details on UMS can be found in <a href="31_chapter19.html#sec19.7.3.7">Section 19.7.3.7</a>.</p>
        <h3 class="subtitle"><a id="sec6.7.3"></a>6.7.3 Example: Solaris Scheduling</h3>
        <p class="text">Solaris uses priority-based thread scheduling. Each thread belongs to one of six classes:</p>
        <ol style="list-style-type:decimal;">
        <li>Time sharing (TS)</li>
        <li>Interactive (IA)</li>
        <li>Real time (RT)</li>
        <li>System (SYS)</li>
        <li>Fair share (FSS)</li>
        <li>Fixed priority (FP)</li>
        </ol>
        <p class="text">Within each class there are different priorities and different scheduling algorithms.</p>
        <p class="text-indent">The default scheduling class for a process is time sharing. The scheduling policy for the time-sharing class dynamically alters priorities and assigns time slices of different lengths using a multilevel feedback queue. By default, there is an inverse relationship between priorities and time slices. The higher the priority, the smaller the time slice; and the lower the priority, the larger the time slice. Interactive processes typically have a higher priority; CPU-bound processes, a lower priority. This scheduling policy gives good response time for interactive processes and good throughput for CPU-bound processes. The interactive class uses the same scheduling policy as the time-sharing class, but it gives windowing applications—such as those created by the KDE or GNOME window managers—a higher priority for better performance.</p>
        <p class="text-indent"><a href="13_chapter06.html#fig6.23">Figure 6.23</a> shows the dispatch table for scheduling time-sharing and interactive threads. These two scheduling classes include 60 priority levels, but for brevity, we display only a handful. The dispatch table shown in <a href="13_chapter06.html#fig6.23">Figure 6.23</a> contains the following fields:</p>
        <ul style="list-style-type:disc;">
        <li><b>Priority</b>. The class-dependent priority for the time-sharing and interactive classes. A higher number indicates a higher priority.</li>
        </ul>
        <p class="center"><a id="page_298"></a><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f023.jpg" alt="image" class="imgepub" width="501" height="452"></p>
        <p class="caption"><a id="fig6.23"></a><b>Figure 6.23</b> Solaris dispatch table for time-sharing and interactive threads.</p>
        <ul style="list-style-type:disc;">
        <li><b>Time quantum</b>. The time quantum for the associated priority. This illustrates the inverse relationship between priorities and time quanta: the lowest priority (priority 0) has the highest time quantum (200 milliseconds), and the highest priority (priority 59) has the lowest time quantum (20 milliseconds).</li>
        <li><b>Time quantum expired</b>. The new priority of a thread that has used its entire time quantum without blocking. Such threads are considered CPU-intensive. As shown in the table, these threads have their priorities lowered.</li>
        <li><b>Return from sleep</b>. The priority of a thread that is returning from sleeping (such as from waiting for I/O). As the table illustrates, when I/O is available for a waiting thread, its priority is boosted to between 50 and 59, supporting the scheduling policy of providing good response time for interactive processes.</li>
        </ul>
        <p class="text-indent">Threads in the real-time class are given the highest priority. A real-time process will run before a process in any other class. This assignment allows a real-time process to have a guaranteed response from the system within a bounded period of time. In general, however, few processes belong to the real-time class.</p>
        <p class="text-indent">Solaris uses the system class to run kernel threads, such as the scheduler and paging daemon. Once the priority of a system thread is established, it does not change. The system class is reserved for kernel use (user processes running in kernel mode are not in the system class).</p>
        <p class="text-indent"><a id="page_299"></a>The fixed-priority and fair-share classes were introduced with Solaris 9. Threads in the fixed-priority class have the same priority range as those in the time-sharing class; however, their priorities are not dynamically adjusted. The fair-share scheduling class uses CPU <b>shares</b> instead of priorities to make scheduling decisions. CPU shares indicate entitlement to available CPU resources and are allocated to a set of processes (known as a <b>project</b>).</p>
        <p class="text-indent">Each scheduling class includes a set of priorities. However, the scheduler converts the class-specific priorities into global priorities and selects the thread with the highest global priority to run. The selected thread runs on the CPU until it (1) blocks, (2) uses its time slice, or (3) is preempted by a higher-priority thread. If there are multiple threads with the same priority, the scheduler uses a round-robin queue. <a href="13_chapter06.html#fig6.24">Figure 6.24</a> illustrates how the six scheduling classes relate to one another and how they map to global priorities. Notice that the kernel maintains ten threads for servicing interrupts. These threads do not belong to any scheduling class and execute at the highest priority (160–169). As mentioned, Solaris has traditionally used the many-to-many model (<a href="11_chapter04.html#sec4.3.3">Section 4.3.3</a>) but switched to the one-to-one model (<a href="11_chapter04.html#sec4.3.2">Section 4.3.2</a>) beginning with Solaris 9.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f024.jpg" alt="image" class="imgepub" width="355" height="547"></p>
        <p class="caption"><a id="fig6.24"></a><b>Figure 6.24</b> Solaris scheduling.</p>
        <h2 class="subtitle"><a id="sec6.8"></a>6.8 Algorithm Evaluation</h2>
        <p class="text"><a id="page_300"></a>How do we select a CPU-scheduling algorithm for a particular system? As we saw in <a href="13_chapter06.html#sec6.3">Section 6.3</a>, there are many scheduling algorithms, each with its own parameters. As a result, selecting an algorithm can be difficult.</p>
        <p class="text-indent">The first problem is defining the criteria to be used in selecting an algorithm. As we saw in <a href="13_chapter06.html#sec6.2">Section 6.2</a>, criteria are often defined in terms of CPU utilization, response time, or throughput. To select an algorithm, we must first define the relative importance of these elements. Our criteria may include several measures, such as these:</p>
        <ul style="list-style-type:disc;">
        <li>Maximizing CPU utilization under the constraint that the maximum response time is 1 second</li>
        <li>Maximizing throughput such that turnaround time is (on average) linearly proportional to total execution time</li>
        </ul>
        <p class="text-indent">Once the selection criteria have been defined, we want to evaluate the algorithms under consideration. We next describe the various evaluation methods we can use.</p>
        <h3 class="subtitle"><a id="sec6.8.1"></a>6.8.1 Deterministic Modeling</h3>
        <p class="text">One major class of evaluation methods is <b>analytic evaluation</b>. Analytic evaluation uses the given algorithm and the system workload to produce a formula or number to evaluate the performance of the algorithm for that workload.</p>
        <p class="text-indent"><b>Deterministic modeling</b> is one type of analytic evaluation. This method takes a particular predetermined workload and defines the performance of each algorithm for that workload. For example, assume that we have the workload shown below. All five processes arrive at time 0, in the order given, with the length of the CPU burst given in milliseconds:</p>
        <table class="bodytable">
        <colgroup>
        <col width="50%">
        <col width="50%">
        </colgroup>
        <thead>
        <tr>
        <td class="tabularhead"><span class="underline">Process</span></td>
        <td class="tabularhead"><span class="underline">Burst Time</span></td>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>1</sub></td>
        <td class="tabularentry" align="center">10</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>2</sub></td>
        <td class="tabularentry" align="center">29</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>3</sub></td>
        <td class="tabularentry" align="center">3</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>4</sub></td>
        <td class="tabularentry" align="center">7</td>
        </tr>
        <tr>
        <td class="tabularentry" align="center"><i>P</i><sub>5</sub></td>
        <td class="tabularentry" align="center">12</td>
        </tr>
        </tbody>
        </table>
        <p class="text">Consider the FCFS, SJF, and RR (quantum = 10 milliseconds) scheduling algorithms for this set of processes. Which algorithm would give the minimum average waiting time?</p>
        <p class="text-indent">For the FCFS algorithm, we would execute the processes as</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p300-001.jpg" alt="image" class="imgepub" width="628" height="69"></p>
        <p class="text"><a id="page_301"></a>The waiting time is 0 milliseconds for process <i>P</i><sub>1</sub>, 10 milliseconds for process <i>P</i><sub>2</sub>, 39 milliseconds for process <i>P</i><sub>3</sub>, 42 milliseconds for process <i>P</i><sub>4</sub>, and 49 milliseconds for process <i>P</i><sub>5</sub>. Thus, the average waiting time is (0 + 10 + 39 + 42 + 49)/5 = 28 milliseconds.</p>
        <p class="text-indent">With nonpreemptive SJF scheduling, we execute the processes as</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p301-001.jpg" alt="image" class="imgepub" width="628" height="69"></p>
        <p class="text">The waiting time is 10 milliseconds for process <i>P</i><sub>1</sub>, 32 milliseconds for process <i>P</i><sub>2</sub>, 0 milliseconds for process <i>P</i><sub>3</sub>, 3 milliseconds for process <i>P</i><sub>4</sub>, and 20 milliseconds for process <i>P</i><sub>5</sub>. Thus, the average waiting time is (10 + 32 + 0 + 3 + 20)/5 = 13 milliseconds.</p>
        <p class="text-indent">With the RR algorithm, we execute the processes as</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p301-002.jpg" alt="image" class="imgepub" width="625" height="69"></p>
        <p class="text">The waiting time is 0 milliseconds for process <i>P</i><sub>1</sub>, 32 milliseconds for process <i>P</i><sub>2</sub>, 20 milliseconds for process <i>P</i><sub>3</sub>, 23 milliseconds for process <i>P</i><sub>4</sub>, and 40 milliseconds for process <i>P</i><sub>5</sub>. Thus, the average waiting time is (0 + 32 + 20 + 23 + 40)/5 = 23 milliseconds.</p>
        <p class="text-indent">We can see that, in this case, the average waiting time obtained with the SJF policy is less than half that obtained with FCFS scheduling; the RR algorithm gives us an intermediate value.</p>
        <p class="text-indent">Deterministic modeling is simple and fast. It gives us exact numbers, allowing us to compare the algorithms. However, it requires exact numbers for input, and its answers apply only to those cases. The main uses of deterministic modeling are in describing scheduling algorithms and providing examples. In cases where we are running the same program over and over again and can measure the program's processing requirements exactly, we may be able to use deterministic modeling to select a scheduling algorithm. Furthermore, over a set of examples, deterministic modeling may indicate trends that can then be analyzed and proved separately. For example, it can be shown that, for the environment described (all processes and their times available at time 0), the SJF policy will always result in the minimum waiting time.</p>
        <h3 class="subtitle"><a id="sec6.8.2"></a>6.8.2 Queueing Models</h3>
        <p class="text">On many systems, the processes that are run vary from day to day, so there is no static set of processes (or times) to use for deterministic modeling. What can be determined, however, is the distribution of CPU and I/O bursts. These distributions can be measured and then approximated or simply estimated. The result is a mathematical formula describing the probability of a particular CPU burst. Commonly, this distribution is exponential and is described by its mean. Similarly, we can describe the distribution of times when processes arrive in the system (the arrival-time distribution). From these two distributions, it is <a id="page_302"></a>possible to compute the average throughput, utilization, waiting time, and so on for most algorithms.</p>
        <p class="text-indent">The computer system is described as a network of servers. Each server has a queue of waiting processes. The CPU is a server with its ready queue, as is the I/O system with its device queues. Knowing arrival rates and service rates, we can compute utilization, average queue length, average wait time, and so on. This area of study is called <b>queueing-network analysis</b>.</p>
        <p class="text-indent">As an example, let <i>n</i> be the average queue length (excluding the process being serviced), let <i>W</i> be the average waiting time in the queue, and let λ be the average arrival rate for new processes in the queue (such as three processes per second). We expect that during the time <i>W</i> that a process waits, λ × <i>W</i> new processes will arrive in the queue. If the system is in a steady state, then the number of processes leaving the queue must be equal to the number of processes that arrive. Thus,</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p302-001.jpg" alt="image" class="imgepub" width="89" height="15"></p>
        <p class="text">This equation, known as <b>Little's formula</b>, is particularly useful because it is valid for any scheduling algorithm and arrival distribution.</p>
        <p class="text-indent">We can use Little's formula to compute one of the three variables if we know the other two. For example, if we know that 7 processes arrive every second (on average) and that there are normally 14 processes in the queue, then we can compute the average waiting time per process as 2 seconds.</p>
        <p class="text-indent">Queueing analysis can be useful in comparing scheduling algorithms, but it also has limitations. At the moment, the classes of algorithms and distributions that can be handled are fairly limited. The mathematics of complicated algorithms and distributions can be difficult to work with. Thus, arrival and service distributions are often defined in mathematically tractable—but unrealistic—ways. It is also generally necessary to make a number of independent assumptions, which may not be accurate. As a result of these difficulties, queueing models are often only approximations of real systems, and the accuracy of the computed results may be questionable.</p>
        <h3 class="subtitle"><a id="sec6.8.3"></a>6.8.3 Simulations</h3>
        <p class="text">To get a more accurate evaluation of scheduling algorithms, we can use simulations. Running simulations involves programming a model of the computer system. Software data structures represent the major components of the system. The simulator has a variable representing a clock. As this variable's value is increased, the simulator modifies the system state to reflect the activities of the devices, the processes, and the scheduler. As the simulation executes, statistics that indicate algorithm performance are gathered and printed.</p>
        <p class="text-indent">The data to drive the simulation can be generated in several ways. The most common method uses a random-number generator that is programmed to generate processes, CPU burst times, arrivals, departures, and so on, according to probability distributions. The distributions can be defined mathematically (uniform, exponential, Poisson) or empirically. If a distribution is to be defined empirically, measurements of the actual system under study are taken. The results define the distribution of events in the real system; this distribution can then be used to drive the simulation.</p>
        <p class="center"><a id="page_303"></a><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/ch006-f025.jpg" alt="image" class="imgepub" width="569" height="355"></p>
        <p class="caption"><a id="fig6.25"></a><b>Figure 6.25</b> Evaluation of CPU schedulers by simulation.</p>
        <p class="text-indent">A distribution-driven simulation may be inaccurate, however, because of relationships between successive events in the real system. The frequency distribution indicates only how many instances of each event occur; it does not indicate anything about the order of their occurrence. To correct this problem, we can use <b>trace tapes</b>. We create a trace tape by monitoring the real system and recording the sequence of actual events (<a href="13_chapter06.html#fig6.25">Figure 6.25</a>). We then use this sequence to drive the simulation. Trace tapes provide an excellent way to compare two algorithms on exactly the same set of real inputs. This method can produce accurate results for its inputs.</p>
        <p class="text-indent">Simulations can be expensive, often requiring hours of computer time. A more detailed simulation provides more accurate results, but it also takes more computer time. In addition, trace tapes can require large amounts of storage space. Finally, the design, coding, and debugging of the simulator can be a major task.</p>
        <h3 class="subtitle"><a id="sec6.8.4"></a>6.8.4 Implementation</h3>
        <p class="text">Even a simulation is of limited accuracy. The only completely accurate way to evaluate a scheduling algorithm is to code it up, put it in the operating system, and see how it works. This approach puts the actual algorithm in the real system for evaluation under real operating conditions.</p>
        <p class="text-indent">The major difficulty with this approach is the high cost. The expense is incurred not only in coding the algorithm and modifying the operating system to support it (along with its required data structures) but also in the reaction of the users to a constantly changing operating system. Most users are not interested in building a better operating system; they merely want to get their processes executed and use their results. A constantly changing operating system does not help the users to get their work done.</p>
        <p class="text-indent">Another difficulty is that the environment in which the algorithm is used will change. The environment will change not only in the usual way, as new <a id="page_304"></a>programs are written and the types of problems change, but also as a result of the performance of the scheduler. If short processes are given priority, then users may break larger processes into sets of smaller processes. If interactive processes are given priority over noninteractive processes, then users may switch to interactive use.</p>
        <p class="text-indent">For example, researchers designed one system that classified interactive and noninteractive processes automatically by looking at the amount of terminal I/O. If a process did not input or output to the terminal in a 1-second interval, the process was classified as noninteractive and was moved to a lower-priority queue. In response to this policy, one programmer modified his programs to write an arbitrary character to the terminal at regular intervals of less than 1 second. The system gave his programs a high priority, even though the terminal output was completely meaningless.</p>
        <p class="text-indent">The most flexible scheduling algorithms are those that can be altered by the system managers or by the users so that they can be tuned for a specific application or set of applications. A workstation that performs high-end graphical applications, for instance, may have scheduling needs different from those of a Web server or file server. Some operating systems—particularly several versions of UNIX—allow the system manager to fine-tune the scheduling parameters for a particular system configuration. For example, Solaris provides the <span class="inlinecode">dispadmin</span> command to allow the system administrator to modify the parameters of the scheduling classes described in <a href="13_chapter06.html#sec6.7.3">Section 6.7.3</a>.</p>
        <p class="text-indent">Another approach is to use APIs that can modify the priority of a process or thread. The Java, POSIX, and Windows API provide such functions. The downfall of this approach is that performance-tuning a system or application most often does not result in improved performance in more general situations.</p>
        <h2 class="subtitle"><a id="sec6.9"></a>6.9 Summary</h2>
        <p class="text">CPU scheduling is the task of selecting a waiting process from the ready queue and allocating the CPU to it. The CPU is allocated to the selected process by the dispatcher.</p>
        <p class="text-indent">First-come, first-served (FCFS) scheduling is the simplest scheduling algorithm, but it can cause short processes to wait for very long processes. Shortest-job-first (SJF) scheduling is provably optimal, providing the shortest average waiting time. Implementing SJF scheduling is difficult, however, because predicting the length of the next CPU burst is difficult. The SJF algorithm is a special case of the general priority scheduling algorithm, which simply allocates the CPU to the highest-priority process. Both priority and SJF scheduling may suffer from starvation. Aging is a technique to prevent starvation.</p>
        <p class="text-indent">Round-robin (RR) scheduling is more appropriate for a time-shared (interactive) system. RR scheduling allocates the CPU to the first process in the ready queue for <i>q</i> time units, where <i>q</i> is the time quantum. After <i>q</i> time units, if the process has not relinquished the CPU, it is preempted, and the process is put at the tail of the ready queue. The major problem is the selection of the time quantum. If the quantum is too large, RR scheduling degenerates to FCFS scheduling. If the quantum is too small, scheduling overhead in the form of context-switch time becomes excessive.</p>
        <p class="text-indent"><a id="page_305"></a>The FCFS algorithm is nonpreemptive; the RR algorithm is preemptive. The SJF and priority algorithms may be either preemptive or nonpreemptive.</p>
        <p class="text-indent">Multilevel queue algorithms allow different algorithms to be used for different classes of processes. The most common model includes a foreground interactive queue that uses RR scheduling and a background batch queue that uses FCFS scheduling. Multilevel feedback queues allow processes to move from one queue to another.</p>
        <p class="text-indent">Many contemporary computer systems support multiple processors and allow each processor to schedule itself independently. Typically, each processor maintains its own private queue of processes (or threads), all of which are available to run. Additional issues related to multiprocessor scheduling include processor affinity, load balancing, and multicore processing.</p>
        <p class="text-indent">A real-time computer system requires that results arrive within a deadline period; results arriving after the deadline has passed are useless. Hard real-time systems must guarantee that real-time tasks are serviced within their deadline periods. Soft real-time systems are less restrictive, assigning real-time tasks higher scheduling priority than other tasks.</p>
        <p class="text-indent">Real-time scheduling algorithms include rate-monotonic and earliest-deadline-first scheduling. Rate-monotonic scheduling assigns tasks that require the CPU more often a higher priority than tasks that require the CPU less often. Earliest-deadline-first scheduling assigns priority according to upcoming deadlines—the earlier the deadline, the higher the priority. Proportional share scheduling divides up processor time into shares and assigning each process a number of shares, thus guaranteeing each process a proportional share of CPU time. The POSIX Pthread API provides various features for scheduling real-time threads as well.</p>
        <p class="text-indent">Operating systems supporting threads at the kernel level must schedule threads—not processes—for execution. This is the case with Solaris and Windows. Both of these systems schedule threads using preemptive, priority-based scheduling algorithms, including support for real-time threads. The Linux process scheduler uses a priority-based algorithm with real-time support as well. The scheduling algorithms for these three operating systems typically favor interactive over CPU-bound processes.</p>
        <p class="text-indent">The wide variety of scheduling algorithms demands that we have methods to select among algorithms. Analytic methods use mathematical analysis to determine the performance of an algorithm. Simulation methods determine performance by imitating the scheduling algorithm on a “representative” sample of processes and computing the resulting performance. However, simulation can at best provide an approximation of actual system performance. The only reliable technique for evaluating a scheduling algorithm is to implement the algorithm on an actual system and monitor its performance in a “real-world” environment.</p>
        <h2 class="subhead">Practice Exercises</h2>
        <p class="list">&nbsp;&nbsp;<b>6.1</b>&nbsp;&nbsp;&nbsp;A CPU-scheduling algorithm determines an order for the execution of its scheduled processes. Given <i>n</i> processes to be scheduled on one processor, how many different schedules are possible? Give a formula in terms of <i>n.</i></p>
        <p class="list"><a id="page_306"></a>&nbsp;&nbsp;<b>6.2</b>&nbsp;&nbsp;&nbsp;Explain the difference between preemptive and nonpreemptive scheduling.</p>
        <p class="list">&nbsp;&nbsp;<b>6.3</b>&nbsp;&nbsp;&nbsp;Suppose that the following processes arrive for execution at the times indicated. Each process will run for the amount of time listed. In answering the questions, use nonpreemptive scheduling, and base all decisions on the information you have at the time the decision must be made.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p306-001.jpg" alt="image" class="imgepub" width="318" height="96"></p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>What is the average turnaround time for these processes with the FCFS scheduling algorithm?</li>
        <li>What is the average turnaround time for these processes with the SJF scheduling algorithm?</li>
        <li>The SJF algorithm is supposed to improve performance, but notice that we chose to run process <i>P</i><sub>1</sub> at time 0 because we did not know that two shorter processes would arrive soon. Compute what the average turnaround time will be if the CPU is left idle for the first 1 unit and then SJF scheduling is used. Remember that processes <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub> are waiting during this idle time, so their waiting time may increase. This algorithm could be called future-knowledge scheduling.</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.4</b>&nbsp;&nbsp;&nbsp;What advantage is there in having different time-quantum sizes at different levels of a multilevel queueing system?</p>
        <p class="list">&nbsp;&nbsp;<b>6.5</b>&nbsp;&nbsp;&nbsp;Many CPU-scheduling algorithms are parameterized. For example, the RR algorithm requires a parameter to indicate the time slice. Multilevel feedback queues require parameters to define the number of queues, the scheduling algorithm for each queue, the criteria used to move processes between queues, and so on.</p>
        <p class="list-indent">These algorithms are thus really sets of algorithms (for example, the set of RR algorithms for all time slices, and so on). One set of algorithms may include another (for example, the FCFS algorithm is the RR algorithm with an infinite time quantum). What (if any) relation holds between the following pairs of algorithm sets?</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>Priority and SJF</li>
        <li>Multilevel feedback queues and FCFS</li>
        <li>Priority and FCFS</li>
        <li>RR and SJF</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.6</b>&nbsp;&nbsp;&nbsp;Suppose that a scheduling algorithm (at the level of short-term CPU scheduling) favors those processes that have used the least processor <a id="page_307"></a>time in the recent past. Why will this algorithm favor I/O-bound programs and yet not permanently starve CPU-bound programs?</p>
        <p class="list">&nbsp;&nbsp;<b>6.7</b>&nbsp;&nbsp;&nbsp;Distinguish between PCS and SCS scheduling.</p>
        <p class="list">&nbsp;&nbsp;<b>6.8</b>&nbsp;&nbsp;&nbsp;Assume that an operating system maps user-level threads to the kernel using the many-to-many model and that the mapping is done through the use of LWPs. Furthermore, the system allows program developers to create real-time threads. Is it necessary to bind a real-time thread to an LWP?</p>
        <p class="list">&nbsp;&nbsp;<b>6.9</b>&nbsp;&nbsp;&nbsp;The traditional UNIX scheduler enforces an inverse relationship between priority numbers and priorities: the higher the number, the lower the priority. The scheduler recalculates process priorities once per second using the following function:</p>
        <p class="list-indent">&nbsp; &nbsp; &nbsp;Priority = (recent CPU usage / 2) + base</p>
        <p class="list-text">where base = 60 and <i>recent CPU usage</i> refers to a value indicating how often a process has used the CPU since priorities were last recalculated.</p>
        <p class="list-indent">Assume that recent CPU usage is 40 for process <i>P</i><sub>1</sub>, 18 for process <i>P</i><sub>2</sub>, and 10 for process <i>P</i><sub>3</sub>. What will be the new priorities for these three processes when priorities are recalculated? Based on this information, does the traditional UNIX scheduler raise or lower the relative priority of a CPU-bound process?</p>
        <h3 class="subtitle"><a id="chap6-exer"></a>Exercises</h3>
        <p class="list">&nbsp;&nbsp;<b>6.10</b> Why is it important for the scheduler to distinguish I/O-bound programs from CPU-bound programs?</p>
        <p class="list">&nbsp;&nbsp;<b>6.11</b> Discuss how the following pairs of scheduling criteria conflict in certain settings.</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>CPU utilization and response time</li>
        <li>Average turnaround time and maximum waiting time</li>
        <li>I/O device utilization and CPU utilization</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.12</b> One technique for implementing <b>lottery scheduling</b> works by assigning processes lottery tickets, which are used for allocating CPU time. Whenever a scheduling decision has to be made, a lottery ticket is chosen at random, and the process holding that ticket gets the CPU. The BTV operating system implements lottery scheduling by holding a lottery 50 times each second, with each lottery winner getting 20 milliseconds of CPU time (20 milliseconds × 50 = 1 second). Describe how the BTV scheduler can ensure that higher-priority threads receive more attention from the CPU than lower-priority threads.</p>
        <p class="list">&nbsp;&nbsp;<b>6.13</b> In <a href="12_chapter05.html#chap5">Chapter 5</a>, we discussed possible race conditions on various kernel data structures. Most scheduling algorithms maintain a <b>run queue</b>, which lists processes eligible to run on a processor. On multicore systems, there are two general options: (1) each processing core has its own run <a id="page_308"></a>queue, or (2) a single run queue is shared by all processing cores. What are the advantages and disadvantages of each of these approaches?</p>
        <p class="list">&nbsp;&nbsp;<b>6.14</b> Consider the exponential average formula used to predict the length of the next CPU burst. What are the implications of assigning the following values to the parameters used by the algorithm?</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>α = 0 and τ<sub>0</sub> = 100 milliseconds</li>
        <li>α = 0.99 and τ<sub>0</sub> = 10 milliseconds</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.15</b> A variation of the round-robin scheduler is the <b>regressive round-robin</b> scheduler. This scheduler assigns each process a time quantum and a priority. The initial value of a time quantum is 50 milliseconds. However, every time a process has been allocated the CPU and uses its entire time quantum (does not block for I/O), 10 milliseconds is added to its time quantum, and its priority level is boosted. (The time quantum for a process can be increased to a maximum of 100 milliseconds.) When a process blocks before using its entire time quantum, its time quantum is reduced by 5 milliseconds, but its priority remains the same. What type of process (CPU-bound or I/O-bound) does the regressive round-robin scheduler favor? Explain.</p>
        <p class="list">&nbsp;&nbsp;<b>6.16</b> Consider the following set of processes, with the length of the CPU burst given in milliseconds:</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p308-001.jpg" alt="image" class="imgepub" width="275" height="143"></p>
        <p class="list-text">The processes are assumed to have arrived in the order <i>P</i><sub>1</sub>, <i>P</i><sub>2</sub>, <i>P</i><sub>3</sub>, <i>P</i><sub>4</sub>, <i>P</i><sub>5</sub>, all at time 0.</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>Draw four Gantt charts that illustrate the execution of these processes using the following scheduling algorithms: FCFS, SJF, nonpreemptive priority (a larger priority number implies a higher priority), and RR (quantum = 2).</li>
        <li>What is the turnaround time of each process for each of the scheduling algorithms in part a?</li>
        <li>What is the waiting time of each process for each of these scheduling algorithms?</li>
        <li>Which of the algorithms results in the minimum average waiting time (over all processes)?</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.17</b> The following processes are being scheduled using a preemptive, round-robin scheduling algorithm. Each process is assigned a numerical priority, with a higher number indicating a higher relative priority. In addition to the processes listed below, the system also has an <b><i>idle task</i></b> <a id="page_309"></a>(which consumes no CPU resources and is identified as <i>P<sub>idle</sub></i>). This task has priority 0 and is scheduled whenever the system has no other available processes to run. The length of a time quantum is 10 units. If a process is preempted by a higher-priority process, the preempted process is placed at the end of the queue.</p>
        <p class="center"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781118063330/files/images/p309-001.jpg" alt="image" class="imgepub" width="337" height="175"></p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>Show the scheduling order of the processes using a Gantt chart.</li>
        <li>What is the turnaround time for each process?</li>
        <li>What is the waiting time for each process?</li>
        <li>What is the CPU utilization rate?</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.18</b> The <span class="inlinecode">nice</span> command is used to set the nice value of a process on Linux, as well as on other UNIX systems. Explain why some systems may allow any user to assign a process a nice value &gt;= 0 yet allow only the root user to assign nice values &lt; 0.</p>
        <p class="list">&nbsp;&nbsp;<b>6.19</b> Which of the following scheduling algorithms could result in starvation?</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>First-come, first-served</li>
        <li>Shortest job first</li>
        <li>Round robin</li>
        <li>Priority</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.20</b> Consider a variant of the RR scheduling algorithm in which the entries in the ready queue are pointers to the PCBs.</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>What would be the effect of putting two pointers to the same process in the ready queue?</li>
        <li>What would be two major advantages and two disadvantages of this scheme?</li>
        <li>How would you modify the basic RR algorithm to achieve the same effect without the duplicate pointers?</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.21</b> Consider a system running ten I/O-bound tasks and one CPU-bound task. Assume that the I/O-bound tasks issue an I/O operation once for every millisecond of CPU computing and that each I/O operation takes 10 milliseconds to complete. Also assume that the context-switching overhead is 0.1 millisecond and that all processes are long-running tasks. Describe the CPU utilization for a round-robin scheduler when:</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li><a id="page_310"></a>The time quantum is 1 millisecond</li>
        <li>The time quantum is 10 milliseconds</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.22</b> Consider a system implementing multilevel queue scheduling. What strategy can a computer user employ to maximize the amount of CPU time allocated to the user's process?</p>
        <p class="list">&nbsp;&nbsp;<b>6.23</b> Consider a preemptive priority scheduling algorithm based on dynamically changing priorities. Larger priority numbers imply higher priority. When a process is waiting for the CPU (in the ready queue, but not running), its priority changes at a rate α. When it is running, its priority changes at a rate β. All processes are given a priority of 0 when they enter the ready queue. The parameters α and β can be set to give many different scheduling algorithms.</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>What is the algorithm that results from β &gt; α &gt; 0?</li>
        <li>What is the algorithm that results from α &lt; β &lt; 0?</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.24</b> Explain the differences in how much the following scheduling algorithms discriminate in favor of short processes:</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>FCFS</li>
        <li>RR</li>
        <li>Multilevel feedback queues</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.25</b> Using the Windows scheduling algorithm, determine the numeric priority of each of the following threads.</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>A thread in the REALTIME_PRIORITY_CLASS with a relative priority of NORMAL</li>
        <li>A thread in the ABOVE_NORMAL_PRIORITY_CLASS with a relative priority of HIGHEST</li>
        <li>A thread in the BELOW_NORMAL_PRIORITY_CLASS with a relative priority of ABOVE_NORMAL</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.26</b> Assuming that no threads belong to the REALTIME_PRIORITY_CLASS and that none may be assigned a TIME_CRITICAL priority, what combination of priority class and priority corresponds to the highest possible relative priority in Windows scheduling?</p>
        <p class="list">&nbsp;&nbsp;<b>6.27</b> Consider the scheduling algorithm in the Solaris operating system for time-sharing threads.</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>What is the time quantum (in milliseconds) for a thread with priority 15? With priority 40?</li>
        <li>Assume that a thread with priority 50 has used its entire time quantum without blocking. What new priority will the scheduler assign this thread?</li>
        <li>Assume that a thread with priority 20 blocks for I/O before its time quantum has expired. What new priority will the scheduler assign this thread?</li>
        </ol>
        <p class="list"><a id="page_311"></a>&nbsp;&nbsp;<b>6.28</b> Assume that two tasks <i>A</i> and <i>B</i> are running on a Linux system. The nice values of <i>A</i> and <i>B</i> are −5 and +5, respectively. Using the CFS scheduler as a guide, describe how the respective values of <span class="inlinecode">vruntime</span> vary between the two processes given each of the following scenarios:</p>
        <ul style="list-style-type:disc;margin-left:1.5em;">
        <li>Both <i>A</i> and <i>B</i> are CPU-bound.</li>
        <li><i>A</i> is I/O-bound, and <i>B</i> is CPU-bound.</li>
        <li><i>A</i> is CPU-bound, and <i>B</i> is I/O-bound.</li>
        </ul>
        <p class="list">&nbsp;&nbsp;<b>6.29</b> Discuss ways in which the priority inversion problem could be addressed in a real-time system. Also discuss whether the solutions could be implemented within the context of a proportional share scheduler.</p>
        <p class="list">&nbsp;&nbsp;<b>6.30</b> Under what circumstances is rate-monotonic scheduling inferior to earliest-deadline-first scheduling in meeting the deadlines associated with processes?</p>
        <p class="list">&nbsp;&nbsp;<b>6.31</b> Consider two processes, <i>P</i><sub>1</sub> and <i>P</i><sub>2</sub>, where <i>p</i><sub>1</sub> = 50, <i>t</i><sub>1</sub> = 25, <i>p</i><sub>2</sub> = 75, and <i>t</i><sub>2</sub> = 30.</p>
        <ol style="list-style-type:lower-alpha;margin-left:2em;">
        <li>Can these two processes be scheduled using rate-monotonic scheduling? Illustrate your answer using a Gantt chart such as the ones in <a href="13_chapter06.html#fig6.16">Figure 6.16</a>–<a href="13_chapter06.html#fig6.19">Figure 6.19</a>.</li>
        <li>Illustrate the scheduling of these two processes using earliest-deadline-first (EDF) scheduling.</li>
        </ol>
        <p class="list">&nbsp;&nbsp;<b>6.32</b> Explain why interrupt and dispatch latency times must be bounded in a hard real-time system.</p>
        <h3 class="subtitle"><a id="chap6-bibli"></a>Bibliographical Notes</h3>
        <p class="text">Feedback queues were originally implemented on the CTSS system described in [Corbato et al. (1962)]. This feedback queue scheduling system was analyzed by [Schrage (1967)]. The preemptive priority scheduling algorithm of Exercise 6.23 was suggested by [Kleinrock (1975)]. The scheduling algorithms for hard real-time systems, such as rate monotonic scheduling and earliest-deadline-first scheduling, are presented in [Liu and Layland (1973)].</p>
        <p class="text-indent">[Anderson et al. (1989)], [Lewis and Berg (1998)], and [Philbin et al. (1996)] discuss thread scheduling. Multicore scheduling is examined in [McNairy and Bhatia (2005)] and [Kongetira et al. (2005)].</p>
        <p class="text-indent">[Fisher (1981)], [Hall et al. (1996)], and [Lowney et al. (1993)] describe scheduling techniques that take into account information regarding process execution times from previous runs.</p>
        <p class="text-indent">Fair-share schedulers are covered by [Henry (1984)], [Woodside (1986)], and [Kay and Lauder (1988)].</p>
        <p class="text-indent">Scheduling policies used in the UNIX V operating system are described by [Bach (1987)]; those for UNIX FreeBSD 5.2 are presented by [McKusick and Neville-Neil (2005)]; and those for the Mach operating system are discussed by [Black (1990)]. [Love (2010)] and [Mauerer (2008)] cover scheduling in <a id="page_312"></a>Linux. [Faggioli et al. (2009)] discuss adding an EDF scheduler to the Linux kernel. Details of the ULE scheduler can be found in [Roberson (2003)]. Solaris scheduling is described by [Mauro and McDougall (2007)]. [Russinovich and Solomon (2009)] discusses scheduling in Windows internals. [Butenhof (1997)] and [Lewis and Berg (1998)] describe scheduling in Pthreads systems. [Siddha et al. (2007)] discuss scheduling challenges on multicore systems.</p>
        <h2 class="subhead">Bibliography</h2>
        <p class="reference"><b>[Anderson et al. (1989)]</b> T. E. Anderson, E. D. Lazowska, and H. M. Levy, “The Performance Implications of Thread Management Alternatives for Shared-Memory Multiprocessors”, <i>IEEE Transactions on Computers</i>, Volume 38, Number 12 (1989), pages 1631–1644.</p>
        <p class="reference"><b>[Bach (1987)]</b> M. J. Bach, <i>The Design of the UNIX Operating System</i>, Prentice Hall (1987).</p>
        <p class="reference"><b>[Black (1990)]</b> D. L. Black, “Scheduling Support for Concurrency and Parallelism in the Mach Operating System”, <i>IEEE Computer</i>, Volume 23, Number 5 (1990), pages 35–43.</p>
        <p class="reference"><b>[Butenhof (1997)]</b> D. Butenhof, <i>Programming with POSIX Threads</i>, Addison-Wesley (1997).</p>
        <p class="reference"><b>[Corbato et al. (1962)]</b> F. J. Corbato, M. Merwin-Daggett, and R. C. Daley, “An Experimental Time-Sharing System”, <i>Proceedings of the AFIPS Fall Joint Computer Conference</i> (1962), pages 335–344.</p>
        <p class="reference"><b>[Faggioli et al. (2009)]</b> D. Faggioli, F. Checconi, M. Trimarchi, and C. Scordino, “An EDF scheduling class for the Linux kernel”, <i>Proceedings of the 11th Real-Time Linux Workshop</i> (2009).</p>
        <p class="reference"><b>[Fisher (1981)]</b> J. A. Fisher, “Trace Scheduling: A Technique for Global Microcode Compaction”, <i>IEEE Transactions on Computers</i>, Volume 30, Number 7 (1981), pages 478–490.</p>
        <p class="reference"><b>[Hall et al. (1996)]</b> L. Hall, D. Shmoys, and J. Wein, “Scheduling To Minimize Average Completion Time: Off-line and On-line Algorithms”, <i>SODA: ACM-SIAM Symposium on Discrete Algorithms</i> (1996).</p>
        <p class="reference"><b>[Henry (1984)]</b> G. Henry, “The Fair Share Scheduler”, <i>AT&amp;T Bell Laboratories Technical Journal</i> (1984).</p>
        <p class="reference"><b>[Kay and Lauder (1988)]</b> J. Kay and P. Lauder, “A Fair Share Scheduler”, <i>Communications of the ACM</i>, Volume 31, Number 1 (1988), pages 44–55.</p>
        <p class="reference"><b>[Kleinrock (1975)]</b> L. Kleinrock, <i>Queueing Systems, Volume II: Computer Applications</i>, Wiley-Interscience (1975).</p>
        <p class="reference"><b>[Kongetira et al. (2005)]</b> P. Kongetira, K. Aingaran, and K. Olukotun, “Niagara: A 32-Way Multithreaded SPARC Processor”, <i>IEEE Micro Magazine</i>, Volume 25, Number 2 (2005), pages 21–29.</p>
        <p class="reference"><a id="page_313"></a><b>[Lewis and Berg (1998)]</b> B. Lewis and D. Berg, <i>Multithreaded Programming with Pthreads</i>, Sun Microsystems Press (1998).</p>
        <p class="reference"><b>[Liu and Layland (1973)]</b> C. L. Liu and J. W. Layland, “Scheduling Algorithms for Multiprogramming in a Hard Real-Time Environment”, <i>Communications of the ACM</i>, Volume 20, Number 1 (1973), pages 46–61.</p>
        <p class="reference"><b>[Love (2010)]</b> R. Love, <i>Linux Kernel Development</i>, Third Edition, Developer's Library (2010).</p>
        <p class="reference"><b>[Lowney et al. (1993)]</b> P. G. Lowney, S. M. Freudenberger, T. J. Karzes, W. D. Lichtenstein, R. P. Nix, J. S. O'Donnell, and J. C. Ruttenberg, “The Multiflow Trace Scheduling Compiler”, <i>Journal of Supercomputing</i>, Volume 7, Number 1-2 (1993), pages 51–142.</p>
        <p class="reference"><b>[Mauerer (2008)]</b> W. Mauerer, <i>Professional Linux Kernel Architecture</i>, John Wiley and Sons (2008).</p>
        <p class="reference"><b>[Mauro and McDougall (2007)]</b> J. Mauro and R. McDougall, <i>Solaris Internals: Core Kernel Architecture</i>, Prentice Hall (2007).</p>
        <p class="reference"><b>[McKusick and Neville-Neil (2005)]</b> M. K. McKusick and G. V. Neville-Neil, <i>The Design and Implementation of the FreeBSD UNIX Operating System</i>, Addison Wesley (2005).</p>
        <p class="reference"><b>[McNairy and Bhatia (2005)]</b> C. McNairy and R. Bhatia, “Montecito: A Dual–Core, Dual-Threaded Itanium Processor”, <i>IEEE Micro Magazine</i>, Volume 25, Number 2 (2005), pages 10–20.</p>
        <p class="reference"><b>[Philbin et al. (1996)]</b> J. Philbin, J. Edler, O. J. Anshus, C. C. Douglas, and K. Li, “Thread Scheduling for Cache Locality”, <i>Architectural Support for Programming Languages and Operating Systems</i> (1996), pages 60–71.</p>
        <p class="reference"><b>[Roberson (2003)]</b> J. Roberson, “ULE: A Modern Scheduler For FreeBSD”, <i>Proceedings of the USENIX BSDCon Conference</i> (2003), pages 17–28.</p>
        <p class="reference"><b>[Russinovich and Solomon (2009)]</b> M. E. Russinovich and D. A. Solomon, <i>Windows Internals: Including Windows Server 2008 and Windows Vista</i>, Fifth Edition, Microsoft Press (2009).</p>
        <p class="reference"><b>[Schrage (1967)]</b> L. E. Schrage, “The Queue M/G/I with Feedback to Lower Priority Queues”, <i>Management Science</i>, Volume 13, (1967), pages 466–474.</p>
        <p class="reference"><b>[Siddha et al. (2007)]</b> S. Siddha, V. Pallipadi, and A. Mallick, “Process Scheduling Challenges in the Era of Multi-Core Processors”, <i>Intel Technology Journal</i>, Volume 11, Number 4 (2007).</p>
        <p class="reference"><b>[Woodside (1986)]</b> C. Woodside, “Controllability of Computer Performance Tradeoffs Obtained Using Controlled-Share Queue Schedulers”, <i>IEEE Transactions on Software Engineering</i>, Volume SE-12, Number 10 (1986), pages 1041–1048.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781118063330/files/9781118063330.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com