<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="appendix" epub:type="appendix" data-pdf-bookmark="Appendix A. Leftovers: The Top Five Topics We Didn’t Cover"><div class="appendix" id="leftoverscolon_the_top_five_topics_we_di">
        <h1><span class="label">Appendix A. </span>Leftovers: <em>The Top Five Topics We Didn’t Cover</em></h1>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0443-01.png" alt="Image" width="600" height="500">
        <h6></h6>
        </div></figure>
        <p><strong>We’ve covered a lot of ground, and you’re almost finished with this book.</strong> We’ll miss you, but before we let you go, we wouldn’t feel right about sending you out into the world without a <em>little</em> more preparation. Git offers a <em>lot</em> of functionality, and we couldn’t possibly fit all of it in one book. We saved some really juicy bits for this appendix.</p>
        <section data-type="sect1" data-pdf-bookmark="#1 Tags (remember me forever)"><div class="sect1" id="hashone_tags_left_parenthesisremember_me">
        <h1>#1 Tags (remember me forever)</h1>
        <p><a data-type="indexterm" data-primary="branches" data-secondary="compared to tags" id="idm45426355987520"></a><a data-type="indexterm" data-primary="commit histories" data-secondary="tags" id="idm45426355986544"></a><a data-type="indexterm" data-primary="commit IDs" data-secondary="tags" id="idm45426355985472"></a><a data-type="indexterm" data-primary="commits" data-secondary="tags as references" id="idm45426355984368"></a><a data-type="indexterm" data-primary="fetch command" data-secondary="tags" id="idm45426355983264"></a><a data-type="indexterm" data-primary="flags" data-secondary="fetch command" data-tertiary="--tags" id="idm45426355982160"></a><a data-type="indexterm" data-primary="flags" data-secondary="push command" data-tertiary="--tags" id="idm45426355980784"></a><a data-type="indexterm" data-primary="flags" data-secondary="tag command" id="idm45426355979408"></a><a data-type="indexterm" data-primary="flags" data-secondary="tag command" data-tertiary="-l" id="idm45426355978304"></a><a data-type="indexterm" data-primary="flags" data-secondary="tag command" data-tertiary="--list" id="idm45426355976928"></a><a data-type="indexterm" data-primary="flags" data-secondary="tag command" data-tertiary="-list" id="idm45426355975552"></a><a data-type="indexterm" data-primary="git tag command" id="idm45426355974176"></a><a data-type="indexterm" data-primary="-l flag (tag command)" id="idm45426355973344"></a><a data-type="indexterm" data-primary="--list flag (tag command)" id="idm45426355972512"></a><a data-type="indexterm" data-primary="naming conventions" data-secondary="tags" id="idm45426355971712"></a><a data-type="indexterm" data-primary="push command" data-secondary="tags" id="idm45426355970608"></a><a data-type="indexterm" data-primary="tag command" id="idm45426355969504"></a><a data-type="indexterm" data-primary="tags, commit references" id="idm45426355968672"></a><a data-type="indexterm" data-primary="--tags flag (fetch command)" id="idm45426355967840"></a><a data-type="indexterm" data-primary="--tags flag (push command)" id="idm45426355967040"></a>You know that Git branches are sticky notes—a branch is simply a named reference to a commit. You also know that if you make a new commit on a branch, Git moves the branch to point to the new commit ID on that branch. Tags, like branches, are also named references to commits, except that once they are created, they <strong>never</strong> move. Tags are very useful if you want to name a commit so you can find and get it to easily. We use tags to record “landmarks” in a project history. For example, we could tag the commit that marks a specific version of our software, like <code>v1.0.0</code>. Or the commit that fixed a particularly nasty bug. To create a tag, Git offers the <code>git tag</code> command:</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0444-01.png" alt="Image" width="600" height="75">
        <h6></h6>
        </div></figure>
        <p>By default, the <code>tag</code> command will record the current ID (that is, where <code>HEAD</code> points to) in the tag. However, you can supply a specific commit ID after the tag name.</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0444-02.png" alt="Image" width="582" height="88">
        <h6></h6>
        </div></figure>
        <p>Tag names follow the same rules as branch names. They don’t allow spaces (we like using hyphens instead), but they can have forward slashes and periods.</p>
        <p>To list all the tags in your repository, you can simply supply the <code>-l</code> (lowercase “L,” which is shorthand for <code>--list</code>) flag to the <code>git tag</code> command.</p>
        <p>Tags, like branches, are part of your commit history, and you can fetch (and push) tags from the remote to share them with the rest of your team. Both the <code>fetch</code> and <code>push</code> command support the <code>--tags</code> flag. Supplying this flag ensures that the commit history for everyone working on a shared repository accurately reflects all tags that are part of your commit history.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><span style="color:#9D9EA0;">The git pull command also supports the --tags flag.</span></p>
        </div>
        <p>One thing to watch out for—try to avoid naming a tag the same name as a branch. Much like we encourage putting your initials in branch names, we encourage finding appropriate prefixes for tag names. We like using the letter “v” (for “version”) to label version numbers.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="serious_coding-id00317">
        <h5>Serious Coding</h5>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/cap.png" alt="Image" width="123" height="128">
        <h6></h6>
        </div></figure>
        <p>A <em>tag</em>, like a branch, is a named reference to a commit. As long as you have a tag pointing to a commit, it will always be reachable, even if it has no branch or child commit pointing to it.</p>
        </div></aside>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="#2 Cherry-pick (copying commits)"><div class="sect1" id="hashtwo_cherryhyphenpick_left_parenthesi">
        <h1>#2 Cherry-pick (copying commits)</h1>
        <p><a data-type="indexterm" data-primary="branches" data-secondary="commits" data-tertiary="copying" id="idm45426355948464"></a><a data-type="indexterm" data-primary="branches" data-secondary="merging" data-tertiary="cherry-picking considerations" id="idm45426355947120"></a><a data-type="indexterm" data-primary="cherry-pick command" id="idm45426355945776"></a><a data-type="indexterm" data-primary="commit histories" data-secondary="cherry-picking commits" id="idm45426355944944"></a><a data-type="indexterm" data-primary="commit IDs" data-secondary="cherry-picking commits" id="idm45426355943840"></a><a data-type="indexterm" data-primary="commits" data-secondary="copying to other branches" id="idm45426355942736"></a><a data-type="indexterm" data-primary="git cherry-pick command" id="idm45426355941664"></a><a data-type="indexterm" data-primary="merge conflicts" id="idm45426355940832"></a><a data-type="indexterm" data-primary="merge conflicts" data-secondary="cherry-picking commits" id="idm45426355940000"></a>Imagine you’re working on a new feature and notice a bug in the code. You fix the bug and make a commit (preferably prefixed with the “type” “fix”). Then you learn that your teammates are getting affected by the same bug. Your branch includes the fix, but you aren’t ready to merge your branch in just yet. So what’s to be done? The commit that contains the bug fix is on your feature branch—how can you apply <em>just</em> that fix to the integration branch?</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><span style="color:#9D9EA0;">In case you were wondering where you heard the term cherry-pick before, we mentioned it in <a data-type="xref" href="ch03.html#looking_aroundcolon_investigating_your_g">Chapter&nbsp;3</a>.</span></p>
        </div>
        <p>You have two options. First, you could create a new branch based on the integration branch, manually reapply your bug fix, commit, and issue a pull request.</p>
        <p>Second, you could use another Git command, called <code>cherry-pick</code>, which allows you to copy a commit to another branch. Since you want the fix to be on the <code>master</code> branch, you’d first switch to the <code>master</code> branch. Let’s see how this would play out:</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0445-02.png" alt="Image" width="600" height="171">
        <h6></h6>
        </div></figure>
        <p>Having the ability to cherry-pick commits does not mean you shouldn’t create a feature branch to apply your work, nor does it mean avoiding your team’s conventions around how that change is applied to the integration branch (issue a pull request or merge locally and push). It does, however, avoid you having to redo a change manually—you can rely on Git’s memory to confidently apply the changes introduced in a commit by simply asking it to copy them to a new location in your commit history.</p>
        <p>Note that you can get a merge conflict since Git will replay your changes on the <code>master</code> branch.</p>
        <p>Recall that when calculating the commit ID, Git uses the commit’s parent commit ID. This means that the cherry-picked commit <em>will</em> have a different commit ID than the original.</p>
        <p>This is yet another reason why separating your work into different types of commits is a good idea. You never know when you might have to reach and copy a commit over to another branch.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="watch_itexclamation_mark-id00318">
        <h5>Watch it!</h5>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/watch.png" alt="Image" width="89" height="84">
        <h6></h6>
        </div></figure>
        <p><strong>Don’t overuse cherry-picking!</strong></p>
        <p><em>The best way to integrate your work is to merge your feature branch into the integration branch. Cherry-picking commits should be only used as a last-ditch effort, in situations where you absolutely can’t merge the branch where the work was done. Remember, when you are cherry-picking commits, you are making copies of those commits, which contain the same set of changes as the original. Doing this too often can make it hard to decipher your commit history</em>.</p>
        </div></aside>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="#3 Stashes (pseudo-commits)"><div class="sect1" id="hashthree_stashes_left_parenthesispseudo">
        <h1>#3 Stashes (pseudo-commits)</h1>
        <p><a data-type="indexterm" data-primary="branches" data-secondary="stashing changes" id="idm45426356256928"></a><a data-type="indexterm" data-primary="git stash command" id="idm45426356254224"></a><a data-type="indexterm" data-primary="pseudo commits, stashing changes" id="idm45426355915120"></a><a data-type="indexterm" data-primary="stash command" id="idm45426355910368"></a>You are knee deep in work. You’ve edited a bunch of files, maybe even added a few files to the index. You check your status and realize you are on the wrong branch! Oops. You should have been on your feature branch, but instead you’re on the <code>master</code> branch.</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0446-01.png" alt="Image" width="600" height="216">
        <h6></h6>
        </div></figure>
        <p>Recall that when you switch branches, Git will rewrite your working directory to look like it did when you made the most recent commit on that branch. This means that if you’ve modified a file that looks different in the two branches, Git won’t let you switch because it would have to overwrite your changes.</p>
        <p>How can you switch branches now that you have a few changes in flight? Git allows you to stash away your changes using the <code>git stash</code> command.</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0446-02.png" alt="Image" width="600" height="113">
        <h6></h6>
        </div></figure>
        <p>When you ask Git to stash your changes, Git stuffs them away in a special location. This leaves your working directory clean. You can now switch branches.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><span style="color:#9D9EA0;">Recall all those times when someone asked you to clean your room? You take everything in sight, shove it all in a drawer, and ta-da! Clean room. See, you’re already an expert in stashing.</span></p>
        </div>
        <p>You can think of a stash as a sort of pseudo-commit. The difference is that stashing records the changes in both your working directory and the index, as opposed to a commit, which only records what is in your index. The other difference is that a commit adds to your commit history, while a stash does not. If you push, your stashes don’t go along for the ride—they remain in your local Git repository.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><span style="color:#9D9EA0;">This is important. Stashes are local to your repository and are not designed to be shared.</span></p>
        </div>
        <p>So now that you’ve stashed your changes—how do you get them back?</p>
        <p><a data-type="indexterm" data-primary="branches" data-secondary="stashing changes" data-tertiary="popping stashes" id="idm45426357407328"></a><a data-type="indexterm" data-primary="commit messages" data-secondary="stashed changes" id="idm45426356191712"></a><a data-type="indexterm" data-primary="git stash command" data-secondary="overuse of" id="idm45426355897792"></a><a data-type="indexterm" data-primary="git stash command" data-secondary="popping stashes" id="idm45426355896816"></a><a data-type="indexterm" data-primary="popping stashes" id="idm45426355895840"></a><a data-type="indexterm" data-primary="stash command" data-secondary="overuse of" id="idm45426355895104"></a><a data-type="indexterm" data-primary="stash command" data-secondary="popping stashes" id="idm45426355894128"></a>You switch branches, and now you’d like you all that work you stashed away back (pretty please with sugar on top). When you stash something, Git puts your work in a stack. This allows you to create multiple stashes, and much like a stack of pancakes, your latest stash created will be at the top. Git allows you to “pop” a stash. This means asking Git to take the topmost (latest) stash, recover all the changes recorded in it, and bring them back, just as they were recorded in the stash.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><span style="color:#9D9EA0;">Mmm...pancakes.</span></p>
        </div>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><span style="color:#9D9EA0;">This is often referred to as a “last in, first out” (LIFO) structure.</span></p>
        </div>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0447-02.png" alt="Image" width="600" height="215">
        <h6></h6>
        </div></figure>
        <p>Git diligently remembers which changes were in the index and which were in the working directory, and it puts them back. Now that you are on the right branch and those changes you made are in the right place, you can get back to work!</p>
        <p>There’s a lot more to stashes—you can supply them with a commit message (just like a standard commit message), list them, view the changes you’ve put in them and even apply specific stashes (rather than just popping the last one you created). And while stashing, by default, only stows away any changes to tracked files, Git allows you to pick whether you want all files (tracked and untracked), only files in the index, or even individual files.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="watch_itexclamation_mark-id00319">
        <h5>Watch it!</h5>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/watch.png" alt="Image" width="89" height="84">
        <h6></h6>
        </div></figure>
        <p><strong>Don’t overuse stashes</strong></p>
        <p><em>It’s tempting to use stashes to store “work in progress” items. Sometimes stashes may seem like a good way to stuff away some work while you try an alternative approach to solving a problem. But you already have a solution for this exact problem: branches!</em></p>
        <p><em>We’ll admit—we don’t use stashes very often. (That’s why they are in the appendix of this book!) One of the times we reach for them is when we are faced with the exact scenario we just described, where we’ve made some edits, haven’t committed just yet, and find ourselves on the wrong branch</em>.</p>
        </div></aside>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="#4 reflog (reference log)"><div class="sect1" id="hashfour_reflog_left_parenthesisreferenc">
        <h1>#4 reflog (reference log)</h1>
        <p><a data-type="indexterm" data-primary="git reflog command" id="idm45426355922112"></a><a data-type="indexterm" data-primary="git reset command" data-secondary="HEAD movement" id="idm45426356329808"></a><a data-type="indexterm" data-primary="HEAD" data-secondary="reflog" id="idm45426355872000"></a><a data-type="indexterm" data-primary="reflog command" id="idm45426355871024"></a><a data-type="indexterm" data-primary="reset command" data-secondary="HEAD movement" id="idm45426355870288"></a>You know that every time you switch branches or check out a specific Git commit using the <code>git checkout</code> command, <code>HEAD</code> moves. You also know that when you make a commit on a branch, both the branch and <code>HEAD</code> move to the new commit on that branch. What happens when you do a reset? <code>HEAD</code> moves to the commit you reset to. Turns out, a lot of operations involve <code>HEAD</code>, like moving around in Git repositories, or adding to (or removing from) your commit history.</p>
        <p>Git maintains a log called the reflog (short for <em>reference log</em>), which is updated every time <code>HEAD</code> moves. You can see the reflog for any repository using the <code>git reflog</code> command:</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0448-01.png" alt="Image" width="600" height="144">
        <h6></h6>
        </div></figure>
        <p>Looking closely at one entry in the reflog, we can discern a lot about what happened:</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0448-02.png" alt="Image" width="600" height="106">
        <h6></h6>
        </div></figure>
        <p>Reading the reflog and getting used to all the information Git records in it can take a little. However, it’s important because the reflog is your safety net. Suppose you reset a commit (which might make a commit unreachable) and then change your mind. Well, since the <code>git reset</code> command moves both <code>HEAD</code> and the branch pointer, the reflog can tell you where you were before you reset.</p>
        <p>Here’s another example: say you are in detached <code>HEAD</code> state. You switch away to another branch or commit, but now you can’t recall which commit you had checked out previously. Reflog to the rescue!</p>
        <p>Stashes and the reflog have a lot in common. Like the stashes list, the reflog is maintained last-in, first-out (LIFO): the latest movement of <code>HEAD</code> is listed at the top. If you were to make another commit or switch branches, that would be inserted at the top of the list, and the current topmost item would move down one.</p>
        <p>Another thing stashes and the reflog share is that the reflog, like your stashes, is local to your repository—it is not shared.</p>
        <p>While the reflog isn’t something you’ll use a lot in your day-to-day work with Git, it is certainly a powerful ally if you ever find yourself in a pickle. So stay calm and use reflog.</p>
        </div></section>
        <section data-type="sect1" data-pdf-bookmark="#5 rebase (another way to merge)"><div class="sect1" id="hashfive_rebase_left_parenthesisanother">
        <h1>#5 rebase (another way to merge)</h1>
        <p><a data-type="indexterm" data-primary="branches" data-secondary="merging" data-tertiary="rebase" id="idm45426356013728"></a><a data-type="indexterm" data-primary="git rebase command" id="idm45426355852608"></a><a data-type="indexterm" data-primary="merging" data-secondary="branches" data-tertiary="rebase" id="idm45426355851872"></a><a data-type="indexterm" data-primary="rebase command" id="idm45426355850656"></a>Merging branches is an integral part of working with Git. A merge unites work from separate branches. You know that when you merge two branches, you can either get a fast-forward merge (where the proposing branch jumps forward) or a merge commit. Git offers another way to merge your work: rebase.</p>
        <p>Before we dive into the details of what rebase offers us and how it is different than doing a merge, let’s consider a hypothetical scenario: suppose you are working on a feature branch (<code>rg/feat-a</code> in this case) and are ready to merge. However, your feature branch and the integration branch (<code>master</code>) have diverged. You already know what will happen if you merge your feature branch <em>into</em> the integration branch—you’ll get a merge commit:</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0449-01.png" alt="Image" width="600" height="193">
        <h6></h6>
        </div></figure>
        <p>Here, the merge commit (E), which Git created, represents the union of the work that happened in the two branches.</p>
        <p>What if, instead of creating a branch off commit A, you had created the <code>rg/feat-a</code> branch branch after commit B (on the <code>master</code> branch) had already been created? In other words, you do the same work (same diff) in commits C and D, but instead of building off commit A, you build your work on top of commit B?</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0449-02.png" alt="Image" width="431" height="235">
        <h6></h6>
        </div></figure>
        <p>If you think about it, commit D′ (D prime) is effectively the union of the work in the <code>master</code> and the <code>rg/feat-a</code> branch, because it started with everything the <code>master</code> branch had to offer! That is, D′ <em>is</em> the merge of the <code>master</code> and <code>feat-a</code> branches.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><span style="color:#9D9EA0;">If you were to merge rg/feat-a into the master branch, it would be a fast-forward merge, which further solidifies our argument.</span></p>
        </div>
        <p>And this is exactly what Git’s rebase capability allows you to do—it allows you to merge two branches by moving one branch on top of another, effectively merging the two without actually merging.</p>
        <p>When you rebase one branch onto another, you are asking Git to replay all the commits on the current branch on top of the latest commit on the other branch. Perhaps this is best explained by an example—let’s revisit the one example from the previous page:</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0450-01.png" alt="Image" width="600" height="165">
        <h6></h6>
        </div></figure>
        <p>Performing a rebase involves another Git command, called <code>git rebase</code>. You start by switching to the branch you want to rebase—<code>rg/feat-a</code> branch in this case. If you rebase this branch on <code>master</code>, Git iterates over all the commits in the feature branch, starting with the first commit (C). It records a new commit (C′) that has the same changes contained in commit C, except the new commit’s parent will be B (as opposed to A). It then proceeds to the next commit on the feature branch, D in this case, and records a new commit (D′) with the same changes as D—except its parent will be the C′. It does this till all the commits have been re-recorded, then it moves the feature branch to point to the latest commit (D′).</p>
        <p>Note that the branch being rebased moves to the newly recorded commit (D′), as opposed to merging, where the proposing branch moves to the merge point.</p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0450-02.png" alt="Image" width="292" height="339">
        <h6></h6>
        </div></figure>
        <p>As you can see, there are a few differences between merging and rebasing. Your history is very different. Rebasing “flattens” the history—you end up with a straight line, with C′ being the parent of D′, B being the parent of C′, and so forth. Rebasing is also more involved than merging, since Git rewrites your commits, which changes their IDs, as opposed to merging, which leaves commit IDs the same. This means that you should not rebase public commits.</p>
        <p>If merging and rebasing have the same results, which one should you reach for when aiming to integrate your work? Merging is much more straightforward and does not involve Git having to rewrite your commit history. This means you can safely merge branches, even those with public commits. Since you are just learning the ropes, use merges. As you get more familiar with Git, and the different kinds of workflows that teams use, you can decide whether you should merge or rebase.</p>
        <section data-type="sect2" data-pdf-bookmark="This isn’t goodbye!"><div class="sect2" id="this_isnapostrophet_goodbyeexclamation_m">
        <h2>This isn’t goodbye!</h2>
        <p><strong>Bring your brain over to <a href="https://i-love-git.com">https://i-love-git.com</a></strong></p>
        <figure class="informal"><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/assets/f0451-01.png" alt="Image" width="597" height="747">
        <h6></h6>
        </div></figure>
        </div></section>
        </div></section>
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com