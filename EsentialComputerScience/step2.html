<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div epub:type="chapter" role="doc-chapter"><div class="ChapterContextInformation"><div class="ContextInformation" id="b978-1-4842-7107-0_2"><div class="ChapterCopyright">©&nbsp;The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature&nbsp;2021</div><span class="ContextInformationAuthorEditorNames">P. D. Crutcher et al.</span><span class="ContextInformationBookTitles"><span class="BookTitle">Essential Computer Science</span></span><span class="ChapterDOI"><a href="https://doi.org/10.1007/978-1-4842-7107-0_2">https://doi.org/10.1007/978-1-4842-7107-0_2</a></span></div></div><!--Begin Abstract--><div class="MainTitleSection"><h1 class="ChapterTitle" lang="en">2.&nbsp;Programming</h1></div><div class="AuthorGroup"><div class="AuthorNames"><span class="Author"><span class="AuthorName">Paul&nbsp;D.&nbsp;Crutcher</span><sup><a href="#Aff4">1</a>&nbsp;<span class="ContactIcon">&nbsp;</span></sup>, </span><span class="Author"><span class="AuthorName">Neeraj&nbsp;Kumar&nbsp;Singh</span><sup><a href="#Aff5">2</a></sup> and </span><span class="Author"><span class="AuthorName">Peter&nbsp;Tiegs</span><sup><a href="#Aff6">3</a></sup></span></div><div class="Affiliations"><div class="Affiliation" id="Aff4"><span class="AffiliationNumber">(1)</span><div class="AffiliationText">Welches, OR, USA</div></div><div class="Affiliation" id="Aff5"><span class="AffiliationNumber">(2)</span><div class="AffiliationText">Bangalore, Karnataka, India</div></div><div class="Affiliation" id="Aff6"><span class="AffiliationNumber">(3)</span><div class="AffiliationText">Hillsboro, OR, USA</div></div><div class="ClearBoth">&nbsp;</div></div></div><!--End Abstract--><div class="Fulltext"><p class="Para" id="Par2">In Chapter <span class="ExternalRef"><a href="503707_1_En_1_Chapter.xhtml"><span class="RefSource">1</span></a></span>, we learned how the CPU fetches, decodes, and executes instructions and that those instructions sit on a persistent storage device until the CPU is turned on and transfers them to main memory. Of course, someone has to write the instructions in the first place, which we call “programming.” So simply put, <span id="ITerm1">programming</span> is the act of writing instructions for a computer to do some specific task. In this chapter, we will explore the different types of programming languages you can use, along with the advancements that have been developed over the years to make programming easier.</p><p class="Para" id="Par3">One of the most interesting aspects of computer science and software in general is how we are continuously inventing new programming languages. In the end, they are all converted to machine language appropriate for the ISA of a given CPU, but how this process is done varies. For example, in some cases the program is converted to machine language once. In other cases, the program may be converted every time it is about to be executed, in which case you need a program that does the conversion on the fly.</p><p class="Para" id="Par4">Deciding which programming language to use can be daunting when you look at the landscape of possibilities, and it’s not always a black-and-white decision; often it comes down to personal preference.</p><p class="Para" id="Par5">Let’s jump into the fundamentals of programming languages so you have a grounding in the basic concepts that are shared by almost all languages. There are entire books written about a single programming language, so we will touch on the basics and give you some good references for learning more.</p><section class="Section1 RenderAsSection1" id="Sec1"><h2 class="Heading">Programming Language Fundamentals</h2><div class="Para" id="Par6">It is possible to program a computer using the computer’s native machine language. However, machine language is essentially a stream of binary numbers, which are difficult to read and extremely difficult to write. Listing <span class="InternalRef"><a href="#PC1">2-1</a></span> shows the machine language in hexadecimal format for a simple program. Can you tell what it’s doing?<div class="ProgramCode" id="PC1"><div class="LineGroup"><div class="FixedLine">Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruction</div><div class="FixedLine">00000098&nbsp;&nbsp;&nbsp;&nbsp;B800000000</div><div class="FixedLine">0000009D&nbsp;&nbsp;&nbsp;&nbsp;B904000000</div><div class="FixedLine">000000A2&nbsp;&nbsp;&nbsp;&nbsp;BE00000000</div><div class="FixedLine">000000A7&nbsp;&nbsp;&nbsp;&nbsp;BF00000000</div><div class="FixedLine">000000AC&nbsp;&nbsp;&nbsp;&nbsp;6AF5</div><div class="FixedLine">000000AE&nbsp;&nbsp;&nbsp;&nbsp;E800000000</div><div class="FixedLine">000000B3&nbsp;&nbsp;&nbsp;&nbsp;6A00</div><div class="FixedLine">000000B5&nbsp;&nbsp;&nbsp;&nbsp;6800000000</div><div class="FixedLine">000000BA&nbsp;&nbsp;&nbsp;&nbsp;6A0C</div><div class="FixedLine">000000BC&nbsp;&nbsp;&nbsp;&nbsp;6800000000</div><div class="FixedLine">000000C1&nbsp;&nbsp;&nbsp;&nbsp;50</div><div class="FixedLine">000000C2&nbsp;&nbsp;&nbsp;&nbsp;E800000000</div><div class="FixedLine">000000C7&nbsp;&nbsp;&nbsp;&nbsp;6A00</div><div class="FixedLine">000000C9&nbsp;&nbsp;&nbsp;&nbsp;E800000000</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 2-1</span><p class="SimplePara">Machine Language for a Simple <span id="ITerm2">Program</span></p></div></div></div></div><p class="Para" id="Par7">No? That’s not surprising! Obviously, we need a better way to program the computer, and that’s where programming languages come into play. One of the first languages developed is called “assembly language.” Assembly language is very close to machine language in terms of the instructions and syntax, so it is referred to as a “low-level” language.</p><section class="Section2 RenderAsSection2" id="Sec2"><h3 class="Heading">Hello, World!</h3><div class="Para" id="Par8">When you are learning a new programming language, it’s common practice to write a program that prints “Hello, World” to the screen. This will enable you to understand the minimal amount of work you have to do to get the program to <span id="ITerm3">compile</span> and output a message. Knowing how to output a message from your program is important because you may need to print messages from your program to help you debug it when it isn’t working as intended. Let’s look at printing “Hello, World” using assembly language in Listing <span class="InternalRef"><a href="#PC2">2-2</a></span>.<div class="ProgramCode" id="PC2"><div class="LineGroup"><div class="FixedLine">STD_OUTPUT_HANDLE equ -11</div><div class="FixedLine">NULL&nbsp;&nbsp;&nbsp;&nbsp;equ 0</div></div><div class="LineGroup"><div class="FixedLine">global&nbsp;&nbsp;main</div><div class="FixedLine">extern ExitProcess, GetStdHandle, WriteConsoleA</div></div><div class="LineGroup"><div class="FixedLine">section .data</div><div class="FixedLine">hello db "Hello, World", 0</div><div class="FixedLine">hellol equ $ - hello</div></div><div class="LineGroup"><div class="FixedLine">section .bss</div><div class="FixedLine">dummy&nbsp;&nbsp;&nbsp;resd 1</div></div><div class="LineGroup"><div class="FixedLine">section .text</div><div class="FixedLine">main:</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov eax, 0</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov ecx, 4</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov esi, 0</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;mov edi, 0</div></div><div class="LineGroup"><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;STD_OUTPUT_HANDLE</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;GetStdHandle</div></div><div class="LineGroup"><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;NULL</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;dummy</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;hellol</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;hello</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push&nbsp;&nbsp;&nbsp;&nbsp;eax</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call&nbsp;&nbsp;&nbsp;&nbsp;WriteConsoleA</div></div><div class="LineGroup"><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;push NULL</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;call ExitProcess<span id="ITerm4">



</span></div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 2-2</span><p class="SimplePara">“Hello, World” Using Assembly Language</p></div></div></div></div><p class="Para" id="Par9">There’s a lot going on in this example! You can see it uses a variable to represent a memory location (e.g., “<span class="EmphasisFontCategoryNonProportional ">hello</span>”), specifies blocks of data (e.g., “<span class="EmphasisFontCategoryNonProportional ">section .data</span>”) and code (e.g., “<span class="EmphasisFontCategoryNonProportional ">section .text</span>”), uses a label to represent the memory address of the start of the program (e.g., “<span class="EmphasisFontCategoryNonProportional ">main:</span>”), and also leverages Windows operating system routines (e.g., “<span class="EmphasisFontCategoryNonProportional ">GetStdHandle</span>,” “<span class="EmphasisFontCategoryNonProportional ">WriteConsoleA</span>,” “<span class="EmphasisFontCategoryNonProportional ">ExitProcess</span>”). There’s also a section called “<span class="EmphasisFontCategoryNonProportional ">section .bss</span>” where you declare variables that should be initialized to 0. This is obviously easier to read than raw machine language, as you can see, but it is structured in a particular way. Can you guess why that is?</p><p class="Para" id="Par10">Since the example isn’t in machine language, the CPU can’t execute the instructions directly. We need a special program called a compiler to convert the assembly language code into machine language.</p></section><section class="Section2 RenderAsSection2" id="Sec3"><h3 class="Heading">Compile, Link, and Load</h3><div class="Para" id="Par11">Unlike the machine language example that was dumped from memory, the assembly language example is text that you must save to storage as a file. The instructions in the file need to be converted to machine language and put into memory so the CPU can execute them. As depicted in Figure <span class="InternalRef"><a href="#Fig1">2-1</a></span>, this process is typically broken down into three phases: compile, link, and load.<figure class="Figure" id="Fig1"><div class="MediaObject" id="MO1"><img alt="../images/503707_1_En_2_Chapter/503707_1_En_2_Fig1_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_2_Chapter/503707_1_En_2_Fig1_HTML.jpg" style="width:23.38em" width="935" height="758"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 2-1</span><p class="SimplePara">Compile, Link, Load</p></div></figcaption></figure></div><p class="Para" id="Par12">A <span id="ITerm5">compiler</span><span id="ITerm6">



</span> is a program that handles the task of taking the assembly instructions and converting them to machine language. The compiler verifies the syntax of the code relative to the language it is written in and generates machine language instructions for the CPU it will execute on. Much of the syntax in the assembly language example is there for the sake of the compiler so it can generate the appropriate machine code, for example, having to distinguish between data and code using “<span class="EmphasisFontCategoryNonProportional ">section .data</span>” and “<span class="EmphasisFontCategoryNonProportional ">section .text</span>,” respectively. The compiler output will contain the values for global variables that are initialized to specific values (like “<span class="EmphasisFontCategoryNonProportional ">hello</span>”), the code, a list of variables that should be initialized to 0, and references to functions that the compiler expects to come from some other source, like the output from another compiler or from the operating system. The binary files that the compiler generates are called object files. In Linux, object files have a “<span class="EmphasisFontCategoryNonProportional ">.o</span>” extension, while Microsoft Windows object files have a “<span class="EmphasisFontCategoryNonProportional ">.obj</span>” file extension.</p><p class="Para" id="Par13">A program called a <span id="ITerm7">linker</span> takes multiple compiled object files and puts them together to create an executable program that can be loaded by a particular operating system. The linker’s job is to make sure all the references in the object files are resolved before generating the executable program. It’s common to get errors when linking a program typically indicating an incorrect or missing reference to a function or variable that you expected to import from some other source.</p><p class="Para" id="Par14">The ability to link object <span id="ITerm8">files</span> from different sources together is powerful because it enables us to share and reuse code modules. When you create code that you want to reuse in multiple programs, you can have the compiler generate the object file and then use that object file when linking to other programs. We call this type of code a “static library.” You can use different programming languages to generate them as long as the machine language they generate is compatible. For example, you could have two languages with a complier for each; the compilers need to use compatible mechanisms for passing parameters to functions on the stack so the code in their object files can call functions in other object files.</p><p class="Para" id="Par15"><span id="ITerm9">Static libraries</span> are great for reusing code, but they have one drawback. If you update a static library because you’ve added functionality or fixed a problem in the code, you need to recreate the executable file for all the programs you’ve written that use that static library. Dynamic libraries were invented to fix this problem. You need to use special operating system calls to load dynamic libraries instead of linking the machine code directly into your program. This means you can update the dynamic library without having to recompile your original program – as long as the interfaces to the functions don’t change! For now, just know that there are two types of libraries and that using dynamic libraries is a powerful, yet tricky, mechanism for reusing code.</p><p class="Para" id="Par16">Operating systems, like programming languages, are designed to make it easier to write programs. In the assembly language example, there are routines you can call to do work for you, like writing information to the console using the Microsoft Windows <span class="EmphasisFontCategoryNonProportional ">WriteConsoleA</span> function<span id="ITerm10">

</span>. Another service the operating system provides is loading and executing your program. The operating system needs to know a few things about your program, like which part of it holds data (variables and default values), which part has instructions, and which instruction should be executed first. It will then put the data and instructions in memory and update the instructions to use appropriate memory locations. The operating system has a special program called a “<span id="ITerm11">loader</span>” that handles this process. The loader expects the program to be stored as a file on a media device, like a hard drive, in a specific format, called the “executable file format.” There are several executable file formats that have been developed over time, such as the <span id="ITerm12">Executable and Linkable Format (ELF)</span><span id="ITerm13">



</span>, which is used by Linux (and many other operating systems). Microsoft Windows uses the Portable Executable (PE) format.</p><p class="Para" id="Par17">Separating the process into compiling, linking, loading, and executing phases is very flexible. For example, you could write compilers for many different languages that target the same linker. The compiler focuses on converting the intermediate instruction format to different types of instruction set architectures. It can also optimize the instructions for those specific architectures and create specific executable file formats. Having a program that has a specific output format that another program can work with is a very important concept in programming. Imagine how much more work it would be if every time someone came up with a new programming language, they had to write the compiler and linker and the executable file format, as well as load it and execute it! By breaking this process up into steps, it saves a lot of time and enables sharing of code between programs.</p></section><section class="Section2 RenderAsSection2" id="Sec4"><h3 class="Heading">High-Level Languages</h3><div class="Para" id="Par18">Let’s compare our “Hello, World” assembly language example to an example <span id="ITerm14">written</span> in the relatively old but popular “C” language. C became popular in the 1980s after Brian Kernighan and Dennis Ritchie published their edition of C in 1978. Their version included the standard input/output library, additional data types, and compound assignment operators. The following sample in Listing <span class="InternalRef"><a href="#PC3">2-3</a></span> is a simple “Hello, World” program in C, and as you can see, it is very different than assembly language!<div class="ProgramCode" id="PC3"><div class="LineGroup"><div class="FixedLine">#include &lt;stdio.h&gt;</div><div class="FixedLine">int main() {</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;printf("Hello, World!");</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;return 0;</div><div class="FixedLine">}</div></div><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Listing 2-3</span><p class="SimplePara">“Hello, World” in the C Programming <span id="ITerm15">Language</span></p></div></div></div></div><p class="Para" id="Par19">There are special keywords that you use so that the compiler can do its job. For example, the “<span class="EmphasisFontCategoryNonProportional ">#include</span>” keyword tells the compiler to include another file, in this case “<span class="EmphasisFontCategoryNonProportional ">stdio.h</span>,” which is the C standard input/output library header file. Header files are used separate from the code files (which typically end in .c for the C language). They allow the compiler to understand how to call functions in other libraries without having to look at the code itself. The header file lists the names and parameters for functions that are available for use from the code file (as well as variable names and macro definitions). The brackets “<span class="EmphasisFontCategoryNonProportional ">&lt;</span>” and “<span class="EmphasisFontCategoryNonProportional ">&gt;</span>” tell the compiler to look for that file outside of the current folder by using the “include path,” which is an operating system environment variable that we won’t cover here. Every executable program in C must have a function called “<span class="EmphasisFontCategoryNonProportional ">main</span>.” Brackets (“<span class="EmphasisFontCategoryNonProportional ">{</span>”, “<span class="EmphasisFontCategoryNonProportional ">}</span>”) are used to group lines of code together. “<span class="EmphasisFontCategoryNonProportional ">printf</span>” is a function that is defined in “<span class="EmphasisFontCategoryNonProportional ">stdio.h</span>” that prints data to the screen. Parameters to the <span class="EmphasisFontCategoryNonProportional ">printf</span> function<span id="ITerm16">

</span> are specified inside parentheses. A semicolon is used to specify the end of a string of commands.</p><p class="Para" id="Par20">The use of parentheses, brackets, and semicolons is all part of the C language syntax. The syntax is the rules for combining language-specific symbols in the correct order that the compiler will be able to understand. Remember, the compiler is just another program, so strict rules are necessary to make it easier to convert the language into machine language code through procedural programming mechanisms as we’re describing here.</p><div class="Para" id="Par21">Let’s take a deeper look at the compilation process for a high-level language like C. Figure <span class="InternalRef"><a href="#Fig2">2-2</a></span> shows how a compiler breaks down the compilation process in terms of preprocessing, lexical analysis, parsing, building a symbol table, and generating the code.<figure class="Figure" id="Fig2"><div class="MediaObject" id="MO2"><img alt="../images/503707_1_En_2_Chapter/503707_1_En_2_Fig2_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_2_Chapter/503707_1_En_2_Fig2_HTML.jpg" style="width:32.1em" width="1284" height="279"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 2-2</span><p class="SimplePara">Compilation Process</p></div></figcaption></figure></div><p class="Para" id="Par22">The <span id="ITerm17">preprocessor</span> looks for specific identifiers in the source code and resolves those to create a file that can be scanned by the next step in the process. In the C language, preprocessor directives start with “#”, for example, “#include.” The preprocessor will load the file specified by the #include so it becomes part of the source file.</p><p class="Para" id="Par23">Once the preprocessing is done, the lexical analyzer scans the source file to identify tokens. As it is identifying tokens (e.g., “int” is a keyword, “main” is an identifier, etc.), it updates the symbol table. If there are characters that are not allowed based on the syntax of the program, the lexical analyzer will throw an error. An advanced analyzer may try to recover from the error so it can continue with the compilation process.</p><p class="Para" id="Par24">The parser does the syntax analysis. It receives the tokens from the lexical analyzer and determines if they are in the appropriate order based on the syntax of the language. Parsers may generate what’s called a “parse tree” or an “abstract syntax tree.” The parse tree (trees are discussed in Chapter <span class="ExternalRef"><a href="503707_1_En_3_Chapter.xhtml"><span class="RefSource">3</span></a></span>) is a representation of the input that conforms to the grammar of the language, and you can generate a version of the original source by walking the tree in the right order. Having a tree-oriented representation of the source code allows the compiler to make multiple passes when generating the machine language without having to reparse the original source. You could also imagine a compiler that creates the parse tree and then uses that to generate multiple output files for different types of processors without having to retokenize and parse the original source code. The parser is also responsible for detecting and reporting syntactical errors (like missing a semicolon), semantic errors (like trying to assign the wrong type of value to a variable), and logical errors (like an infinite loop or unreachable code). Compiling high-level languages is a complex topic, so if you’re interested in more detail, we encourage you to read some of the references we’ve cited at the end of this chapter.</p><p class="Para" id="Par25">Hopefully you are starting to appreciate why C is considered a high-level <span id="ITerm18">language</span> as compared to assembly and machine languages! Since the early 1950s, many high-level programming languages have been created. Fortran, LISP (List Processing), Algol, COBOL (Common Business-Oriented Language), BASIC, Pascal, Smalltalk, SQL (Structured Query Language), Objective-C, C++, Perl, Java, Python, Visual Basic, R, Java, PHP, Ruby, JavaScript, Delphi, C#, Scala, Groovy, Go, PowerShell, and Swift are a few of the more popular languages. Once you understand several of the key programming paradigms, you’ll see how many of these languages have quite a bit in common.</p></section></section><section class="Section1 RenderAsSection1" id="Sec5"><h2 class="Heading">Programming Paradigms</h2><p class="Para" id="Par26">So far, we’ve looked at machine language, assembly language, and C “Hello, World” examples (you may have guessed by now that the first machine language example was a version of “Hello, World”). We recognize that machine language and assembly language are low-level programming languages, and we know how programs are compiled, linked, and loaded. High-level programming languages abstract away the machine language entirely, and the compilation process is broken down into several phases.</p><p class="Para" id="Par27">Within the classification of high-level programming languages, though, there are several different programming paradigms you should be aware of: imperative, declarative, object-oriented, interpreted, parallel, and machine learning (ML). Learning about these programming paradigms helps you recognize the common elements of many high-level programming languages. Let’s take a closer look at each one.</p><section class="Section2 RenderAsSection2" id="Sec6"><h3 class="Heading">Imperative Programming</h3><p class="Para" id="Par28">Imperative programming is the oldest programming paradigm. Imperative program languages are constructed through a series of well-defined commands in a specific order, and the program flow is controlled by loops and branches. Imperative programs can be broken down into additional programming styles: structured, procedural, and modular.</p><p class="Para" id="Par29">Structured <span id="ITerm19">programming</span> adds sequences, selection, and iteration operations to solve problems with nonstructured imperative programs. Procedural programming is when you divide the program into a small set of procedures, or functions, while modular programming is where you break down the program into a set of modules (files) that can be tested independently of each other.</p><p class="Para" id="Par30">Imperative programming is typically easier to read and relatively easier to learn because you can easily follow the execution flow, which is why most people learn an imperative programming language first. However, the programs are often much larger, relative to other paradigms, when trying to solve more complex problems. Some alternatives, like functional programming, which is considered a declarative programming paradigm, can do a lot more with less code but are typically harder to learn and read.</p><p class="Para" id="Par31">Most of the examples we’ve studied so far have been imperative, so we won’t revisit them here. The C programming language is considered an imperative programming language, as well as COBOL, Pascal, Fortran, and many others.</p></section><section class="Section2 RenderAsSection2" id="Sec7"><h3 class="Heading">Declarative Programming</h3><p class="Para" id="Par32">With <span id="ITerm20">declarative programming</span>, instead of programming based on the steps you go through to arrive at the solution, the program is written by describing the end result. It’s also done at a higher level of abstraction. Functional programming is a common type of declarative programming.</p><div class="Para" id="Par33">In functional programming, the primary rule is that a function has no side effects. It cannot rely on data outside of the function; it can only operate on the data passed to it as parameters. Here’s an example of an imperative programming function that violates that rule:<div class="ProgramCode" id="PC4"><div class="LineGroup"><div class="FixedLine">int a = 0;</div></div><div class="LineGroup"><div class="FixedLine">void increment() {</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;a = a + 1;</div><div class="FixedLine">}</div></div></div></div><div class="Para" id="Par34">In this simple example, the <span class="EmphasisFontCategoryNonProportional ">increment</span> function takes no arguments, and it is incrementing a variable that is declared outside of the function. This is a valid function in an imperative language like C, but if you’re adhering to functional programming rules, you would implement the function this way:<div class="ProgramCode" id="PC5"><div class="LineGroup"><div class="FixedLine">int increment( int a ) {</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;return a + 1;</div><div class="FixedLine">}</div></div></div></div><p class="Para" id="Par35">This “increment” <span id="ITerm21">example</span> is considered a <span id="ITerm22">“pure” function</span> because it only operates on its parameters and thus there can be no side effects like setting the value of a variable outside of the function, and it doesn’t keep track of anything between calls. It simply operates on the parameters that are passed to it and nothing else.</p><div class="Para" id="Par36">Another type of function is one that takes other functions as parameters or returns a function as a result. These are called <span id="ITerm23">“higher-order” functions</span>. Consider the following Python code that prints the length of each string in a list. The map function takes a function name as the first parameter and a list of objects (we cover object-oriented programming in the next section) as the second parameter. It simply applies the function to each object in the list and returns the result as a special type of object called an iterator. You then pass the iterator object, which will walk through all of the elements in the data structure, from the map function to a list function to create a list of objects:<div class="ProgramCode" id="PC6"><div class="LineGroup"><div class="FixedLine">print( list( map( len, ["programming", "is", "fun"] ) ) )</div></div></div></div><div class="Para" id="Par37">The output looks like this:<div class="ProgramCode" id="PC7"><div class="LineGroup"><div class="FixedLine">[11, 2, 3]</div></div></div></div><p class="Para" id="Par38">Here we are able to accomplish the task in one line of code! However, it’s not as easy to understand what is going on, is it? The flow of the code isn’t obvious because it’s about the operations you are performing on the data (in this case, a list of words). To understand it, you read the code from the inside out, so to speak, and also have to understand what the function is going to do, which isn’t always obvious.</p><p class="Para" id="Par39">You have to think differently when writing declarative code, but it can be very powerful. For example, it is easier to execute the operations in parallel. In this case, it’s possible to execute the “<span class="EmphasisFontCategoryNonProportional ">len</span>” command for each parameter on a different CPU at the same time, which would be very fast!</p><div class="Para" id="Par40">Writing this <span id="ITerm24">code</span> in an imperative way is much different. Let’s look at the imperative version, again using Python:<div class="ProgramCode" id="PC8"><div class="LineGroup"><div class="FixedLine">word_lengths = [0,0,0]</div><div class="FixedLine">word_list = ["programming", "is", "fun"]</div><div class="FixedLine">for i in range(len(word_list)):</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;word_lengths[i] = len(word_list[i])</div><div class="FixedLine">print(list(word_lengths))</div></div></div></div><p class="Para" id="Par41">There are several more lines of code in this example, but it is a little bit easier to follow the flow of execution. However, since the “<span class="EmphasisFontCategoryNonProportional ">for</span>” loop operates each command sequentially, it’s not as easy for the system to execute the instructions in parallel.</p></section><section class="Section2 RenderAsSection2" id="Sec8"><h3 class="Heading">Object-Oriented Programming</h3><p class="Para" id="Par42"><span id="ITerm25">Object-oriented programming</span><span id="ITerm26">



</span> is an evolution of procedural programming that introduces some very important concepts such as encapsulation, abstraction, inheritance, and polymorphism.</p><div class="Para" id="Par43">In object-oriented programming, encapsulation is achieved by defining classes of objects. A class defines the private variables that only the methods of that class can act upon, protected variables that only derived classes can access, and public variables the functions and methods outside of the class can access. All of the code that operates on those variables is encapsulated within the class definition. Code external to the class can only use the public mechanisms to interact with an instance of the class. An instance of a class is called an object. For example, in C++, you can define a Vehicle class that has a public method for getting the capacity of the vehicle, but have private and protected properties and methods that are not visible outside of the class:<div class="ProgramCode" id="PC9"><div class="LineGroup"><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;class Vehicle {</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;private:</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int access_count = 0;</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected:</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int capacity = 0;</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public:</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int get_capacity() {</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;++access_count;</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return capacity;</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};</div></div></div></div><p class="Para" id="Par44">In this <span id="ITerm27">example</span><span id="ITerm28">



</span>, the Vehicle has a private variable that increments every time “get_capacity” is executed. However, the capacity variable is set to 0 and is “protected,” not “private” like the “access_count” variable. This means classes that derive from the Vehicle class (like a car or bus) can manipulate the capacity variable but not “access_count.”</p><div class="Para" id="Par45">Inheritance is when you define a new “child” class based on the definition of an existing “parent” class. The child class can add additional methods and properties or override the parent implementation and/or add new functionality. We’ve defined a Vehicle class. Now let’s inherit from it to create two new classes, Car and Bus:<div class="ProgramCode" id="PC10"><div class="LineGroup"><div class="FixedLine">class Car: public Vehicle {</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;public:</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Car() { capacity = 4; }</div><div class="FixedLine">}</div></div><div class="LineGroup"><div class="FixedLine">class Bus: public Vehicle {</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;public:</div><div class="FixedLine">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Bus() { capacity = 20; }</div><div class="FixedLine">}</div></div></div></div><div class="Para" id="Par46">We’ve introduced a new C++ concept in this example called the “constructor.” The constructor has the same name as the class being created. The constructor is called automatically when the object is created. In this example, when you create a Car, it initializes the capacity variable to 4, but when you create a Bus, it initializes the capacity variable to 20. Note that neither class defines the capacity variable because it was defined in the Vehicle parent class. Because the Vehicle class has already specified the function to get the capacity of the vehicle, the child class doesn’t have to do anything other than initialize the variable in its constructor. When you create a Bus or Car, you can call those functions that are defined by the Vehicle class, like this:<div class="ProgramCode" id="PC11"><div class="LineGroup"><div class="FixedLine">Bus aBus;</div><div class="FixedLine">int capacity = aBus.get_capacity();</div></div></div></div><div class="Para" id="Par47">We can use the <span id="ITerm29">same</span><span id="ITerm30">



</span> vehicle example to describe polymorphism, which means having many forms. When you write code that deals with instances of the <span class="EmphasisFontCategoryNonProportional ">Vehicle</span> class, you can access the public <span id="ITerm31">get_capacity method</span>. It doesn’t matter if the object is a bus or car because they both inherit from the Vehicle class. The implementation of get_capacity is different, though, depending on whether or not the object is a car or bus. In this case your code is dealing with vehicles, but they can have different forms. Here’s an example where we create a Bus but treat it as a Vehicle:<div class="ProgramCode" id="PC12"><div class="LineGroup"><div class="FixedLine">Bus aBus;</div><div class="FixedLine">Vehicle* aVehicle = &amp;aBus;</div><div class="FixedLine">int capacity = aVehicle-&gt;get_capacity();</div></div></div></div><p class="Para" id="Par48">We declared a variable called “<span class="EmphasisFontCategoryNonProportional ">aVehicle</span>” that is a “<span class="EmphasisFontCategoryNonProportional ">Vehicle*</span>”. That’s special syntax in the C language to specify that the “<span class="EmphasisFontCategoryNonProportional ">aVehicle</span>” variable is the memory address of another variable that inherits from the Vehicle class. I can “point” that variable at an instance of a <span class="EmphasisFontCategoryNonProportional ">Bus</span> object, as in this example, using the “<span class="EmphasisFontCategoryNonProportional ">&amp;</span>” operator. The ampersand tells the compiler to use the address of <span class="EmphasisFontCategoryNonProportional ">aBus</span> and then assign it to <span class="EmphasisFontCategoryNonProportional ">aVehicle</span>. Later, we can change <span class="EmphasisFontCategoryNonProportional ">aVehicle</span> to be the address of the <span class="EmphasisFontCategoryNonProportional ">Car</span> object. This is how we enable polymorphism in C++. We write our code using the <span class="EmphasisFontCategoryNonProportional ">aVehicle</span> variable, and depending on what address it is assigned to, it could be a <span class="EmphasisFontCategoryNonProportional ">Car</span> or a <span class="EmphasisFontCategoryNonProportional ">Bus</span>.</p><p class="Para" id="Par49">Now that we’ve covered the primary concepts common to object-oriented programming languages (encapsulation, inheritance, and polymorphism), we can move on to the interpreted programming paradigm.</p></section><section class="Section2 RenderAsSection2" id="Sec9"><h3 class="Heading">Interpreted Programming</h3><div class="Para" id="Par50">Instead of compiling your source code into an executable file, you can use a program called an <span id="ITerm32">interpreter</span><span id="ITerm33">



</span> and either type in the commands directly at a prompt or put them in a source file and have the interpreter execute it. Interpreters are able to execute the high-level code instructions as they read them instead of compiling and linking into an executable program. The interpreter itself is an executable program that reads the code and interacts with the operating system to do what the code says. Python is the interpreter for the, you guessed it, Python programming language! Let’s look at an example of a “hello world” program in Python:<div class="ProgramCode" id="PC13"><div class="LineGroup"><div class="FixedLine">print("hello world")</div></div></div></div><div class="Para" id="Par51">Whoa, it’s just a single line of code! However, you do have to run this example from the Python program from the command line, which will load and print a prompt (“<span class="EmphasisFontCategoryNonProportional ">&gt;&gt;&gt;</span>”) when it’s ready for input, like this:<div class="ProgramCode" id="PC14"><div class="LineGroup"><div class="FixedLine">C:\python</div><div class="FixedLine">Python 3.9.1 (tags/v3.9.1:1e5d33e, Dec&nbsp;&nbsp;7 2020, 17:08:21) [MSC v.1927 64 bit (AMD64)] on win32</div><div class="FixedLine">Type "help", "copyright", "credits" or "license" for more information.</div><div class="FixedLine">&gt;&gt;&gt; _</div></div></div></div><p class="Para" id="Par52">Interpreted languages like Python are very powerful. You can easily evaluate code using the interpreter and do rapid testing because you don’t have to perform compile/link/load.</p><div class="Para" id="Par53">JavaScript is another interpreted language that is commonly executed by web browsers like Google Chrome and Microsoft Edge. Instead of running an interpreter from the Windows command line prompt or a Linux terminal, JavaScript is executed by an interpreter in the browser. The script sits on a web server waiting to get downloaded by the browser. In Figure <span class="InternalRef"><a href="#Fig3">2-3</a></span>, the browser requests a page from a web server, which is an HTML document that contains the JavaScript code. JavaScript can be embedded in HTML, or there can be a reference to a JavaScript file in the HTML file. For this example, it’s embedded in the HTML file.<figure class="Figure" id="Fig3"><div class="MediaObject" id="MO3"><img alt="../images/503707_1_En_2_Chapter/503707_1_En_2_Fig3_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_2_Chapter/503707_1_En_2_Fig3_HTML.jpg" style="width:25em" width="1000" height="272"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 2-3</span><p class="SimplePara">Browser Getting a Page from a Web Server</p></div></figcaption></figure></div><div class="Para" id="Par54">In Figure <span class="InternalRef"><a href="#Fig4">2-4</a></span>, the browser receives the HTML file containing the JavaScript code from the server. Now the browser has a copy of the script and can start interpreting it.<figure class="Figure" id="Fig4"><div class="MediaObject" id="MO4"><img alt="../images/503707_1_En_2_Chapter/503707_1_En_2_Fig4_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_2_Chapter/503707_1_En_2_Fig4_HTML.jpg" style="width:25em" width="1000" height="274"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 2-4</span><p class="SimplePara">Browser Receiving a Page from a Web Server</p></div></figcaption></figure></div><p class="Para" id="Par55">It’s very important to understand the context in which your program is executing. For this example, the JavaScript code is executing in the browser, despite its origin being on the <span id="ITerm34">server</span>. The script can interact with the browser itself, or it can make calls over the Internet back to the server it was downloaded from to get data or have the server do work on its behalf. This is a very different environment compared to a program that is running entirely on the same machine.</p><p class="Para" id="Par56">It’s also important to realize that interpreted languages can also be imperative, declarative, and object-oriented. Python and JavaScript are both object-oriented and interpreted languages, as well as supporting declarative and imperative mechanisms!</p></section><section class="Section2 RenderAsSection2" id="Sec10"><h3 class="Heading">Parallel Programming</h3><p class="Para" id="Par57"><span id="ITerm35">Parallel programming</span><span id="ITerm36">



</span> is when your program takes advantage of multiple CPU cores or <span id="ITerm37">Graphics Processing Units (GPUs)</span> to run routines at the same time. A GPU is also a type of processor, but it is designed to run parallel tasks more efficiently. As we saw previously, declarative programming lends itself well to parallel execution. Imperative programming languages add additional mechanisms to help write code that executes in parallel.</p><div class="Para" id="Par58">First, we should understand how processes work and how they’re scheduled by the operating system to run on a CPU. When your program is loaded by the operating system, it’s launched as a new process. Your program uses CPU registers and accesses memory as it executes instructions, and there’s also the stack that it uses to keep track of function parameters, local variables, and return addresses. If there’s just one process running on the system, these resources are used exclusively by that one process, but rarely is that the case. In an operating system like Linux or Windows, there are almost always many more processes loaded into memory than the number of CPU cores that can execute them. Figure <span class="InternalRef"><a href="#Fig5">2-5</a></span> is a screenshot of the Windows Task Manager’s CPU performance screen. On this one machine, there are 225 processes loaded, but only eight cores!<figure class="Figure" id="Fig5"><div class="MediaObject" id="MO5"><img alt="../images/503707_1_En_2_Chapter/503707_1_En_2_Fig5_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_2_Chapter/503707_1_En_2_Fig5_HTML.jpg" style="width:30em" width="1200" height="481"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 2-5</span><p class="SimplePara">Windows Task Manager CPU Performance Information</p></div></figcaption></figure></div><p class="Para" id="Par59">The operating system is responsible for scheduling all of these processes on the different cores. In this case, it’s possible to run up to eight processes at the same time, one on each core, but we likely need to give CPU time to more than eight <span id="ITerm38">processes</span> to keep all aspects of the system running smoothly. The operating system has to use a technique called time slicing to give additional processes CPU time. In short, the operating system initializes the CPU to run a specific process by saving and restoring register values so that the process doesn’t need to know it’s being time-sliced. The operating system sets a timer on the CPU that will execute the scheduling code when it goes off. Because the operating system is handling this in the background, you don’t really need to worry about what the operating system is doing to make this work.</p><p class="Para" id="Par60">The trick to hide the complexity of process switching from the process itself is memory mapping. With memory mapping, the process thinks it has access to all of physical memory, but in reality, the CPU translates the memory addresses that the process is referencing into physical addresses. Because the program is not using actual physical addresses, the memory that the program references is called “virtual memory.” By using virtual memory, the process can assume its stack grows down from the top of memory at the same address every time it executes, but in reality, it is in different pages of physical memory. When the OS switches between processes, it needs to adjust the memory mapping. This is an expensive operation because the CPU has internal buffers that keep track of the mapping so that it happens very quickly. These buffers need to be flushed and get reinitialized when the process switch happens. Thus, a process will suffer a brief performance hit after a process is scheduled to start running.</p><div class="Para" id="Par61">Threads<span id="ITerm39">



</span>, on the other hand, are associated with one process and are faster to switch between than processes because the virtual memory map doesn’t have to change. Figure <span class="InternalRef"><a href="#Fig6">2-6</a></span> shows the relationship between a process and its threads.<figure class="Figure" id="Fig6"><div class="MediaObject" id="MO6"><img alt="../images/503707_1_En_2_Chapter/503707_1_En_2_Fig6_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_2_Chapter/503707_1_En_2_Fig6_HTML.jpg" style="width:30em" width="1200" height="506"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 2-6</span><p class="SimplePara">A Process and Its Threads</p></div></figcaption></figure></div><p class="Para" id="Par62">When using threads, you need to be very careful since they share resources, memory in particular, with other threads running in the same process. You can run into situations where two threads are trying to change the same memory location and overwrite values in unpredictable ways. To avoid these problems, you have to use techniques like locks and semaphores, discussed later in Chapter <span class="ExternalRef"><a href="503707_1_En_4_Chapter.xhtml"><span class="RefSource">4</span></a></span>. You also have to be careful that your threads aren’t waiting on each other, in which case they will wait forever, which is called a “deadlock.” Writing multi-threaded programs is one of the most difficult programming techniques, but is extremely powerful if you get it right!</p></section><section class="Section2 RenderAsSection2" id="Sec11"><h3 class="Heading">Machine Learning</h3><p class="Para" id="Par63"><span id="ITerm40">Machine learning</span><span id="ITerm41">



</span> is a totally different programing paradigm. Instead of focusing on the flow of the program or writing functions, the computer learns from experience so that it can make predictions in the future. <span id="ITerm42">Machine learning</span> is so fundamentally different than other programming paradigms that we decided to devote Chapter <span class="ExternalRef"><a href="503707_1_En_8_Chapter.xhtml"><span class="RefSource">8</span></a></span> to cover it in detail.</p></section></section><section class="Section1 RenderAsSection1" id="Sec12"><h2 class="Heading">Summary</h2><p class="Para" id="Par64">In this chapter, we learned that assembly language was one of the first programming languages. Assembly language introduced some key concepts like using variable names to represent memory locations. A process called compiling and linking is used to create executable programs. The operating system loads executable programs, so they are created in a format that the operating system understands. Operating systems make writing programs much easier by providing services, such as writing to the screen and loading your program into memory. There are many different types of programming techniques you can use to program the computer. We briefly covered imperative, declarative, object-oriented, interpreted and parallel programming.</p></section><section class="Section1 RenderAsSection1" id="Sec13"><h2 class="Heading">References and Further Reading</h2><div class="Para" id="Par65">
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par66">Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman. <em class="EmphasisTypeItalic ">Compilers: Principles, Techniques, and Tools</em>. Pearson Education, Inc. 1986, 2006</p></li><li><p class="Para" id="Par67">Keith D. Cooper, Linda Torczon. <em class="EmphasisTypeItalic ">Engineering a Compiler (Second Edition)</em>. Morgan Kaufmann, 2011</p></li><li><p class="Para" id="Par68">John R Levine. <em class="EmphasisTypeItalic ">Linkers and Loaders (First Edition)</em>. Morgan Kaufmann, 1999</p></li><li><p class="Para" id="Par69">Donald Knuth. <em class="EmphasisTypeItalic ">The Art of Computer Programming, Volume 1</em>. Addison-Wesley, 1968</p></li><li><p class="Para" id="Par70">Mary Rose Cook. “A practical introduction to functional programming.” Publish date not known, retrieved March 2021 &lt;<span class="ExternalRef"><a href="https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">https://maryrosecook.com/blog/post/a-practical-introduction-to-functional-programming</span></span></a></span>&gt;</p></li><li><p class="Para" id="Par71">Brian Kernighan, Dennis Ritchie. <em class="EmphasisTypeItalic ">The</em> C <em class="EmphasisTypeItalic ">Programming Language (Second Edition)</em>. Pearson, 1988</p></li><li><p class="Para" id="Par72">Mark Lutz. <em class="EmphasisTypeItalic ">Programming Python (Third Edition)</em>. O’Reilly Media, 2006</p></li></ul></div>
</div></section></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781484271070/files/css/springer_epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com