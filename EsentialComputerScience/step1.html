<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div epub:type="chapter" role="doc-chapter"><div class="ChapterContextInformation"><div class="ContextInformation" id="b978-1-4842-7107-0_1"><div class="ChapterCopyright">©&nbsp;The Author(s), under exclusive license to APress Media, LLC, part of Springer Nature&nbsp;2021</div><span class="ContextInformationAuthorEditorNames">P. D. Crutcher et al.</span><span class="ContextInformationBookTitles"><span class="BookTitle">Essential Computer Science</span></span><span class="ChapterDOI"><a href="https://doi.org/10.1007/978-1-4842-7107-0_1">https://doi.org/10.1007/978-1-4842-7107-0_1</a></span></div></div><!--Begin Abstract--><div class="MainTitleSection"><h1 class="ChapterTitle" lang="en">1.&nbsp;Fundamentals of a Computer System</h1></div><div class="AuthorGroup"><div class="AuthorNames"><span class="Author"><span class="AuthorName">Paul&nbsp;D.&nbsp;Crutcher</span><sup><a href="#Aff4">1</a>&nbsp;<span class="ContactIcon">&nbsp;</span></sup>, </span><span class="Author"><span class="AuthorName">Neeraj&nbsp;Kumar&nbsp;Singh</span><sup><a href="#Aff5">2</a></sup> and </span><span class="Author"><span class="AuthorName">Peter&nbsp;Tiegs</span><sup><a href="#Aff6">3</a></sup></span></div><div class="Affiliations"><div class="Affiliation" id="Aff4"><span class="AffiliationNumber">(1)</span><div class="AffiliationText">Welches, OR, USA</div></div><div class="Affiliation" id="Aff5"><span class="AffiliationNumber">(2)</span><div class="AffiliationText">Bangalore, Karnataka, India</div></div><div class="Affiliation" id="Aff6"><span class="AffiliationNumber">(3)</span><div class="AffiliationText">Hillsboro, OR, USA</div></div><div class="ClearBoth">&nbsp;</div></div></div><!--End Abstract--><div class="Fulltext"><p class="Para" id="Par2">There are many resources online to get you started programming, but if you don’t have training in computer science, there are certain fundamental concepts that you may not have learned yet that will help you avoid getting frustrated, such as choosing the wrong programming language for the task at hand or feeling overwhelmed. We wrote this book to help you understand computer science basics, whether you already started programming or you are just getting started. We will touch on the topics someone with a computer science degree learns above and beyond the semantics and syntax of a programming language. In this first chapter, we will cover a brief history and evolution of a computer system and the fundamentals of how it operates. We will cover some low-level computer architecture and programming concepts in this chapter, but subsequent chapters will cover higher-level programming concepts that make it much easier to program the computer.</p><section class="Section1 RenderAsSection1" id="Sec1"><h2 class="Heading">von Neumann Architecture</h2><p class="Para" id="Par3">You’ve probably heard <span id="ITerm1">stories</span> about computers the size of an entire room in the 1940s into the 1970s, built with thousands of vacuum tubes, relays, resistors, capacitors, and other components. Using these various components, scientists invented the concept of gates, buffers, and flip-flops, the standard building blocks of electronic circuits today. In the 1970s, Intel invented the first general-purpose microprocessor, called the 8088, that IBM used to make the first PC that was small enough for personal use. Despite the continuous advancements that have made it possible to shrink the microprocessor, as you’ll see, the core elements of today’s desktop or laptop computer are consistent with the first computers designed in the 1940s!</p><div class="Para" id="Par4">In 1945, John von <span id="ITerm2">Neumann</span> documented the primary elements of a computer in the “First Draft of a Report on the EDVAC” based on the work he was doing for the government. EDVAC stands for Electronic Discrete Variable Automatic Computer, which was the successor to the <span id="ITerm3">Electronic Numerical Integrator and Computer (ENIAC)</span>, the first general-purpose computer developed during World War II to compute ballistic firing tables. EDVAC was designed to do more general calculations than calculating ballistic firing tables. As depicted in Figure <span class="InternalRef"><a href="#Fig1">1-1</a></span>, von Neumann described five subdivisions of the system: central arithmetic and central control (C), main memory (M), input (I), output (O), and recording medium (R). These five components and how they interact is still the standard architecture of most computers today.<figure class="Figure" id="Fig1"><div class="MediaObject" id="MO1"><img alt="../images/503707_1_En_1_Chapter/503707_1_En_1_Fig1_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_1_Chapter/503707_1_En_1_Fig1_HTML.jpg" style="width:32.5em" width="1300" height="533"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 1-1</span><p class="SimplePara">Primary Architecture Elements of a Computer</p></div></figcaption></figure></div><p class="Para" id="Par5">In his paper, von Neumann called the central arithmetic and control unit the central control organ and the combination of central control and main memory as corresponding to associative neurons. Even today, people refer to the central processing unit, or CPU, as the “brain” of the computer. Don’t be fooled, though, because a computer based on this architecture does exactly what it is programmed to do, nothing more and nothing less. Most often the difficulties we <span id="ITerm4">encounter</span> when programming computers are due to the complex nature of how your code depends on code written by other people (e.g., the operating system), combined with your ability to understand the nuances of the programming language you’re using. Despite what a lot of people might think, there’s no magic to how a computer works, but it can be complicated!</p></section><section class="Section1 RenderAsSection1" id="Sec2"><h2 class="Heading">CPU: Fetch, Decode, Execute, and Store</h2><p class="Para" id="Par6">The CPU’s <span id="ITerm5">job</span> is to fetch, decode, execute, and store the results of instructions. There are many improvements that have been invented to do it as efficiently as possible, but in the end, the CPU repeats this cycle over and over until you tell it to stop or remove power. How this cycle works is important to understand as it will help you debug multi-threaded programs and code for multicore or multiprocessor systems.</p><div class="FormalPara FormalParaRenderingStyle1 ParaTypeImportant" id="FPar1"><div class="Heading">Note</div><p class="Para FirstParaInFormalPara" id="Par7"><span id="ITerm6">Threads</span> are a mechanism used to simulate executing a set of instructions in parallel (at the same time), whereas multiple cores in the same system actually do execute instructions in parallel.</p></div><div class="Para" id="Par8">The basic <span id="ITerm7">blocks</span> of a CPU are shown in Figure <span class="InternalRef"><a href="#Fig2">1-2</a></span>. The CPU needs a clock that sends an electric pulse at a regular interval, called a frequency. The frequency of the clock dictates how fast the CPU can execute its internal logic. The control unit drives the fetch, decode, execute, and store function of the processor. The arithmetic and logic unit, or ALU, performs math operations and digital logic operations like AND, OR, XOR, and so on. The CPU has an internal memory unit for registers and one or more high-speed memory caches to store data proactively pulled in from main memory.<figure class="Figure" id="Fig2"><div class="MediaObject" id="MO2"><img alt="../images/503707_1_En_1_Chapter/503707_1_En_1_Fig2_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_1_Chapter/503707_1_En_1_Fig2_HTML.jpg" style="width:27.5em" width="1100" height="802"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 1-2</span><p class="SimplePara">Basic Blocks Inside a <span id="ITerm8">CPU</span></p></div></figcaption></figure></div><section class="Section2 RenderAsSection2" id="Sec3"><h3 class="Heading">Fetch</h3><p class="Para" id="Par9">The CPU fetches instructions from memory using addresses. Consider your home’s mailbox; it has an address and, if it’s anything like my mailbox, contains junk mail and a letter from my mom, if I’m lucky. Like the mail in your mailbox, instructions sit in memory at a specific address. Your mailbox is probably not much bigger than a shoebox, so it has a limit to how much mail the mail carrier can put into <span id="ITerm9">it</span>. Computer memory is similar in that each address location has a specific size. This is an important concept to grasp because much of computer programming has to do with data and instructions stored at an address in memory, the size of the memory location, and so on.</p><p class="Para" id="Par10">When the CPU turns on, it starts executing instructions from a specific location as specified by the default value of its instruction pointer. The instruction pointer is a special memory location, called a register, that stores the memory address of the next instruction.</p><div class="Para" id="Par11">Here’s a simple example of instructions in memory that add two numbers <span id="ITerm10">together</span>:<div class="ProgramCode" id="PC1"><div class="LineGroup"><div class="FixedLine"><strong class="EmphasisTypeBold ">Address&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Instruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Human-Readable Instruction</strong></div><div class="FixedLine">200&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B80A000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EAX,10</div><div class="FixedLine">205&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;BB0A000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EBX,10</div><div class="FixedLine">20A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;01D8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADD EAX,EBX</div></div></div></div><p class="Para" id="Par12">The first column is the address in memory where the instruction is stored, the second column is the instruction itself, and the third column is the human-readable version of the instruction. The address and instruction numbers are in hexadecimal format. Hexadecimal is a base <span class="EmphasisFontCategoryNonProportional ">16</span> number system, which means a digit can be <span class="EmphasisFontCategoryNonProportional ">0—F</span>, not just <span class="EmphasisFontCategoryNonProportional ">0—9</span> as with the decimal system. The address of the first instruction is <span class="EmphasisFontCategoryNonProportional ">200</span>, and the instruction is “<span class="EmphasisFontCategoryNonProportional ">mov eax,10</span>,” which means “move the number <span class="EmphasisFontCategoryNonProportional ">10</span> into the <span class="EmphasisFontCategoryNonProportional ">EAX</span> register.” B8 represents “move something into <span class="EmphasisFontCategoryNonProportional ">EAX</span>,” and <span class="EmphasisFontCategoryNonProportional ">0A000000</span> is the value. Hexadecimal digit <span class="EmphasisFontCategoryNonProportional ">A</span> is a <span class="EmphasisFontCategoryNonProportional ">10</span> in decimal, but you might wonder why it’s in that particular position.</p><p class="Para" id="Par13">It turns out that CPUs work with ones and zeros, which we call binary. The number 10 in binary is <span class="EmphasisFontCategoryNonProportional ">1010</span>. <span class="EmphasisFontCategoryNonProportional ">B8</span> is <span class="EmphasisFontCategoryNonProportional ">10111000</span> in binary, so the instruction <span class="EmphasisFontCategoryNonProportional ">B80A000000</span> in binary would be <span class="EmphasisFontCategoryNonProportional ">1011 1000 0000 1010 0000 0000 0000 0000 0000 0000</span>. Can you imagine having to read binary numbers? Yikes!</p><div class="Para" id="Par14">In this binary format, a single digit is called a “bit.” A group of <span class="EmphasisFontCategoryNonProportional ">8</span> bits is called a “byte.” This means the maximum value of a byte would be <span class="EmphasisFontCategoryNonProportional ">1111 1111</span>, which is <span class="EmphasisFontCategoryNonProportional ">255</span> in decimal and <span class="EmphasisFontCategoryNonProportional ">FF</span> in hexadecimal. A word is 2 bytes, which is <span class="EmphasisFontCategoryNonProportional ">16</span> bits. In this example, the “<span class="EmphasisFontCategoryNonProportional ">MOV EAX</span>” instruction uses a byte for the instruction and then 4 words for the data. If you do the math, 4 words is 8 bytes, which is 32 bits. But if you are specifying the number 10 (or <span class="EmphasisFontCategoryNonProportional ">0A</span> in hexadecimal) to be moved into the <span class="EmphasisFontCategoryNonProportional ">EAX</span> register, why is it <span class="EmphasisFontCategoryNonProportional ">0A000000</span>? Wouldn’t that be <span class="EmphasisFontCategoryNonProportional ">167,772,160</span> in decimal? It would, but it turns out processors don’t expect numbers to be stored in memory that way.<div class="ProgramCode" id="PC2"><div class="LineGroup"><div class="FixedLine">bit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0 or 1</div><div class="FixedLine">byte&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8 bits</div><div class="FixedLine">word&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 bytes = 16 bits</div><div class="FixedLine">dword&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2 words = 4 bytes = 32 bits</div></div></div></div><div class="Para" id="Par15">Most CPUs expect the lower byte of the word to be before the upper byte of the word in <span id="ITerm11">memory</span>. A human would write the number <span class="EmphasisFontCategoryNonProportional ">10</span> as a hexadecimal word like this: <span class="EmphasisFontCategoryNonProportional ">000A</span>. The first byte, <span class="EmphasisFontCategoryNonProportional ">00</span>, would be considered the most significant byte; and the second byte, <span class="EmphasisFontCategoryNonProportional ">0A</span>, would be the least significant. The first byte is more significant than the second byte because it’s the larger part of the number. For example, in the hexadecimal word <span class="EmphasisFontCategoryNonProportional ">0102</span>, the first byte <span class="EmphasisFontCategoryNonProportional ">01</span> is the “most significant” byte. In this case, it represents the number <span class="EmphasisFontCategoryNonProportional ">256</span> (<span class="EmphasisFontCategoryNonProportional ">0100</span> in hexadecimal is <span class="EmphasisFontCategoryNonProportional ">256</span>). The second <span class="EmphasisFontCategoryNonProportional ">02</span> byte represents the number 2, so the decimal value of the hexadecimal word <span class="EmphasisFontCategoryNonProportional ">0102</span> is <span class="EmphasisFontCategoryNonProportional ">258.</span> Now, let’s look at the “<span class="EmphasisFontCategoryNonProportional ">MOV EAX,10</span>” instruction as a stream of bytes in memory:<div class="ProgramCode" id="PC3"><div class="LineGroup"><div class="FixedLine">200:&nbsp;&nbsp;B8&nbsp;&nbsp;&nbsp;&nbsp;&lt;- Instruction (MOV EAX)</div><div class="FixedLine">201:&nbsp;&nbsp;0A&nbsp;&nbsp;&nbsp;&nbsp;&lt;- Least significant byte of 1st word</div><div class="FixedLine">202:&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&lt;- Most significant byte of 1st word</div><div class="FixedLine">203:&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&lt;- Least significant byte of 2nd word</div><div class="FixedLine">204:&nbsp;&nbsp;00&nbsp;&nbsp;&nbsp;&nbsp;&lt;- Most significant byte of 2nd word</div><div class="FixedLine">205:&nbsp;&nbsp;??&nbsp;&nbsp;&nbsp;&nbsp;&lt;- Start of next instruction</div></div></div></div><p class="Para" id="Par16">The instruction is a single byte, and then it expects 4 bytes for the data, or 2 words, also called a “double word” (programmers use DWORD for short). A double word, then, is 32 bits. If you are adding a hexadecimal number that requires 32 bits, like <span class="EmphasisFontCategoryNonProportional ">0D0C0B0A</span>, it will be in this order in memory: <span class="EmphasisFontCategoryNonProportional ">0A0B0C0D</span>. This is called “little-endian.” If the most significant byte is first, it’s called “big-endian.” Most CPUs use “little-endian,” but in some cases data may be written in “big-endian” byte order when sent between devices, for instance, over a network, so it’s good to understand the byte order you’re dealing with.</p><p class="Para" id="Par17">For this example, the CPU’s instruction pointer starts at address <span class="EmphasisFontCategoryNonProportional ">200</span>. The CPU will fetch the instruction from address <span class="EmphasisFontCategoryNonProportional ">200</span> and advance the instruction pointer to the location of the next instruction, which in this case is address 205.</p><div class="Para" id="Par18">The examples we’ve been studying so far have been using decimal, binary, and hexadecimal number conventions. Sometimes it is hard to tell what type of number is being used. For example, 10 in decimal is 2 in binary and 16 in hexadecimal. We need to use a mechanism so that it is easy to tell which number system is being used. The rest of this book will use the following notation:<div class="UnorderedList"><ul class="UnorderedListMarkNone"><li><p class="Para" id="Par19">Decimal: No modifier. Example: <span class="EmphasisFontCategoryNonProportional ">10</span></p></li><li><p class="Para" id="Par20">Hexadecimal: Starts with <span class="EmphasisFontCategoryNonProportional ">0x</span> or ends in <span class="EmphasisFontCategoryNonProportional ">h</span>. Example: <span class="EmphasisFontCategoryNonProportional ">0x10</span> or <span class="EmphasisFontCategoryNonProportional ">10h</span></p></li><li><p class="Para" id="Par21">Binary: Ends in <span class="EmphasisFontCategoryNonProportional ">b</span>. Example: <span class="EmphasisFontCategoryNonProportional ">10b</span><span id="ITerm12">


</span></p></li></ul></div></div><section class="Section3 RenderAsSection3" id="Sec4"><h4 class="Heading">Instruction Set Architecture</h4><p class="Para" id="Par22">Instructions are defined per a specification, called instruction set <span id="ITerm13">architecture</span>, or ISA. There are two primary approaches to instruction set architecture that have evolved over time: complex instruction sets and reduced instruction sets. A system built with a complex instruction set is called a complex instruction set computer, abbreviated as CISC. Conversely, a system built with a reduced instruction set is referred to as a reduced instruction set computer, abbreviated as RISC. A reduced instruction set is an optimized set of instructions that the CPU can execute quickly, maybe in a single cycle, and typically involves fewer memory accesses.</p><p class="Para" id="Par23">Complex instructions will do more work in a single instruction and take as much time to execute as needed. These are used as guiding principles when designing the instruction set, but they also have a profound impact on the microarchitecture of the CPU. Microarchitecture is how the instruction set is implemented. There are multiple microarchitectures that support the same ISA, for example, both Intel and AMD (Advanced Micro <span id="ITerm14">Devices</span>) make processors that support the x86 ISA, but they have a different implementation, or microarchitecture. Because they implement the same ISA, the CPU can run the exact same programs as they were compiled and assembled into binary format. If the ISA isn’t the same, you have to recompile and assemble your program to use it on a different CPU.</p><div class="FormalPara FormalParaRenderingStyle1 ParaTypeImportant" id="FPar2"><div class="Heading">Note</div><p class="Para FirstParaInFormalPara" id="Par24">A compiler and an assembler are special programs that take code written by humans and convert it into instructions for a CPU that supports a specific instruction set architecture (ISA).</p></div><p class="Para" id="Par25">Whether it is complex or <span id="ITerm15">reduced</span>, the instruction set will have instructions for doing arithmetic, moving data between memory locations (registers or main memory), controlling the flow of execution, and more. We will use examples based on the x86 ISA to understand how the CPU decodes and executes instructions in the following sections.</p></section><section class="Section3 RenderAsSection3" id="Sec5"><h4 class="Heading">Registers</h4><div class="Para" id="Par26">CPUs have special memory locations called <span id="ITerm16">registers</span>. Registers are used to store values in the CPU that help it execute instructions without having to refer back to main memory. The CPU will also store results of operations in registers. This enables you to instruct the CPU to do calculations between registers and avoid excess memory accesses. Table <span class="InternalRef"><a href="#Tab1">1-1</a></span> is the original x86 ISA base register set.<div class="Table" id="Tab1"><div class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Table 1-1</span><p class="SimplePara">x86 Base Register Set</p></div></div><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"><col class="tcol3 align-left"><col class="tcol4 align-left"><col class="tcol5 align-left"></colgroup><thead><tr><th rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</th><th rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">64 bits</p><p class="SimplePara">(x86_64)</p></th><th rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">32 bits</p><p class="SimplePara">(x86)</p></th><th colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">16 bits(8086)</p></th></tr><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">8 bits</p></th><th style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">8 bits</p></th></tr></thead><tbody><tr><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Accumulator</p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">RAX</span></p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">EAX</span></p></td><td colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">AX</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">AH</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">AL</span></p></td></tr><tr><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Base register</p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">RBX</span></p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">EBX</span></p></td><td colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">BX</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">BH</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">BL</span></p></td></tr><tr><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Counter</p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">RCX</span></p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">ECX</span></p></td><td colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">CX</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">CH</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">CL</span></p></td></tr><tr><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Data</p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">RDX</span></p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">EDX</span></p></td><td colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">DX</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">DH</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">DL</span></p></td></tr><tr><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Base pointer</p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">RBP</span></p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">EBP</span></p></td><td colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">BP</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">BPL</span></p></td></tr><tr><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Source index</p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">RSI</span></p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">ESI</span></p></td><td colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">SI</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">SIL</span></p></td></tr><tr><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Destination index</p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">RDI</span></p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">EDI</span></p></td><td colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">DI</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">DIL</span></p></td></tr><tr><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Stack pointer</p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">RSP</span></p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">ESP</span></p></td><td colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">SP</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">SPL</span></p></td></tr><tr><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">General purpose</p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">R8-R15</span></p></td><td rowspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">R8D-R15D</span></p></td><td colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">R8W-R15W</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">R8B-R15B</span></p></td></tr></tbody></table></div></div><p class="Para" id="Par27">It’s important to understand how the registers are used by the CPU for the given ISA. For example, the 32-bit counter, in this case ECX, will be automatically decremented by the loop instruction. Another example is the stack <span id="ITerm17">pointer</span> where you can directly manipulate it, but it’s modified by many other instructions (we will explore the concept of a stack later in this chapter).</p><p class="Para" id="Par28">The x86 register set has evolved over time and is meant to be backward compatible with older versions of x86 CPUs. You can see the progression from the original 16-bit processor to 32-bit and the now more common 64-bit memory address sizes. As the memory address size increased, so did the register size, and new names were given to allow using the different register sizes with the appropriate instructions. Even when in 64-bit mode, the 32-bit register names enable programs written for 32 bits to run on 64-bit machines.</p><p class="Para" id="Par29">A typical ISA will have multiple register sets. For example, x86 has a floating-point register set and another register set for handling large data sets. The popular ARM architecture also has multiple register sets. The register set and the ISA go hand in hand!</p></section></section><section class="Section2 RenderAsSection2" id="Sec6"><h3 class="Heading">Decode, Execute, and Store</h3><p class="Para" id="Par30">Decoding<span id="ITerm18">


</span> is when the CPU interprets the instruction and transfers the data needed to execute the instruction into the CPU to prepare to execute the instruction.</p><p class="Para" id="Par31">Instructions are formatted in a particular way to enable efficient decoding. The instruction format specifies the opcode (the operation to be performed), the operands (the registers or data needed for the operation), and the addressing mode. The number and order of the operands depends on the instruction addressing mode as follows:</p><div class="Para" id="Par32">Register Direct: Both operands are registers:<div class="ProgramCode" id="PC4"><div class="LineGroup"><div class="FixedLine">ADD EAX, EAX</div></div></div></div><div class="Para" id="Par33">Register Indirect: <span class="EmphasisFontCategoryNonProportional ">B</span>oth operands are registers, but one contains the address where the operand is stored in memory:<div class="ProgramCode" id="PC5"><div class="LineGroup"><div class="FixedLine">MOV ECX, [EBX]</div></div></div></div><div class="Para" id="Par34">Immediate: The operand is included immediately after the instruction in memory:<div class="ProgramCode" id="PC6"><div class="LineGroup"><div class="FixedLine">ADD EAX, 10</div></div></div></div><div class="Para" id="Par35">Indexed: The address is calculated using a base address plus an index, which can be another register:<div class="ProgramCode" id="PC7"><div class="LineGroup"><div class="FixedLine">MOV AL,&nbsp;&nbsp;[ESI+0x401000]</div><div class="FixedLine">MOV EAX, [EBX+EDI]</div></div></div></div><p class="Para" id="Par36">The CPU control unit decodes the instruction and then, based on the addressing scheme, moves data from memory into the appropriate registers. At this point, the instruction is ready, and the control unit drives the ALU to do its work. For example, <span class="EmphasisFontCategoryNonProportional ">ADD EAX, 10</span> will add the number <span class="EmphasisFontCategoryNonProportional ">10</span> to the current value of the <span class="EmphasisFontCategoryNonProportional ">EAX</span> register and store the result in the <span class="EmphasisFontCategoryNonProportional ">EAX</span> register.</p><div class="Para" id="Par37">The <span id="ITerm19">ALU</span> can support typical math instructions like add (<span class="EmphasisFontCategoryNonProportional ">ADD</span>), multiply (<span class="EmphasisFontCategoryNonProportional ">MUL</span>), and divide (<span class="EmphasisFontCategoryNonProportional ">DIV</span>) for integer numbers. The original arithmetic unit doesn’t handle floating-point numbers directly. For example, when you divide a number using the <span class="EmphasisFontCategoryNonProportional ">DIV</span> instruction, you put the dividend in <span class="EmphasisFontCategoryNonProportional ">EAX</span> and the divisor in <span class="EmphasisFontCategoryNonProportional ">ECX</span> and then issue the divide instruction:<div class="ProgramCode" id="PC8"><div class="LineGroup"><div class="FixedLine">MOV EDX, 0</div><div class="FixedLine">MOV EAX, 13</div><div class="FixedLine">MOV ECX, 2</div><div class="FixedLine">DIV ECX</div></div></div></div><p class="Para" id="Par38">Since 13 is not an even number, there will be a remainder. The instruction deals with integers only, so the quotient, 6, is stored in <span class="EmphasisFontCategoryNonProportional ">EAX</span>, and the remainder, 1, is stored in <span class="EmphasisFontCategoryNonProportional ">EDX</span>. <span class="EmphasisFontCategoryNonProportional ">ECX</span> will still be 2. You can use other registers for the divisor, but the quotient and remainder will be stored in <span class="EmphasisFontCategoryNonProportional ">EAX</span> and <span class="EmphasisFontCategoryNonProportional ">EDX</span>. In 16-bit mode, they are stored in <span class="EmphasisFontCategoryNonProportional ">AX</span> and <span class="EmphasisFontCategoryNonProportional ">DX</span>, and in 8-bit mode, this pattern breaks and the quotient is stored in <span class="EmphasisFontCategoryNonProportional ">AL</span> with the remainder in <span class="EmphasisFontCategoryNonProportional ">AH</span>.</p><div class="Para" id="Par39">Just like division has special handling for remainders, addition and subtraction have special handling for carrying and borrowing. For example, a binary number is either 0 or 1. The number 2 is represented as 10b in binary. When you add two bits together (1b + 1b), a carry occurs. This is easily represented digitally by an <span class="EmphasisFontCategoryNonProportional ">XOR</span> logic gate and an <span class="EmphasisFontCategoryNonProportional ">AND</span> logic gate. A logic gate is a set of transistors that perform logical operations on binary inputs. Figure <span class="InternalRef"><a href="#Fig3">1-3</a></span> shows how the <span class="EmphasisFontCategoryNonProportional ">XOR</span> and the <span class="EmphasisFontCategoryNonProportional ">AND</span> gates are wired together to form a half adder circuit. The output of an <span class="EmphasisFontCategoryNonProportional ">XOR</span> gate is “one or the other but not both,” so it will be 0 if both inputs are 1. The output of an <span class="EmphasisFontCategoryNonProportional ">AND</span> gate is 1 only if both inputs are 1. The output of the <span class="EmphasisFontCategoryNonProportional ">AND</span> gate is used to set the carry bit for the add operation.<figure class="Figure" id="Fig3"><div class="MediaObject" id="MO3"><img alt="../images/503707_1_En_1_Chapter/503707_1_En_1_Fig3_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_1_Chapter/503707_1_En_1_Fig3_HTML.jpg" style="width:22.5em" width="900" height="729"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 1-3</span><p class="SimplePara">Half Adder <span id="ITerm20">Circuit</span></p></div></figcaption></figure></div><p class="Para" id="Par40">The ALU uses many different combinations of logic gates to implement the various instructions. In addition, the ALU also supports logic operations such as <span class="EmphasisFontCategoryNonProportional ">OR</span> and <span class="EmphasisFontCategoryNonProportional ">AND</span>, shifting bits, comparing, incrementing, decrementing, and more. We’re just scratching the surface here, so if you’re interested in more, we encourage you to study the ISA for your processor.</p></section><section class="Section2 RenderAsSection2" id="Sec7"><h3 class="Heading">Controlling the Flow</h3><div class="Para" id="Par41">A very important instruction is one that tells the CPU to start executing instructions from a different location, which is typically referred to as a “jump” <span id="ITerm21">instruction</span>. You can program the CPU to perform calculations and then jump (change the instruction pointer) to a different location in memory based on the outcome of the calculations. This technique is used to perform a loop operation. In the following example, we will initialize the <span class="EmphasisFontCategoryNonProportional ">ECX</span> counter register to 4 and the <span class="EmphasisFontCategoryNonProportional ">ESI</span> index register to 0. Then we will increment the <span class="EmphasisFontCategoryNonProportional ">ESI</span> register and call the <span class="EmphasisFontCategoryNonProportional ">LOOP</span> instruction. The <span class="EmphasisFontCategoryNonProportional ">LOOP</span> instruction has a special relationship with the <span class="EmphasisFontCategoryNonProportional ">ECX</span> register. It will automatically decrement the register by one and, if it is greater than zero, jump to the specified location:<div class="ProgramCode" id="PC9"><div class="LineGroup"><div class="FixedLine"><strong class="EmphasisTypeBold ">Address&nbsp;&nbsp;&nbsp;Instruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Human-Readable Instruction</strong></div><div class="FixedLine">0x0200&nbsp;&nbsp;&nbsp;&nbsp;0xB904000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV ECX,0x4</div><div class="FixedLine">0x0205&nbsp;&nbsp;&nbsp;&nbsp;0xBE00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV ESI,0x0</div><div class="FixedLine">0x020A&nbsp;&nbsp;&nbsp;&nbsp;0x46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INC ESI</div><div class="FixedLine">0x020B&nbsp;&nbsp;&nbsp;&nbsp;0xE2FD&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOOP 0x020A</div></div></div></div><div class="Para" id="Par42">Let’s look at a <span id="ITerm22">slightly</span> more complex example. Suppose you have two lists of numbers and you want to add them together and store the result somewhere else in memory:<div class="Table" id="Taba"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"><col class="tcol3 align-left"><col class="tcol4 align-left"><col class="tcol5 align-left"><col class="tcol6 align-left"></colgroup><thead><tr><th colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">List 1</p></th><th colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">List 2</p></th><th colspan="2" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">List 3 (results)</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">Address</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">Data</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">Address</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">Data</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">Address</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">Data</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x401000</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">01</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x402000</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">04</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x403000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">00</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x401001</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">02</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x402001</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">03</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x403001</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">00</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x401002</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">03</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x402002</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">02</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x403002</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">00</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x401004</span></p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">04</span></p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x402003</span></p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">01</span></p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x403003</span></p></td><td style="text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">00</span></p></td></tr></tbody></table></div></div><div class="Para" id="Par43">The following instructions add a number from List 1 to the corresponding number in List 2 and put the result in List 3. Again, we will use the <span class="EmphasisFontCategoryNonProportional ">ECX</span> as a counter, so we initialize it to 4 since there are four elements in each list. Next, we initialize our source index register (<span class="EmphasisFontCategoryNonProportional ">ESI</span>) and destination index register (<span class="EmphasisFontCategoryNonProportional ">EDI</span>) to zero. Starting at address <span class="EmphasisFontCategoryNonProportional ">0x0214</span>, we move a byte from the first list into the <span class="EmphasisFontCategoryNonProportional ">AL</span> register and a byte from the second list into the <span class="EmphasisFontCategoryNonProportional ">AH</span> register. Next, starting at address <span class="EmphasisFontCategoryNonProportional ">0x0220</span>, we move one byte into our destination and then add the other byte to that same location. <span class="EmphasisFontCategoryNonProportional ">ESI</span> is added to the address, and then the data located at that calculated address is moved into the <span class="EmphasisFontCategoryNonProportional ">AL</span> register. Since we are adding <span class="EmphasisFontCategoryNonProportional ">ESI</span> and <span class="EmphasisFontCategoryNonProportional ">EDI</span> to the addresses, we increment both of them with the <span class="EmphasisFontCategoryNonProportional ">INC</span> instruction before the <span class="EmphasisFontCategoryNonProportional ">LOOP</span> instruction. The <span class="EmphasisFontCategoryNonProportional ">LOOP</span> instruction automatically decrements <span class="EmphasisFontCategoryNonProportional ">ECX</span><span id="ITerm23">


</span> and jumps to address <span class="EmphasisFontCategoryNonProportional ">0x214</span> as long as <span class="EmphasisFontCategoryNonProportional ">ECX</span> is greater than zero. There are several other conditional loops and jump instructions that enable you to control program flow in a variety of ways:<div class="ProgramCode" id="PC10"><div class="LineGroup"><div class="FixedLine"><strong class="EmphasisTypeBold ">Address&nbsp;&nbsp;&nbsp;Instruction&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Human-Readable Instruction</strong></div><div class="FixedLine">0x0205&nbsp;&nbsp;&nbsp;&nbsp;0xB904000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV ECX,0x4</div><div class="FixedLine">0x020A&nbsp;&nbsp;&nbsp;&nbsp;0xBE00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV ESI,0x0</div><div class="FixedLine">0x020F&nbsp;&nbsp;&nbsp;&nbsp;0xBF00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EDI,0x0</div><div class="FixedLine">0x0214&nbsp;&nbsp;&nbsp;&nbsp;0x8A8600104000&nbsp;&nbsp;&nbsp;&nbsp;MOV AL,[ESI+0x401000]</div><div class="FixedLine">0x021A&nbsp;&nbsp;&nbsp;&nbsp;0x8AA600204000&nbsp;&nbsp;&nbsp;&nbsp;MOV AH,[ESI+0x402000]</div><div class="FixedLine">0x0220&nbsp;&nbsp;&nbsp;&nbsp;0x888700304000&nbsp;&nbsp;&nbsp;&nbsp;MOV [EDI+0x403000],AL</div><div class="FixedLine">0x0226&nbsp;&nbsp;&nbsp;&nbsp;0x00A700304000&nbsp;&nbsp;&nbsp;&nbsp;ADD [EDI +0x403000],AH</div><div class="FixedLine">0x022C&nbsp;&nbsp;&nbsp;&nbsp;0x46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INC ESI</div><div class="FixedLine">0x022D&nbsp;&nbsp;&nbsp;&nbsp;0x47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INC EDI</div><div class="FixedLine">0x022E&nbsp;&nbsp;&nbsp;&nbsp;0xE2E4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOOP 0x0214</div></div></div></div><p class="Para" id="Par44">What if you needed to do this operation often? It would be of help if you could put this set of instructions in your program and jump to it from other parts of your program whenever you need to add two lists of numbers together, right? You would need to pass information to this code for the location of the two lists in memory, how many numbers are in the lists, and another memory location to store the results. Also, when the code is done, you need to tell the processor to return to the location it came from so it can continue execution instructions. We call this a function or routine, and thankfully the processor has special instructions and registers to keep track of the input to the function and where to jump to when the function is done doing its work. These special instructions store the needed information on the stack.</p></section><section class="Section2 RenderAsSection2" id="Sec8"><h3 class="Heading">The Stack</h3><p class="Para" id="Par45">The <span id="ITerm24">stack</span> works on a Last In, First Out (LIFO) principle. Imagine a card game between two people sitting at a table. There are just a few simple rules. First, if there are no cards on the table, you can put a card on the table. If there’s a card on the table, you must put the next card on top of the existing card, or stack them. Second, if either of you wants to take a card from the table, you have to take the card from the top of the stack. Thus, the last card put on the top of the stack is always the first one to come off the stack of cards. Of course, we’re talking about computers, not people, so in a computer, the table is memory, the people are functions of your program, and the cards are data being passed back and <span id="ITerm25">forth</span>. To make it more interesting, some CPUs require that the table is upside down!</p><div class="Para" id="Par46">For the x86 ISA, there are two instructions to work with the stack: <span class="EmphasisFontCategoryNonProportional ">PUSH</span> and <span class="EmphasisFontCategoryNonProportional ">POP</span>. There’s also a special register called the extended stack pointer (<span class="EmphasisFontCategoryNonProportional ">ESP</span>)<span id="ITerm26">

</span>. The x86 stack always starts at a high memory address. As data is pushed onto the stack, the <span class="EmphasisFontCategoryNonProportional ">ESP</span> decrements to the next address. When the pop instruction is executed, the <span class="EmphasisFontCategoryNonProportional ">ESP</span> increments to reveal the previous item on the stack. Here is an empty 32-bit stack with <span class="EmphasisFontCategoryNonProportional ">ESP</span> set to the address of the first available position:<div class="Table" id="Tabb"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"><col class="tcol3 align-left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Data (DWORD)</p></th><th style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">ESP</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x01000000</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x01000000</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFFC</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF8</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF4</span></p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="text-align: left;">&nbsp;</td></tr></tbody></table></div></div><div class="Para" id="Par47">Let’s push a value onto the stack and look at the result:<div class="ProgramCode" id="PC11"><div class="LineGroup"><div class="FixedLine">MOV&nbsp;&nbsp;EAX, 10</div><div class="FixedLine">PUSH EAX</div></div></div></div><div class="Para" id="Par48">This is what the stack will look like and the value of the ESP register:<div class="Table" id="Tabc"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"><col class="tcol3 align-left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Data (DWORD)</p></th><th style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">ESP</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x01000000</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFFC</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x0A000000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFFC</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF8</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF4</span></p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="text-align: left;">&nbsp;</td></tr></tbody></table></div></div><div class="Para" id="Par49">Notice anything? The value is actually stored in the next available spot, not the current location <span class="EmphasisFontCategoryNonProportional ">ESP</span> was referring to! The push instruction decrements the address in the <span class="EmphasisFontCategoryNonProportional ">ESP</span> register by 4, and then it stores the value at the location. The <span class="EmphasisFontCategoryNonProportional ">POP</span> instruction<span id="ITerm27">

</span><span id="ITerm28">


</span> does the opposite; it moves the value at the current address in the <span class="EmphasisFontCategoryNonProportional ">ESP</span> register and then increments the <span class="EmphasisFontCategoryNonProportional ">ESP</span> register by 4. If we do <span class="EmphasisFontCategoryNonProportional ">POP EAX,</span> which means “take the value on the stack and put it in EAX,” the stack will look like this in 32-bit mode:<div class="Table" id="Tabd"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"><col class="tcol3 align-left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Data (DWORD)</p></th><th style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">ESP</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x01000000</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x01000000</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFFC</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x0A000000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF8</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF4</span></p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00000000</span></p></td><td style="text-align: left;">&nbsp;</td></tr></tbody></table></div></div><p class="Para" id="Par50">The ESP register is now back to <span class="EmphasisFontCategoryNonProportional ">0x01000000</span>; however, the <span class="EmphasisFontCategoryNonProportional ">0A</span> value is still sitting at location <span class="EmphasisFontCategoryNonProportional ">0x00FFFFFC</span>! The <span class="EmphasisFontCategoryNonProportional ">POP</span> instruction doesn’t touch the data; it just copies it to the register you specify and changes the address value stored in <span class="EmphasisFontCategoryNonProportional ">ESP</span>. However, you can’t count on that data staying there as the next push command will overwrite it.</p><div class="Para" id="Par51">Now that we know how the stack pointer works, let’s look at calling the routine we talked about earlier that adds the elements of two lists of numbers and stores the result in memory. Our routine needs the address of the two lists of numbers and the address where to store the results. It also needs to know the number of items in these lists, so let’s push these items onto the stack:<div class="ProgramCode" id="PC12"><div class="LineGroup"><div class="FixedLine"><strong class="EmphasisTypeBold ">Address Instruction&nbsp;&nbsp;&nbsp;Human-Readable Instruction</strong></div><div class="FixedLine">0x0200&nbsp;&nbsp;0x6800104000&nbsp;&nbsp;PUSH DWORD 0x401000</div><div class="FixedLine">0x0205&nbsp;&nbsp;0x6800204000&nbsp;&nbsp;PUSH DWORD 0x402000</div><div class="FixedLine">0x020A&nbsp;&nbsp;0x6800304000&nbsp;&nbsp;PUSH DWORD 0x403000</div><div class="FixedLine">0x020F&nbsp;&nbsp;0x6A04&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PUSH BYTE +0x4</div></div></div></div><div class="Para" id="Par52">We use the <span id="ITerm29">DWORD</span> and BYTE modifiers as hints to the compiler how to treat the numbers. We will cover compiling, linking, and loading in the next chapter. We also need to push an address on the stack so the routine knows where to tell the processor to return to when it is done and then jump to our routine. It turns out that the <span class="EmphasisFontCategoryNonProportional ">CALL</span> instruction does this for us, so now we just need to call our routine, which is at address <span class="EmphasisFontCategoryNonProportional ">0x024C</span> in this example:<div class="ProgramCode" id="PC13"><div class="LineGroup"><div class="FixedLine">0x0211&nbsp;&nbsp;&nbsp;0xE836000000&nbsp;&nbsp;&nbsp;&nbsp;CALL 0x024C</div><div class="FixedLine">0x0216&nbsp;&nbsp;&nbsp;;address of next instruction</div></div></div></div><div class="Para" id="Par53">Now the stack looks like this:<div class="Table" id="Tabe"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"><col class="tcol3 align-left"></colgroup><thead><tr><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Address</p></th><th style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Data (DWORD)</p></th><th style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">ESP</p></th></tr></thead><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x01000000</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x0401000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">+16</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFFC</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x0402000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">+12</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF8</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x0403000</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">+8</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF4</span></p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x0000004</span></p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">+4</span></p></td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF0</span></p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x0000216</span></p></td><td style="text-align: left;"><p class="SimplePara"><span class="EmphasisFontCategoryNonProportional ">0x00FFFFF0</span></p></td></tr></tbody></table></div></div><div class="Para" id="Par54">We can reference the parameters on the stack in relation to the current stack pointer. The beginning of our routine will use this technique to put the number of bytes in the lists into <span class="EmphasisFontCategoryNonProportional ">ECX</span>, the destination for the results into <span class="EmphasisFontCategoryNonProportional ">EDI</span>, the address of the second list of numbers in <span class="EmphasisFontCategoryNonProportional ">EBX</span>, and the address of the first list of numbers in <span class="EmphasisFontCategoryNonProportional ">EDX</span><span id="ITerm30">


</span>. Then, we will do add the numbers together from the two lists and store them at the location stored in <span class="EmphasisFontCategoryNonProportional ">EDI</span>. The code has changed a bit because we’re using registers in a slightly different way, but it has the same outcome. Note that the ret instruction will use the address at ESP to jump to address <span class="EmphasisFontCategoryNonProportional ">216</span> to continue executing the next instruction after the call to our routine:<div class="ProgramCode" id="PC14"><div class="LineGroup"><div class="FixedLine">0x024C&nbsp;&nbsp;0x8B4C2404&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV ECX,[ESP+4]</div><div class="FixedLine">0x0250&nbsp;&nbsp;0x8B7C2408&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EDI,[ESP+8]</div><div class="FixedLine">0x0254&nbsp;&nbsp;0x8B5C240C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EBX,[ESP+12]</div><div class="FixedLine">0x0258&nbsp;&nbsp;0x8B542410&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EDX,[ESP+16]</div></div><div class="LineGroup"><div class="FixedLine">0x025C&nbsp;&nbsp;0xB800000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EAX,0x0</div><div class="FixedLine">0x0261&nbsp;&nbsp;0xBE00000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV ESI,0x0</div></div><div class="LineGroup"><div class="FixedLine">0x0266&nbsp;&nbsp;0x8A0432&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV AL,[EDX+ESI]</div><div class="FixedLine">0x0269&nbsp;&nbsp;0x8A2433&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV AH,[EBX+ESI]</div><div class="FixedLine">0x026C&nbsp;&nbsp;0x00E0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ADD AL,AH</div><div class="FixedLine">0x026E&nbsp;&nbsp;0x8807&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV [EDI],AL</div><div class="FixedLine">0x0270&nbsp;&nbsp;0x46&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INC ESI</div><div class="FixedLine">0x0271&nbsp;&nbsp;0x47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;INC EDI</div><div class="FixedLine">0x0272&nbsp;&nbsp;0xE2F2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LOOP 0x266</div></div><div class="LineGroup"><div class="FixedLine">0x0274&nbsp;&nbsp;0xC3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RET</div></div></div></div><div class="Para" id="Par55">Our routine is simpler than the first list addition example; it doesn’t need to use any temporary variables to get its job done. But if we did need temporary variables, there’s a way to use the stack to store those variables so that you do not have to allocate them in memory and then have to remember to free that memory. If you use the stack, when your function returns, the stack pointer is adjusted appropriately. It’s like a free scratch space for storing information. The way you accomplish this is to simply add the amount of space you want to allocate to the stack pointer, like this:<div class="ProgramCode" id="PC15"><div class="LineGroup"><div class="FixedLine">ADD&nbsp;&nbsp;&nbsp;&nbsp;ESP, 24</div></div></div></div><div class="Para" id="Par56">One problem, though, is as routines call other routines (so-called subroutines), the stack will grow. The stack pointer will continue to grow downward as you push items onto it and call other functions. Within your routine, you need some way to reference your local variables. We use the EBP <span id="ITerm31">register</span>, also called the <span id="ITerm32">base pointer</span>, to save the value of ESP before we change it. There’s a trick, though, because the routine that called our routine may also be using the base pointer to keep track of its local variable space. To avoid any issues, we push the current base pointer, set the base pointer to the current stack pointer, and then move the stack pointer, like this:<div class="ProgramCode" id="PC16"><div class="LineGroup"><div class="FixedLine">PUSH&nbsp;&nbsp;EBP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;save current base pointer</div><div class="FixedLine">MOV&nbsp;&nbsp;&nbsp;EBP, ESP&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;set base pointer to ESP</div><div class="FixedLine">ADD&nbsp;&nbsp;&nbsp;ESP, 24&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;;move ESP down the stack</div></div></div></div><div class="Para" id="Par57">The area on the stack we use for this purpose is called the “stack frame.” To reference this space, we can now subtract from the base pointer, EBP. For example, to initialize three locations on this space, you could do this:<div class="ProgramCode" id="PC17"><div class="LineGroup"><div class="FixedLine">MOV [EBP-4], 1</div><div class="FixedLine">MOV [EBP-8], 2</div><div class="FixedLine">MOV [EBP-12],4</div></div></div></div><div class="Para" id="Par58">Now we can reference those locations throughout our routine. When we exit our routine, we need to do some cleanup before calling the return function. Basically, we need to restore the stack pointer and then pop the <span class="EmphasisFontCategoryNonProportional ">EBP</span> register off the stack to restore the stack frame to what our caller expected:<div class="ProgramCode" id="PC18"><div class="LineGroup"><div class="FixedLine">MOV ESP, EBP</div><div class="FixedLine">POP EBP</div><div class="FixedLine">RET</div></div></div></div><p class="Para" id="Par59">Remember how we pushed parameters on the stack before calling our function? We definitely want to clean those up. That can be done either by our routine using the <span class="EmphasisFontCategoryNonProportional ">RET</span> (short for “return” to the caller) instruction, or we can expect the caller to clean up the stack. This is referred to as the “calling convention” for a routine. It’s important to understand the calling convention that the code you are calling uses, and you should pick a consistent calling convention when you write code. Luckily, higher-level programing languages do this for us, but as we write assembly code to work with those higher-level languages, we need to follow those language conventions.</p></section><section class="Section2 RenderAsSection2" id="Sec9"><h3 class="Heading">Instruction Pipeline</h3><p class="Para" id="Par60">CPUs are designed to fetch, decode, and execute instructions as efficiently as possible. The <span id="ITerm33">circuitry</span> of the CPU is designed in stages that can run in parallel, called parallel execution units. For example, when the CPU is performing the second stage of an instruction, it can start executing the next instruction’s first phase. This allows the CPU to use all of its circuitry and execute instructions faster. The stages of executing an instruction are referred to as a pipeline.</p><div class="Para" id="Par61">A simple five-stage pipeline would have stages for fetching (F), decoding (D), executing (E), accessing memory (M), and writing to a register (R). Here are instructions executing without a pipeline:<div class="Table" id="Tabf"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"><col class="tcol3 align-left"><col class="tcol4 align-left"><col class="tcol5 align-left"><col class="tcol6 align-left"><col class="tcol7 align-left"><col class="tcol8 align-left"><col class="tcol9 align-left"><col class="tcol10 align-left"></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T9</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T10</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">F1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">D1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">E1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">M1</p></td><td colspan="6" style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">R1</p></td></tr><tr><td colspan="6" style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">F2</p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">D2</p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">E2</p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">M2</p></td><td style="text-align: left;"><p class="SimplePara">R2</p></td></tr></tbody></table></div></div><p class="Para" id="Par62">The first row is time (T1–T10), the second row is the first instruction, and the third row is the second instruction. In this example, we can’t fetch the second instruction until the first instruction completes all five stages:</p><div class="Para" id="Par63">Utilizing parallel stages in the pipeline, we can start fetching the second instruction after the first one moves to the second stage. This will enable the CPU to greatly decrease the amount of time it takes to execute the two instructions. Instead of ten steps, the instructions are done in only six steps, as follows:<div class="Table" id="Tabg"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"><col class="tcol3 align-left"><col class="tcol4 align-left"><col class="tcol5 align-left"><col class="tcol6 align-left"><col class="tcol7 align-left"><col class="tcol8 align-left"><col class="tcol9 align-left"><col class="tcol10 align-left"></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T2</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T3</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T4</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T5</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T6</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T7</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T8</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T9</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">T10</p></td></tr><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">F1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">D1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">E1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">M1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">R1</p></td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-bottom: 0.5pt solid ; text-align: left;">&nbsp;</td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">F2</p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">D2</p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">E2</p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">M2</p></td><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">R2</p></td><td style="border-right: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-right: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="border-right: 0.5pt solid ; text-align: left;">&nbsp;</td><td style="text-align: left;">&nbsp;</td></tr></tbody></table></div></div><p class="Para" id="Par64">There are instances where the pipeline will not work well, for example, when the next instruction is relying on the result from a previous instruction. This is called a <span id="ITerm34">data hazard</span>. If you’re writing code in assembly language, you need to consider how you’re using registers to ensure that these hazards are avoided. For higher-level languages, the compiler and assembler will optimize the machine language to ensure the pipeline is executing efficiently to get the best performance out of the processor.</p><p class="Para" id="Par65">Modern processors have a deep pipeline consisting of over 30 stages! They also use very fast internal memory called a cache to prefetch instructions and data and even execute instructions proactively by predicting the control flow.</p></section><section class="Section2 RenderAsSection2" id="Sec10"><h3 class="Heading">Flynn’s Taxonomy</h3><p class="Para" id="Par66">Let’s revisit the code we wrote to add the values of two lists of numbers. In that <span id="ITerm35">example</span>, we were using the add instruction repeatedly on the data in memory. Each instruction was executed against a single piece of data. What if you could tell the processor to execute the add instruction on all of that data with a single instruction? Well, you can. It’s called a <span id="ITerm36">single instruction, multiple data (SIMD)</span> operation. In 1966, Michael J. Flynn proposed a taxonomy for the different ways that instructions operate on data.</p><div class="Para" id="Par67">Flynn defined a taxonomy in 1966 to classify parallel computing scenarios. In a parallel computing environment, you have multiple independent processors that can execute concurrently. Today, CPUs have multiple cores that can execute tasks in parallel, so they can execute parallel instructions. Flynn defined four classes, or scenarios:<div class="Table" id="Tabh"><table style="border-collapse: collapse;border-top: 0.5pt solid ; border-bottom: 0.5pt solid ; border-left: 0.5pt solid ; border-right: 0.5pt solid ; "><colgroup><col class="tcol1 align-left"><col class="tcol2 align-left"></colgroup><tbody><tr><td style="border-right: 0.5pt solid ; border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Single instruction, single data (SISD)</p></td><td style="border-bottom: 0.5pt solid ; text-align: left;"><p class="SimplePara">Single instruction, multiple data (SIMD)</p></td></tr><tr><td style="border-right: 0.5pt solid ; text-align: left;"><p class="SimplePara">Multiple instruction, single data (MISD)</p></td><td style="text-align: left;"><p class="SimplePara">Multiple instruction, multiple data (MIMD)</p></td></tr></tbody></table></div></div><div class="Para" id="Par68">We’ve been focusing on SISD, single <span id="ITerm37">instruction</span>, single data, which is typical in a single-processor scenario. Let’s look at our example of adding two lists of numbers together. The two lists of numbers are multiple data inputs, and it turns out there are instructions in the x86 instruction set that support multiple data inputs, or SIMD instructions as defined by Flynn. It’s kind of interesting how it works. We will use the x86 <span class="EmphasisFontCategoryNonProportional ">PADDB</span> instruction to add the values of both lists together in one shot. <span class="EmphasisFontCategoryNonProportional ">PADDB</span> stands for “add packed integers.” To use the <span class="EmphasisFontCategoryNonProportional ">PADDB</span> instruction, you need to “pack” the data into a register using the <span class="EmphasisFontCategoryNonProportional ">MOVDQU</span> instruction. <span class="EmphasisFontCategoryNonProportional ">MOVDQU</span> stands for “move aligned double quadword.” A double quadword is 128 bits (2 × 4 × 16) and is also referred to as an “<span class="EmphasisFontCategoryNonProportional ">OWORD.</span>” If you remember, our previous example used lists that had 4 bytes. If we increase those to hold 16 bytes, then we have 128 bits. We can “pack” those 128 bits of contiguous data into a 128-bit register using the <span class="EmphasisFontCategoryNonProportional ">MOVDQU</span> instruction, use <span class="EmphasisFontCategoryNonProportional ">PADDB</span> to do the addition in one instruction, and then move the result to the destination passed in on the stack as follows:<div class="ProgramCode" id="PC19"><div class="LineGroup"><div class="FixedLine">0x00000256&nbsp;&nbsp;0x8B7C2404&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EDI,[RSP+4]</div><div class="FixedLine">0x0000025A&nbsp;&nbsp;0x8B5C2408&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EBX,[RSP+8]</div><div class="FixedLine">0x0000025E&nbsp;&nbsp;0x8B54240C&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;MOV EDX,[RSP+12]</div><div class="FixedLine">0x00000262&nbsp;&nbsp;0xF30F6F02&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="EmphasisTypeBold ">MOVDQU XMM0, OWORD [RDX]</strong></div><div class="FixedLine">0x00000266&nbsp;&nbsp;0xF30F6F0B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="EmphasisTypeBold ">MOVDQU XMM1, OWORD [RBX]</strong></div><div class="FixedLine">0x0000026A&nbsp;&nbsp;0x660FFCC1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="EmphasisTypeBold ">PADDB XMM0,XMM1</strong></div><div class="FixedLine">0x0000026E&nbsp;&nbsp;0xF30F7F07&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong class="EmphasisTypeBold ">MOVDQU OWORD [RDI],XMM0</strong></div><div class="FixedLine">0x00000272&nbsp;&nbsp;0xC3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;RET</div></div></div></div><p class="Para" id="Par69">Using the <span class="EmphasisFontCategoryNonProportional ">PADDB</span> instruction, we’ve removed the loop entirely! Packing your data into the XMM registers is the trick that makes it work. This implies that these instructions have limitations as to the amount of data you can pack and add at a time, so if the data set is large, you would still have to write a loop to complete the operation, but in the end it should be faster.</p><p class="Para" id="Par70">Multiple instruction, multiple data, or MIMD, is the case where you have multiple CPUs or CPU cores operating on multiple data streams at once. This is a typical multiprocessor scenario that happens often in today’s seemingly single-processor systems. Most CPUs today have multiple cores built into them that can truly execute instructions in parallel. Most of the coordination of running programs on different cores in parallel is handled by the operating system. As a programmer, you write a program, and within that program if you want to execute multiple instructions concurrently on different CPUs, you create execution threads for those instructions with some help from the operating system.</p><p class="Para" id="Par71"><span id="ITerm38">Multiple instruction, single data (MISD)</span><span id="ITerm39">


</span> is a less common technique. A good example of MISD would be a fault-tolerant system where you may have processors run a known algorithm on the same data set. If the results don’t match, the system knows one of the processors is malfunctioning, at which point it can stop using it and let humans know to replace it!</p></section></section><section class="Section1 RenderAsSection1" id="Sec11"><h2 class="Heading">Main Memory and Secondary Storage</h2><p class="Para" id="Par72">We’ve covered how the CPU fetches information from memory using <span id="ITerm40">addresses</span> and how it decodes and executes instructions with help from special memory locations called registers. We also now know that information in memory is stored in byte-sized chunks (8 bits per byte) and that the CPU keeps track of the next instruction using an instruction pointer. To do its job effectively, the CPU must be able to access any location in memory quickly, which means the main memory must support random access. We call this type of memory “random access memory,” or RAM. The main memory must be very fast and is implemented using electronic circuits consisting of capacitors and transistors that work together to store bits. Electronic circuits can only save information while they have power, so that type of memory is called “<span id="ITerm41">volatile memory</span>.” Therefore, a computer system also needs “<span id="ITerm42">non-volatile memory</span>” that will save instructions when there’s no power. This type of memory is called secondary storage.</p><p class="Para" id="Par73">Originally, instructions were encoded on punch cards that were fed by hand into memory. This was very cumbersome! Magnetic tape was originally invented to store audio in the late 1800s and further refined in the early 1900s. In 1950, the first tape recorder was created for storing digital information to be used by a computer. Information on a reel of magnetic tape could not be accessed randomly; instead, it had to be accessed from beginning to end, or sequentially. The tape drive is connected to the computer in a way that the computer can send the drive commands to start reading data from the tape and store it in a particular location in memory. After the instructions from the tape are loaded into <span id="ITerm43">memory</span>, the CPU instruction pointer is set to start reading those instructions. This was better than punch cards, but still relatively slow, especially as the number of instructions and data used to run a program increased.</p><p class="Para" id="Par74">Researchers invented the “hard drive” to provide random access to instructions and data. Hard drives store data on magnetic disks housed in a special container. The disks spin at a high rate, and the mechanism to read the data is on an arm that moves left and right across the surface of the disk to read the data. This provided a cheaper and faster way to read programs from secondary storage into the much faster main memory.</p><p class="Para" id="Par75">Floppy disks are another type of magnetic media invented after tape. The advantage of a floppy disk was that it could be inserted into a drive that had a head that moved left and right while the disk was spinning to read blocks of data in a more random fashion (but still much, much slower than RAM). They were called floppy drives because they were somewhat flexible when not inserted into the drive.</p><p class="Para" id="Par76">Secondary storage technology has continued to evolve from high-density CD ROM, which is read and written to using a laser, to <span id="ITerm44">solid-state drives (SSDs)</span> that have no moving parts at all. The evolution will continue with the advent of persistent memory that has the potential to be an alternative for main memory that does not lose its content when power is removed or lost. Imagine the implications of a system where the main memory is persistent and instructions no longer have to be moved from secondary storage to main memory before the CPU starts its fetch, decode, and execute cycle.</p></section><section class="Section1 RenderAsSection1" id="Sec12"><h2 class="Heading">Input and Output (I/O)</h2><div class="Para" id="Par77">We’ve talked about how the CPU needs to load the instructions from secondary storage into main memory. But how is that actually done? In modern computers, devices are connected to the same address bus as the CPU and main memory, as depicted in Figure <span class="InternalRef"><a href="#Fig4">1-4</a></span>. This enables CPU instructions to use memory addresses to perform input and output (I/O) <span id="ITerm45">operations</span><span id="ITerm46">


</span> with devices, which is called “memory-mapped I/O (MMIO).”<figure class="Figure" id="Fig4"><div class="MediaObject" id="MO4"><img alt="../images/503707_1_En_1_Chapter/503707_1_En_1_Fig4_HTML.jpg" src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781484271070/files/images/503707_1_En_1_Chapter/503707_1_En_1_Fig4_HTML.jpg" style="width:27.5em" width="1100" height="609"></div><figcaption class="Caption" lang="en"><div class="CaptionContent"><span class="CaptionNumber">Figure 1-4</span><p class="SimplePara">Devices Connected to the Address Bus</p></div></figcaption></figure></div><p class="Para" id="Par78">In early x86 processors, there were <span class="EmphasisFontCategoryNonProportional ">input</span> and <span class="EmphasisFontCategoryNonProportional ">output</span> instructions that read and wrote to I/O port addresses. Using other CPU instructions with the I/O port addresses would reference main memory, not the intended device. The only way to interact with the device was by using <span class="EmphasisFontCategoryNonProportional ">input</span> and <span class="EmphasisFontCategoryNonProportional ">output</span> instructions to load data into CPU registers and then execute instructions using those registers as operands. With memory-mapped I/O, you can simply use the address location for the device as the operand for any CPU instruction. The <span class="EmphasisFontCategoryNonProportional ">input</span> and <span class="EmphasisFontCategoryNonProportional ">output</span> instructions still exist in the x86 ISA, but aren’t used except by the operating system and some common device drivers.</p><p class="Para" id="Par79">Through these memory accesses, the CPU can set values that the device interprets as commands. A common scenario is the CPU telling the device to transfer data into main memory, for example, having a hard drive transfer data from its disk to main memory, which is called direct memory access, or DMA. After telling a device to initiate direct memory access, the CPU is free to execute other instructions.</p><p class="Para" id="Par80">When a device completes its operation, it will let the CPU know it is done through an <span id="ITerm47">interrupt</span>, which is a signal connected to the CPU that the device raises or lowers to get the CPU’s attention. When the CPU receives the signal, it can stop executing instructions and switch to a special routine that takes care of the interrupt.</p></section><section class="Section1 RenderAsSection1" id="Sec13"><h2 class="Heading">Summary</h2><div class="Para" id="Par81">In this chapter, we learned about the fundamentals of a computer system:<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par82"><span id="ITerm48">von Neumann Architecture</span>: Central arithmetic and central control (C), main memory (M), input (I), output (O), and recording medium (R)</p></li><li><p class="Para" id="Par83">Operation of a CPU: Fetch, decode, execute, and store</p></li><li><p class="Para" id="Par84">Instruction set architecture and register sets</p></li><li><p class="Para" id="Par85">Controlling the flow of execution and using the stack to implement routines</p></li><li><p class="Para" id="Par86">Classifying parallel instruction and data using Flynn’s taxonomy</p></li><li><p class="Para" id="Par87">Understanding the difference between main memory and secondary storage</p></li><li><p class="Para" id="Par88">Input and Output: Memory-mapped I/O and interrupts</p></li></ul></div></div><p class="Para" id="Par89">Now that we have a basic understanding and hopefully appreciation of computer fundamentals, we can move on to Chapter <span class="ExternalRef"><a href="503707_1_En_2_Chapter.xhtml"><span class="RefSource">2</span></a></span>.</p></section><section class="Section1 RenderAsSection1" id="Sec14"><h2 class="Heading">References and Further Reading</h2><div class="Para" id="Par90">
<div class="UnorderedList"><ul class="UnorderedListMarkBullet"><li><p class="Para" id="Par91">The ENIAC Story: <span class="ExternalRef"><a href="https://web.archive.org/web/20110814181522/http://ftp.arl.mil/%257Emike/comphist/eniac-story.html"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">https://web.archive.org/web/20110814181522/http://ftp.arl.mil/~mike/comphist/eniac-story.html</span></span></a></span></p></li><li><p class="Para" id="Par93">Intel 8088 Microprocessor Family: <span class="ExternalRef"><a href="http://www.cpu-world.com/CPUs/8088/"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">www.cpu-world.com/CPUs/8088/</span></span></a></span></p></li><li><p class="Para" id="Par94">“First Draft of a Report on the EDVAC”: <span class="ExternalRef"><a href="https://web.mit.edu/STS.035/www/PDFs/edvac.pdf"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">https://web.mit.edu/STS.035/www/PDFs/edvac.pdf</span></span></a></span></p></li><li><p class="Para" id="Par95">History of Magnetic Tape: <span class="ExternalRef"><a href="https://history-computer.com/ModernComputer/Basis/tape.html"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">https://history-computer.com/ModernComputer/Basis/tape.html</span></span></a></span></p></li><li><p class="Para" id="Par96">Introduction to Dynamic Random Access Memory: <span class="ExternalRef"><a href="http://www.allaboutcircuits.com/technical-articles/introduction-to-dram-dynamic-random-access-memory/"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">www.allaboutcircuits.com/technical-articles/introduction-to-dram-dynamic-random-access-memory/</span></span></a></span></p></li><li><p class="Para" id="Par97">John L. Patterson, David A. Hennessy. <em class="EmphasisTypeItalic ">Computer Organization and Design: The Hardware/Software Interface</em>. Elsevier Science Ltd, 2007</p></li><li><p class="Para" id="Par98">Intel 64 and IA-32 Architectures Software Developer Manuals: <span class="ExternalRef"><a href="https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">https://software.intel.com/content/www/us/en/develop/articles/intel-sdm.html</span></span></a></span></p></li><li><p class="Para" id="Par100">ARM Developer Documentation: <span class="ExternalRef"><a href="https://developer.arm.com/documentation"><span class="RefSource"><span class="EmphasisFontCategoryNonProportional ">https://developer.arm.com/documentation</span></span></a></span></p></li></ul></div>
</div></section></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781484271070/files/css/springer_epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com