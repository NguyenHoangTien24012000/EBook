<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class=""><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2 noOutline" id="ch22" tabindex="-1"><span epub:type="pagebreak" id="page_391"></span><span class="f1">22</span><br>JAVASCRIPT AND PERFORMANCE</h2>
        <p class="intro">Running a computer program on a machine requires bridging the gap between the programming language and the machine’s own instruction format. This can be done by writing a program that <em>interprets</em> other programs, as we did in <a href="ch11.xhtml#ch11">Chapter 11</a>, but it is usually done by <em>compiling</em> (translating) the program to machine code.</p>
        <p class="indent">Some languages, such as the C and Rust programming languages, are designed to express exactly those things that the machine is known to be good at. This makes them easy to compile efficiently. JavaScript is designed in a very different way, focusing on simplicity and ease of use instead. Almost none of its features correspond directly to features of the machine. That makes JavaScript a lot more difficult to compile.</p>
        <p class="indent">Yet somehow modern JavaScript <em>engines</em> (the programs that compile and run JavaScript) do manage to run scripts at a surprising speed. It is possible to write JavaScript programs that are about 10 percent as fast as an equivalent C or Rust program. That may still sound like a huge gap, but older JavaScript engines (as well as contemporary implementations of languages with a similar design, such as Python and Ruby), tend to be closer to 1 percent the speed of C. Compared to these languages, modern JavaScript is <span epub:type="pagebreak" id="page_392"></span>strikingly fast—so fast that you’ll rarely be forced to switch to another language because of performance problems.</p>
        <p class="indent">Still, you may occasionally need to rewrite your code to avoid the slower aspects of JavaScript. As an example of that process, this chapter works through a speed-hungry program and makes it faster. In the process we’ll discuss the way JavaScript engines compile your programs.</p>
        <h3 class="h3" id="ch22lev1">Staged Compilation</h3>
        <p class="noindent">First you must understand that JavaScript compilers do not simply compile a program once, the way classical compilers do. Instead, code is compiled and recompiled as needed, while the program is running.</p>
        <p class="indent">With most languages, compiling a big program takes a while. That is usually acceptable because programs are compiled ahead of time and distributed in compiled form.</p>
        <p class="indent">For JavaScript the situation is different. A website might include a large amount of code that is retrieved in text form and must be compiled every time the website is opened. If that took five minutes, the user wouldn’t be happy. A JavaScript compiler must be able to start running a program—even a big program—almost instantaneously.</p>
        <p class="indent">To do this, JavaScript compilers have multiple compilation strategies. When a website is opened, the scripts are first compiled in a cheap, superficial way. This doesn’t result in very fast execution, but it allows the script to start quickly. Functions may not be compiled at all until the first time they are called.</p>
        <p class="indent">In a typical program, most code is run only a handful of times (or not at all). For these parts of the program, the cheap compilation strategy is sufficient—they won’t take much time anyway. But functions that are called often or that contain loops that do a lot of work have to be treated differently. While running the program, the JavaScript engine observes how often each piece of code runs. When it looks like some code might consume a serious amount of time (this is often called <em>hot code</em>), it is recompiled with a more advanced but slower compiler. This compiler performs more <em>optimizations</em> to produce faster code. There may even be more than two compilation strategies, with ever more expensive optimizations being applied to <em>very</em> hot code.</p>
        <p class="indent">Interleaving running and compiling code means that by the time the clever compiler starts working with a piece of code, it has already been run multiple times. This makes it possible to <em>observe</em> the running code and gather information about it. Later in the chapter we’ll see how that can allow the compiler to create more efficient code.</p>
        <h3 class="h3" id="ch22lev2">Graph Layout</h3>
        <p class="noindent">Our example problem for this chapter concerns itself with graphs again. Pictures of graphs can be useful to describe road systems, networks, the way control flows through a computer program, and so on. The following <span epub:type="pagebreak" id="page_393"></span>picture shows a graph representing some countries in the Middle East, with edges between those that share land borders:</p>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492071198/files/images/f0393-01.jpg" alt="Image" width="524" height="303"></div>
        <p class="indent">Deriving a picture like this from the definition of a graph is called <em>graph layout</em>. It involves assigning a place to each node in such a way that connected nodes are near each other, yet the nodes don’t crowd into each other. A random layout of the same graph is a lot harder to interpret.</p>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492071198/files/images/f0393-02.jpg" alt="Image" width="539" height="303"></div>
        <p class="indent">Finding a nice-looking layout for a given graph is a notoriously difficult problem. There is no known solution that reliably does this for arbitrary graphs, and large, densely connected graphs are especially hard. But for some specific types of graphs, for example, <em>planar</em> ones (which can be drawn without edges crossing each other), effective approaches exist.</p>
        <p class="indent">To lay out a small graph (say, up to 200 nodes) that isn’t too tangled, we can apply an approach called <em>force-directed graph layout</em>. This runs a simplified physics simulation on the nodes of the graph, treating edges as if they are springs and having the nodes themselves repel each other as if electrically charged.</p>
        <p class="indent">In this chapter we’ll implement a force-directed graph layout system and observe its performance. We can run such a simulation by repeatedly computing the forces that act on each node and moving the nodes around in response to those forces. Performance of such a program is important <span epub:type="pagebreak" id="page_394"></span>since it might take a lot of iterations to reach a good-looking layout and each iteration computes a lot of forces.</p>
        <h3 class="h3" id="ch22lev3">Defining a Graph</h3>
        <p class="noindent">We can represent a graph layout as an array of <span class="literal">GraphNode</span> objects, each of which carries its current position and an array of the nodes to which it has edges. We randomize their starting positions.</p>
        <p class="programs">class GraphNode {<br>&nbsp;&nbsp;constructor() {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.pos = new Vec(Math.random() * 1000,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Math.random() * 1000);<br>&nbsp;&nbsp;&nbsp;&nbsp;this.edges = [];<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;connect(other) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.edges.push(other);<br>&nbsp;&nbsp;&nbsp;&nbsp;other.edges.push(this);<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;hasEdge(other) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return this.edges.includes(other);<br>&nbsp;&nbsp;}<br>}</p>
        <p class="indent">This uses the familiar <span class="literal">Vec</span> class from previous chapters to represent positions and forces.</p>
        <p class="indent">The <span class="literal">connect</span> method is used to connect a node to another node when building up a graph. To find out whether two nodes are connected, we’ll call the <span class="literal">hasEdge</span> method.</p>
        <p class="indent">To build up graphs to test our programs, we’ll use a function called <span class="literal">treeGraph</span>. It takes two parameters that specify the depth of the tree and the number of branches to create at each split, and it recursively constructs a tree-shaped graph with the specified shape.</p>
        <p class="programs">function treeGraph(depth, branches) {<br>&nbsp;&nbsp;let graph = [new GraphNode()];<br>&nbsp;&nbsp;if (depth &gt; 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; branches; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let subGraph = treeGraph(depth - 1, branches);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graph[0].connect(subGraph[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;graph = graph.concat(subGraph);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return graph;<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_395"></span>Tree-shaped graphs don’t contain cycles, which makes them relatively easy to lay out and allows even the unsophisticated program we build in this chapter to produce good-looking shapes.</p>
        <p class="indent">The graph created by <span class="literal">treeGraph(3, 5)</span> would be a tree of depth 3, with five branches.</p>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492071198/files/images/f0395-01.jpg" alt="Image" width="228" height="226"></div>
        <p class="indent">To allow us to inspect the layouts produced by our code, I’ve defined a <span class="literal">drawGraph</span> function that draws the graph onto a canvas. This function is defined in the code at <em><a href="http://eloquentjavascript.net/code/draw_layout.js">eloquentjavascript.net/code/draw_layout.js</a></em> and is available in the online sandbox.</p>
        <h3 class="h3" id="ch22lev4">Force-Directed Layout</h3>
        <p class="noindent">We’ll move nodes one at a time, computing the forces that act on the current node and immediately moving that node in the direction of the sum of these forces.</p>
        <p class="indent">The force that an (idealized) spring applies can be approximated with Hooke’s law, which says that this force is proportional to the difference between the spring’s resting length and its current length. The binding <span class="literal">springLength</span> defines the resting length of our edge springs. The rigidity of the springs is defined by <span class="literal">springStrength</span>, which we’ll multiply by the length difference to determine the resulting force.</p>
        <p class="programs">const springLength = 40;<br>const springStrength = 0.1;</p>
        <p class="indent">To model the repulsion between nodes, we use another physical formula—Coulomb’s law—which says that the repulsion between two electrically charged particles is inversely proportional to the square of the distance between them. When two nodes are almost on top of each other, the squared distance is tiny, and the resulting force is gigantic. As the nodes move further apart, the squared distance grows rapidly so that the repelling force quickly weakens.</p>
        <p class="indent">We’ll again multiply by an experimentally determined constant, <span class="literal">repulsionStrength</span>, which controls the strength with which nodes repel each other.</p>
        <p class="programs">const repulsionStrength = 1500;</p>
        <p class="indent"><span epub:type="pagebreak" id="page_396"></span>The force that acts on a given node is computed by looping over all other nodes and applying the repelling force for each of them. When another node shares an edge with the current node, the force caused by the spring is also applied.</p>
        <p class="indent">Both of these forces depend on the distance between the two nodes. For each pair of nodes, our function will compute a vector named <span class="literal">apart</span> that represents the path from the current node to the other node. The function then takes the length of the vector to find the actual distance. When the distance is less than one, we set it to one to prevent dividing by zero or by very small numbers because that will produce <span class="literal">NaN</span> values or forces so gigantic they catapult the node into outer space.</p>
        <p class="indent">Using this distance, we can compute the magnitude of the force that acts between these two given nodes. To go from a magnitude to a force vector, we must multiply the magnitude by a normalized version of the <span class="literal">apart</span> vector. <em>Normalizing</em> a vector means creating a vector with the same direction but with a length of one. We can do that by dividing the vector by its own length.</p>
        <p class="programs">function forceDirected_simple(graph) {<br>&nbsp;&nbsp;for (let node of graph) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let other of graph) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (other == node) continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let apart = other.pos.minus(node.pos);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let distance = Math.max(1, apart.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let forceSize = -repulsionStrength / (distance * distance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.hasEdge(other)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forceSize += (distance - springLength) * springStrength;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let normalized = apart.times(1 / distance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.pos = node.pos.plus(normalized.times(forceSize));<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</p>
        <p class="indent">We will use the following function to test a given implementation of our graph layout system. It runs the model for 4,000 steps and tracks the time this takes. To give us something to look at while the code runs, it draws the current layout of the graph after every 100 steps.</p>
        <p class="programs">function runLayout(implementation, graph) {<br>&nbsp;&nbsp;function run(steps, time) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let startTime = Date.now();<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; 100; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;implementation(graph);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;time += Date.now() - startTime;<br>&nbsp;&nbsp;&nbsp;&nbsp;drawGraph(graph);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (steps == 0) console.log(time);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else requestAnimationFrame(() =&gt; run(steps - 100, time));<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;run(4000, 0);<br>&nbsp;&nbsp;}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_397"></span>We could now run this first implementation and see how much time it takes.</p>
        <p class="programs">&lt;script&gt;<br>&nbsp;&nbsp;runLayout(forceDirected_simple, treeGraph(4, 4));<br>&lt;/script&gt;</p>
        <p class="indent">On my machine, using version 58 of the Firefox browser, those 4,000 iterations took a little more than two seconds, so that’s two iterations per millisecond. That’s a lot. Let’s see whether we can do better.</p>
        <h3 class="h3" id="ch22lev5">Avoiding Work</h3>
        <p class="noindent">The fastest way to do something is to avoid doing it—or at least part of it—at all. By thinking about what the code is doing, you can often spot unnecessary redundancy or things that can be done in a faster way.</p>
        <p class="indent">In the case of our example project, there is such an opportunity for doing less work. Every pair of nodes has the forces between them computed twice, once when moving the first node and once when moving the second. Since the force that node <em>X</em> exerts on node <em>Y</em> is exactly the opposite of the force <em>Y</em> exerts on <em>X</em>, we do not need to compute these forces twice.</p>
        <p class="indent">The next version of the function changes the inner loop to go over only the nodes that come after the current one so that each pair of nodes is looked at exactly once. After computing a force between a pair of nodes, the function updates the position of both.</p>
        <p class="programs">function forceDirected_noRepeat(graph) {<br>&nbsp;&nbsp;for (let i = 0; i &lt; graph.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let node = graph[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let j = i + 1; j &lt; graph.length; j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let other = graph[j];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let apart = other.pos.minus(node.pos);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let distance = Math.max(1, apart.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let forceSize = -repulsionStrength / (distance * distance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (node.hasEdge(other)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forceSize += (distance - springLength) * springStrength;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let applied = apart.times(forceSize / distance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.pos = node.pos.plus(applied);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.pos = other.pos.minus(applied);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_398"></span>Measuring this code shows a significant speed boost. It is twice as fast on Firefox 58, about 30 percent faster on Chrome 63, and 75 percent faster on Edge 6.</p>
        <p class="indent">The big boost on Firefox and Edge is only partially a result of the actual optimization. Because we need the inner loop to go over only part of the array, the new function replaces the <span class="literal">for</span>/<span class="literal">of</span> loops with regular <span class="literal">for</span> loops. On Chrome, this has no measurable effect on the speed of the program, but on Firefox simply not using iterators makes the code 20 percent faster—and on Edge it makes a 50 percent difference.</p>
        <p class="indent">So, different JavaScript engines work differently and may run programs at different speeds. A change that makes code run faster in one engine may not help (or may even hurt) in another engine—or even a different version of the same engine.</p>
        <p class="indent">Interestingly, Chrome’s engine, which is called V8 and is also the one Node.js uses, is able to optimize <span class="literal">for</span>/<span class="literal">of</span> loops over arrays to code that’s no slower than looping over the index. Remember that the iterator interface involves a method call that returns an object for each element in the iterator. Somehow, V8 manages to optimize most of that away.</p>
        <p class="indent">Taking another good look at what our program is doing, possibly by calling <span class="literal">console.log</span> to output <span class="literal">forceSize</span>, it becomes clear that the forces generated between most pairs of nodes are so tiny that they aren’t really impacting the layout at all. Specifically, when nodes are not connected and are far away from each other, the forces between them don’t amount to much. Yet we still compute vectors for them and move the nodes a tiny bit. What if we just didn’t?</p>
        <p class="indent">This next version defines a distance above which pairs of (unconnected) nodes will no longer compute and apply forces. With that distance set to 175, forces below 0.05 are ignored.</p>
        <p class="programs">const skipDistance = 175;<br><br>function forceDirected_skip(graph) {<br>&nbsp;&nbsp;for (let i = 0; i &lt; graph.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let node = graph[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let j = i + 1; j &lt; graph.length; j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let other = graph[j];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let apart = other.pos.minus(node.pos);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let distance = Math.max(1, apart.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let hasEdge = node.hasEdge(other);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!hasEdge &amp;&amp; distance &gt; skipDistance) continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let forceSize = -repulsionStrength / (distance * distance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hasEdge) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forceSize += (distance - springLength) * springStrength;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let applied = apart.times(forceSize / distance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.pos = node.pos.plus(applied);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.pos = other.pos.minus(applied);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_399"></span>This yields another 50 percent improvement in speed, with no discernable degradation of the layout. We cut a corner and got away with it.</p>
        <h3 class="h3" id="ch22lev6">Profiling</h3>
        <p class="noindent">We were able to speed up the program quite a bit just by reasoning about it. But when it comes <em>micro-optimization</em>—the process of doing things slightly differently to make them faster—it is usually hard to predict which changes will help and which won’t. There we can no longer rely on reasoning—we have to <em>observe</em>.</p>
        <p class="indent">Our <span class="literal">runLayout</span> function measures the time the program currently takes. That’s a good start. To improve something, you must measure it. Without measuring, you have no way of knowing whether your changes are having the effect you intended.</p>
        <p class="indent">The developer tools in modern browsers provide an even better way to measure the speed of your program. This tool is called a <em>profiler</em>. It will, while a program is running, gather information about the time used by the various parts of the program.</p>
        <p class="indent">If your browser has a profiler, it will be available from the developer tool interface, probably on a tab called Performance. The profiler in Chrome spits out the following table when I have it record 4,000 iterations of our current program:</p>
        <p class="programs">Self time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Total time&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Function<br>&nbsp;816.6 ms 75.4 %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1030.4 ms 95.2&nbsp;&nbsp;%&nbsp;&nbsp;&nbsp;forceDirected_skip<br>&nbsp;194.1 ms 17.9 %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;199.8 ms 18.5&nbsp;&nbsp;%&nbsp;&nbsp;&nbsp;includes<br>&nbsp;&nbsp;32.0 ms&nbsp; 3.0 %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;32.0 ms 3.0&nbsp;&nbsp;&nbsp;%&nbsp;&nbsp;&nbsp;Minor GC<br>&nbsp;&nbsp;&nbsp;2.1 ms&nbsp; 0.2 %&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1043.6 ms 96.4&nbsp;&nbsp;%&nbsp;&nbsp;&nbsp;run</p>
        <p class="indent">This lists the functions (or other tasks) that took a serious amount of time. For each function, it reports the time spent executing the function, both in milliseconds and as a percentage of the total time taken. The first column shows only the time that control was actually in the function, whereas the second column includes time spent in functions called by this function.</p>
        <p class="indent">As far as profiles go, that’s a <em>very</em> simple one since the program doesn’t <em>have</em> a lot of functions. For more complicated programs, the lists will be much, much longer. But because the functions that take the most time are shown at the top, it is still usually easy to find the interesting information.</p>
        <p class="indent">From this table, we can tell that by far the most time is spent in the physics simulation function. That wasn’t unexpected. But on the second <span epub:type="pagebreak" id="page_400"></span>row, we see the <span class="literal">includes</span> array method, as used in <span class="literal">GraphNode.hasEdge</span>, taking up about 18 percent of the program’s time.</p>
        <p class="indent">That <em>is</em> a bit more than I expected. We are calling it a lot—in an 85-node graph (which you get with <span class="literal">treeGraph(4, 4)</span>), there are 3,570 pairs of nodes. So with 4,000 iterations, that’s more than 14 million calls to <span class="literal">hasEdge</span>.</p>
        <p class="indent">Let’s see whether we can do better. We add another variant of the <span class="literal">hasEdge</span> method to the <span class="literal">GraphNode</span> class and create a new variant of our simulation function that calls that instead of <span class="literal">hasEdge</span>.</p>
        <p class="programs">GraphNode.prototype.hasEdgeFast = function(other) {<br>&nbsp;&nbsp;for (let i = 0; i &lt; this.edges.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (this.edges[i] === other) return true;<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return false;<br>};</p>
        <p class="indent">On Chrome, this shaves about 17 percent off the time it takes to compute the layout, which is most of the time taken by <span class="literal">includes</span> in the profile. On Edge, it makes the program 40 percent faster. But on Firefox, it makes it slightly (about 3 percent) slower. So, in this case, Firefox’s engine (called SpiderMonkey) did a better job optimizing calls to <span class="literal">includes</span>.</p>
        <p class="indent">The row labeled “Minor GC” in the profile gives us the time spent cleaning up memory that is no longer being used. Given that our program creates a huge number of vector objects, the 3 percent time spent reclaiming memory is strikingly low. JavaScript engines tend to have very effective garbage collectors.</p>
        <h3 class="h3" id="ch22lev7">Function Inlining</h3>
        <p class="noindent">No vector methods (such as <span class="literal">times</span>) show up in the profile we saw, even though they are being used heavily. This is because the compiler <em>inlined</em> them. Rather than having the code in the inner function call an actual method to multiply vectors, the vector-multiplication code is put directly inside the function, and no actual method calls happen in the compiled code.</p>
        <p class="indent">There are various ways in which inlining helps make code fast. Functions and methods are, at the machine level, called using a protocol that requires putting the arguments and the return address (the place where execution must continue when the function returns) somewhere the function can find them. The way a function call gives control to another part of the program also often requires saving some of the processor’s state so that the called function can use the processor without interfering with data that the caller still needs. All of this becomes unnecessary when a function is inlined.</p>
        <p class="indent">Furthermore, a good compiler will do its best to find ways to simplify the code it generates. If functions are treated as black boxes that might do anything, the compiler does not have a lot to work with. On the other hand, if it can see and include the function body in its analysis, it might find additional opportunities to optimize the code.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_401"></span>For example, a JavaScript engine could avoid creating some of the vector objects in our code altogether. In an expression like the following one, if we can see through the methods, it is clear that the resulting vector’s coordinates are the result of adding <span class="literal">force</span>’s coordinates to the product of <span class="literal">normalized</span>’s coordinates and the <span class="literal">forceSize</span> binding. Thus, there is no need to create the intermediate object produced by the <span class="literal">times</span> method.</p>
        <p class="programs">pos.plus(normalized.times(forceSize))</p>
        <p class="indent">But JavaScript allows us to replace methods at any time. How does the compiler figure out which function this <span class="literal">times</span> method actually is? And what if someone changes the value stored in <span class="literal">Vec.prototype.times</span> later? The next time code that has inlined that function runs, it might continue to use the old definition, violating the programmer’s assumptions about the way their program behaves.</p>
        <p class="indent">This is where the interleaving of execution and compilation starts to pay off. When a hot function is compiled, it has already run a number of times. If, during those runs, it always called the same function, it is reasonable to try inlining that function. The code is optimistically compiled with the assumption that, in the future, the same function is going to be called here.</p>
        <p class="indent">To handle the pessimistic case, where another function ends up being called, the compiler inserts a test that compares the called function to the one that was inlined. If the two do not match, the optimistically compiled code is wrong, and the JavaScript engine must <em>deoptimize</em>, meaning it falls back to a less optimized version of the code.</p>
        <h3 class="h3" id="ch22lev8">Creating Less Garbage</h3>
        <p class="noindent">Though some of the vector objects that we are creating might be optimized away entirely by some engines, there is likely still a cost to creating all those objects. To estimate the size of this cost, let’s write a version of the code that does the vector computations “by hand,” using local bindings for both dimensions.</p>
        <p class="programs">function forceDirected_noVector(graph) {<br>&nbsp;&nbsp;for (let i = 0; i &lt; graph.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let node = graph[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let j = i + 1; j &lt; graph.length; j++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let other = graph[j];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let apartX = other.pos.x - node.pos.x;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let apartY = other.pos.y - node.pos.y;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let distance = Math.max(1, Math.sqrt(apartX * apartX +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apartY * apartY));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let hasEdge = node.hasEdgeFast(other);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!hasEdge &amp;&amp; distance &gt; skipDistance) continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let forceSize = -repulsionStrength / (distance * distance);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (hasEdge) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forceSize += (distance - springLength) * springStrength;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let forceX = apartX * forceSize / distance;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let forceY = apartY * forceSize / distance;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;node.pos.x += forceX; node.pos.y += forceY;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;other.pos.x -= forceX; other.pos.y -= forceY;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_402"></span>The new code is wordier and more repetitive, but if I measure it, the improvement is large enough to consider doing this kind of manual object flattening in performance-sensitive code. On both Firefox and Chrome the new version is about 30 percent faster than the previous one. On Edge it’s about 60 percent faster.</p>
        <p class="indent">Taking all these steps together, we’ve made the program about 5 times faster than the initial version on Chrome and Firefox and more than 20 times faster on Edge. That’s quite an improvement. But remember that doing this work is useful only for code that actually takes a lot of time. Trying to optimize everything right away will only slow you down and leave you with a lot of needlessly overcomplicated code.</p>
        <h3 class="h3" id="ch22lev9">Garbage Collection</h3>
        <p class="noindent">So why is the code that avoids creating objects faster? There are several reasons. The engine has to find a place to store the objects, it has to figure out when they are no longer used and reclaim them, and when you access their properties, it has to figure out where in memory those are stored. JavaScript engines are good at all these things but usually not so good that they become free.</p>
        <p class="indent">Imagine memory, again, as a long, long row of bits. When the program starts, it might receive an empty piece of memory and just start putting the objects it creates in there, one after the other. But at some point, the space is full, and some of the objects in it are no longer used. The JavaScript engine has to figure out which objects are used, and which are not, so that it can reuse the unused pieces of memory.</p>
        <p class="indent">Now the program’s memory space is a bit of a mess, containing living objects interspersed with free space. Creating a new object involves finding a piece of free space large enough for the object, which might require some searching. Alternatively, the engine could move all live objects to the start of the memory space, which makes creating new objects cheaper (they can just be put one after the other again) but requires more work when moving the old objects.</p>
        <p class="indent">In principle, figuring out which objects are still used requires tracing through all reachable objects, starting from the global scope and the currently active local scope. Any object referenced from those scopes, directly or indirectly, is still alive. If your program has a lot of data in memory, this is quite a lot of work.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_403"></span>A technique called <em>generational garbage collection</em> can help reduce these costs. This approach exploits the fact that most objects have short lives. It splits the memory available to the JavaScript program into two or more <em>generations</em>. New objects are created in the space reserved for the young generation. When this space is full, the engine figures out which of the objects in it are still alive and moves those to the next generation. If only a small fraction of the objects in the young generation are still alive when this occurs, only a small amount of work has to be done to move them.</p>
        <p class="indent">Of course, figuring out which objects are alive does require knowing about all references to objects in the live generation. The garbage collector wants to avoid looking through all the objects in the older generations every time the young generation is collected. So when a reference is created from an old object to a new object, this reference must be recorded so that it can be taken into account during the next collection. This makes writing to old objects slightly more expensive, but that cost is more than compensated for by the time saved during garbage collection.</p>
        <h3 class="h3" id="ch22lev10">Dynamic Types</h3>
        <p class="noindent">JavaScript expressions like <span class="literal">node.pos</span>, which fetch a property from an object, are far from trivial to compile. In many languages, <em>bindings</em> have a type, and thus, when you perform an operation on the value they hold, the compiler already knows what kind of operation you need. In JavaScript, only <em>values</em> have types, and a binding can end up holding values of different types.</p>
        <p class="indent">This means that initially the compiler knows little about the property the code might be trying to access and has to produce code that handles all possible types. If <span class="literal">node</span> holds an undefined value, the code must throw an error. If it holds a string, it must look up <span class="literal">pos</span> in <span class="literal">String.prototype</span>. If it holds an object, the way the <span class="literal">pos</span> property is extracted from it depends on the shape of object. And so on.</p>
        <p class="indent">Fortunately, though JavaScript does not require it, bindings in most programs <em>do</em> have a single type. And if the compiler knows this type, it can use that information to produce more efficient code. If <span class="literal">node</span> has always been an object with <span class="literal">pos</span> and <span class="literal">edges</span> properties so far, the optimizing compiler code can create code that fetches the property from its known position in such an object, which is simple and fast.</p>
        <p class="indent">But events observed in the past do not give any guarantees about events that will occur in the future. Some piece of code that hasn’t run yet might still pass another type of value to our function—a different kind of node object, for example, that also has an <span class="literal">id</span> property.</p>
        <p class="indent">So the compiled code still has to <em>check</em> whether its assumptions hold and take an appropriate action if they don’t. An engine could deoptimize entirely, falling back to the unoptimized version of the function. Or it could compile a new version of the function that also handles the newly observed type.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_404"></span>You can observe the slowdown caused by the failure to predict object types by intentionally messing up the uniformity of the input objects for our graph layout function, as in this example:</p>
        <p class="programs">let mangledGraph = treeGraph(4, 4);<br>for (let node of mangledGraph) {<br>&nbsp;&nbsp;node[`p${Math.floor(Math.random() * 999)}`] = true;<br>}<br><br>runLayout(forceDirected_noVector, mangledGraph);</p>
        <p class="indent">Every node gets an extra property with a random name. If we run our fast simulation code on the resulting graph, it becomes 5 times as slow on Chrome 63 and 10 (!) times as slow on Firefox 58. Now that object types vary, the code has to look up the properties without prior knowledge about the shape of the object, which is a lot more expensive to do.</p>
        <p class="indent">Interestingly, after running this code, <span class="literal">forceDirected_noVector</span> has become slow even when run on a regular, non-mangled graph. The messy types have “poisoned” the compiled code, at least for a while—at some point, browsers tend to throw away compiled code and recompile it from scratch, removing this effect.</p>
        <p class="indent">A similar technique is used for things other than property access. The <span class="literal">+</span> operator, for example, means different things depending on what kind of values it is applied to. Instead of always running the full code that handles all these meanings, a smart JavaScript compiler will use previous observations to build up some expectation of the type that the operator is probably being applied to. If it is applied only to numbers, a much simpler piece of machine code can be generated to handle it. But again, such assumptions must be checked every time the function runs.</p>
        <p class="indent">The moral of this story is that if a piece of code needs to be fast, you can help by feeding it consistent types. JavaScript engines can handle cases where a few different types occur relatively well—they will generate code that handles all these types and deoptimizes only when a new type is seen. But even there, the resulting code is slower than what you would get for a single type.</p>
        <h3 class="h3" id="ch22lev11">Summary</h3>
        <p class="noindent">Thanks to the enormous amount of money being poured into the web, as well as the rivalry between the different browsers, JavaScript compilers are good at what they do: making code run fast.</p>
        <p class="indent">But sometimes you have to help them a little and rewrite your inner loops to avoid more expensive JavaScript features. Creating fewer objects (and arrays and strings) often helps.</p>
        <p class="indent">Before you start mangling your code to be faster, think about ways to make it do less work. The biggest opportunities for optimization are often found in that direction.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_405"></span>JavaScript engines compile hot code multiple times and will use information gathered during previous execution to compile more efficient code. You can help by giving your bindings a consistent type.</p>
        <h3 class="h3" id="ch22lev12">Exercises</h3>
        <h4 class="h4" id="ch22lev13"><em>Pathfinding</em></h4>
        <p class="noindent">Write a function <span class="literal">findPath</span> that, like the function you saw in <a href="ch07.xhtml#ch07">Chapter 7</a>, tries to find the shortest path between two nodes in a graph. It takes two <span class="literal">GraphNode</span> objects (as used throughout this chapter) as arguments and returns either <span class="literal">null</span>, if no path could be found, or an array of nodes that represents a path through the graph. Nodes that occur next to each other in this array should have an edge between them.</p>
        <p class="indent">A good approach for finding a path in a graph goes like this:</p>
        <ol>
        <li class="noindent">Create a work list that contains a single path that contains only the starting node.</li>
        <li class="noindent">Start with the first path in the work list.</li>
        <li class="noindent">If the node at the end of the current path is the goal node, return this path.</li>
        <li class="noindent">Otherwise, for each neighbor of the node at the end of the path, if that node has not been looked at before (does not occur at the end of any paths in the work list), create a new path by extending the current path with that neighbor and add it to the work list.</li>
        <li class="noindent">If there are more paths in the work list, go to the next path and continue at step 3.</li>
        <li class="noindent">Otherwise, there is no path.</li>
        </ol>
        <p class="indent">By “spreading out” paths from the start node, this approach ensures that it always reaches a given other node by the shortest path since longer paths are considered only after all shorter paths have been tried.</p>
        <p class="indent">Implement this program and test it on some simple tree graphs. Construct a graph with a cycle in it (for example, by adding edges to a tree graph with the <span class="literal">connect</span> method) and see whether your function can find the shortest path when there are multiple possibilities.</p>
        <h4 class="h4" id="ch22lev14"><em>Timing</em></h4>
        <p class="noindent">Use <span class="literal">Date.now()</span> to measure the time it takes your <span class="literal">findPath</span> function to find a path in a more complicated graph. Since <span class="literal">treeGraph</span> always puts the root at the start of the graph array and a leaf at the end, you can give your function a nontrivial task by doing something like this:</p>
        <p class="programs">let graph = treeGraph(6, 6);<br>console.log(findPath(graph[0], graph[graph.length - 1]).length);<br>// → 6</p>
        <p class="indent"><span epub:type="pagebreak" id="page_406"></span>Create a test case that has a running time of around half a second. Be careful with passing larger numbers to <span class="literal">treeGraph</span>—the size of the graph increases exponentially, so you can easily make your graph so big that it’ll take huge amounts of time and memory to find a path through them.</p>
        <h4 class="h4" id="ch22lev15"><em>Optimizing</em></h4>
        <p class="noindent">Now that you have a measured test case, find ways to make your <span class="literal">findPath</span> function faster.</p>
        <p class="indent">Think both about macro-optimization (doing less work) and micro-optimization (doing the given work in a cheaper way). Also, consider ways to use less memory and allocate fewer or smaller data structures.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492071198/files/styles/9781593279516.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com