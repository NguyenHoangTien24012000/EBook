<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class=""><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2 noOutline" id="ch11" tabindex="-1"><span epub:type="pagebreak" id="page_181"></span><span class="f1">11</span><br>ASYNCHRONOUS PROGRAMMING</h2>
        <p class="intro">The central part of a computer, the part that carries out the individual steps that make up our programs, is called the <em>processor</em>. The programs we have seen so far are things that will keep the processor busy until they have finished their work. The speed at which something like a loop that manipulates numbers can be executed depends pretty much entirely on the speed of the processor.</p>
        <p class="indent">But many programs interact with things outside of the processor. For example, they may communicate over a computer network or request data from the hard disk—which is a lot slower than getting it from memory.</p>
        <p class="indent">When such a thing is happening, it would be a shame to let the processor sit idle—there might be some other work it could do in the meantime. In part, this is handled by your operating system, which will switch the processor between multiple running programs. But that doesn’t help when we want a <em>single</em> program to be able to make progress while it is waiting for a network request.</p>
        <h3 class="h3" id="ch11lev1"><span epub:type="pagebreak" id="page_182"></span>Asynchronicity</h3>
        <p class="noindent">In a <em>synchronous</em> programming model, things happen one at a time. When you call a function that performs a long-running action, it returns only when the action has finished and it can return the result. This stops your program for the time the action takes.</p>
        <p class="indent">An <em>asynchronous</em> model allows multiple things to happen at the same time. When you start an action, your program continues to run. When the action finishes, the program is informed and gets access to the result (for example, the data read from disk).</p>
        <p class="indent">We can compare synchronous and asynchronous programming using a small example: a program that fetches two resources from the network and then combines results.</p>
        <p class="indent">In a synchronous environment, where the request function returns only after it has done its work, the easiest way to perform this task is to make the requests one after the other. This has the drawback that the second request will be started only when the first has finished. The total time taken will be at least the sum of the two response times.</p>
        <p class="indent">The solution to this problem, in a synchronous system, is to start additional threads of control. A <em>thread</em> is another running program whose execution may be interleaved with other programs by the operating system—since most modern computers contain multiple processors, multiple threads may even run at the same time, on different processors. A second thread could start the second request, and then both threads wait for their results to come back, after which they resynchronize to combine their results.</p>
        <p class="indent">In the following diagram, the thick lines represent time the program spends running normally, and the thin lines represent time spent waiting for the network. In the synchronous model, the time taken by the network is <em>part</em> of the timeline for a given thread of control. In the asynchronous model, starting a network action conceptually causes a <em>split</em> in the timeline. The program that initiated the action continues running, and the action happens alongside it, notifying the program when it is finished.</p>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492071198/files/images/f0182-01.jpg" alt="Image" width="689" height="315"></div>
        <p class="indent"><span epub:type="pagebreak" id="page_183"></span>Another way to describe the difference is that waiting for actions to finish is <em>implicit</em> in the synchronous model, while it is <em>explicit</em>, under our control, in the asynchronous one.</p>
        <p class="indent">Asynchronicity cuts both ways. It makes expressing programs that do not fit the straight-line model of control easier, but it can also make expressing programs that do follow a straight line more awkward. We’ll see some ways to address this awkwardness later in the chapter.</p>
        <p class="indent">Both of the important JavaScript programming platforms—browsers and Node.js—make operations that might take a while asynchronous, rather than relying on threads. Since programming with threads is notoriously hard (understanding what a program does is much more difficult when it’s doing multiple things at once), this is generally considered a good thing.</p>
        <h3 class="h3" id="ch11lev2">Crow Tech</h3>
        <p class="noindent">Most people are aware of the fact that crows are very smart birds. They can use tools, plan ahead, remember things, and even communicate these things among themselves.</p>
        <p class="indent">What most people don’t know is that they are capable of many things that they keep well hidden from us. I’ve been told by a reputable (if somewhat eccentric) expert on corvids that crow technology is not far behind human technology, and they are catching up.</p>
        <p class="indent">For example, many crow cultures have the ability to construct computing devices. These are not electronic, as human computing devices are, but operate through the actions of tiny insects, a species closely related to the termite, which has developed a symbiotic relationship with the crows. The birds provide them with food, and in return the insects build and operate their complex colonies that, with the help of the living creatures inside them, perform computations.</p>
        <p class="indent">Such colonies are usually located in big, long-lived nests. The birds and insects work together to build a network of bulbous clay structures, hidden between the twigs of the nest, in which the insects live and work.</p>
        <p class="indent">To communicate with other devices, these machines use light signals. The crows embed pieces of reflective material in special communication stalks, and the insects aim these to reflect light at another nest, encoding data as a sequence of quick flashes. This means that only nests that have an unbroken visual connection can communicate.</p>
        <p class="indent">Our friend the corvid expert has mapped the network of crow nests in the village of Hières-sur-Amby, on the banks of the river Rhône. The following map shows the nests and their connections.</p>
        <div class="image"><span epub:type="pagebreak" id="page_184"></span><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492071198/files/images/f0184-01.jpg" alt="Image" width="544" height="274"></div>
        <p class="indent">In an astounding example of convergent evolution, crow computers run JavaScript. In this chapter we’ll write some basic networking functions for them.</p>
        <h3 class="h3" id="ch11lev3">Callbacks</h3>
        <p class="noindent">One approach to asynchronous programming is to make functions that perform a slow action take an extra argument, a <em>callback function</em>. The action is started, and when it finishes, the callback function is called with the result.</p>
        <p class="indent">As an example, the <span class="literal">setTimeout</span> function, available both in Node.js and in browsers, waits a given number of milliseconds (a second is a thousand milliseconds) and then calls a function.</p>
        <p class="programs">setTimeout(() =&gt; console.log("Tick"), 500);</p>
        <p class="indent">Waiting is not generally a very important type of work, but it can be useful when doing something like updating an animation or checking whether something is taking longer than a given amount of time.</p>
        <p class="indent">Performing multiple asynchronous actions in a row using callbacks means that you have to keep passing new functions to handle the continuation of the computation after the actions.</p>
        <p class="indent">Most crow nest computers have a long-term data storage bulb, where pieces of information are etched into twigs so that they can be retrieved later. Etching, or finding a piece of data, takes a moment, so the interface to long-term storage is asynchronous and uses callback functions.</p>
        <p class="indent">Storage bulbs store pieces of JSON-encodable data under names. A crow might store information about the places where it’s hidden food under the name <span class="literal">"food caches"</span>, which could hold an array of names that point at other pieces of data, describing the actual cache. To look up a food cache in the storage bulbs of the <em>Big Oak</em> nest, a crow could run code like this:</p>
        <p class="programs">import {bigOak} from "./crow-tech";<br><br>bigOak.readStorage("food caches", caches =&gt; {<br>&nbsp;&nbsp;let firstCache = caches[0];<br>&nbsp;&nbsp;bigOak.readStorage(firstCache, info =&gt; {<br><span epub:type="pagebreak" id="page_185"></span>&nbsp;&nbsp;console.log(info);<br>&nbsp;});<br>});</p>
        <p class="indent">(All binding names and strings have been translated from crow language to English.)</p>
        <p class="indent">This style of programming is workable, but the indentation level increases with each asynchronous action because you end up in another function. Doing more complicated things, such as running multiple actions at the same time, can get a little awkward.</p>
        <p class="indent">Crow nest computers are built to communicate using request-response pairs. That means one nest sends a message to another nest, which then immediately sends a message back, confirming receipt and possibly including a reply to a question asked in the message.</p>
        <p class="indent">Each message is tagged with a <em>type</em>, which determines how it is handled. Our code can define handlers for specific request types, and when such a request comes in, the handler is called to produce a response.</p>
        <p class="indent">The interface exported by the <span class="literal">"./crow-tech"</span> module provides callback-based functions for communication. Nests have a <span class="literal">send</span> method that sends off a request. It expects the name of the target nest, the type of the request, and the content of the request as its first three arguments, and it expects a function to call when a response comes in as its fourth and last argument.</p>
        <p class="programs">bigOak.send("Cow Pasture", "note", "Let's caw loudly at 7PM",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;() =&gt; console.log("Note delivered."));</p>
        <p class="indent">But to make nests capable of receiving that request, we first have to define a request type named <span class="literal">"note"</span>. The code that handles the requests has to run not just on this nest-computer but on all nests that can receive messages of this type. We’ll just assume that a crow flies over and installs our handler code on all the nests.</p>
        <p class="programs">import {defineRequestType} from "./crow-tech";<br><br>defineRequestType("note", (nest, content, source, done) =&gt; {<br>&nbsp;&nbsp;console.log(`${nest.name} received note: ${content}`);<br>&nbsp;&nbsp;done();<br>});</p>
        <p class="indent">The <span class="literal">defineRequestType</span> function defines a new type of request. The example adds support for <span class="literal">"note"</span> requests, which just sends a note to a given nest. Our implementation calls <span class="literal">console.log</span> so that we can verify that the request arrived. Nests have a <span class="literal">name</span> property that holds their name.</p>
        <p class="indent">The fourth argument given to the handler, <span class="literal">done</span>, is a callback function that it must call when it is done with the request. If we had used the handler’s return value as the response value, that would mean that a request handler can’t itself perform asynchronous actions. A function <span epub:type="pagebreak" id="page_186"></span>doing asynchronous work typically returns before the work is done, having arranged for a callback to be called when it completes. So we need some asynchronous mechanism—in this case, another callback function—to signal when a response is available.</p>
        <p class="indent">In a way, asynchronicity is <em>contagious</em>. Any function that calls a function that works asynchronously must itself be asynchronous, using a callback or similar mechanism to deliver its result. Calling a callback is somewhat more involved and error-prone than simply returning a value, so needing to structure large parts of your program that way is not great.</p>
        <h3 class="h3" id="ch11lev4">Promises</h3>
        <p class="noindent">Working with abstract concepts is often easier when those concepts can be represented by values. In the case of asynchronous actions, you could, instead of arranging for a function to be called at some point in the future, return an object that represents this future event.</p>
        <p class="indent">This is what the standard class <span class="literal">Promise</span> is for. A <em>promise</em> is an asynchronous action that may complete at some point and produce a value. It is able to notify anyone who is interested when its value is available.</p>
        <p class="indent">The easiest way to create a promise is by calling <span class="literal">Promise.resolve</span>. This function ensures that the value you give it is wrapped in a promise. If it’s already a promise, it is simply returned—otherwise, you get a new promise that immediately finishes with your value as its result.</p>
        <p class="programs">let fifteen = Promise.resolve(15);<br>fifteen.then(value =&gt; console.log(`Got ${value}`));<br>// → Got 15</p>
        <p class="indent">To get the result of a promise, you can use its <span class="literal">then</span> method. This registers a callback function to be called when the promise resolves and produces a value. You can add multiple callbacks to a single promise, and they will be called, even if you add them after the promise has already <em>resolved</em> (finished).</p>
        <p class="indent">But that’s not all the <span class="literal">then</span> method does. It returns another promise, which resolves to the value that the handler function returns or, if that returns a promise, waits for that promise and then resolves to its result.</p>
        <p class="indent">It is useful to think of promises as a device to move values into an asynchronous reality. A normal value is simply there. A promised value is a value that <em>might</em> already be there or might appear at some point in the future. Computations defined in terms of promises act on such wrapped values and are executed asynchronously as the values become available.</p>
        <p class="indent">To create a promise, you can use <span class="literal">Promise</span> as a constructor. It has a somewhat odd interface—the constructor expects a function as argument, which it immediately calls, passing it a function that it can use to resolve the promise. It works this way, instead of, for example, with a <span class="literal">resolve</span> method, so that only the code that created the promise can resolve it.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_187"></span>This is how you’d create a promise-based interface for the <span class="literal">readStorage</span> function:</p>
        <p class="programs">function storage(nest, name) {<br>&nbsp;&nbsp;return new Promise(resolve =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;nest.readStorage(name, result =&gt; resolve(result));<br>&nbsp;&nbsp;});<br>}<br><br>storage(bigOak, "enemies")<br>.then(value =&gt; console.log("Got", value));</p>
        <p class="indent">This asynchronous function returns a meaningful value. This is the main advantage of promises—they simplify the use of asynchronous functions. Instead of having to pass around callbacks, promise-based functions look similar to regular ones: they take input as arguments and return their output. The only difference is that the output may not be available yet.</p>
        <h3 class="h3" id="ch11lev5">Failure</h3>
        <p class="noindent">Regular JavaScript computations can fail by throwing an exception. Asynchronous computations often need something like that. A network request may fail, or some code that is part of the asynchronous computation may throw an exception.</p>
        <p class="indent">One of the most pressing problems with the callback style of asynchronous programming is that it makes it extremely difficult to make sure failures are properly reported to the callbacks.</p>
        <p class="indent">A widely used convention is that the first argument to the callback is used to indicate that the action failed, and the second contains the value produced by the action when it was successful. Such callback functions must always check whether they received an exception and make sure that any problems they cause, including exceptions thrown by functions they call, are caught and given to the right function.</p>
        <p class="indent">Promises make this easier. They can be either resolved (the action finished successfully) or rejected (it failed). Resolve handlers (as registered with <span class="literal">then</span>) are called only when the action is successful, and rejections are automatically propagated to the new promise that is returned by <span class="literal">then</span>. And when a handler throws an exception, this automatically causes the promise produced by its <span class="literal">then</span> call to be rejected. So if any element in a chain of asynchronous actions fails, the outcome of the whole chain is marked as rejected, and no success handlers are called beyond the point where it failed.</p>
        <p class="indent">Much like resolving a promise provides a value, rejecting one also provides one, usually called the <em>reason</em> of the rejection. When an exception in a handler function causes the rejection, the exception value is used as the reason. Similarly, when a handler returns a promise that is rejected, that <span epub:type="pagebreak" id="page_188"></span>rejection flows into the next promise. There’s a <span class="literal">Promise.reject</span> function that creates a new, immediately rejected promise.</p>
        <p class="indent">To explicitly handle such rejections, promises have a <span class="literal">catch</span> method that registers a handler to be called when the promise is rejected, similar to how <span class="literal">then</span> handlers handle normal resolution. It’s also very much like <span class="literal">then</span> in that it returns a new promise, which resolves to the original promise’s value if it resolves normally and to the result of the <span class="literal">catch</span> handler otherwise. If a <span class="literal">catch</span> handler throws an error, the new promise is also rejected.</p>
        <p class="indent">As a shorthand, <span class="literal">then</span> also accepts a rejection handler as a second argument, so you can install both types of handlers in a single method call.</p>
        <p class="indent">A function passed to the <span class="literal">Promise</span> constructor receives a second argument, alongside the resolve function, which it can use to reject the new promise.</p>
        <p class="indent">The chains of promise values created by calls to <span class="literal">then</span> and <span class="literal">catch</span> can be seen as a pipeline through which asynchronous values or failures move. Since such chains are created by registering handlers, each link has a success handler or a rejection handler (or both) associated with it. Handlers that don’t match the type of outcome (success or failure) are ignored. But those that do match are called, and their outcome determines what kind of value comes next—success when it returns a non-promise value, rejection when it throws an exception, and the outcome of a promise when it returns one of those.</p>
        <p class="programs">new Promise((_, reject) =&gt; reject(new Error("Fail")))<br>&nbsp;&nbsp;.then(value =&gt; console.log("Handler 1"))<br>&nbsp;&nbsp;.catch(reason =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Caught failure " + reason);<br>&nbsp;&nbsp;&nbsp;&nbsp;return "nothing";<br>&nbsp;&nbsp;})<br>&nbsp;&nbsp;.then(value =&gt; console.log("Handler 2", value));<br>// → Caught failure Error: Fail<br>// → Handler 2 nothing</p>
        <p class="indent">Much like an uncaught exception is handled by the environment, JavaScript environments can detect when a promise rejection isn’t handled and will report this as an error.</p>
        <h3 class="h3" id="ch11lev6">Networks Are Hard</h3>
        <p class="noindent">Occasionally, there isn’t enough light for the crows’ mirror systems to transmit a signal, or something is blocking the path of the signal. It is possible for a signal to be sent but never received.</p>
        <p class="indent">As it is, that will just cause the callback given to <span class="literal">send</span> to never be called, which will probably cause the program to stop without even noticing there is a problem. It would be nice if, after a given period of not getting a response, a request would <em>time out</em> and report failure.</p>
        <p class="indent">Often, transmission failures are random accidents, like a car’s headlight interfering with the light signals, and simply retrying the request may cause <span epub:type="pagebreak" id="page_189"></span>it to succeed. So while we’re at it, let’s make our request function automatically retry the sending of the request a few times before it gives up.</p>
        <p class="indent">And, since we’ve established that promises are a good thing, we’ll also make our request function return a promise. In terms of what they can express, callbacks and promises are equivalent. Callback-based functions can be wrapped to expose a promise-based interface, and vice versa.</p>
        <p class="indent">Even when a request and its response are successfully delivered, the response may indicate failure—for example, if the request tries to use a request type that hasn’t been defined or the handler throws an error. To support this, <span class="literal">send</span> and <span class="literal">defineRequestType</span> follow the convention mentioned before, where the first argument passed to callbacks is the failure reason, if any, and the second is the actual result.</p>
        <p class="indent">These can be translated to promise resolution and rejection by our wrapper.</p>
        <p class="programs">class Timeout extends Error {}<br><br>function request(nest, target, type, content) {<br>&nbsp;&nbsp;return new Promise((resolve, reject) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;let done = false;<br>&nbsp;&nbsp;&nbsp;&nbsp;function attempt(n) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nest.send(target, type, content, (failed, value) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done = true;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (failed) reject(failed);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else resolve(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(() =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (done) return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if (n &lt; 3) attempt(n + 1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else reject(new Timeout("Timed out"));<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, 250);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;attempt(1);<br>&nbsp;&nbsp;});<br>}</p>
        <p class="indent">Because promises can be resolved (or rejected) only once, this will work. The first time <span class="literal">resolve</span> or <span class="literal">reject</span> is called determines the outcome of the promise, and any further calls, such as the timeout arriving after the request finishes or a request coming back after another request finished, are ignored.</p>
        <p class="indent">To build an asynchronous loop, for the retries, we need to use a recursive function—a regular loop doesn’t allow us to stop and wait for an asynchronous action. The <span class="literal">attempt</span> function makes a single attempt to send a request. It also sets a timeout that, if no response has come back after 250 milliseconds, either starts the next attempt or, if this was the third attempt, rejects the promise with an instance of <span class="literal">Timeout</span> as the reason.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_190"></span>Retrying every quarter-second and giving up when no response has come in after three-quarter second is definitely somewhat arbitrary. It is even possible, if the request did come through but the handler is just taking a bit longer, for requests to be delivered multiple times. We’ll write our handlers with that problem in mind—duplicate messages should be harmless.</p>
        <p class="indent">In general, we will not be building a world-class, robust network today. But that’s okay—crows don’t have very high expectations yet when it comes to computing.</p>
        <p class="indent">To isolate ourselves from callbacks altogether, we’ll go ahead and also define a wrapper for <span class="literal">defineRequestType</span> that allows the handler function to return a promise or plain value and wires that up to the callback for us.</p>
        <p class="programs">function requestType(name, handler) {<br>&nbsp;&nbsp;defineRequestType(name, (nest, content, source,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Promise.resolve(handler(nest, content, source))<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(response =&gt; callback(null, response),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;failure =&gt; callback(failure));<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (exception) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(exception);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;});<br>}</p>
        <p class="indent"><span class="literal">Promise.resolve</span> is used to convert the value returned by <span class="literal">handler</span> to a promise if it isn’t already.</p>
        <p class="indent">Note that the call to <span class="literal">handler</span> had to be wrapped in a <span class="literal">try</span> block to make sure any exception it raises directly is given to the callback. This nicely illustrates the difficulty of properly handling errors with raw callbacks—it is easy to forget to properly route exceptions like that, and if you don’t do it, failures won’t get reported to the right callback. Promises make this mostly automatic and thus less error-prone.</p>
        <h3 class="h3" id="ch11lev7">Collections of Promises</h3>
        <p class="noindent">Each nest computer keeps an array of other nests within transmission distance in its <span class="literal">neighbors</span> property. To check which of those are currently reachable, you could write a function that tries to send a <span class="literal">"ping"</span> request (a request that simply asks for a response) to each of them and see which ones come back.</p>
        <p class="indent">When working with collections of promises running at the same time, the <span class="literal">Promise.all</span> function can be useful. It returns a promise that waits for all of the promises in the array to resolve and then resolves to an array of the values that these promises produced (in the same order as the original array). If any promise is rejected, the result of <span class="literal">Promise.all</span> is itself rejected.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_191"></span>requestType("ping", () =&gt; "pong");<br><br>function availableNeighbors(nest) {<br>&nbsp;&nbsp;let requests = nest.neighbors.map(neighbor =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;return request(nest, neighbor, "ping")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(() =&gt; true, () =&gt; false);<br>&nbsp;&nbsp;});<br>&nbsp;&nbsp;return Promise.all(requests).then(result =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;return nest.neighbors.filter((_, i) =&gt; result[i]);<br>&nbsp;&nbsp;});<br>}</p>
        <p class="indent">When a neighbor isn’t available, we don’t want the entire combined promise to fail since then we still wouldn’t know anything. So the function that is mapped over the set of neighbors to turn them into request promises attaches handlers that make successful requests produce <span class="literal">true</span> and rejected ones produce <span class="literal">false</span>.</p>
        <p class="indent">In the handler for the combined promise, <span class="literal">filter</span> is used to remove those elements from the <span class="literal">neighbors</span> array whose corresponding value is false. This makes use of the fact that <span class="literal">filter</span> passes the array index of the current element as a second argument to its filtering function (<span class="literal">map</span>, <span class="literal">some</span>, and similar higher-order array methods do the same).</p>
        <h3 class="h3" id="ch11lev8">Network Flooding</h3>
        <p class="noindent">The fact that nests can talk only to their neighbors greatly inhibits the usefulness of this network.</p>
        <p class="indent">For broadcasting information to the whole network, one solution is to set up a type of request that is automatically forwarded to neighbors. These neighbors then in turn forward it to their neighbors, until the whole network has received the message.</p>
        <p class="programs">import {everywhere} from "./crow-tech";<br><br>everywhere(nest =&gt; {<br>&nbsp;&nbsp;nest.state.gossip = [];<br>});<br><br>function sendGossip(nest, message, exceptFor = null) {<br>&nbsp;&nbsp;nest.state.gossip.push(message);<br>&nbsp;&nbsp;for (let neighbor of nest.neighbors) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (neighbor == exceptFor) continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;request(nest, neighbor, "gossip", message);<br>&nbsp;&nbsp;}<br>}<br><br>requestType("gossip", (nest, message, source) =&gt; {<br>&nbsp;&nbsp;if (nest.state.gossip.includes(message)) return;<br>&nbsp;&nbsp;console.log(`${nest.name} received gossip '${<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message}' from ${source}`);<br>&nbsp;&nbsp;sendGossip(nest, message, source);<br>});</p>
        <p class="indent"><span epub:type="pagebreak" id="page_192"></span>To avoid sending the same message around the network forever, each nest keeps an array of gossip strings that it has already seen. To define this array, we use the <span class="literal">everywhere</span> function—which runs code on every nest—to add a property to the nest’s <span class="literal">state</span> object, which is where we’ll keep nest-local state.</p>
        <p class="indent">When a nest receives a duplicate gossip message, which is very likely to happen with everybody blindly resending them, it ignores it. But when it receives a new message, it excitedly tells all its neighbors except for the one who sent it the message.</p>
        <p class="indent">This will cause a new piece of gossip to spread through the network like an ink stain in water. Even when some connections aren’t currently working, if there is an alternative route to a given nest, the gossip will reach it through there.</p>
        <p class="indent">This style of network communication is called <em>flooding</em> —it floods the network with a piece of information until all nodes have it.</p>
        <h3 class="h3" id="ch11lev9">Message Routing</h3>
        <p class="noindent">If a given node wants to talk to a single other node, flooding is not a very efficient approach. Especially when the network is big, that would lead to a lot of useless data transfers.</p>
        <p class="indent">An alternative approach is to set up a way for messages to hop from node to node until they reach their destination. The difficulty with that is it requires knowledge about the layout of the network. To send a request in the direction of a faraway nest, it is necessary to know which neighboring nest gets it closer to its destination. Sending it in the wrong direction will not do much good.</p>
        <p class="indent">Since each nest knows only about its direct neighbors, it doesn’t have the information it needs to compute a route. We must somehow spread the information about these connections to all nests, preferably in a way that allows it to change over time, when nests are abandoned or new nests are built.</p>
        <p class="indent">We can use flooding again, but instead of checking whether a given message has already been received, we now check whether the new set of neighbors for a given nest matches the current set we have for it.</p>
        <p class="programs">requestType("connections", (nest, {name, neighbors},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;source) =&gt; {<br>&nbsp;&nbsp;let connections = nest.state.connections;<br>&nbsp;&nbsp;if (JSON.stringify(connections.get(name)) ==<br><br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;JSON.stringify(neighbors)) return;<br>&nbsp;&nbsp;connections.set(name, neighbors);<br>&nbsp;&nbsp;broadcastConnections(nest, name, source);<br>});<br><br>function broadcastConnections(nest, name, exceptFor = null) {<br>&nbsp;&nbsp;for (let neighbor of nest.neighbors) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (neighbor == exceptFor) continue;<br>&nbsp;&nbsp;&nbsp;&nbsp;request(nest, neighbor, "connections", {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;neighbors: nest.state.connections.get(name)<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;}<br>}<br><br>everywhere(nest =&gt; {<br>&nbsp;&nbsp;&nbsp;nest.state.connections = new Map();<br>&nbsp;&nbsp;&nbsp;nest.state.connections.set(nest.name, nest.neighbors);<br>&nbsp;&nbsp;&nbsp;broadcastConnections(nest, nest.name);<br>});</p>
        <p class="indent"><span epub:type="pagebreak" id="page_193"></span>The comparison uses <span class="literal">JSON.stringify</span> because <span class="literal">==</span>, on objects or arrays, will return true only when the two are the exact same value, which is not what we need here. Comparing the JSON strings is a crude but effective way to compare their content.</p>
        <p class="indent">The nodes immediately start broadcasting their connections, which should, unless some nests are completely unreachable, quickly give every nest a map of the current network graph.</p>
        <p class="indent">A thing you can do with graphs is find routes in them, as we saw in <a href="ch07.xhtml#ch07">Chapter 7</a>. If we have a route toward a message’s destination, we know which direction to send it in.</p>
        <p class="indent">This <span class="literal">findRoute</span> function, which greatly resembles the <span class="literal">findRoute</span> function from <a href="ch07.xhtml#ch07">Chapter 7</a>, searches for a way to reach a given node in the network. But instead of returning the whole route, it just returns the next step. That next nest, using its current information about the network, will decide where <em>it</em> sends the message.</p>
        <p class="programs">function findRoute(from, to, connections) {<br>&nbsp;&nbsp;let work = [{at: from, via: null}];<br>&nbsp;&nbsp;for (let i = 0; i &lt; work.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let {at, via} = work[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let next of connections.get(at) || []) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (next == to) return via;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!work.some(w =&gt; w.at == next)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;work.push({at: next, via: via || next});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;return null;<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_194"></span>Now we can build a function that can send long-distance messages. If the message is addressed to a direct neighbor, it is delivered as usual. If not, it is packaged in an object and sent to a neighbor that is closer to the target, using the <span class="literal">"route"</span> request type, which will cause that neighbor to repeat the same behavior.</p>
        <p class="programs">function routeRequest(nest, target, type, content) {<br>&nbsp;&nbsp;if (nest.neighbors.includes(target)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return request(nest, target, type, content);<br>&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;let via = findRoute(nest.name, target,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;nest.state.connections);<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!via) throw new Error(`No route to ${target}`);<br>&nbsp;&nbsp;&nbsp;&nbsp;return request(nest, via, "route",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{target, type, content});<br>&nbsp;&nbsp;}<br>}<br><br>requestType("route", (nest, {target, type, content}) =&gt; {<br>&nbsp;&nbsp;return routeRequest(nest, target, type, content);<br>});</p>
        <p class="indent">We’ve constructed several layers of functionality on top of a primitive communication system to make it convenient to use. This is a nice (though simplified) model of how real computer networks work.</p>
        <p class="indent">A distinguishing property of computer networks is that they aren’t reliable—abstractions built on top of them can help, but you can’t abstract away network failure. So network programming is typically very much about anticipating and dealing with failures.</p>
        <h3 class="h3" id="ch11lev10">Async Functions</h3>
        <p class="noindent">To store important information, crows are known to duplicate it across nests. That way, when a hawk destroys a nest, the information isn’t lost.</p>
        <p class="indent">To retrieve a given piece of information that it doesn’t have in its own storage bulb, a nest computer might consult random other nests in the network until it finds one that has it.</p>
        <p class="programs">requestType("storage", (nest, name) =&gt; storage(nest, name));<br><br>function findInStorage(nest, name) {<br>&nbsp;&nbsp;return storage(nest, name).then(found =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (found != null) return found;<br>&nbsp;&nbsp;&nbsp;&nbsp;else return findInRemoteStorage(nest, name);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}<br><br>function network(nest) {<br>&nbsp;&nbsp;return Array.from(nest.state.connections.keys());<br>}<br><br>function findInRemoteStorage(nest, name) {<br>&nbsp;&nbsp;let sources = network(nest).filter(n =&gt; n != nest.name);<br>&nbsp;&nbsp;function next() {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (sources.length == 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Promise.reject(new Error("Not found"));<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let source = sources[Math.floor(Math.random() *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sources.length)];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sources = sources.filter(n =&gt; n != source);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return routeRequest(nest, source, "storage", name)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;.then(value =&gt; value != null ? value : next(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;return next();<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_195"></span>Because <span class="literal">connections</span> is a <span class="literal">Map</span>, <span class="literal">Object.keys</span> doesn’t work on it. It has a <span class="literal">keys</span> <em>method</em>, but that returns an iterator rather than an array. An iterator (or iterable value) can be converted to an array with the <span class="literal">Array.from</span> function.</p>
        <p class="indent">Even with promises this is some rather awkward code. Multiple asynchronous actions are chained together in non-obvious ways. We again need a recursive function (<span class="literal">next</span>) to model looping through the nests.</p>
        <p class="indent">And the thing the code actually does is completely linear—it always waits for the previous action to complete before starting the next one. In a synchronous programming model, it’d be simpler to express.</p>
        <p class="indent">The good news is that JavaScript allows you to write pseudo-synchronous code to describe asynchronous computation. An <span class="literal">async</span> function is a function that implicitly returns a promise and that can, in its body, <span class="literal">await</span> other promises in a way that <em>looks</em> synchronous.</p>
        <p class="indent">We can rewrite <span class="literal">findInStorage</span> like this:</p>
        <p class="programs">async function findInStorage(nest, name) {<br>&nbsp;&nbsp;let local = await storage(nest, name);<br>&nbsp;&nbsp;if (local != null) return local;<br><br>&nbsp;&nbsp;let sources = network(nest).filter(n =&gt; n != nest.name);<br>&nbsp;&nbsp;while (sources.length &gt; 0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let source = sources[Math.floor(Math.random() *<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sources.length)];<br>&nbsp;&nbsp;&nbsp;&nbsp;sources = sources.filter(n =&gt; n != source);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let found = await routeRequest(nest, source, "storage",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (found != null) return found;<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (_) {}<br>&nbsp;&nbsp;}<br>&nbsp;&nbsp;throw new Error("Not found");<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_196"></span>An <span class="literal">async</span> function is marked by the word <span class="literal">async</span> before the <span class="literal">function</span> keyword. Methods can also be made <span class="literal">async</span> by writing <span class="literal">async</span> before their name. When such a function or method is called, it returns a promise. As soon as the body returns something, that promise is resolved. If it throws an exception, the promise is rejected.</p>
        <p class="indent">Inside an <span class="literal">async</span> function, the word <span class="literal">await</span> can be put in front of an expression to wait for a promise to resolve and only then continue the execution of the function.</p>
        <p class="indent">Such a function no longer, like a regular JavaScript function, runs from start to completion in one go. Instead, it can be <em>frozen</em> at any point that has an <span class="literal">await</span>, and can be resumed at a later time.</p>
        <p class="indent">For nontrivial asynchronous code, this notation is usually more convenient than directly using promises. Even if you need to do something that doesn’t fit the synchronous model, such as perform multiple actions at the same time, it is easy to combine <span class="literal">await</span> with the direct use of promises.</p>
        <h3 class="h3" id="ch11lev11">Generators</h3>
        <p class="noindent">This ability of functions to be paused and then resumed again is not exclusive to <span class="literal">async</span> functions. JavaScript also has a feature called <em>generator</em> functions. These are similar, but without the promises.</p>
        <p class="indent">When you define a function with <span class="literal">function*</span> (placing an asterisk after the word <span class="literal">function</span>), it becomes a generator. When you call a generator, it returns an iterator, which we already saw in <a href="ch06.xhtml#ch06">Chapter 6</a>.</p>
        <p class="programs">function* powers(n) {<br>&nbsp;&nbsp;for (let current = n;; current *= n) {<br>&nbsp;&nbsp;&nbsp;&nbsp;yield current;<br>&nbsp;&nbsp;}<br>}<br><br>for (let power of powers(3)) {<br>&nbsp;&nbsp;if (power &gt; 50) break;<br>&nbsp;&nbsp;console.log(power);<br>}<br>// → 3<br>// → 9<br>// → 27</p>
        <p class="indent"><span epub:type="pagebreak" id="page_197"></span>Initially, when you call <span class="literal">powers</span>, the function is frozen at its start. Every time you call <span class="literal">next</span> on the iterator, the function runs until it hits a <span class="literal">yield</span> expression, which pauses it and causes the yielded value to become the next value produced by the iterator. When the function returns (the one in the example never does), the iterator is done.</p>
        <p class="indent">Writing iterators is often much easier when you use generator functions. The iterator for the <span class="literal">Group</span> class (from the exercise in “Iterable Groups” on <a href="ch06.xhtml#page_114">page 114</a>) can be written with this generator:</p>
        <p class="programs">Group.prototype[Symbol.iterator] = function*() {<br>&nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; this.members.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield this.members[i];<br>&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent">There’s no longer a need to create an object to hold the iteration state—generators automatically save their local state every time they yield.</p>
        <p class="indent">Such <span class="literal">yield</span> expressions may occur only directly in the generator function itself and not in an inner function you define inside of it. The state a generator saves, when yielding, is only its <em>local</em> environment and the position where it yielded.</p>
        <p class="indent">An <span class="literal">async</span> function is a special type of generator. It produces a promise when called, which is resolved when it returns (finishes) and rejected when it throws an exception. Whenever it yields (awaits) a promise, the result of that promise (value or thrown exception) is the result of the <span class="literal">await</span> expression.</p>
        <h3 class="h3" id="ch11lev12">The Event Loop</h3>
        <p class="noindent">Asynchronous programs are executed piece by piece. Each piece may start some actions and schedule code to be executed when the action finishes or fails. In between these pieces, the program sits idle, waiting for the next action.</p>
        <p class="indent">So callbacks are not directly called by the code that scheduled them. If I call <span class="literal">setTimeout</span> from within a function, that function will have returned by the time the callback function is called. And when the callback returns, control does not go back to the function that scheduled it.</p>
        <p class="indent">Asynchronous behavior happens on its own empty function call stack. This is one of the reasons that, without promises, managing exceptions across asynchronous code is hard. Since each callback starts with a mostly empty stack, your <span class="literal">catch</span> handlers won’t be on the stack when they throw an exception.</p>
        <p class="programs">try {<br>&nbsp;&nbsp;setTimeout(() =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Woosh");<br>&nbsp;&nbsp;}, 20);<br>} catch (_) {<br><br>&nbsp;&nbsp;// This will not run<br>&nbsp;&nbsp;console.log("Caught!");<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_198"></span>No matter how closely together events—such as timeouts or incoming requests—happen, a JavaScript environment will run only one program at a time. You can think of this as it running a big loop <em>around</em> your program, called the <em>event loop</em>. When there’s nothing to be done, that loop is stopped. But as events come in, they are added to a queue, and their code is executed one after the other. Because no two things run at the same time, slow-running code might delay the handling of other events.</p>
        <p class="indent">This example sets a timeout but then dallies until after the timeout’s intended point of time, causing the timeout to be late.</p>
        <p class="programs">let start = Date.now();<br>setTimeout(() =&gt; {<br>&nbsp;&nbsp;console.log("Timeout ran at", Date.now() - start);<br>}, 20);<br>while (Date.now() &lt; start + 50) {}<br>console.log("Wasted time until", Date.now() - start);<br>// → Wasted time until 50<br>// → Timeout ran at 55</p>
        <p class="indent">Promises always resolve or reject as a new event. Even if a promise is already resolved, waiting for it will cause your callback to run after the current script finishes, rather than right away.</p>
        <p class="programs">Promise.resolve("Done").then(console.log);<br>console.log("Me first!");<br>// → Me first!<br>// → Done</p>
        <p class="indent">In later chapters we’ll see various other types of events that run on the event loop.</p>
        <h3 class="h3" id="ch11lev13">Asynchronous Bugs</h3>
        <p class="noindent">When your program runs synchronously, in a single go, there are no state changes happening except those that the program itself makes. For asynchronous programs this is different—they may have <em>gaps</em> in their execution during which other code can run.</p>
        <p class="indent">Let’s look at an example. One of the hobbies of our crows is to count the number of chicks that hatch throughout the village every year. Nests store this count in their storage bulbs. The following code tries to enumerate the counts from all the nests for a given year:</p>
        <p class="programs">function anyStorage(nest, source, name) {<br>&nbsp;&nbsp;if (source == nest.name) return storage(nest, name);<br><br>&nbsp;&nbsp;else return routeRequest(nest, source, "storage", name);<br>}<br><br>async function chicks(nest, year) {<br>&nbsp;&nbsp;let list = "";<br>&nbsp;&nbsp;await Promise.all(network(nest).map(async name =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;list += `${name}: ${<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await anyStorage(nest, name, `chicks in ${year}`)<br>&nbsp;&nbsp;&nbsp;&nbsp;}\n`;<br>&nbsp;&nbsp;}));<br>&nbsp;&nbsp;return list;<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_199"></span>The <span class="literal">async name =&gt;</span> part shows that arrow functions can also be made <span class="literal">async</span> by putting the word <span class="literal">async</span> in front of them.</p>
        <p class="indent">The code doesn’t immediately look suspicious . . . it maps the <span class="literal">async</span> arrow function over the set of nests, creating an array of promises, and then uses <span class="literal">Promise.all</span> to wait for all of these before returning the list they build up.</p>
        <p class="indent">But it is seriously broken. It’ll always return only a single line of output, listing the nest that was slowest to respond.</p>
        <p class="indent">Can you work out why?</p>
        <p class="indent">The problem lies in the <span class="literal">+=</span> operator, which takes the <em>current</em> value of <span class="literal">list</span> at the time where the statement starts executing and then, when the <span class="literal">await</span> finishes, sets the <span class="literal">list</span> binding to be that value plus the added string.</p>
        <p class="indent">But between the time where the statement starts executing and the time where it finishes there’s an asynchronous gap. The <span class="literal">map</span> expression runs before anything has been added to the list, so each of the <span class="literal">+=</span> operators starts from an empty string and ends up, when its storage retrieval finishes, setting <span class="literal">list</span> to a single-line list—the result of adding its line to the empty string.</p>
        <p class="indent">This could have easily been avoided by returning the lines from the mapped promises and calling <span class="literal">join</span> on the result of <span class="literal">Promise.all</span>, instead of building up the list by changing a binding. As usual, computing new values is less error-prone than changing existing values.</p>
        <p class="programs">async function chicks(nest, year) {<br>&nbsp;&nbsp;let lines = network(nest).map(async name =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;return name + ": " +<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;await anyStorage(nest, name, `chicks in ${year}`);<br>&nbsp;&nbsp;});<br>&nbsp;&nbsp;return (await Promise.all(lines)).join("\n");<br>}</p>
        <p class="indent">Mistakes like this are easy to make, especially when using <span class="literal">await</span>, and you should be aware of where the gaps in your code occur. An advantage of JavaScript’s <em>explicit</em> asynchronicity (whether through callbacks, promises, or <span class="literal">await</span>) is that spotting these gaps is relatively easy.</p>
        <h3 class="h3" id="ch11lev14"><span epub:type="pagebreak" id="page_200"></span>Summary</h3>
        <p class="noindent">Asynchronous programming makes it possible to express waiting for long-running actions without freezing the program during these actions. JavaScript environments typically implement this style of programming using callbacks, functions that are called when the actions complete. An event loop schedules such callbacks to be called when appropriate, one after the other, so that their execution does not overlap.</p>
        <p class="indent">Programming asynchronously is made easier by promises, objects that represent actions that might complete in the future, and <span class="literal">async</span> functions, which allow you to write an asynchronous program as if it were synchronous.</p>
        <h3 class="h3" id="ch11lev15">Exercises</h3>
        <h4 class="h4" id="ch11lev16"><em>Tracking the Scalpel</em></h4>
        <p class="noindent">The village crows own an old scalpel that they occasionally use on special missions—say, to cut through screen doors or packaging. To be able to quickly track it down, every time the scalpel is moved to another nest, an entry is added to the storage of both the nest that had it and the nest that took it, under the name <span class="literal">"scalpel"</span>, with its new location as the value.</p>
        <p class="indent">This means that finding the scalpel is a matter of following the bread-crumb trail of storage entries, until you find a nest where that points at the nest itself.</p>
        <p class="indent">Write an <span class="literal">async</span> function <span class="literal">locateScalpel</span> that does this, starting at the nest on which it runs. You can use the <span class="literal">anyStorage</span> function defined earlier to access storage in arbitrary nests. The scalpel has been going around long enough that you may assume that every nest has a <span class="literal">"scalpel"</span> entry in its data storage.</p>
        <p class="indent">Next, write the same function again without using <span class="literal">async</span> and <span class="literal">await</span>.</p>
        <p class="indent">Do request failures properly show up as rejections of the returned promise in both versions? How?</p>
        <h4 class="h4" id="ch11lev17"><em>Building Promise.all</em></h4>
        <p class="noindent">Given an array of promises, <span class="literal">Promise.all</span> returns a promise that waits for all of the promises in the array to finish. It then succeeds, yielding an array of result values. If a promise in the array fails, the promise returned by <span class="literal">all</span> fails too, with the failure reason from the failing promise.</p>
        <p class="indent">Implement something like this yourself as a regular function called <span class="literal">Promise_all</span>.</p>
        <p class="indent">Remember that after a promise has succeeded or failed, it can’t succeed or fail again, and further calls to the functions that resolve it are ignored. This can simplify the way you handle failure of your promise.<span epub:type="pagebreak" id="page_201"></span></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492071198/files/styles/9781593279516.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com