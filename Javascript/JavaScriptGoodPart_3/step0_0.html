<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class=""><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div class="chapter" title="Chapter&nbsp;1.&nbsp;Good Parts"><div class="titlepage"><div><div><h1 class="title"><a id="good_parts"></a>Chapter&nbsp;1.&nbsp;Good Parts</h1></div></div></div><div class="epigraph"><p>...setting the attractions of my good parts aside I have no other charms.</p><div class="attribution"><span>—<span class="attribution">William Shakespeare, <span class="emphasis"><em>The Merry Wives of
        Windsor</em></span></span></span></div></div><p>When I was a young journeyman programmer, I would learn about every feature of the
    languages I was using, and I would attempt to use all of those features when I wrote. I
    suppose it was a way of showing off, and I suppose it worked because I was the guy you
    went to if you wanted to know how to use a particular feature.</p><p>Eventually I figured out that some of those features were more trouble than they were
    worth. Some of them were poorly specified, and so were more likely to cause portability
    problems. Some resulted in code that was difficult to read or modify. Some induced me to
    write in a manner that was too tricky and error-prone. And some of those features were
    design errors. Sometimes language designers make mistakes.</p><p>Most programming languages contain good parts and bad parts. I discovered that I could
    be a better programmer by using only the good parts and avoiding the bad parts. After
    all, how can you build something good out of bad parts?</p><p>It is rarely possible for standards committees to remove imperfections from a language
    because doing so would cause the breakage of all of the bad programs that depend on
    those bad parts. They are usually powerless to do anything except heap more features on
    top of the existing pile of imperfections. And the new features do not always interact
    harmoniously, thus producing more bad parts.</p><p>But <span class="emphasis"><em>you</em></span> have the power to define your own subset. You can write
    better programs by relying exclusively on the good parts.</p><p>JavaScript is a language with more than its share of bad parts. It went from
    non-existence to global adoption in an alarmingly short period of time. It never had an
    interval in the lab when it could be tried out and polished. It went straight into
    Netscape Navigator 2 just as it was, and it was very rough. When Java™ applets failed,
    JavaScript became the "Language of the Web" by default. JavaScript's popularity is
    almost completely independent of its qualities as a programming language.</p><p>Fortunately, JavaScript has some extraordinarily good parts. In JavaScript, there is a
    beautiful, elegant, highly expressive language that is buried under a steaming pile of
    good intentions and blunders. The best nature of JavaScript is so effectively hidden
    that for many years the prevailing opinion of JavaScript was that it was an unsightly,
    incompetent toy. My intention here is to expose the goodness in JavaScript, an
    outstanding, dynamic programming language. JavaScript is a block of marble, and I chip
    away the features that are not beautiful until the language's true nature reveals
    itself. I believe that the elegant subset I carved out is vastly superior to the
    language as a whole, being more reliable, readable, and maintainable.</p><p>This book will not attempt to fully describe the language. Instead, it will focus on
    the good parts with occasional warnings to avoid the bad. The subset that will be
    described here can be used to construct reliable, readable programs small and large. By
    focusing on just the good parts, we can reduce learning time, increase robustness, and
    save some trees.</p><p>Perhaps the greatest benefit of studying the good parts is that you can avoid the need
    to unlearn the bad parts. Unlearning bad patterns is very difficult. It is a painful
    task that most of us face with extreme reluctance. Sometimes languages are subsetted to
    make them work better for students. But in this case, I am subsetting JavaScript to make
    it work better for professionals.</p><div class="sect1" title="Why JavaScript?"><div class="titlepage"><div><div><h1 class="title"><a id="why_javascript_question" class="noOutline" tabindex="-1"></a>Why JavaScript?</h1></div></div></div><p>JavaScript is an important language because it is the language of the web browser.
        Its association with the browser makes it one of the most popular programming
        languages in the world. At the same time, it is one of the most despised programming
        languages in the world. The API of the browser, the Document Object Model (DOM) is
        quite awful, and JavaScript is unfairly blamed. The DOM would be painful to work
        with in any language. The DOM is poorly specified and inconsistently implemented.
        This book touches only very lightly on the DOM. I think writing a <span class="emphasis"><em>Good
            Parts</em></span> book about the DOM would be extremely challenging.<a id="IDX-CHP-1-0001" class="indexterm"></a></p><p>JavaScript is most despised because it isn't SOME OTHER LANGUAGE. If you are good
        in SOME OTHER LANGUAGE and you have to program in an environment that only supports
        JavaScript, then you are forced to use JavaScript, and that is annoying. Most people
        in that situation don't even bother to learn JavaScript first, and then they are
        surprised when JavaScript turns out to have significant differences from the SOME
        OTHER LANGUAGE they would rather be using, and that those differences matter.</p><p>The amazing thing about JavaScript is that it is possible to get work done with it
        without knowing much about the language, or even knowing much about programming. It
        is a language with enormous expressive power. It is even better when you know what
        you're doing. Programming is difficult business. It should never be undertaken in
        ignorance.</p></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780596517748/files/core.css" crossorigin="anonymous"></div></div></section>
        <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div class="sect1" title="Analyzing JavaScript"><div class="titlepage"><div><div><h1 class="title"><a id="analyzing_javascript"></a>Analyzing JavaScript</h1></div></div></div><p>JavaScript is built on some very good ideas and a few very bad ones.<a id="IDX-CHP-1-0002" class="indexterm"></a><a id="IDX-CHP-1-0003" class="indexterm"></a></p><p>The very good ideas include functions, loose typing, dynamic objects, and an
            expressive object literal notation. The bad ideas include a programming model based
            on global variables.</p><p>JavaScript's functions are first class objects with (mostly) lexical scoping.
            JavaScript is the first lambda language to go mainstream. Deep down, JavaScript has
            more in common with Lisp and Scheme than with Java. It is Lisp in C's clothing. This
            makes JavaScript a remarkably powerful language.</p><p>The fashion in most programming languages today demands strong typing. The theory
            is that strong typing allows a compiler to detect a large class of errors at compile
            time. The sooner we can detect and repair errors, the less they cost us. JavaScript
            is a loosely typed language, so JavaScript compilers are unable to detect type
            errors. This can be alarming to people who are coming to JavaScript from strongly
            typed languages. But it turns out that strong typing does not eliminate the need for
            careful testing. And I have found in my work that the sorts of errors that strong
            type checking finds are not the errors I worry about. On the other hand, I find
            loose typing to be liberating. I don't need to form complex class hierarchies. And I
            never have to cast or wrestle with the type system to get the behavior that I
            want.</p><p>JavaScript has a very powerful object literal notation. Objects can be created
            simply by listing their components. This notation was the inspiration for JSON, the
            popular data interchange format. (There will be more about JSON in <a class="xref" href="ape.html" title="Appendix&nbsp;E.&nbsp;JSON">Appendix&nbsp;E</a>.)</p><p>A controversial feature in JavaScript is prototypal inheritance. JavaScript has a
            class-free object system in which objects inherit properties directly from other
            objects. This is really powerful, but it is unfamiliar to classically trained
            programmers. If you attempt to apply classical design patterns directly to
            JavaScript, you will be frustrated. But if you learn to work with JavaScript's
            prototypal nature, your efforts will be rewarded.<a id="IDX-CHP-1-0004" class="indexterm"></a><a id="IDX-CHP-1-0005" class="indexterm"></a></p><p>JavaScript is much maligned for its choice of key ideas. For the most part,
            though, those choices were good, if unusual. But there was one choice that was
            particularly bad: JavaScript depends on global variables for linkage. All of the
            top-level variables of all compilation units are tossed together in a common
            namespace called <span class="emphasis"><em>the global object</em></span>. This is a bad thing because
            global variables are evil, and in JavaScript they are fundamental. Fortunately, as
            we will see, JavaScript also gives us the tools to mitigate this problem.</p><p>In a few cases, we can't ignore the bad parts. There are some unavoidable awful
            parts, which will be called out as they occur. They will also be summarized in <a class="xref" href="apa.html" title="Appendix&nbsp;A.&nbsp;Awful Parts">Appendix&nbsp;A</a>. But we will succeed in avoiding most of the bad parts
            in this book, summarizing much of what was left out in <a class="xref" href="apb.html" title="Appendix&nbsp;B.&nbsp;Bad Parts">Appendix&nbsp;B</a>.
            If you want to learn more about the bad parts and how to use them badly, consult any
            other JavaScript book.</p><p>The standard that defines JavaScript (aka JScript) is the third edition of
                <span class="emphasis"><em>The ECMAScript Programming Language</em></span>, which is available
            from <a class="ulink" href="http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf">http://www.ecma-international.org/publications/files/ecma-st/ECMA-262.pdf</a>. The language described in this book is a proper subset of ECMAScript. This book
            does not describe the whole language because it leaves out the bad parts. The
            treatment here is not exhaustive. It avoids the edge cases. You should, too. There
            is danger and misery at the edges.<a id="IDX-CHP-1-0006" class="indexterm"></a></p><p><a class="xref" href="apc.html" title="Appendix&nbsp;C.&nbsp;JSLint">Appendix&nbsp;C</a> describes a programming tool called JSLint, a JavaScript
            parser that can analyze a JavaScript program and report on the bad parts that it
            contains. JSLint provides a degree of rigor that is generally lacking in JavaScript
            development. It can give you confidence that your programs contain only the good
                parts.<a id="IDX-CHP-1-0007" class="indexterm"></a></p><p>JavaScript is a language of many contrasts. It contains many errors and sharp
            edges, so you might wonder, "Why should I use JavaScript?" There are two answers.
            The first is that you don't have a choice. The Web has become an important platform
            for application development, and JavaScript is the only language that is found in
            all browsers. It is unfortunate that Java failed in that environment; if it hadn't,
            there could be a choice for people desiring a strongly typed classical language. But
            Java did fail and JavaScript is flourishing, so there is evidence that JavaScript
            did something right.</p><p>The other answer is that, despite its deficiencies, <span class="emphasis"><em>JavaScript is really
                good</em></span>. It is lightweight and expressive. And once you get the hang of
            it, functional programming is a lot of fun.</p><p>But in order to use the language well, you must be well informed about its
            limitations. I will pound on those with some brutality. Don't let that discourage
            you. The good parts are good enough to compensate for the bad parts.</p></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780596517748/files/core.css" crossorigin="anonymous"></div></div></section>
            <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div class="sect1" title="A Simple Testing Ground"><div class="titlepage"><div><div><h1 class="title"><a id="a_simple_testing_ground"></a>A Simple Testing Ground</h1></div></div></div><p>If you have a web browser and any text editor, you have everything you need to run
                JavaScript programs. First, make an HTML file with a name like <em class="filename">program.html</em>:<a id="IDX-CHP-1-0008" class="indexterm"></a></p><a id="I_programlisting1_d1e426"></a><pre class="programlisting">&lt;html&gt;&lt;body&gt;&lt;pre&gt;&lt;script src="https://learning.oreilly.comprogram.js"&gt;
&lt;/script&gt;&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;</pre><p>Then, make a file in the same directory with a name like <em class="filename">program.js</em>:</p><a id="I_programlisting1_d1e433"></a><pre class="programlisting">document.writeln('Hello, world!');</pre><p>Next, open your HTML file in your browser to see the result. Throughout the book,
                a <code class="literal">method</code> method is used to define new methods.
                This is its definition:</p><a id="I_programlisting1_d1e440"></a><pre class="programlisting">Function.prototype.method = function (name, func) {
    this.prototype[name] = func;
    return this;
};</pre><p>It will be explained in <a class="xref" href="ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter&nbsp;4</a>.</p></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780596517748/files/core.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com