<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. API Additions"><div class="chapter" id="chapter-6-api-additions">
        <h1><span class="label">Chapter 6. </span>API Additions</h1>
        
        
        <p>From conversions of values to mathematic calculations, ES6 adds many
        static properties and methods to various built-in natives and objects to
        help with common tasks. In addition, instances of some of the natives
        have new capabilities via various new prototype <span class="keep-together">methods</span>.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>Most of these features can be faithfully polyfilled. We will not
        dive into such details here, but check out <a href="https://github.com/paulmillr/es6-shim/">“ES6 Shim”</a> for standards-compliant
        shims/polyfills.</p>
        </div>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Array"><div class="sect1" id="idm45967357405816">
        <h1>Array</h1>
        
        <p>One of the most commonly extended features in JS by various user
        libraries is the Array type. It should be no surprise that ES6 adds a
        number of helpers to Array, both static and prototype (instance).</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Array.of(..) Static Function"><div class="sect2" id="idm45967357403736">
        <h2>Array.of(..) Static Function</h2>
        
        <p>There’s a well-known gotcha with the <code>Array(..)</code> constructor, which is
        that if there’s only one argument passed, and that argument is a number,
        instead of making an array of one element with that number value in it,
        it constructs an empty array with a <code>length</code> property equal to the
        number. This action produces the unfortunate and quirky “empty slots”
        behavior that’s reviled about JS arrays.</p>
        
        <p><code>Array.of(..)</code> replaces <code>Array(..)</code> as the preferred function-form
        constructor for arrays, because <code>Array.of(..)</code> does not have that
        special single-number-argument case. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">(</code> <code class="mi">3</code> <code class="p">);</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                       <code class="c1">// 3</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>                           <code class="c1">// undefined</code>
        
        <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">of</code><code class="p">(</code> <code class="mi">3</code> <code class="p">);</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                       <code class="c1">// 1</code>
        <code class="nx">b</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code>                           <code class="c1">// 3</code>
        
        <code class="kd">var</code> <code class="nx">c</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">of</code><code class="p">(</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code> <code class="p">);</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                       <code class="c1">// 3</code>
        <code class="nx">c</code><code class="p">;</code>                              <code class="c1">// [1,2,3]</code></pre>
        
        <p>Under what circumstances would you want to use <code>Array.of(..)</code> instead of
        just creating an array with literal syntax, like <code>c = [1,2,3]</code>? There’s
        two possible cases.</p>
        
        <p>If you have a callback that’s supposed to wrap argument(s) passed to it
        in an array, <code>Array.of(..)</code> fits the bill perfectly. That’s probably not
        terribly common, but it may scratch an itch for you.</p>
        
        <p>The other scenario is if you subclass <code>Array</code> (see <a data-type="xref" href="ch03.html#class-sect">“Classes”</a> in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>) and want to be able to create and initialize elements in an instance
        of your subclass, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">MyCoolArray</code> <code class="k">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="nx">sum</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">reduce</code><code class="p">(</code> <code class="kd">function </code><code class="nx">reducer</code><code class="p">(</code><code class="nx">acc</code><code class="p">,</code><code class="nx">curr</code><code class="p">){</code>
                    <code class="k">return</code> <code class="nx">acc</code> <code class="o">+</code> <code class="nx">curr</code><code class="p">;</code>
                <code class="p">},</code> <code class="mi">0</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyCoolArray</code><code class="p">(</code> <code class="mi">3</code> <code class="p">);</code>
        <code class="nx">x</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                       <code class="c1">// 3--oops!</code>
        <code class="nx">x</code><code class="p">.</code><code class="nx">sum</code><code class="p">();</code>                        <code class="c1">// 0--oops!</code>
        
        <code class="kd">var</code> <code class="nx">y</code> <code class="o">=</code> <code class="p">[</code><code class="mi">3</code><code class="p">];</code>                    <code class="c1">// Array, not MyCoolArray</code>
        <code class="nx">y</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                       <code class="c1">// 1</code>
        <code class="nx">y</code><code class="p">.</code><code class="nx">sum</code><code class="p">();</code>                        <code class="c1">// `sum` is not a function</code>
        
        <code class="kd">var</code> <code class="nx">z</code> <code class="o">=</code> <code class="nx">MyCoolArray</code><code class="p">.</code><code class="nx">of</code><code class="p">(</code> <code class="mi">3</code> <code class="p">);</code>
        <code class="nx">z</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                       <code class="c1">// 1</code>
        <code class="nx">z</code><code class="p">.</code><code class="nx">sum</code><code class="p">();</code>                        <code class="c1">// 3</code></pre>
        
        <p>You can’t just (easily) create a constructor for <code>MyCoolArray</code> that
        overrides the behavior of the <code>Array</code> parent constructor, because that
        constructor is necessary to actually create a well-behaving array value
        (initializing the <code>this</code>). The “inherited” static <code>of(..)</code> method on the
        <code>MyCoolArray</code> subclass provides a nice solution.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Array.from(..) Static Function"><div class="sect2" id="arrayFromSF_sect">
        <h2>Array.from(..) Static Function</h2>
        
        <p>An “array-like object” in JavaScript is an object that has a <code>length</code>
        property on it, specifically with an integer value of zero or higher.</p>
        
        <p>These values have been notoriously frustrating to work with in JS; it’s
        been quite common to need to transform them into an actual array, so
        that the various <code>Array.prototype</code> methods (<code>map(..)</code>, <code>indexOf(..)</code>,
        etc.) are available to use with it. That process usually looks like:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="c1">// array-like object</code>
        <code class="kd">var</code> <code class="nx">arrLike</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">length</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
            <code class="mi">0</code><code class="o">:</code> <code class="s2">"foo"</code><code class="p">,</code>
            <code class="mi">1</code><code class="o">:</code> <code class="s2">"bar"</code>
        <code class="p">};</code>
        
        <code class="kd">var</code> <code class="nx">arr</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">slice</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code> <code class="nx">arrLike</code> <code class="p">);</code></pre>
        
        <p>Another common task where <code>slice(..)</code> is often used is in duplicating a
        real array:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">arr2</code> <code class="o">=</code> <code class="nx">arr</code><code class="p">.</code><code class="nx">slice</code><code class="p">();</code></pre>
        
        <p>In both cases, the new ES6 <code>Array.from(..)</code> method can be a more
        understandable and graceful—if also less verbose—approach:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">arr</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="nx">arrLike</code> <code class="p">);</code>
        
        <code class="kd">var</code> <code class="nx">arrCopy</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="nx">arr</code> <code class="p">);</code></pre>
        
        <p><code>Array.from(..)</code> looks to see if the first argument is an iterable (see
        <a data-type="xref" href="ch03.html#iterSect">“Iterators”</a> in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>), and if so, it uses the iterator to produce
        values to “copy” into the returned array. Because real arrays have an
        iterator for those values, that iterator is automatically used.</p>
        
        <p>But if you pass an array-like object as the first argument to
        <code>Array.from(..)</code>, it behaves basically the same as <code>slice()</code> (no
        arguments!) or <code>apply(..)</code> does, which is that it simply loops over the
        value, accessing numerically named properties from <code>0</code> up to whatever
        the value of <code>length</code> is.</p>
        
        <p class="pagebreak-before">Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">arrLike</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">length</code><code class="o">:</code> <code class="mi">4</code><code class="p">,</code>
            <code class="mi">2</code><code class="o">:</code> <code class="s2">"foo"</code>
        <code class="p">};</code>
        
        <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="nx">arrLike</code> <code class="p">);</code>
        <code class="c1">// [ undefined, undefined, "foo", undefined ]</code></pre>
        
        <p>Because positions <code>0</code>, <code>1</code>, and <code>3</code> didn’t exist on <code>arrLike</code>, the
        result was the <code>undefined</code> value for each of those slots.</p>
        
        <p>You could produce a similar outcome like this:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">emptySlotsArr</code> <code class="o">=</code> <code class="p">[];</code>
        <code class="nx">emptySlotsArr</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
        <code class="nx">emptySlotsArr</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"foo"</code><code class="p">;</code>
        
        <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="nx">emptySlotsArr</code> <code class="p">);</code>
        <code class="c1">// [ undefined, undefined, "foo", undefined ]</code></pre>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Avoiding Empty Slots"><div class="sect3" id="avoid_emptySlots">
        <h3>Avoiding Empty Slots</h3>
        
        <p>There’s a subtle but important difference in the previous snippet
        between the <code>emptySlotsArr</code> and the result of the <code>Array.from(..)</code> call.
        <code>Array.from(..)</code> never produces empty slots.</p>
        
        <p>Prior to ES6, if you wanted to produce an array initialized to a certain
        length with actual <code>undefined</code> values in each slot (no empty slots!),
        you had to do extra work:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">(</code> <code class="mi">4</code> <code class="p">);</code>
        <code class="c1">// four empty slots!</code>
        
        <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code> <code class="kc">null</code><code class="p">,</code> <code class="p">{</code> <code class="nx">length</code><code class="o">:</code> <code class="mi">4</code> <code class="p">}</code> <code class="p">);</code>
        <code class="c1">// four `undefined` values</code></pre>
        
        <p>But <code>Array.from(..)</code> now makes this easier:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">c</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="p">{</code> <code class="nx">length</code><code class="o">:</code> <code class="mi">4</code> <code class="p">}</code> <code class="p">);</code>
        <code class="c1">// four `undefined` values</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Using an empty slot array like <code>a</code> in the previous snippets
        would work with some array functions, but others ignore empty slots
        (like <code>map(..)</code>, etc.). You should never intentionally work with empty
        slots, as it will almost certainly lead to strange/unpredictable
        behavior in your programs.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Mapping"><div class="sect3" id="mapping-sect">
        <h3>Mapping</h3>
        
        <p>The <code>Array.from(..)</code> utility has another helpful trick up its sleeve.
        The second argument, if provided, is a mapping callback (almost the same
        as the regular <code>Array#map(..)</code> expects), which is called to map/transform
        each value from the source to the returned target. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">arrLike</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">length</code><code class="o">:</code> <code class="mi">4</code><code class="p">,</code>
            <code class="mi">2</code><code class="o">:</code> <code class="s2">"foo"</code>
        <code class="p">};</code>
        
        <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="nx">arrLike</code><code class="p">,</code> <code class="kd">function </code><code class="nx">mapper</code><code class="p">(</code><code class="nx">val</code><code class="p">,</code><code class="nx">idx</code><code class="p">){</code>
            <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">val</code> <code class="o">==</code> <code class="s2">"string"</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nx">val</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
            <code class="p">}</code>
            <code class="k">else</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nx">idx</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code> <code class="p">);</code>
        <code class="c1">// [ 0, 1, "FOO", 3 ]</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>As with other array methods that take callbacks,
        <code>Array.from(..)</code> takes an optional third argument that if set will
        specify the <code>this</code> binding for the callback passed as the second
        argument. Otherwise, <code>this</code> will be <code>undefined</code>.</p>
        </div>
        
        <p>See <a data-type="xref" href="ch05.html#typedarraysect">“TypedArrays”</a> in <a data-type="xref" href="ch05.html#chapter-5-collections">Chapter&nbsp;5</a> for an example of using <code>Array.from(..)</code>
        in translating values from an array of 8-bit values to an array of
        16-bit values.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Creating Arrays and Subtypes"><div class="sect2" id="arrays_sect">
        <h2>Creating Arrays and Subtypes</h2>
        
        <p>In the last couple of sections, we’ve discussed <code>Array.of(..)</code> and
        <code>Array.from(..)</code>, both of which create a new array in a similar way to a
        constructor. But what do they do in subclasses? Do they create instances
        of the base <code>Array</code> or the derived subclass?</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">MyCoolArray</code> <code class="k">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="p">..</code>
        <code class="p">}</code>
        
        <code class="nx">MyCoolArray</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]</code> <code class="p">)</code> <code class="k">instanceof</code> <code class="nx">MyCoolArray</code><code class="p">;</code>  <code class="c1">// true</code>
        
        <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code>
            <code class="nx">MyCoolArray</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">]</code> <code class="p">)</code>
        <code class="p">)</code> <code class="k">instanceof</code> <code class="nx">MyCoolArray</code><code class="p">;</code>                           <code class="c1">// false</code></pre>
        
        <p>Both <code>of(..)</code> and <code>from(..)</code> use the constructor that they’re accessed
        from to construct the array. So if you use the base <code>Array.of(..)</code>
        you’ll get an <code>Array</code> instance, but if you use <code>MyCoolArray.of(..)</code>,
        you’ll get a <code>MyCoolArray</code> instance.</p>
        
        <p>In <a data-type="xref" href="ch03.html#class-sect">“Classes”</a> in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>, we covered the <code>@@species</code> setting that all
        the built-in classes (like <code>Array</code>) have defined, which is used by any
        prototype methods if they create a new instance. <code>slice(..)</code> is a great
        example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyCoolArray</code><code class="p">(</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code> <code class="p">);</code>
        
        <code class="nx">x</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code> <code class="mi">1</code> <code class="p">)</code> <code class="k">instanceof</code> <code class="nx">MyCoolArray</code><code class="p">;</code>                <code class="c1">// true</code></pre>
        
        <p>Generally, that default behavior will probably be desired, but as we
        discussed in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>, you <em>can</em> override if you want:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">MyCoolArray</code> <code class="k">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="c1">// force `species` to be parent constructor</code>
            <code class="k">static</code> <code class="nx">get</code> <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Array</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyCoolArray</code><code class="p">(</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code> <code class="p">);</code>
        
        <code class="nx">x</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code> <code class="mi">1</code> <code class="p">)</code> <code class="k">instanceof</code> <code class="nx">MyCoolArray</code><code class="p">;</code>                <code class="c1">// false</code>
        <code class="nx">x</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code> <code class="mi">1</code> <code class="p">)</code> <code class="k">instanceof</code> <code class="nb">Array</code><code class="p">;</code>                      <code class="c1">// true</code></pre>
        
        <p>It’s important to note that the <code>@@species</code> setting is only used for the
        prototype methods, like <code>slice(..)</code>. It’s not used by <code>of(..)</code> and
        <code>from(..)</code>; they both just use the <code>this</code> binding (whatever constructor
        is used to make the reference). Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">MyCoolArray</code> <code class="k">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="c1">// force `species` to be parent constructor</code>
            <code class="k">static</code> <code class="nx">get</code> <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Array</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyCoolArray</code><code class="p">(</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code> <code class="p">);</code>
        
        <code class="nx">MyCoolArray</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="nx">x</code> <code class="p">)</code> <code class="k">instanceof</code> <code class="nx">MyCoolArray</code><code class="p">;</code>       <code class="c1">// true</code>
        <code class="nx">MyCoolArray</code><code class="p">.</code><code class="nx">of</code><code class="p">(</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">]</code> <code class="p">)</code> <code class="k">instanceof</code> <code class="nx">MyCoolArray</code><code class="p">;</code>    <code class="c1">// true</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="copyWithin(..) Prototype Method"><div class="sect2" id="idm45967356731240">
        <h2>copyWithin(..) Prototype Method</h2>
        
        <p><code>Array#copyWithin(..)</code> is a new mutator method available to all arrays
        (including typed arrays; see <a data-type="xref" href="ch05.html#chapter-5-collections">Chapter&nbsp;5</a>). <code>copyWithin(..)</code> copies a
        portion of an array to another location in the same array, overwriting
        whatever was there before.</p>
        
        <p>The arguments are <em>target</em> (the index to copy to), <em>start</em> (the
        inclusive index to start the copying from), and optionally <em>end</em> (the
        exclusive index to stop copying). If any of the arguments are negative,
        they’re taken to be relative from the end of the array.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">].</code><code class="nx">copyWithin</code><code class="p">(</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">0</code> <code class="p">);</code>         <code class="c1">// [1,2,3,1,2]</code>
        
        <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">].</code><code class="nx">copyWithin</code><code class="p">(</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code> <code class="p">);</code>      <code class="c1">// [1,2,3,1,5]</code>
        
        <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">].</code><code class="nx">copyWithin</code><code class="p">(</code> <code class="mi">0</code><code class="p">,</code> <code class="o">-</code><code class="mi">2</code> <code class="p">);</code>        <code class="c1">// [4,5,3,4,5]</code>
        
        <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">].</code><code class="nx">copyWithin</code><code class="p">(</code> <code class="mi">0</code><code class="p">,</code> <code class="o">-</code><code class="mi">2</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code> <code class="p">);</code>    <code class="c1">// [4,2,3,4,5]</code></pre>
        
        <p>The <code>copyWithin(..)</code> method does not extend the array’s length, as the
        first example in the previous snippet shows. Copying simply stops when
        the end of the array is reached.</p>
        
        <p>Contrary to what you might think, the copying doesn’t always go in
        left-to-right (ascending index) order. It’s possible this would result
        in repeatedly copying an already copied value if the from and target
        ranges overlap, which is presumably not desired behavior.</p>
        
        <p>So internally, the algorithm avoids this case by copying in reverse
        order to avoid that gotcha. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">].</code><code class="nx">copyWithin</code><code class="p">(</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">1</code> <code class="p">);</code>     <code class="c1">// ???</code></pre>
        
        <p>If the algorithm was strictly moving left to right, then the <code>2</code> should
        be copied to overwrite the <code>3</code>, then <em>that</em> copied <code>2</code> should be copied
        to overwrite <code>4</code>, then <em>that</em> copied <code>2</code> should be copied to overwrite
        <code>5</code>, and you’d end up with <code>[1,2,2,2,2]</code>.</p>
        
        <p>Instead, the copying algorithm reverses direction and copies <code>4</code> to
        overwrite <code>5</code>, then copies <code>3</code> to overwrite <code>4</code>, then copies <code>2</code> to
        overwrite <code>3</code>, and the final result is <code>[1,2,2,3,4]</code>. That’s probably
        more “correct” in terms of expectation, but it can be confusing if
        you’re only thinking about the copying algorithm in a naive
        left-to-right <span class="keep-together">fashion</span>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="fill(..) Prototype Method"><div class="sect2" id="idm45967356486936">
        <h2>fill(..) Prototype Method</h2>
        
        <p>Filling an existing array entirely (or partially) with a specified value
        is natively supported as of ES6 with the <code>Array#fill(..)</code> method:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">(</code> <code class="mi">4</code> <code class="p">).</code><code class="nx">fill</code><code class="p">(</code> <code class="kc">undefined</code> <code class="p">);</code>
        <code class="nx">a</code><code class="p">;</code>
        <code class="c1">// [undefined,undefined,undefined,undefined]</code></pre>
        
        <p><code>fill(..)</code> optionally takes <em>start</em> and <em>end</em> parameters, which indicate
        a subset portion of the array to fill, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code> <code class="kc">null</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="kc">null</code> <code class="p">].</code><code class="nx">fill</code><code class="p">(</code> <code class="mi">42</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">3</code> <code class="p">);</code>
        
        <code class="nx">a</code><code class="p">;</code>                                  <code class="c1">// [null,42,42,null]</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="find(..) Prototype Method"><div class="sect2" id="idm45967356267832">
        <h2>find(..) Prototype Method</h2>
        
        <p>The most common way to search for a value in an array has generally been
        the <code>indexOf(..)</code> method, which returns the index the value is found at
        or <code>-1</code> if not found:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        
        <code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code> <code class="mi">3</code> <code class="p">)</code> <code class="o">!=</code> <code class="o">-</code><code class="mi">1</code><code class="p">);</code>             <code class="c1">// true</code>
        <code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code> <code class="mi">7</code> <code class="p">)</code> <code class="o">!=</code> <code class="o">-</code><code class="mi">1</code><code class="p">);</code>             <code class="c1">// false</code>
        
        <code class="p">(</code><code class="nx">a</code><code class="p">.</code><code class="nx">indexOf</code><code class="p">(</code> <code class="s2">"2"</code> <code class="p">)</code> <code class="o">!=</code> <code class="o">-</code><code class="mi">1</code><code class="p">);</code>           <code class="c1">// false</code></pre>
        
        <p>The <code>indexOf(..)</code> comparison requires a strict <code>===</code> match, so a search
        for <code>"2"</code> fails to find a value of <code>2</code>, and vice versa. There’s no way
        to override the matching algorithm for <code>indexOf(..)</code>. It’s also
        unfortunate/ungraceful to have to make the manual comparison to the <code>-1</code>
        value.</p>
        <div data-type="tip"><h6>Tip</h6>
        <p>See the <em>Types &amp; Grammar</em> title of this series for an interesting
        (and controversially confusing) technique to work around the <code>-1</code>
        ugliness with the <code>~</code> operator.</p>
        </div>
        
        <p>Since ES5, the most common workaround to have control over the matching
        logic has been the <code>some(..)</code> method. It works by calling a function
        callback for each element, until one of those calls returns a
        <code>true</code>/truthy value, and then it stops. Because you get to define the
        callback function, you have full control over how a match is made:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        
        <code class="nx">a</code><code class="p">.</code><code class="nx">some</code><code class="p">(</code> <code class="kd">function </code><code class="nx">matcher</code><code class="p">(</code><code class="nx">v</code><code class="p">){</code>
            <code class="k">return</code> <code class="nx">v</code> <code class="o">==</code> <code class="s2">"2"</code><code class="p">;</code>
        <code class="p">}</code> <code class="p">);</code>                                <code class="c1">// true</code>
        
        <code class="nx">a</code><code class="p">.</code><code class="nx">some</code><code class="p">(</code> <code class="kd">function </code><code class="nx">matcher</code><code class="p">(</code><code class="nx">v</code><code class="p">){</code>
            <code class="k">return</code> <code class="nx">v</code> <code class="o">==</code> <code class="mi">7</code><code class="p">;</code>
        <code class="p">}</code> <code class="p">);</code>                                <code class="c1">// false</code></pre>
        
        <p>But the downside to this approach is that you only get the
        <code>true</code>/<code>false</code> indicating if a suitably matched value was found, but not
        what the actual matched value was.</p>
        
        <p>ES6’s <code>find(..)</code> addresses this. It works basically the same as
        <code>some(..)</code>, except that once the callback returns a <code>true</code>/truthy value,
        the actual array value is returned:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        
        <code class="nx">a</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code> <code class="kd">function </code><code class="nx">matcher</code><code class="p">(</code><code class="nx">v</code><code class="p">){</code>
            <code class="k">return</code> <code class="nx">v</code> <code class="o">==</code> <code class="s2">"2"</code><code class="p">;</code>
        <code class="p">}</code> <code class="p">);</code>                                <code class="c1">// 2</code>
        
        <code class="nx">a</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code> <code class="kd">function </code><code class="nx">matcher</code><code class="p">(</code><code class="nx">v</code><code class="p">){</code>
            <code class="k">return</code> <code class="nx">v</code> <code class="o">==</code> <code class="mi">7</code><code class="p">;</code>                  <code class="c1">// undefined</code>
        <code class="p">});</code></pre>
        
        <p>Using a custom <code>matcher(..)</code> function also lets you match against
        complex values like objects:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">points</code> <code class="o">=</code> <code class="p">[</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">20</code> <code class="p">},</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">20</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">30</code> <code class="p">},</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">30</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">40</code> <code class="p">},</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">50</code> <code class="p">},</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">50</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">60</code> <code class="p">}</code>
        <code class="p">];</code>
        
        <code class="nx">points</code><code class="p">.</code><code class="nx">find</code><code class="p">(</code> <code class="kd">function </code><code class="nx">matcher</code><code class="p">(</code><code class="nx">point</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">(</code>
                <code class="nx">point</code><code class="p">.</code><code class="nx">x</code> <code class="o">%</code> <code class="mi">3</code> <code class="o">==</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code>
                <code class="nx">point</code><code class="p">.</code><code class="nx">y</code> <code class="o">%</code> <code class="mi">4</code> <code class="o">==</code> <code class="mi">0</code>
            <code class="p">);</code>
        <code class="p">}</code> <code class="p">);</code>                                <code class="c1">// { x: 30, y: 40 }</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>As with other array methods that take callbacks, <code>find(..)</code>
        takes an optional second argument that if set will specify the <code>this</code>
        binding for the callback passed as the first argument. Otherwise, <code>this</code>
        will be <code>undefined</code>.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="findIndex(..) Prototype Method"><div class="sect2" id="idm45967356192808">
        <h2>findIndex(..) Prototype Method</h2>
        
        <p>While the previous section illustrates how <code>some(..)</code> yields a boolean
        result for a search of an array, and <code>find(..)</code> yields the matched value
        itself from the array search, there’s also a need to find the
        positional index of the matched value.</p>
        
        <p><code>indexOf(..)</code> does that, but there’s no control over its matching logic;
        it always uses <code>===</code> strict equality. So ES6’s <code>findIndex(..)</code> is the
        answer:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">points</code> <code class="o">=</code> <code class="p">[</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">20</code> <code class="p">},</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">20</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">30</code> <code class="p">},</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">30</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">40</code> <code class="p">},</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">40</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">50</code> <code class="p">},</code>
            <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">50</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">60</code> <code class="p">}</code>
        <code class="p">];</code>
        
        <code class="nx">points</code><code class="p">.</code><code class="nx">findIndex</code><code class="p">(</code> <code class="kd">function </code><code class="nx">matcher</code><code class="p">(</code><code class="nx">point</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">(</code>
                <code class="nx">point</code><code class="p">.</code><code class="nx">x</code> <code class="o">%</code> <code class="mi">3</code> <code class="o">==</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code>
                <code class="nx">point</code><code class="p">.</code><code class="nx">y</code> <code class="o">%</code> <code class="mi">4</code> <code class="o">==</code> <code class="mi">0</code>
            <code class="p">);</code>
        <code class="p">}</code> <code class="p">);</code>                                <code class="c1">// 2</code>
        
        <code class="nx">points</code><code class="p">.</code><code class="nx">findIndex</code><code class="p">(</code> <code class="kd">function </code><code class="nx">matcher</code><code class="p">(</code><code class="nx">point</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">(</code>
                <code class="nx">point</code><code class="p">.</code><code class="nx">x</code> <code class="o">%</code> <code class="mi">6</code> <code class="o">==</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code>
                <code class="nx">point</code><code class="p">.</code><code class="nx">y</code> <code class="o">%</code> <code class="mi">7</code> <code class="o">==</code> <code class="mi">0</code>
            <code class="p">);</code>
        <code class="p">}</code> <code class="p">);</code>                                <code class="c1">// -1</code></pre>
        
        <p>Don’t use <code>findIndex(..) != -1</code> (the way it’s always been done with
        <code>indexOf(..)</code>) to get a boolean from the search, because <code>some(..)</code>
        already yields the <code>true</code>/<code>false</code> you want. And don’t do
        <code>a[ a.findIndex(..) ]</code> to get the matched value, because that’s what
        <code>find(..)</code> accomplishes. And finally, use <code>indexOf(..)</code> if you need the
        index of a strict match, or <code>findIndex(..)</code> if you need the index of a
        more customized match.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>As with other array methods that take callbacks, <code>find(..)</code>
        takes an optional second argument that if set will specify the <code>this</code>
        binding for the callback passed as the first argument. Otherwise, <code>this</code>
        will be <code>undefined</code>.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="entries(), values(), keys() Prototype Methods"><div class="sect2" id="idm45967355635816">
        <h2>entries(), values(), keys() Prototype Methods</h2>
        
        <p>In <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>, we illustrated how data structures can provide a patterned
        item-by-item enumeration of their values, via an iterator. We then
        expounded on this approach in <a data-type="xref" href="ch05.html#chapter-5-collections">Chapter&nbsp;5</a>, as we explored how the new ES6
        collections (Map, Set, etc.) provide several methods for producing
        different kinds of iterations.</p>
        
        <p>Because it’s not new to ES6, <code>Array</code> might not be thought of
        traditionally as a “collection,” but it is one in the sense that it
        provides these same iterator methods: <code>entries()</code>, <code>values()</code>, and
        <code>keys()</code>. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        
        <code class="p">[</code><code class="o">...</code><code class="nx">a</code><code class="p">.</code><code class="nx">values</code><code class="p">()];</code>                    <code class="c1">// [1,2,3]</code>
        <code class="p">[</code><code class="o">...</code><code class="nx">a</code><code class="p">.</code><code class="nx">keys</code><code class="p">()];</code>                      <code class="c1">// [0,1,2]</code>
        <code class="p">[</code><code class="o">...</code><code class="nx">a</code><code class="p">.</code><code class="nx">entries</code><code class="p">()];</code>                   <code class="c1">// [ [0,1], [1,2], [2,3] ]</code>
        
        <code class="p">[</code><code class="o">...</code><code class="nx">a</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()];</code>          <code class="c1">// [1,2,3]</code></pre>
        
        <p>Just like with <code>Set</code>, the default <code>Array</code> iterator is the same as what
        <code>values()</code> returns.</p>
        
        <p>In <a data-type="xref" href="#string-inspection_sect">“String Inspection Functions”</a>, we illustrated how
        <code>Array.from(..)</code> treats empty slots in an array as just being present
        slots with <code>undefined</code> in them. That’s actually because under the
        covers, the array iterators behave that way:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[];</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
        
        <code class="p">[</code><code class="o">...</code><code class="nx">a</code><code class="p">.</code><code class="nx">values</code><code class="p">()];</code>    <code class="c1">// [undefined,2,undefined]</code>
        <code class="p">[</code><code class="o">...</code><code class="nx">a</code><code class="p">.</code><code class="nx">keys</code><code class="p">()];</code>      <code class="c1">// [0,1,2]</code>
        <code class="p">[</code><code class="o">...</code><code class="nx">a</code><code class="p">.</code><code class="nx">entries</code><code class="p">()];</code>   <code class="c1">// [ [0,undefined], [1,2], [2,undefined] ]</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Object"><div class="sect1" id="idm45967357405192">
        <h1>Object</h1>
        
        <p>A few additional static helpers have been added to <code>Object</code>.
        Traditionally, functions of this sort have been seen as focused on the
        behaviors/capabilities of object values.</p>
        
        <p>However, starting with ES6, <code>Object</code> static functions will also be for
        general-purpose global APIs of any sort that don’t already belong more
        naturally in some other location (i.e., <code>Array.from(..)</code>).</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Object.is(..) Static Function"><div class="sect2" id="idm45967355416920">
        <h2>Object.is(..) Static Function</h2>
        
        <p>The <code>Object.is(..)</code> static function makes value comparisons in an even
        more strict fashion than the <code>===</code> comparison.</p>
        
        <p><code>Object.is(..)</code> invokes the underlying <code>SameValue</code> algorithm (ES6 spec,
        section 7.2.9). The <code>SameValue</code> algorithm is basically the same as the
        <code>===</code> Strict Equality Comparison Algorithm (ES6 spec, section 7.2.13),
        with two important exceptions.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="kc">NaN</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="o">-</code><code class="mi">0</code><code class="p">;</code>
        
        <code class="nx">x</code> <code class="o">===</code> <code class="nx">x</code><code class="p">;</code>                            <code class="c1">// false</code>
        <code class="nx">y</code> <code class="o">===</code> <code class="nx">z</code><code class="p">;</code>                            <code class="c1">// true</code>
        
        <code class="nb">Object</code><code class="p">.</code><code class="nx">is</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">x</code> <code class="p">);</code>                  <code class="c1">// true</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">is</code><code class="p">(</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>                  <code class="c1">// false</code></pre>
        
        <p>You should continue to use <code>===</code> for strict equality comparisons;
        <code>Object.is(..)</code> shouldn’t be thought of as a replacement for the
        operator. However, in cases where you’re trying to strictly identify a
        <code>NaN</code> or <code>-0</code> value, <code>Object.is(..)</code> is now the preferred option.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>ES6 also adds a <code>Number.isNaN(..)</code> utility (discussed later in
        this chapter), which may be a slightly more convenient test; you may
        prefer <code>Number.isNaN(x)</code> over <code>Object.is(x,NaN)</code>. You <em>can</em> accurately
        test for <code>-0</code> with a clumsy <code>x == 0 &amp;&amp; 1 / x === -Infinity</code>, but in this
        case <code>Object.is(x,-0)</code> is much better.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Object.getOwnPropertySymbols(..) Static Function"><div class="sect2" id="idm45967355327752">
        <h2>Object.getOwnPropertySymbols(..) Static Function</h2>
        
        <p><a data-type="xref" href="ch02.html#symbolSect">“Symbols”</a> in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a> discusses the new Symbol primitive
        value type in ES6.</p>
        
        <p>Symbols are likely going to be mostly used as special (meta) properties
        on objects. So the <code>Object.getOwnPropertySymbols(..)</code> utility was
        introduced, which retrieves only the symbol properties directly on an
        object:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="o">:</code> <code class="mi">42</code><code class="p">,</code>
            <code class="p">[</code> <code class="nb">Symbol</code><code class="p">(</code> <code class="s2">"bar"</code> <code class="p">)</code> <code class="p">]</code><code class="o">:</code> <code class="s2">"hello world"</code><code class="p">,</code>
            <code class="nx">baz</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">};</code>
        
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertySymbols</code><code class="p">(</code> <code class="nx">o</code> <code class="p">);</code>  <code class="c1">// [ Symbol(bar) ]</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Object.setPrototypeOf(..) Static Function"><div class="sect2" id="idm45967355322328">
        <h2>Object.setPrototypeOf(..) Static Function</h2>
        
        <p>Also in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a>, we mentioned the <code>Object.setPrototypeOf(..)</code> utility,
        which (unsurprisingly) sets the <code>[[Prototype]]</code> of an object for the
        purposes of <em>behavior delegation</em> (see the <em>this &amp; Object Prototypes</em>
        title of this series). Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"foo"</code> <code class="p">);</code> <code class="p">}</code>
        <code class="p">};</code>
        <code class="kd">var</code> <code class="nx">o2</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// .. o2's definition ..</code>
        <code class="p">};</code>
        
        <code class="nb">Object</code><code class="p">.</code><code class="nx">setPrototypeOf</code><code class="p">(</code> <code class="nx">o2</code><code class="p">,</code> <code class="nx">o1</code> <code class="p">);</code>
        
        <code class="c1">// delegates to `o1.foo()`</code>
        <code class="nx">o2</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code>                           <code class="c1">// foo</code></pre>
        
        <p>Alternatively:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"foo"</code> <code class="p">);</code> <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="kd">var</code> <code class="nx">o2</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">setPrototypeOf</code><code class="p">(</code> <code class="p">{</code>
            <code class="c1">// .. o2's definition ..</code>
        <code class="p">},</code> <code class="nx">o1</code> <code class="p">);</code>
        
        <code class="c1">// delegates to `o1.foo()`</code>
        <code class="nx">o2</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code>                           <code class="c1">// foo</code></pre>
        
        <p>In both previous snippets, the relationship between <code>o2</code> and <code>o1</code>
        appears at the end of the <code>o2</code> definition. More commonly, the
        relationship between an <code>o2</code> and <code>o1</code> is specified at the top of the
        <code>o2</code> definition, as it is with classes, and also with <code>__proto__</code> in
        object literals (see <a data-type="xref" href="ch02.html#settingprototypes">“Setting [[Prototype]]”</a> in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a>).</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Setting a <code>[[Prototype]]</code> right after object creation is
        reasonable, as shown. But changing it much later is generally not a good
        idea and will usually lead to more confusion than clarity.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Object.assign(..) Static Function"><div class="sect2" id="objectassign_sf-sect">
        <h2>Object.assign(..) Static Function</h2>
        
        <p>Many JavaScript libraries/frameworks provide utilities for
        copying/mixing one object’s properties into another (e.g., jQuery’s
        <code>extend(..)</code>). There are various nuanced differences between these
        different utilities, such as whether a property with value <code>undefined</code>
        is ignored or not.</p>
        
        <p>ES6 adds <code>Object.assign(..)</code>, which is a simplified version of these
        algorithms. The first argument is the <em>target</em>, and any other arguments
        passed are the <em>sources</em>, which will be processed in listed order. For
        each source, its enumerable and own (e.g., not “inherited”) keys, including
        symbols, are copied as if by plain <code>=</code> assignment. <code>Object.assign(..)</code>
        returns the target object.</p>
        
        <p>Consider this object setup:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">target</code> <code class="o">=</code> <code class="p">{},</code>
            <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="mi">1</code> <code class="p">},</code> <code class="nx">o2</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">b</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code>
            <code class="nx">o3</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">c</code><code class="o">:</code> <code class="mi">3</code> <code class="p">},</code> <code class="nx">o4</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">d</code><code class="o">:</code> <code class="mi">4</code> <code class="p">};</code>
        
        <code class="c1">// set up read-only property</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code> <code class="nx">o3</code><code class="p">,</code> <code class="s2">"e"</code><code class="p">,</code> <code class="p">{</code>
            <code class="nx">value</code><code class="o">:</code> <code class="mi">5</code><code class="p">,</code>
            <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
            <code class="nx">writable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
            <code class="nx">configurable</code><code class="o">:</code> <code class="kc">false</code>
        <code class="p">}</code> <code class="p">);</code>
        
        <code class="c1">// set up non-enumerable property</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code> <code class="nx">o3</code><code class="p">,</code> <code class="s2">"f"</code><code class="p">,</code> <code class="p">{</code>
            <code class="nx">value</code><code class="o">:</code> <code class="mi">6</code><code class="p">,</code>
            <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">false</code>
        <code class="p">}</code> <code class="p">);</code>
        
        <code class="nx">o3</code><code class="p">[</code> <code class="nb">Symbol</code><code class="p">(</code> <code class="s2">"g"</code> <code class="p">)</code> <code class="p">]</code> <code class="o">=</code> <code class="mi">7</code><code class="p">;</code>
        
        <code class="c1">// set up non-enumerable symbol</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code> <code class="nx">o3</code><code class="p">,</code> <code class="nb">Symbol</code><code class="p">(</code> <code class="s2">"h"</code> <code class="p">),</code> <code class="p">{</code>
            <code class="nx">value</code><code class="o">:</code> <code class="mi">8</code><code class="p">,</code>
            <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">false</code>
        <code class="p">}</code> <code class="p">);</code>
        
        <code class="nb">Object</code><code class="p">.</code><code class="nx">setPrototypeOf</code><code class="p">(</code> <code class="nx">o3</code><code class="p">,</code> <code class="nx">o4</code> <code class="p">);</code></pre>
        
        <p>Only the properties <code>a</code>, <code>b</code>, <code>c</code>, <code>e</code>, and <code>Symbol("g")</code> will be copied to <code>target</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code> <code class="nx">target</code><code class="p">,</code> <code class="nx">o1</code><code class="p">,</code> <code class="nx">o2</code><code class="p">,</code> <code class="nx">o3</code> <code class="p">);</code>
        
        <code class="nx">target</code><code class="p">.</code><code class="nx">a</code><code class="p">;</code>                           <code class="c1">// 1</code>
        <code class="nx">target</code><code class="p">.</code><code class="nx">b</code><code class="p">;</code>                           <code class="c1">// 2</code>
        <code class="nx">target</code><code class="p">.</code><code class="nx">c</code><code class="p">;</code>                           <code class="c1">// 3</code>
        
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyDescriptor</code><code class="p">(</code> <code class="nx">target</code><code class="p">,</code> <code class="s2">"e"</code> <code class="p">);</code>
        <code class="c1">// { value: 5, writable: true, enumerable: true,</code>
        <code class="c1">//   configurable: true }</code>
        
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertySymbols</code><code class="p">(</code> <code class="nx">target</code> <code class="p">);</code>
        <code class="c1">// [Symbol("g")]</code></pre>
        
        <p>The <code>d</code>, <code>f</code>, and <code>Symbol("h")</code> properties are omitted from copying; non-enumerable properties and non-owned properties are all excluded from the assignment. Also, <code>e</code> is copied as a normal property assignment, not duplicated as a read-only property.</p>
        
        <p>In an earlier section, we showed using <code>setPrototypeOf(..)</code> to set up a
        <code>[[Prototype]]</code> relationship between an <code>o2</code> and <code>o1</code> object. There’s
        another form that leverages <code>Object.assign(..)</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"foo"</code> <code class="p">);</code> <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="kd">var</code> <code class="nx">o2</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code>
            <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code> <code class="nx">o1</code> <code class="p">),</code>
            <code class="p">{</code>
                <code class="c1">// .. o2's definition ..</code>
            <code class="p">}</code>
        <code class="p">);</code>
        
        <code class="c1">// delegates to `o1.foo()`</code>
        <code class="nx">o2</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code>                           <code class="c1">// foo</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><code>Object.create(..)</code> is the ES5 standard utility that creates an
        empty object that is <code>[[Prototype]]</code>-linked. See the <em>this &amp; Object
        Prototypes</em> title of this series for more information.</p>
        </div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Math"><div class="sect1" id="idm45967355118664">
        <h1>Math</h1>
        
        <p>ES6 adds several new mathematic utilities that fill in holes or aid with
        common operations. All of these can be manually calculated, but most of
        them are now defined natively so that in some cases the JS engine can
        either more optimally perform the calculations, or perform them with
        better decimal precision than their manual counterparts.</p>
        
        <p>It’s likely that asm.js/transpiled JS code (see the <em>Async &amp;
        Performance</em> title of this series) is the more likely consumer of many
        of these utilities rather than direct developers.</p>
        
        <p>Trigonometry:</p>
        <dl>
        <dt><code>cosh(..)</code></dt>
        <dd>
        <p>Hyperbolic cosine</p>
        </dd>
        <dt><code>acosh(..)</code></dt>
        <dd>
        <p>Hyperbolic arccosine</p>
        </dd>
        <dt><code>sinh(..)</code></dt>
        <dd>
        <p>Hyperbolic sine</p>
        </dd>
        <dt><code>asinh(..)</code></dt>
        <dd>
        <p>Hyperbolic arcsine</p>
        </dd>
        <dt><code>tanh(..)</code></dt>
        <dd>
        <p>Hyperbolic tangent</p>
        </dd>
        <dt><code>atanh(..)</code></dt>
        <dd>
        <p>Hyperbolic arctangent</p>
        </dd>
        <dt><code>hypot(..)</code></dt>
        <dd>
        <p>The squareroot of the sum of the squares (i.e., the
        generalized Pythagorean theorem)</p>
        </dd>
        </dl>
        
        <p class="pagebreak-before">Arithmetic:</p>
        <dl>
        <dt><code>cbrt(..)</code></dt>
        <dd>
        <p>Cube root</p>
        </dd>
        <dt><code>clz32(..)</code></dt>
        <dd>
        <p>Count leading zeros in 32-bit binary representation</p>
        </dd>
        <dt><code>expm1(..)</code></dt>
        <dd>
        <p>The same as <code>exp(x) - 1</code></p>
        </dd>
        <dt><code>log2(..)</code></dt>
        <dd>
        <p>Binary logarithm (log base 2)</p>
        </dd>
        <dt><code>log10(..)</code></dt>
        <dd>
        <p>Log base 10</p>
        </dd>
        <dt><code>log1p(..)</code></dt>
        <dd>
        <p>The same as <code>log(x + 1)</code></p>
        </dd>
        <dt><code>imul(..)</code></dt>
        <dd>
        <p>32-bit integer multiplication of two numbers</p>
        </dd>
        </dl>
        
        <p>Meta:</p>
        <dl>
        <dt><code>sign(..)</code></dt>
        <dd>
        <p>Returns the sign of the number</p>
        </dd>
        <dt><code>trunc(..)</code></dt>
        <dd>
        <p>Returns only the integer part of a number</p>
        </dd>
        <dt><code>fround(..)</code></dt>
        <dd>
        <p>Rounds to nearest 32-bit (single precision) floating-point value</p>
        </dd>
        </dl>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Number"><div class="sect1" id="idm45967354750744">
        <h1>Number</h1>
        
        <p>Importantly, for your program to properly work, it must accurately
        handle numbers. ES6 adds some additional properties and functions to
        assist with common numeric operations.</p>
        
        <p>Two additions to <code>Number</code> are just references to the pre-existing
        globals: <code>Number.parseInt(..)</code> and <code>Number.parseFloat(..)</code>.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Static Properties"><div class="sect2" id="idm45967354747128">
        <h2>Static Properties</h2>
        
        <p>ES6 adds some helpful numeric constants as static properties:</p>
        <dl>
        <dt><code>Number.EPSILON</code></dt>
        <dd>
        <p>The minimum value between any two numbers: <code>2^-52</code>
        (see Chapter 2 of the <em>Types &amp; Grammar</em> title of this series regarding
        using this value as a tolerance for imprecision in floating-point
        arithmetic)</p>
        </dd>
        <dt><code>Number.MAX_SAFE_INTEGER</code></dt>
        <dd>
        <p>The highest integer that can “safely” be
        represented unambiguously in a JS number value: <code>2^53 - 1</code></p>
        </dd>
        <dt><code>Number.MIN_SAFE_INTEGER</code></dt>
        <dd>
        <p>The lowest integer that can “safely” be
        represented unambiguously in a JS number value: <code>-(2^53 - 1)</code> or
        <code>(-2)^53 + 1</code></p>
        </dd>
        </dl>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>See Chapter 2 of the <em>Types &amp; Grammar</em> title of this series for
        more information about “safe” integers.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Number.isNaN(..) Static Function"><div class="sect2" id="idm45967354714184">
        <h2>Number.isNaN(..) Static Function</h2>
        
        <p>The standard global <code>isNaN(..)</code> utility has been broken since its
        inception, in that it returns <code>true</code> for things that are not numbers,
        not just for the actual <code>NaN</code> value, because it coerces the argument to
        a number type (which can falsely result in a NaN). ES6 adds a fixed
        utility <code>Number.isNaN(..)</code> that works as it should:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="kc">NaN</code><code class="p">,</code> <code class="nx">b</code> <code class="o">=</code> <code class="s2">"NaN"</code><code class="p">,</code> <code class="nx">c</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
        
        <code class="nx">isNaN</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>                         <code class="c1">// true</code>
        <code class="nx">isNaN</code><code class="p">(</code> <code class="nx">b</code> <code class="p">);</code>                         <code class="c1">// true--oops!</code>
        <code class="nx">isNaN</code><code class="p">(</code> <code class="nx">c</code> <code class="p">);</code>                         <code class="c1">// false</code>
        
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isNaN</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>                  <code class="c1">// true</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isNaN</code><code class="p">(</code> <code class="nx">b</code> <code class="p">);</code>                  <code class="c1">// false--fixed!</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isNaN</code><code class="p">(</code> <code class="nx">c</code> <code class="p">);</code>                  <code class="c1">// false</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Number.isFinite(..) Static Function"><div class="sect2" id="idm45967354709080">
        <h2>Number.isFinite(..) Static Function</h2>
        
        <p>There’s a temptation to look at a function name like <code>isFinite(..)</code> and
        assume it’s simply “not infinite”. That’s not quite correct, though.
        There’s more nuance to this new ES6 utility. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="kc">NaN</code><code class="p">,</code> <code class="nx">b</code> <code class="o">=</code> <code class="kc">Infinity</code><code class="p">,</code> <code class="nx">c</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
        
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isFinite</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>               <code class="c1">// false</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isFinite</code><code class="p">(</code> <code class="nx">b</code> <code class="p">);</code>               <code class="c1">// false</code>
        
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isFinite</code><code class="p">(</code> <code class="nx">c</code> <code class="p">);</code>               <code class="c1">// true</code></pre>
        
        <p>The standard global <code>isFinite(..)</code> coerces its argument, but
        <code>Number.isFinite(..)</code> omits the coercive behavior:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="s2">"42"</code><code class="p">;</code>
        
        <code class="nx">isFinite</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>                      <code class="c1">// true</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isFinite</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>               <code class="c1">// false</code></pre>
        
        <p>You may still prefer the coercion, in which case using the global
        <code>isFinite(..)</code> is a valid choice. Alternatively, and perhaps more
        sensibly, you can use <code>Number.isFinite(+x)</code>, which explicitly coerces
        <code>x</code> to a number before passing it in (see Chapter 4 of the <em>Types &amp;
        Grammar</em> title of this series).</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Integer-Related Static Functions"><div class="sect2" id="idm45967354574456">
        <h2>Integer-Related Static Functions</h2>
        
        <p>JavaScript number valuess are always floating point (IEE-754). So the
        notion of determining if a number is an “integer” is not about checking
        its type, because JS makes no such distinction.</p>
        
        <p>Instead, you need to check if there’s any nonzero decimal portion of
        the value. The easiest way to do that has commonly been:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">x</code> <code class="o">===</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code> <code class="nx">x</code> <code class="p">);</code></pre>
        
        <p>ES6 adds a <code>Number.isInteger(..)</code> helper utility that potentially can
        determine this quality slightly more efficiently:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code> <code class="mi">4</code> <code class="p">);</code>              <code class="c1">// true</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code> <code class="mf">4.2</code> <code class="p">);</code>            <code class="c1">// false</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>In JavaScript, there’s no difference between <code>4</code>, <code>4.</code>, <code>4.0</code>,
        or <code>4.0000</code>. All of these would be considered an “integer,” and would
        thus yield <code>true</code> from <span class="keep-together"><code>Number.isInteger(..)</code></span>.</p>
        </div>
        
        <p>In addition, <code>Number.isInteger(..)</code> filters out some clearly not-integer
        values that <code>x === Math.floor(x)</code> could potentially mix up:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code> <code class="kc">NaN</code> <code class="p">);</code>            <code class="c1">// false</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code> <code class="kc">Infinity</code> <code class="p">);</code>       <code class="c1">// false</code></pre>
        
        <p>Working with “integers” is sometimes an important bit of information, as
        it can simplify certain kinds of algorithms. JS code by itself will not
        run faster just from filtering for only integers, but there are
        optimization techniques the engine can take (e.g., asm.js) when only
        integers are being used.</p>
        
        <p>Because of <code>Number.isInteger(..)</code>’s handling of <code>NaN</code> and <code>Infinity</code>
        values, defining a <code>isFloat(..)</code> utility would not be just as simple as
        <code>!Number.isInteger(..)</code>. You’d need to do something like:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">isFloat</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nb">Number</code><code class="p">.</code><code class="nx">isFinite</code><code class="p">(</code> <code class="nx">x</code> <code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code> <code class="nx">x</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">isFloat</code><code class="p">(</code> <code class="mf">4.2</code> <code class="p">);</code>                     <code class="c1">// true</code>
        <code class="nx">isFloat</code><code class="p">(</code> <code class="mi">4</code> <code class="p">);</code>                       <code class="c1">// false</code>
        
        <code class="nx">isFloat</code><code class="p">(</code> <code class="kc">NaN</code> <code class="p">);</code>                     <code class="c1">// false</code>
        <code class="nx">isFloat</code><code class="p">(</code> <code class="kc">Infinity</code> <code class="p">);</code>                <code class="c1">// false</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>It may seem strange, but <code>Infinity</code> should neither be considered
        an integer nor a float.</p>
        </div>
        
        <p>ES6 also defines a <code>Number.isSafeInteger(..)</code> utility, which checks to
        make sure the value is both an integer and within the range of
        <code>Number.MIN_SAFE_INTEGER</code>-<code>Number.MAX_SAFE_INTEGER</code> (inclusive).</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">53</code> <code class="p">),</code>
            <code class="nx">y</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">(</code> <code class="o">-</code><code class="mi">2</code><code class="p">,</code> <code class="mi">53</code> <code class="p">);</code>
        
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isSafeInteger</code><code class="p">(</code> <code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code> <code class="p">);</code>      <code class="c1">// true</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isSafeInteger</code><code class="p">(</code> <code class="nx">y</code> <code class="o">+</code> <code class="mi">1</code> <code class="p">);</code>      <code class="c1">// true</code>
        
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isSafeInteger</code><code class="p">(</code> <code class="nx">x</code> <code class="p">);</code>          <code class="c1">// false</code>
        <code class="nb">Number</code><code class="p">.</code><code class="nx">isSafeInteger</code><code class="p">(</code> <code class="nx">y</code> <code class="p">);</code>          <code class="c1">// false</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="String"><div class="sect1" id="idm45967354573800">
        <h1>String</h1>
        
        <p>Strings already have quite a few helpers prior to ES6, but even more
        have been added to the mix.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Unicode Functions"><div class="sect2" id="idm45967354269320">
        <h2>Unicode Functions</h2>
        
        <p><a data-type="xref" href="ch02.html#ua_stringOps">“Unicode-Aware String Operations”</a> in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a> discusses
        <code>String.fromCodePoint(..)</code>, <code>String#codePointAt(..)</code>, and
        <code>String#normalize(..)</code> in detail. They have been added to improve
        Unicode support in JS string values.</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code> <code class="mh">0x1d49e</code> <code class="p">);</code>            <code class="c1">// "𝒞"</code>
        <code class="s2">"ab𝒞d.codePointAt( 2 ).toString( 16 );     // "</code><code class="mi">1</code><code class="nx">d49e</code><code class="err">"</code></pre>
        
        <p>The <code>normalize(..)</code> string prototype method is used to perform Unicode
        normalizations that either combine characters with adjacent “combining
        marks” or decompose combined characters.</p>
        
        <p>Generally, the normalization won’t create a visible effect on the
        contents of the string, but will change the contents of the string,
        which can affect how things like the <code>length</code> property are reported, as
        well as how character access by position behaves:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s1</code> <code class="o">=</code> <code class="s2">"e\u0301"</code><code class="p">;</code>
        <code class="nx">s1</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                          <code class="c1">// 2</code>
        
        <code class="kd">var</code> <code class="nx">s2</code> <code class="o">=</code> <code class="nx">s1</code><code class="p">.</code><code class="nx">normalize</code><code class="p">();</code>
        <code class="nx">s2</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                          <code class="c1">// 1</code>
        <code class="nx">s2</code> <code class="o">===</code> <code class="s2">"\xE9"</code><code class="p">;</code>                      <code class="c1">// true</code></pre>
        
        <p><code>normalize(..)</code> takes an optional argument that specifies the
        normalization form to use. This argument must be one of the following
        four values: <code>"NFC"</code> (default), <code>"NFD"</code>, <code>"NFKC"</code>, or <code>"NFKD"</code>.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>Normalization forms and their effects on strings is well beyond
        the scope of what we’ll discuss here. See <a href="http://www.unicode.org/reports/tr15/">“Unicode Normalization Forms”</a> for more information.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="String.raw(..) Static Function"><div class="sect2" id="idm45967354162920">
        <h2>String.raw(..) Static Function</h2>
        
        <p>The <code>String.raw(..)</code> utility is provided as a built-in tag function to
        use with template string literals (see <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a>) for obtaining the raw
        string value without any processing of escape sequences.</p>
        
        <p>This function will almost never be called manually, but will be used
        with tagged template literals:</p>
        
        <pre data-type="programlisting" data-code-language="es6" class="pagebreak-before"><code class="kd">var</code> <code class="nx">str</code> <code class="o">=</code> <code class="s2">"bc"</code><code class="p">;</code>
        
        <code class="nt">String.raw</code><code class="sb">`\ta</code><code class="si">${</code><code class="nx">str</code><code class="si">}</code><code class="sb">d\xE9`</code><code class="p">;</code>
        <code class="c1">// "\tabcd\xE9", not "  abcdé"</code></pre>
        
        <p>In the resultant string, <code>\</code> and <code>t</code> are separate raw characters, not
        the one escape sequence character <code>\t</code>. The same is true of the
        Unicode escape sequence.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="repeat(..) Prototype Function"><div class="sect2" id="idm45967354146984">
        <h2>repeat(..) Prototype Function</h2>
        
        <p>In languages like Python and Ruby, you can repeat a string as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="s2">"foo"</code> <code class="o">*</code> <code class="mi">3</code><code class="p">;</code>                          <code class="c1">// "foofoofoo"</code></pre>
        
        <p>That doesn’t work in JS, because <code>*</code> multiplication is only defined for
        numbers, and thus <code>"foo"</code> coerces to the <code>NaN</code> number.</p>
        
        <p>However, ES6 defines a string prototype method <code>repeat(..)</code> to
        accomplish the task:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="s2">"foo"</code><code class="p">.</code><code class="nx">repeat</code><code class="p">(</code> <code class="mi">3</code> <code class="p">);</code>                  <code class="c1">// "foofoofoo"</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="String Inspection Functions"><div class="sect2" id="string-inspection_sect">
        <h2>String Inspection Functions</h2>
        
        <p>In addition to <code>String#indexOf(..)</code> and <code>String#lastIndexOf(..)</code> from
        prior to ES6, three new methods for searching/inspection have been
        added: <code>startsWith(..)</code>, <code>endsWidth(..)</code>, and <code>includes(..)</code>.</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">palindrome</code> <code class="o">=</code> <code class="s2">"step on no pets"</code><code class="p">;</code>
        
        <code class="nx">palindrome</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code> <code class="s2">"step on"</code> <code class="p">);</code> <code class="c1">// true</code>
        <code class="nx">palindrome</code><code class="p">.</code><code class="nx">startsWith</code><code class="p">(</code> <code class="s2">"on"</code><code class="p">,</code> <code class="mi">5</code> <code class="p">);</code>   <code class="c1">// true</code>
        
        <code class="nx">palindrome</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code> <code class="s2">"no pets"</code> <code class="p">);</code>   <code class="c1">// true</code>
        <code class="nx">palindrome</code><code class="p">.</code><code class="nx">endsWith</code><code class="p">(</code> <code class="s2">"no"</code><code class="p">,</code> <code class="mi">10</code> <code class="p">);</code>    <code class="c1">// true</code>
        
        <code class="nx">palindrome</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code> <code class="s2">"on"</code> <code class="p">);</code>        <code class="c1">// true</code>
        <code class="nx">palindrome</code><code class="p">.</code><code class="nx">includes</code><code class="p">(</code> <code class="s2">"on"</code><code class="p">,</code> <code class="mi">6</code> <code class="p">);</code>     <code class="c1">// false</code></pre>
        
        <p>For all the string search/inspection methods, if you look for an empty
        string <code>""</code>, it will either be found at the beginning or the end of the
        string.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>These methods will not by default accept a regular expression
        for the search string. See <a data-type="xref" href="ch07.html#regexSymbols-sect">“Regular Expression Symbols”</a> in <a data-type="xref" href="ch07.html#chapter-7-meta-programming">Chapter&nbsp;7</a> for
        information about disabling the <code>isRegExp</code> check that is performed on
        this first argument.</p>
        </div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Review"><div class="sect1" id="idm45967353963960">
        <h1>Review</h1>
        
        <p>ES6 adds many extra API helpers on the various built-in native objects:</p>
        
        <ul>
        <li>
        <p><code>Array</code> adds <code>of(..)</code> and <code>from(..)</code> static functions, as well as
        prototype functions like <code>copyWithin(..)</code> and <code>fill(..)</code>.</p>
        </li>
        <li>
        <p><code>Object</code> adds static functions like <code>is(..)</code> and <code>assign(..)</code>.</p>
        </li>
        <li>
        <p><code>Math</code> adds static functions like <code>acosh(..)</code> and <code>clz32(..)</code>.</p>
        </li>
        <li>
        <p><code>Number</code> adds static properties like <code>Number.EPSILON</code>, as well as
        static functions like <code>Number.isFinite(..)</code>.</p>
        </li>
        <li>
        <p><code>String</code> adds static functions like <code>String.fromCodePoint(..)</code> and
        <code>String.raw(..)</code>, as well as prototype functions like <code>repeat(..)</code> and
        <code>includes(..)</code>.</p>
        </li>
        </ul>
        
        <p>Most of these additions can be polyfilled (see ES6 Shim), and were
        inspired by utilities in common JS libraries/frameworks.</p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781491905241/files/epub.css" crossorigin="anonymous"></div>
</div>

https://learning.oreilly.com