<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 3. Organization"><div class="chapter" id="chapter-3-organization">
        <h1><span class="label">Chapter 3. </span>Organization</h1>
        
        
        <p>It’s one thing to write JS code, but it’s another to properly organize it. Utilizing common patterns for organization and reuse goes a long way to improving the readability and understandability of your code. Remember: code is at least as much about communicating to other developers as it is about feeding the computer instructions.</p>
        
        <p>ES6 has several important features that help significantly improve these patterns, including iterators, generators, modules, and classes.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Iterators"><div class="sect1" id="iterSect">
        <h1>Iterators</h1>
        
        <p>An <em>iterator</em> is a structured pattern for pulling information from a
        source in one-at-a-time fashion. This pattern has been found in programming for a long time. And to be sure, JS developers have been ad
        hoc designing and implementing iterators in JS programs since before
        anyone can remember, so it’s not at all a new topic.</p>
        
        <p>What ES6 has done is introduce an implicit standardized interface for
        iterators. Many of the built-in data structures in JavaScript will now
        expose an iterator implementing this standard. And you can also
        construct your own iterators adhering to the same standard, for maximal
        interoperability.</p>
        
        <p>Iterators are a way of organizing ordered, sequential, pull-based
        consumption of data.</p>
        
        <p>For example, you may implement a utility that produces a new unique
        identifier each time it’s requested. Or you may produce an infinite
        series of values that rotate through a fixed list, in round-robin
        fashion. Or you could attach an iterator to a database query result to
        pull out new rows one at a time.</p>
        
        <p>Although they have not commonly been used in JS in such a manner,
        iterators can also be thought of as controlling behavior one step at a
        time. This can be illustrated quite clearly when considering generators
        (see <a data-type="xref" href="#generator-sect">“Generators”</a> later in this chapter), though you can certainly do
        the same without generators.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Interfaces"><div class="sect2" id="idm45967368390264">
        <h2>Interfaces</h2>
        
        <p>At the time of this writing, <a href="https://people.mozilla.org/~jorendorff/es6-draft.html#sec-iterator-interface">ES6 section 25.1.1.2</a> details the <code>Iterator</code> interface as having the following requirement:</p>
        
        <pre data-type="programlisting">Iterator [required]
            next() {method}: retrieves next IteratorResult</pre>
        
        <p>There are two optional members that some iterators are extended with:</p>
        
        <pre data-type="programlisting">Iterator [optional]
            return() {method}: stops iterator and returns IteratorResult
            throw() {method}: signals error and returns IteratorResult</pre>
        
        <p>The <code>IteratorResult</code> interface is specified as:</p>
        
        <pre data-type="programlisting">IteratorResult
            value {property}: current iteration value or final return
                value (optional if `undefined`)
            done {property}: boolean, indicates completion status</pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>I call these interfaces implicit not because they’re not
        explicitly called out in the specification—they are!—but because
        they’re not exposed as direct objects accessible to code. JavaScript
        does not, in ES6, support any notion of “interfaces,” so adherence for
        your own code is purely conventional. However, wherever JS expects an
        iterator—a <code>for..of</code> loop, for instance—what you provide must
        adhere to these interfaces or the code will fail.</p>
        </div>
        
        <p>There’s also an <code>Iterable</code> interface, which describes objects that must
        be able to produce iterators:</p>
        
        <pre data-type="programlisting" class="pagebreak-before">Iterable
            @@iterator() {method}: produces an Iterator</pre>
        
        <p>If you recall from <a data-type="xref" href="ch02.html#builtinsym-sect">“Built-In Symbols”</a> in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a>, <code>@@iterator</code> is the
        special built-in symbol representing the method that can produce
        iterator(s) for the object.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="IteratorResult"><div class="sect3" id="idm45967368360664">
        <h3>IteratorResult</h3>
        
        <p>The <code>IteratorResult</code> interface specifies that the return value from any
        iterator operation will be an object of the form:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="p">..</code> <code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="o">/</code> <code class="kc">false</code> <code class="p">}</code></pre>
        
        <p>Built-in iterators will always return values of this form, but more
        properties are, of course, allowed to be present on the return value, as
        necessary.</p>
        
        <p>For example, a custom iterator may add additional metadata to the result
        object (e.g., where the data came from, how long it took to retrieve,
        cache expiration length, frequency for the appropriate next request,
        etc.).</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>Technically, <code>value</code> is optional if it would otherwise be
        considered absent or unset, such as in the case of the value <code>undefined</code>. Because accessing <code>res.value</code> will produce <code>undefined</code>
        whether it’s present with that value or absent entirely, the
        presence/absence of the property is more an implementation detail or an
        optimization (or both), rather than a functional issue.</p>
        </div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="next() Iteration"><div class="sect2" id="idm45967368389672">
        <h2>next() Iteration</h2>
        
        <p>Let’s look at an array, which is an iterable, and the iterator it can
        produce to consume its values:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">arr</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>      <code class="c1">// { value: 1, done: false }</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>      <code class="c1">// { value: 2, done: false }</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>      <code class="c1">// { value: 3, done: false }</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>      <code class="c1">// { value: undefined, done: true }</code></pre>
        
        <p>Each time the method located at <code>Symbol.iterator</code> (see <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a> and <a data-type="xref" href="ch07.html#chapter-7-meta-programming">Chapter&nbsp;7</a>)
        is invoked on this <code>arr</code> value, it will produce a new fresh iterator.
        Most structures will do the same, including all the built-in data
        structures in JS.</p>
        
        <p>However, a structure like an event queue consumer might only ever
        produce a single iterator (singleton pattern). Or a structure might only
        allow one unique iterator at a time, requiring the current one to be
        completed before a new one can be created.</p>
        
        <p>The <code>it</code> iterator in the previous snippet doesn’t report <code>done: true</code>
        when you receive the <code>3</code> value. You have to call <code>next()</code> again, in
        essence going beyond the end of the array’s values, to get the complete
        signal <code>done: true</code>. It may not be clear why until later in this
        section, but that design decision will typically be considered a best
        practice.</p>
        
        <p>Primitive string values are also iterables by default:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">greeting</code> <code class="o">=</code> <code class="s2">"hello world"</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">greeting</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>      <code class="c1">// { value: "h", done: false }</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>      <code class="c1">// { value: "e", done: false }</code>
        <code class="p">..</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>Technically, the primitive value itself isn’t iterable, but
        thanks to “boxing”, <code>"hello world"</code> is coerced/converted to its <code>String</code>
        object wrapper form, which <em>is</em> an iterable. See the <em>Types &amp; Grammar</em>
        title of this series for more information.</p>
        </div>
        
        <p>ES6 also includes several new data structures, called collections (see
        <a data-type="xref" href="ch05.html#chapter-5-collections">Chapter&nbsp;5</a>). These collections are not only iterables themselves, but
        they also provide API method(s) to generate an iterator, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">m</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Map</code><code class="p">();</code>
        <code class="nx">m</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code> <code class="s2">"foo"</code><code class="p">,</code> <code class="mi">42</code> <code class="p">);</code>
        <code class="nx">m</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code> <code class="p">{</code> <code class="nx">cool</code><code class="o">:</code> <code class="kc">true</code> <code class="p">},</code> <code class="s2">"hello world"</code> <code class="p">);</code>
        
        <code class="kd">var</code> <code class="nx">it1</code> <code class="o">=</code> <code class="nx">m</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
        <code class="kd">var</code> <code class="nx">it2</code> <code class="o">=</code> <code class="nx">m</code><code class="p">.</code><code class="nx">entries</code><code class="p">();</code>
        
        <code class="nx">it1</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>     <code class="c1">// { value: [ "foo", 42 ], done: false }</code>
        <code class="nx">it2</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>     <code class="c1">// { value: [ "foo", 42 ], done: false }</code>
        <code class="p">..</code></pre>
        
        <p>The <code>next(..)</code> method of an iterator can optionally take one or more
        arguments. The built-in iterators mostly do not exercise this
        capability, though a generator’s iterator definitely does (see
        <a data-type="xref" href="#generator-sect">“Generators”</a> later in this chapter).</p>
        
        <p>By general convention, including all the built-in iterators, calling
        <code>next(..)</code> on an iterator that’s already been exhausted is not an error,
        but will simply continue to return the result
        <code>{ value: undefined, done: true }</code>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Optional: return(..) and throw(..)"><div class="sect2" id="idm45967368344760">
        <h2>Optional: return(..) and throw(..)</h2>
        
        <p>The optional methods on the iterator interface—<code>return(..)</code> and
        <code>throw(..)</code>—are not implemented on most of the built-in iterators.
        However, they definitely do mean something in the context of generators,
        so see <a data-type="xref" href="#generator-sect">“Generators”</a> for more specific information.</p>
        
        <p><code>return(..)</code> is defined as sending a signal to an iterator that the
        consuming code is complete and will not be pulling any more values from
        it. This signal can be used to notify the producer (the iterator
        responding to <code>next(..)</code> calls) to perform any cleanup it may need to
        do, such as releasing/closing network, database, or file handle
        resources.</p>
        
        <p>If an iterator has a <code>return(..)</code> present and any condition occurs that
        can automatically be interpreted as abnormal or early termination of
        consuming the iterator, <code>return(..)</code> will automatically be called. You
        can call <code>return(..)</code> manually as well.</p>
        
        <p><code>return(..)</code> will return an <code>IteratorResult</code> object just like <code>next(..)</code>
        does. In general, the optional value you send to <code>return(..)</code> would be
        sent back as <code>value</code> in this <code>IteratorResult</code>, though there are nuanced
        cases where that might not be true.</p>
        
        <p><code>throw(..)</code> is used to signal an exception/error to an iterator, which
        possibly may be used differently by the iterator than the completion
        signal implied by <code>return(..)</code>. It does not necessarily imply a complete
        stop of the iterator as <code>return(..)</code> generally does.</p>
        
        <p>For example, with generator iterators, <code>throw(..)</code> actually injects a
        thrown exception into the generator’s paused execution context, which
        can be caught with a <code>try..catch</code>. An uncaught <code>throw(..)</code> exception
        would end up abnormally aborting the generator’s <span class="keep-together">iterator</span>.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>By general convention, an iterator should not produce any more
        results after having called <code>return(..)</code> or <code>throw(..)</code>.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Iterator Loop"><div class="sect2" id="iteratorloop">
        <h2>Iterator Loop</h2>
        
        <p>As we covered in <a data-type="xref" href="ch02.html#forofloops-sect">“for..of Loops”</a> in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a>, the ES6 <code>for..of</code>
        loop directly consumes a conforming iterable.</p>
        
        <p>If an iterator is also an iterable, it can be used directly with the
        <code>for..of</code> loop. You make an iterator an iterable by giving it a
        <span class="keep-together"><code>Symbol.iterator</code></span> method that simply returns the iterator itself:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// make the `it` iterator an iterable</code>
            <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">},</code>
        
            <code class="nx">next</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">},</code>
            <code class="p">..</code>
        <code class="p">};</code>
        
        <code class="nx">it</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="o">===</code> <code class="nx">it</code><code class="p">;</code>       <code class="c1">// true</code></pre>
        
        <p>Now we can consume the <code>it</code> iterator with a <code>for..of</code> loop:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">v</code> <code class="k">of</code> <code class="nx">it</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">v</code> <code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>To fully understand how such a loop works, recall the <code>for</code> equivalent of a <code>for..of</code> loop from <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">v</code><code class="p">,</code> <code class="nx">res</code><code class="p">;</code> <code class="p">(</code><code class="nx">res</code> <code class="o">=</code> <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">())</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">res</code><code class="p">.</code><code class="nx">done</code><code class="p">;</code> <code class="p">)</code> <code class="p">{</code>
            <code class="nx">v</code> <code class="o">=</code> <code class="nx">res</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">v</code> <code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>If you look closely, you’ll see that <code>it.next()</code> is called before each
        iteration, and then <code>res.done</code> is consulted. If <code>res.done</code> is <code>true</code>, the expression evaluates to <code>false</code> and the iteration doesn’t occur.</p>
        
        <p>Recall earlier that we suggested iterators should in general not return
        <code>done: true</code> along with the final intended value from the iterator. Now
        you can see why.</p>
        
        <p>If an iterator returned <code>{ done: true, value: 42 }</code>, the <code>for..of</code> loop
        would completely discard the <code>42</code> value and it’d be lost. For
        this reason, assuming that your iterator may be consumed by patterns
        like the <code>for..of</code> loop or its manual <code>for</code> equivalent, you should probably
        wait to return <code>done: true</code> for signaling completion until after you’ve
        already returned all relevant iteration values.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>You can, of course, intentionally design your iterator to
        return some relevant <code>value</code> at the same time as returning <code>done: true</code>.
        But don’t do this unless you’ve documented that as the case, and thus
        implicitly forced consumers of your iterator to use a different pattern
        for iteration than is implied by <code>for..of</code> or its manual equivalent as we
        depicted.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Custom Iterators"><div class="sect2" id="customiterSect">
        <h2>Custom Iterators</h2>
        
        <p>In addition to the standard built-in iterators, you can make your own!
        All it takes to make them interoperate with ES6’s consumption facilities
        (e.g., the <code>for..of</code> loop and the <code>...</code> operator) is to adhere to the
        proper interface(s).</p>
        
        <p>Let’s try constructing an iterator that produces the infinite series of
        numbers in the Fibonacci sequence:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">Fib</code> <code class="o">=</code> <code class="p">{</code>
            <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
                <code class="kd">var</code> <code class="nx">n1</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">n2</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
        
                <code class="k">return</code> <code class="p">{</code>
                    <code class="c1">// make the iterator an iterable</code>
                    <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">},</code>
        
                    <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
                        <code class="kd">var</code> <code class="nx">current</code> <code class="o">=</code> <code class="nx">n2</code><code class="p">;</code>
                        <code class="nx">n2</code> <code class="o">=</code> <code class="nx">n1</code><code class="p">;</code>
                        <code class="nx">n1</code> <code class="o">=</code> <code class="nx">n1</code> <code class="o">+</code> <code class="nx">current</code><code class="p">;</code>
                        <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">current</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code> <code class="p">};</code>
                    <code class="p">},</code>
        
                    <code class="k">return</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code> <code class="p">{</code>
                        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code>
                            <code class="s2">"Fibonacci sequence abandoned."</code>
                        <code class="p">);</code>
                        <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">v</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">};</code>
                    <code class="p">}</code>
                <code class="p">};</code>
            <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">v</code> <code class="k">of</code> <code class="nx">Fib</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">v</code> <code class="p">);</code>
        
            <code class="k">if</code> <code class="p">(</code><code class="nx">v</code> <code class="o">&gt;</code> <code class="mi">50</code><code class="p">)</code> <code class="k">break</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="c1">// 1 1 2 3 5 8 13 21 34 55</code>
        <code class="c1">// Fibonacci sequence abandoned.</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>If we hadn’t inserted the <code>break</code> condition, this <code>for..of</code>
        loop would have run forever, which is probably not the desired result in
        terms of breaking your program!</p>
        </div>
        
        <p>The <code>Fib[Symbol.iterator]()</code> method when called returns the iterator
        object with <code>next()</code> and <code>return(..)</code> methods on it. State is maintained
        via <code>n1</code> and <code>n2</code> variables, which are kept by the closure.</p>
        
        <p>Let’s <em>next</em> consider an iterator that is designed to run through a
        series (aka a queue) of actions, one item at a time:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">tasks</code> <code class="o">=</code> <code class="p">{</code>
            <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code>
                <code class="kd">var</code> <code class="nx">steps</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">actions</code><code class="p">.</code><code class="nx">slice</code><code class="p">();</code>
        
                <code class="k">return</code> <code class="p">{</code>
                    <code class="c1">// make the iterator an iterable</code>
                    <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">},</code>
        
                    <code class="nx">next</code><code class="p">(</code><code class="o">...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
                        <code class="k">if</code> <code class="p">(</code><code class="nx">steps</code><code class="p">.</code><code class="nx">length</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                            <code class="kd">let</code> <code class="nx">res</code> <code class="o">=</code> <code class="nx">steps</code><code class="p">.</code><code class="nx">shift</code><code class="p">()(</code> <code class="o">...</code><code class="nx">args</code> <code class="p">);</code>
                            <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">res</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code> <code class="p">};</code>
                        <code class="p">}</code>
                        <code class="k">else</code> <code class="p">{</code>
                            <code class="k">return</code> <code class="p">{</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">}</code>
                        <code class="p">}</code>
                    <code class="p">},</code>
        
                    <code class="k">return</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code> <code class="p">{</code>
                        <code class="nx">steps</code><code class="p">.</code><code class="nx">length</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
                        <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">v</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">};</code>
                    <code class="p">}</code>
                <code class="p">};</code>
            <code class="p">},</code>
            <code class="nx">actions</code><code class="o">:</code> <code class="p">[]</code>
        <code class="p">};</code></pre>
        
        <p>The iterator on <code>tasks</code> steps through functions found in the <code>actions</code>
        array property, if any, and executes them one at a time, passing in
        whatever arguments you pass to <code>next(..)</code>, and returning any return
        value to you in the standard <code>IteratorResult</code> object.</p>
        
        <p>Here’s how we could could use this <code>tasks</code> queue:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">tasks</code><code class="p">.</code><code class="nx">actions</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code>
            <code class="kd">function </code><code class="nx">step1</code><code class="p">(</code><code class="nx">x</code><code class="p">){</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"step 1:"</code><code class="p">,</code> <code class="nx">x</code> <code class="p">);</code>
                <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code>
            <code class="p">},</code>
            <code class="kd">function </code><code class="nx">step2</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">){</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"step 2:"</code><code class="p">,</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">);</code>
                <code class="k">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="p">(</code><code class="nx">y</code> <code class="o">*</code> <code class="mi">2</code><code class="p">);</code>
            <code class="p">},</code>
            <code class="kd">function </code><code class="nx">step3</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">,</code><code class="nx">z</code><code class="p">){</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"step 3:"</code><code class="p">,</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>
                <code class="k">return</code> <code class="p">(</code><code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">)</code> <code class="o">+</code> <code class="nx">z</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">);</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">tasks</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="mi">10</code> <code class="p">);</code>          <code class="c1">// step 1: 10</code>
                                <code class="c1">// { value:   20, done: false }</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">50</code> <code class="p">);</code>      <code class="c1">// step 2: 20 50</code>
                                <code class="c1">// { value:  120, done: false }</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="mi">20</code><code class="p">,</code> <code class="mi">50</code><code class="p">,</code> <code class="mi">120</code> <code class="p">);</code> <code class="c1">// step 3: 20 50 120</code>
                                <code class="c1">// { value: 1120, done: false }</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { done: true }</code></pre>
        
        <p>This particular usage reinforces that iterators can be a pattern for
        organizing functionality, not just data. It’s also reminiscent of what
        we’ll see with generators in the next section.</p>
        
        <p>You could even get creative and define an iterator that represents meta
        operations on a single piece of data. For example, we could define an
        iterator for numbers that by default ranges from <code>0</code> up to (or down to,
        for negative numbers) the number in question.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nb">Number</code><code class="p">.</code><code class="nx">prototype</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">])</code> <code class="p">{</code>
            <code class="nb">Object</code><code class="p">.</code><code class="nx">defineProperty</code><code class="p">(</code>
                <code class="nb">Number</code><code class="p">.</code><code class="nx">prototype</code><code class="p">,</code>
                <code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">,</code>
                <code class="p">{</code>
                    <code class="nx">writable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
                    <code class="nx">configurable</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
                    <code class="nx">enumerable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
                    <code class="nx">value</code><code class="o">:</code> <code class="kd">function </code><code class="nx">iterator</code><code class="p">(){</code>
                        <code class="kd">var</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">inc</code><code class="p">,</code> <code class="nx">done</code> <code class="o">=</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">top</code> <code class="o">=</code> <code class="o">+</code><code class="k">this</code><code class="p">;</code>
        
                        <code class="c1">// iterate positively or negatively?</code>
                        <code class="nx">inc</code> <code class="o">=</code> <code class="mi">1</code> <code class="o">*</code> <code class="p">(</code><code class="nx">top</code> <code class="o">&lt;</code> <code class="mi">0</code> <code class="o">?</code> <code class="o">-</code><code class="mi">1</code> <code class="o">:</code> <code class="mi">1</code><code class="p">);</code>
        
                        <code class="k">return</code> <code class="p">{</code>
                            <code class="c1">// make the iterator itself an iterable!</code>
                            <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">](){</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">},</code>
        
                            <code class="nx">next</code><code class="p">()</code> <code class="p">{</code>
                                <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
                                    <code class="c1">// initial iteration always 0</code>
                                    <code class="k">if</code> <code class="p">(</code><code class="nx">i</code> <code class="o">==</code> <code class="kc">null</code><code class="p">)</code> <code class="p">{</code>
                                        <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
                                    <code class="p">}</code>
                                    <code class="c1">// iterating positively</code>
                                    <code class="k">else</code> <code class="k">if</code> <code class="p">(</code><code class="nx">top</code> <code class="o">&gt;=</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                                        <code class="nx">i</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">min</code><code class="p">(</code><code class="nx">top</code><code class="p">,</code><code class="nx">i</code> <code class="o">+</code> <code class="nx">inc</code><code class="p">);</code>
                                    <code class="p">}</code>
                                    <code class="c1">// iterating negatively</code>
                                    <code class="k">else</code> <code class="p">{</code>
                                        <code class="nx">i</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">top</code><code class="p">,</code><code class="nx">i</code> <code class="o">+</code> <code class="nx">inc</code><code class="p">);</code>
                                    <code class="p">}</code>
        
                                    <code class="c1">// done after this iteration?</code>
                                    <code class="k">if</code> <code class="p">(</code><code class="nx">i</code> <code class="o">==</code> <code class="nx">top</code><code class="p">)</code> <code class="nx">done</code> <code class="o">=</code> <code class="kc">true</code><code class="p">;</code>
        
                                    <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">i</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">false</code> <code class="p">};</code>
                                <code class="p">}</code>
                                <code class="k">else</code> <code class="p">{</code>
                                    <code class="k">return</code> <code class="p">{</code> <code class="nx">done</code><code class="o">:</code> <code class="kc">true</code> <code class="p">};</code>
                                <code class="p">}</code>
                            <code class="p">}</code>
                        <code class="p">};</code>
                    <code class="p">}</code>
                <code class="p">}</code>
            <code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>Now, what tricks does this creativity afford us?</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="k">of</code> <code class="mi">3</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">i</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// 0 1 2 3</code>
        
        <code class="p">[</code><code class="o">...-</code><code class="mi">3</code><code class="p">];</code>                <code class="c1">// [0,-1,-2,-3]</code></pre>
        
        <p>Those are some fun tricks, though the practical utility is somewhat
        debatable. But then again, one might wonder why ES6 didn’t just ship
        with such a minor but delightful feature easter egg!</p>
        
        <p>I’d be remiss if I didn’t at least remind you that extending native
        prototypes as I’m doing in the previous snippet is something you should
        only do with caution and awareness of potential hazards.</p>
        
        <p>In this case, the chances that you’ll have a collision with other code
        or even a future JS feature is probably exceedingly low. But just beware
        of the slight possibility. And document what you’re doing verbosely for
        posterity’s sake.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>I’ve expounded on this particular technique in <a href="http://blog.getify.com/iterating-es6-numbers/">this blog post</a> if you want more
        details. And <a href="http://blog.getify.com/iterating-es6-numbers/comment-page-1/#comment-535294">this comment</a> even suggests a similar trick but for making string character ranges.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Iterator Consumption"><div class="sect2" id="idm45967367922888">
        <h2>Iterator Consumption</h2>
        
        <p>We’ve already shown consuming an iterator item by item with the
        <code>for..of</code> loop. But there are other ES6 structures that can consume
        iterators.</p>
        
        <p>Let’s consider the iterator attached to this array (though any iterator
        we choose would have the following behaviors):</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code></pre>
        
        <p>The <code>...</code> spread operator fully exhausts an iterator. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">,</code><code class="nx">z</code><code class="p">,</code><code class="nx">w</code><code class="p">,</code><code class="nx">p</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="nx">z</code> <code class="o">+</code> <code class="nx">w</code> <code class="o">+</code> <code class="nx">p</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="o">...</code><code class="nx">a</code> <code class="p">);</code>            <code class="c1">// 15</code></pre>
        
        <p><code>...</code> can also spread an iterator inside an array:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[</code> <code class="mi">0</code><code class="p">,</code> <code class="o">...</code><code class="nx">a</code><code class="p">,</code> <code class="mi">6</code> <code class="p">];</code>
        <code class="nx">b</code><code class="p">;</code>                      <code class="c1">// [0,1,2,3,4,5,6]</code></pre>
        
        <p>Array destructuring (see <a data-type="xref" href="ch02.html#destructuring-sect">“Destructuring”</a> in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a>) can partially or
        completely (if paired with a <code>...</code> rest/gather operator) consume an
        iterator:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">a</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
        
        <code class="kd">var</code> <code class="p">[</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="nx">it</code><code class="p">;</code>
        <code class="c1">// take just the first two elements from `it`</code>
        <code class="kd">var</code> <code class="p">[</code><code class="nx">z</code><code class="p">,</code> <code class="o">...</code><code class="nx">w</code><code class="p">]</code> <code class="o">=</code> <code class="nx">it</code><code class="p">;</code>
        <code class="c1">// take the third, then the rest all at once</code>
        
        <code class="c1">// is `it` fully exhausted? Yep.</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: undefined, done: true }</code>
        
        <code class="nx">x</code><code class="p">;</code>                      <code class="c1">// 1</code>
        <code class="nx">y</code><code class="p">;</code>                      <code class="c1">// 2</code>
        <code class="nx">z</code><code class="p">;</code>                      <code class="c1">// 3</code>
        <code class="nx">w</code><code class="p">;</code>                      <code class="c1">// [4,5]</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Generators"><div class="sect1" id="generator-sect">
        <h1>Generators</h1>
        
        <p>All functions run to completion, right? In other words, once a function
        starts running, it finishes before anything else can interrupt.</p>
        
        <p>At least that’s how it’s been for the whole history of JavaScript up to
        this point. As of ES6, a new somewhat exotic form of function is being
        introduced, called a generator. A generator can pause itself in
        mid-execution, and can be resumed either right away or at a later time.
        So it clearly does not hold the run-to-completion guarantee that normal
        functions do.</p>
        
        <p>Moreover, each pause/resume cycle in mid-execution is an opportunity for
        two-way message passing, where the generator can return a value, and the
        controlling code that resumes it can send a value back in.</p>
        
        <p>As with iterators in the previous section, there are multiple ways to
        think about what a generator is, or rather what it’s most useful for.
        There’s no one right answer, but we’ll try to consider several angles.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>See the <em>Async &amp; Performance</em> title of this series for more
        information about generators, and also see <a data-type="xref" href="ch04.html#chapter-4-async-flow-control">Chapter&nbsp;4</a> of this current
        title.</p>
        </div>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Syntax"><div class="sect2" id="idm45967366843256">
        <h2>Syntax</h2>
        
        <p>The generator function is declared with this new syntax:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code></pre>
        
        <p>The position of the <code>*</code> is not functionally relevant. The same
        declaration could be written as any of the following:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code>  <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="kd">function*</code> <code class="nx">foo</code><code class="p">()</code>  <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="kd">function *</code> <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="kd">function*</code><code class="nx">foo</code><code class="p">()</code>   <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="p">..</code></pre>
        
        <p>The <em>only</em> difference here is stylistic preference. Most other
        literature seems to prefer <code>function* foo(..) { .. }</code>. I prefer
        <span class="keep-together"><code>function *foo(..) { .. }</code></span>, so that’s how I’ll present them for the rest
        of this title.</p>
        
        <p>My reason is purely didactic in nature. In this text, when referring to
        a generator function, I will use <code>*foo(..)</code>, as opposed to <code>foo(..)</code> for
        a normal function. I observe that <code>*foo(..)</code> more closely matches the
        <code>*</code> positioning of <code>function *foo(..) { .. }</code>.</p>
        
        <p>Moreover, as we saw in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a> with concise methods, there’s a concise
        generator form in object literals:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">{</code>
            <code class="o">*</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>I would say that with concise generators, <code>*foo() { .. }</code> is rather more
        natural than <code>* foo() { .. }</code>. So that further argues for matching the
        consistency with <code>*foo()</code>.</p>
        
        <p>Consistency eases understanding and learning.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Executing a Generator"><div class="sect3" id="idm45967366755128">
        <h3>Executing a Generator</h3>
        
        <p>Though a generator is declared with <code>*</code>, you still execute it like a
        normal function:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">foo</code><code class="p">();</code></pre>
        
        <p class="pagebreak-after">You can still pass it arguments, as in:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">10</code> <code class="p">);</code></pre>
        
        <p>The major difference is that executing a generator, like <code>foo(5,10)</code>,
        doesn’t actually run the code in the generator. Instead, it produces an
        iterator that will control the generator to execute its code.</p>
        
        <p>We’ll come back to this later in <a data-type="xref" href="#iteratorControl">“Iterator Control”</a>, but briefly:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        
        <code class="c1">// to start/advanced `*foo()`, call</code>
        <code class="c1">// `it.next(..)`</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="yield"><div class="sect3" id="idm45967366635896">
        <h3>yield</h3>
        
        <p>Generators also have a new keyword you can use inside them, to signal
        the pause point: <code>yield</code>. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>
            <code class="kd">var</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">20</code><code class="p">;</code>
        
            <code class="kd">yield</code><code class="p">;</code>
        
            <code class="kd">var</code> <code class="nx">z</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>In this <code>*foo()</code> generator, the operations on the first two lines would
        run at the beginning, then <code>yield</code> would pause the generator. If and
        when resumed, the last line of <code>*foo()</code> would run. <code>yield</code> can appear
        any number of times (or not at all, technically!) in a generator.</p>
        
        <p>You can even put <code>yield</code> inside a loop, and it can represent a repeated
        pause point. In fact, a loop that never completes just means a generator
        that never completes, which is completely valid, and sometimes entirely
        what you need.</p>
        
        <p><code>yield</code> is not just a pause point. It’s an expression that sends out a
        value when pausing the generator. Here’s a <code>while..true</code> loop in a
        generator that for each iteration <code>yield</code>s a new random number:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">while</code> <code class="p">(</code><code class="kc">true</code><code class="p">)</code> <code class="p">{</code>
                <code class="kd">yield </code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">();</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>The <code>yield ..</code> expression not only sends a value—<code>yield</code> without a
        value is the same as <code>yield undefined</code>—but also receives (i.e., is
        replaced by) the eventual resumption value. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="kd">yield </code><code class="mi">10</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>This generator will first <code>yield</code> out the value <code>10</code> when pausing
        itself. When you resume the generator—using the <code>it.next(..)</code> we
        referred to earlier—whatever value (if any) you resume with will
        replace/complete the whole <code>yield 10</code> expression, meaning that the value
        will be assigned to the <code>x</code> variable.</p>
        
        <p>A <code>yield ..</code> expression can appear anywhere a normal expression can. For
        example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">arr</code> <code class="o">=</code> <code class="p">[</code> <code class="kd">yield </code><code class="mi">1</code><code class="p">,</code> <code class="kd">yield </code><code class="mi">2</code><code class="p">,</code> <code class="kd">yield </code><code class="mi">3</code> <code class="p">];</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">arr</code><code class="p">,</code> <code class="kd">yield </code><code class="mi">4</code> <code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p><code>*foo()</code> here has four <code>yield ..</code> expressions. Each <code>yield</code> results in
        the generator pausing to wait for a resumption value that’s then used in
        the various expression contexts.</p>
        
        <p><code>yield</code> is not technically an operator, though when used like <code>yield 1</code>
        it sure looks like it. Because <code>yield</code> can be used all by itself as in
        <code>var x = yield;</code>, thinking of it as an operator can sometimes be
        confusing.</p>
        
        <p>Technically, <code>yield ..</code> is of the same “expression precedence”—similar conceptually to operator precedence—as an assignment
        expression like <code>a = 3</code>. That means <code>yield ..</code> can basically appear
        anywhere <code>a = 3</code> can validly appear.</p>
        
        <p>Let’s illustrate the symmetry:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">;</code>
        
        <code class="nx">a</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>                  <code class="c1">// valid</code>
        <code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">+</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>          <code class="c1">// invalid</code>
        <code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">+</code> <code class="p">(</code><code class="nx">a</code> <code class="o">=</code> <code class="mi">3</code><code class="p">);</code>        <code class="c1">// valid</code>
        
        <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>                <code class="c1">// valid</code>
        <code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">+</code> <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>        <code class="c1">// invalid</code>
        <code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code> <code class="o">+</code> <code class="p">(</code><code class="kd">yield </code><code class="mi">3</code><code class="p">);</code>      <code class="c1">// valid</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>If you think about it, it makes a sort of conceptual sense that
        a <code>yield ..</code> expression would behave similar to an assignment
        expression. When a paused <code>yield</code> expression is resumed, it’s
        completed/replaced by the resumption value in a way that’s not terribly
        dissimilar from being “assigned” that value.</p>
        </div>
        
        <p>The takeaway: if you need <code>yield ..</code> to appear in a position where an
        assignment like <code>a = 3</code> would not itself be allowed, it needs to be
        wrapped in a <code>( )</code>.</p>
        
        <p>Because of the low precedence of the <code>yield</code> keyword, almost any
        expression after a <code>yield ..</code> will be computed first before being sent
        with <code>yield</code>. Only the <code>...</code> spread operator and the <code>,</code> comma operator
        have lower precedence, meaning they’d bind after the <code>yield</code> has been
        evaluated.</p>
        
        <p>So just like with multiple operators in normal statements, another case
        where <code>( )</code> might be needed is to override (elevate) the low precedence
        of <code>yield</code>, such as the difference between these expressions:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">yield </code><code class="mi">2</code> <code class="o">+</code> <code class="mi">3</code><code class="p">;</code>            <code class="c1">// same as `yield (2 + 3)`</code>
        
        <code class="p">(</code><code class="kd">yield </code><code class="mi">2</code><code class="p">)</code> <code class="o">+</code> <code class="mi">3</code><code class="p">;</code>          <code class="c1">// `yield 2` first, then `+ 3`</code></pre>
        
        <p>Just like <code>=</code> assignment, <code>yield</code> is also “right-associative,” which
        means that multiple <code>yield</code> expressions in succession are treated as
        having been <code>( .. )</code> grouped from right to left. So,
        <code>yield yield yield 3</code> is treated as <code>yield (yield (yield 3))</code>. A
        “left-associative” interpretation like <code>((yield) yield) yield 3</code> would
        make no sense.</p>
        
        <p>Just like with operators, it’s a good idea to use <code>( .. )</code> grouping,
        even if not strictly required, to disambiguate your intent if <code>yield</code> is
        combined with other operators or <code>yield</code>s.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>See the <em>Types &amp; Grammar</em> title of this series for more
        information about operator precedence and associativity.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="yield *"><div class="sect3" id="idm45967366643400">
        <h3>yield *</h3>
        
        <p>In the same way that the <code>*</code> makes a <code>function</code> declaration into
        <code>function *</code> generator declaration, a <code>*</code> makes <code>yield</code> into <code>yield *</code>,
        which is a very different mechanism, called <em>yield delegation</em>.
        Grammatically, <code>yield *..</code> will behave the same as a <code>yield ..</code>, as
        discussed in the previous section.</p>
        
        <p><code>yield * ..</code> requires an iterable; it then invokes that iterable’s
        iterator, and delegates its own host generator’s control to that
        iterator until it’s exhausted. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">yield *</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        <code class="p">}</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>As with the <code>*</code> position in a generator’s declaration (discussed
        earlier), the <code>*</code> positioning in <code>yield *</code> expressions is stylistically
        up to you. Most other literature prefers <code>yield* ..</code>, but I prefer
        <code>yield *..</code>, for very symmetrical reasons as already discussed.</p>
        </div>
        
        <p>The <code>[1,2,3]</code> value produces an iterator that will step through its
        values, so the <code>*foo()</code> generator will yield those values out as it’s
        consumed. Another way to illustrate the behavior is in yield delegating
        to another generator:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">function *</code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">yield *</code><code class="nx">foo</code><code class="p">();</code>
        <code class="p">}</code></pre>
        
        <p>The iterator produced when <code>*bar()</code> calls <code>*foo()</code> is delegated to via
        <code>yield *</code>, meaning whatever value(s) <code>*foo()</code> produces will be produced
        by <code>*bar()</code>.</p>
        
        <p>Whereas with <code>yield ..</code> the completion value of the expression comes
        from resuming the generator with <code>it.next(..)</code>, the completion value of
        the <code>yield *..</code> expression comes from the return value (if any) from the
        delegated-to iterator.</p>
        
        <p>Built-in iterators generally don’t have return values, as we covered at
        the end of <a data-type="xref" href="#iteratorloop">“Iterator Loop”</a> earlier in this chapter. But if
        you define your own custom iterator (or generator), you can design it to
        <code>return</code> a value, which <code>yield *..</code> would capture:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>
            <code class="k">return</code> <code class="mi">4</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">function *</code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="kd">yield *</code><code class="nx">foo</code><code class="p">();</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"x:"</code><code class="p">,</code> <code class="nx">x</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">v</code> <code class="k">of</code> <code class="nx">bar</code><code class="p">())</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">v</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// 1 2 3</code>
        <code class="c1">// x: 4</code></pre>
        
        <p>While the <code>1</code>, <code>2</code>, and <code>3</code> values are <code>yield</code>ed out of <code>*foo()</code> and
        then out of <code>*bar()</code>, the <code>4</code> value returned from <code>*foo()</code> is the
        completion value of the <code>yield *foo()</code> expression, which then gets
        assigned to <code>x</code>.</p>
        
        <p>Because <code>yield *</code> can call another generator (by way of delegating to
        its iterator), it can also perform a sort of generator recursion by
        calling itself:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">x</code> <code class="o">=</code> <code class="kd">yield *</code><code class="nx">foo</code><code class="p">(</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code> <code class="p">);</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">1</code> <code class="p">);</code></pre>
        
        <p>The result from <code>foo(1)</code> and then calling the iterator’s <code>next()</code> to run
        it through its recursive steps will be <code>24</code>. The first <code>*foo(..)</code> run
        has <code>x</code> at value <code>1</code>, which is <code>x &lt; 3</code>. <code>x + 1</code> is passed recursively to
        <code>*foo(..)</code>, so <code>x</code> is then <code>2</code>. One more recursive call results in <code>x</code>
        of <code>3</code>.</p>
        
        <p class="pagebreak-before">Now, because <code>x &lt; 3</code> fails, the recursion stops, and <code>return 3 * 2</code>
        gives <code>6</code> back to the previous call’s <code>yield *..</code> expression, which is
        then assigned to <code>x</code>. Another <code>return 6 * 2</code> returns <code>12</code> back to the
        previous call’s <code>x</code>. Finally <code>12 * 2</code>, or <code>24</code>, is returned from the
        completed run of the <code>*foo(..)</code> generator.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Iterator Control"><div class="sect2" id="iteratorControl">
        <h2>Iterator Control</h2>
        
        <p>Earlier, we briefly introduced the concept that generators are
        controlled by iterators. Let’s fully dig into that now.</p>
        
        <p>Recall the recursive <code>*foo(..)</code> from the previous section. Here’s how
        we’d run it:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&lt;</code> <code class="mi">3</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">x</code> <code class="o">=</code> <code class="kd">yield *</code><code class="nx">foo</code><code class="p">(</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code> <code class="p">);</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">(</code> <code class="mi">1</code> <code class="p">);</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 24, done: true }</code></pre>
        
        <p>In this case, the generator doesn’t really ever pause, as there’s no
        <code>yield ..</code> expression. Instead, <code>yield *</code> just keeps the current
        iteration step going via the recursive call. So, just one call to the
        iterator’s <code>next()</code> function fully runs the generator.</p>
        
        <p>Now let’s consider a generator that will have multiple steps and thus
        multiple produced values:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>We already know we can consume an iterator, even one attached to a
        generator like <code>*foo()</code>, with a <code>for..of</code> loop:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">v</code> <code class="k">of</code> <code class="nx">foo</code><code class="p">())</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">v</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// 1 2 3</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>The <code>for..of</code> loop requires an iterable. A generator function
        reference (like <code>foo</code>) by itself is not an iterable; you must execute it
        with <code>foo()</code> to get the iterator (which is also an iterable, as we
        explained earlier in this chapter). You could theoretically extend the
        <code>GeneratorPrototype</code> (the prototype of all generator functions) with a
        <code>Symbol.iterator</code> function that essentially just does <code>return this()</code>.
        That would make the <code>foo</code> reference itself an iterable, which means
        <code>for (var v of foo) { .. }</code> (notice no <code>()</code> on <code>foo</code>) will work.</p>
        </div>
        
        <p>Let’s instead iterate the generator manually:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 1, done: false }</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 2, done: false }</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 3, done: false }</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: undefined, done: true }</code></pre>
        
        <p>If you look closely, there are three <code>yield</code> statements and four
        <code>next()</code> calls. That may seem like a strange mismatch. In fact, there
        will always be one more <code>next()</code> call than <code>yield</code> expression, assuming
        all are evaluated and the generator is fully run to completion.</p>
        
        <p>But if you look at it from the opposite perspective (inside-out instead
        of outside-in), the matching between <code>yield</code> and <code>next()</code> makes more
        sense.</p>
        
        <p>Recall that the <code>yield ..</code> expression will be completed by the value you
        resume the generator with. That means the argument you pass to
        <code>next(..)</code> completes whatever <code>yield ..</code> expression is currently paused
        waiting for a completion.</p>
        
        <p>Let’s illustrate this perspective this way:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="kd">var</code> <code class="nx">y</code> <code class="o">=</code> <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
            <code class="kd">var</code> <code class="nx">z</code> <code class="o">=</code> <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>In this snippet, each <code>yield ..</code> is sending a value out (<code>1</code>, <code>2</code>, <code>3</code>),
        but more directly, it’s pausing the generator to wait for a value. In
        other words, it’s almost like asking the question, “What value should I
        use here? I’ll wait to hear back.”</p>
        
        <p>Now, here’s how we control <code>*foo()</code> to start it up:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 1, done: false }</code></pre>
        
        <p>That first <code>next()</code> call is starting up the generator from its initial
        paused state, and running it to the first <code>yield</code>. At the moment you
        call that first <code>next()</code>, there’s no <code>yield ..</code> expression waiting for a
        completion. If you passed a value to that first <code>next()</code> call, it would
        currently just be thrown away, because no <code>yield</code> is waiting to receive
        such a value.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>An early proposal for the “beyond ES6” timeframe <em>would</em> let you
        access a value passed to an initial <code>next(..)</code> call via a separate meta
        property (see <a data-type="xref" href="ch07.html#chapter-7-meta-programming">Chapter&nbsp;7</a>) inside the generator.</p>
        </div>
        
        <p>Now, let’s answer the currently pending question, “What value should I
        assign to <code>x</code>?” We’ll answer it by sending a value to the <em>next</em>
        <code>next(..)</code> call:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="s2">"foo"</code> <code class="p">);</code>       <code class="c1">// { value: 2, done: false }</code></pre>
        
        <p>Now, the <code>x</code> will have the value <code>"foo"</code>, but we’ve also asked a new
        question, “What value should I assign to <code>y</code>?” And we answer:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="s2">"bar"</code> <code class="p">);</code>       <code class="c1">// { value: 3, done: false }</code></pre>
        
        <p>Answer given, another question asked. Final answer:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="s2">"baz"</code> <code class="p">);</code>       <code class="c1">// "foo" "bar" "baz"</code>
                                <code class="c1">// { value: undefined, done: true }</code></pre>
        
        <p>Now it should be clearer how each <code>yield ..</code> “question” is answered by
        the <em>next</em> <code>next(..)</code> call, and so the “extra” <code>next()</code> call we observed
        is always just the initial one that starts everything going.</p>
        
        <p>Let’s put all those steps together:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        
        <code class="c1">// start up the generator</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 1, done: false }</code>
        
        <code class="c1">// answer first question</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="s2">"foo"</code> <code class="p">);</code>       <code class="c1">// { value: 2, done: false }</code>
        
        <code class="c1">// answer second question</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="s2">"bar"</code> <code class="p">);</code>       <code class="c1">// { value: 3, done: false }</code>
        
        <code class="c1">// answer third question</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="s2">"baz"</code> <code class="p">);</code>       <code class="c1">// "foo" "bar" "baz"</code>
                                <code class="c1">// { value: undefined, done: true }</code></pre>
        
        <p>You can think of a generator as a producer of values, in which case each
        iteration is simply producing a value to be consumed.</p>
        
        <p>But in a more general sense, perhaps it’s appropriate to think of
        generators as controlled, progressive code execution, much like the
        <code>tasks</code> queue example from the earlier section <a data-type="xref" href="#customiterSect">“Custom Iterators”</a>.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>That perspective is exactly the motivation for how we’ll revisit
        generators in <a data-type="xref" href="ch04.html#chapter-4-async-flow-control">Chapter&nbsp;4</a>. Specifically, there’s no reason that <code>next(..)</code>
        has to be called right away after the previous <code>next(..)</code> finishes.
        While the generator’s inner execution context is paused, the rest of the
        program continues unblocked, including the ability for asynchronous
        actions to control when the generator is resumed.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Early Completion"><div class="sect2" id="idm45967366002808">
        <h2>Early Completion</h2>
        
        <p>As we covered earlier in this chapter, the iterator attached to a
        generator supports the optional <code>return(..)</code> and <code>throw(..)</code> methods.
        Both of them have the effect of aborting a paused generator immediately.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 1, done: false }</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">return</code><code class="p">(</code> <code class="mi">42</code> <code class="p">);</code>        <code class="c1">// { value: 42, done: true }</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: undefined, done: true }</code></pre>
        
        <p><code>return(x)</code> is kind of like forcing a <code>return x</code> to be processed at
        exactly that moment, such that you get the specified value right back.
        Once a generator is completed, either normally or early as shown, it no
        longer processes any code or returns any values.</p>
        
        <p>In addition to <code>return(..)</code> being callable manually, it’s also called
        automatically at the end of iteration by any of the ES6 constructs that
        consume iterators, such as the <code>for..of</code> loop and the <code>...</code> spread
        operator.</p>
        
        <p>The purpose of this capability is to notify the generator if
        the controlling code is no longer going to iterate over it anymore, so
        that it can perhaps do any cleanup tasks (freeing up resources,
        resetting status, etc.). Identical to a normal function cleanup pattern,
        the main way to accomplish this is to use a <code>finally</code> clause:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">try</code> <code class="p">{</code>
                <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
                <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
                <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>
            <code class="p">}</code>
            <code class="k">finally</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"cleanup!"</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">v</code> <code class="k">of</code> <code class="nx">foo</code><code class="p">())</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">v</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// 1 2 3</code>
        <code class="c1">// cleanup!</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 1, done: false }</code>
        <code class="nx">it</code><code class="p">.</code><code class="nx">return</code><code class="p">(</code> <code class="mi">42</code> <code class="p">);</code>        <code class="c1">// cleanup!</code>
                                <code class="c1">// { value: 42, done: true }</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Do not put a <code>yield</code> statement inside the <code>finally</code> clause!
        It’s valid and legal, but it’s a really terrible idea. It acts in a
        sense as deferring the completion of the <code>return(..)</code> call you made, as
        any <code>yield ..</code> expressions in the <code>finally</code> clause are respected to
        pause and send messages; you don’t immediately get a completed generator
        as expected. There’s basically no good reason to opt in to that crazy
        <em>bad part</em>, so avoid doing so!</p>
        </div>
        
        <p>In addition to the previous snippet showing how <code>return(..)</code> aborts the
        generator while still triggering the <code>finally</code> clause, it also
        demonstrates that a generator produces a whole new iterator each time
        it’s called. In fact, you can use multiple iterators attached to the
        same generator concurrently:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">it1</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        <code class="nx">it1</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>             <code class="c1">// { value: 1, done: false }</code>
        <code class="nx">it1</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>             <code class="c1">// { value: 2, done: false }</code>
        
        <code class="kd">var</code> <code class="nx">it2</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        <code class="nx">it2</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>             <code class="c1">// { value: 1, done: false }</code>
        
        <code class="nx">it1</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>             <code class="c1">// { value: 3, done: false }</code>
        
        <code class="nx">it2</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>             <code class="c1">// { value: 2, done: false }</code>
        <code class="nx">it2</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>             <code class="c1">// { value: 3, done: false }</code>
        
        <code class="nx">it2</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>             <code class="c1">// { value: undefined, done: true }</code>
        <code class="nx">it1</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>             <code class="c1">// { value: undefined, done: true }</code></pre>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Early Abort"><div class="sect3" id="idm45967365331656">
        <h3>Early Abort</h3>
        
        <p>Instead of calling <code>return(..)</code>, you can call <code>throw(..)</code>. Just like
        <code>return(x)</code> is essentially injecting a <code>return x</code> into the generator at
        its current pause point, calling <code>throw(x)</code> is essentially like
        injecting a <code>throw x</code> at the pause point.</p>
        
        <p>Other than the exception behavior (we cover what that means to <code>try</code>
        clauses in the next section), <code>throw(..)</code> produces the same sort of
        early completion that aborts the generator’s run at its current pause
        point. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
            <code class="kd">yield </code><code class="mi">3</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 1, done: false }</code>
        
        <code class="k">try</code> <code class="p">{</code>
            <code class="nx">it</code><code class="p">.</code><code class="nx">throw</code><code class="p">(</code> <code class="s2">"Oops!"</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">err</code> <code class="p">);</code> <code class="c1">// Exception: Oops!</code>
        <code class="p">}</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: undefined, done: true }</code></pre>
        
        <p>Because <code>throw(..)</code> basically injects a <code>throw ..</code> in replacement of the
        <code>yield 1</code> line of the generator, and nothing handles this exception, it
        immediately propagates back out to the calling code, which handles it
        with a <code>try..catch</code>.</p>
        
        <p>Unlike <code>return(..)</code>, the iterator’s <code>throw(..)</code> method is never called
        automatically.</p>
        
        <p>Of course, though not shown in the previous snippet, if a <code>try..finally</code>
        clause was waiting inside the generator when you call <code>throw(..)</code>, the
        <code>finally</code> clause would be given a chance to complete before the
        exception is propagated back to the calling code.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Error Handling"><div class="sect2" id="idm45967365511704">
        <h2>Error Handling</h2>
        
        <p>As we’ve already hinted, error handling with generators can be expressed
        with <code>try..catch</code>, which works in both inbound and outbound directions:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">try</code> <code class="p">{</code>
                <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="p">}</code>
            <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">err</code> <code class="p">);</code>
            <code class="p">}</code>
        
            <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
        
            <code class="k">throw</code> <code class="s2">"Hello!"</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 1, done: false }</code>
        
        <code class="k">try</code> <code class="p">{</code>
            <code class="nx">it</code><code class="p">.</code><code class="nx">throw</code><code class="p">(</code> <code class="s2">"Hi!"</code> <code class="p">);</code>  <code class="c1">// Hi!</code>
                                <code class="c1">// { value: 2, done: false }</code>
            <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>
        
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"never gets here"</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">err</code> <code class="p">);</code> <code class="c1">// Hello!</code>
        <code class="p">}</code></pre>
        
        <p>Errors can also propagate in both directions through <code>yield *</code>
        delegation:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">try</code> <code class="p">{</code>
                <code class="kd">yield </code><code class="mi">1</code><code class="p">;</code>
            <code class="p">}</code>
            <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">err</code> <code class="p">);</code>
            <code class="p">}</code>
        
            <code class="kd">yield </code><code class="mi">2</code><code class="p">;</code>
        
            <code class="k">throw</code> <code class="s2">"foo: e2"</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">function *</code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">try</code> <code class="p">{</code>
                <code class="kd">yield *</code><code class="nx">foo</code><code class="p">();</code>
        
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"never gets here"</code> <code class="p">);</code>
            <code class="p">}</code>
            <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">err</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">();</code>
        
        <code class="k">try</code> <code class="p">{</code>
            <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>          <code class="c1">// { value: 1, done: false }</code>
        
            <code class="nx">it</code><code class="p">.</code><code class="nx">throw</code><code class="p">(</code> <code class="s2">"e1"</code> <code class="p">);</code>   <code class="c1">// e1</code>
                                <code class="c1">// { value: 2, done: false }</code>
        
            <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>          <code class="c1">// foo: e2</code>
                                <code class="c1">// { value: undefined, done: true }</code>
        <code class="p">}</code>
        <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"never gets here"</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: undefined, done: true }</code></pre>
        
        <p>When <code>*foo()</code> calls <code>yield 1</code>, the <code>1</code> value passes through <code>*bar()</code>
        untouched, as we’ve already seen.</p>
        
        <p>But what’s most interesting about this snippet is that when <code>*foo()</code>
        calls <code>throw "foo: e2"</code>, this error propagates to <code>*bar()</code> and is
        immediately caught by <code>*bar()</code>’s <code>try..catch</code> block. The error doesn’t
        pass through <code>*bar()</code> like the <code>1</code> value did.</p>
        
        <p><code>*bar()</code>’s <code>catch</code> then does a normal output of <code>err</code> (<code>"foo: e2"</code>) and
        then <code>*bar()</code> finishes normally, which is why the
        <code>{ value: undefined, done: true }</code> iterator result comes back from
        <code>it.next()</code>.</p>
        
        <p>If <code>*bar()</code> didn’t have a <code>try..catch</code> around the <code>yield *..</code>
        expression, the error would of course propagate all the way out, and on
        the way through it still would complete (abort) <code>*bar()</code>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Transpiling a Generator"><div class="sect2" id="idm45967364876504">
        <h2>Transpiling a Generator</h2>
        
        <p>Is it possible to represent a generator’s capabilities prior to ES6? It
        turns out it is, and there are several great tools that do so, including
        most notably <a href="https://facebook.github.io/regenerator/">Facebook’s Regenerator tool</a>.</p>
        
        <p>But just to better understand generators, let’s try our hand at manually
        converting. Basically, we’re going to create a simple closure-based
        state machine.</p>
        
        <p>We’ll keep our source generator really simple:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="kd">yield </code><code class="mi">42</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>To start, we’ll need a function called <code>foo()</code> that we can execute,
        which needs to return an iterator:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        
            <code class="k">return</code> <code class="p">{</code>
                <code class="nx">next</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// ..</code>
                <code class="p">}</code>
        
                <code class="c1">// we'll skip `return(..)` and `throw(..)`</code>
            <code class="p">};</code>
        <code class="p">}</code></pre>
        
        <p>Now, we need some inner variable to keep track of where we are in the
        steps of our “generator"’s logic. We’ll call it <code>state</code>. There will be
        three states: <code>0</code> initially, <code>1</code> while waiting to fulfill the <code>yield</code>
        expression, and <code>2</code> once the generator is complete.</p>
        
        <p>Each time <code>next(..)</code> is called, we need to process the next step, and
        then increment <code>state</code>. For convenience, we’ll put each step into a
        <code>case</code> clause of a <code>switch</code> statement, and we’ll hold that in an inner
        function called <code>nextState(..)</code> that <code>next(..)</code> can call. Also, because
        <code>x</code> is a variable across the overall scope of the “generator,” it needs
        to live outside the <code>nextState(..)</code> function.</p>
        
        <p>Here it is all together (obviously somewhat simplified, to keep the
        conceptual illustration clearer):</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">function </code><code class="nx">nextState</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">switch</code> <code class="p">(</code><code class="nx">state</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">case</code> <code class="mi">0</code><code class="o">:</code>
                        <code class="nx">state</code><code class="o">++</code><code class="p">;</code>
        
                        <code class="c1">// the `yield` expression</code>
                        <code class="k">return</code> <code class="mi">42</code><code class="p">;</code>
                    <code class="k">case</code> <code class="mi">1</code><code class="o">:</code>
                        <code class="nx">state</code><code class="o">++</code><code class="p">;</code>
        
                        <code class="c1">// `yield` expression fulfilled</code>
                        <code class="nx">x</code> <code class="o">=</code> <code class="nx">v</code><code class="p">;</code>
                        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="p">);</code>
        
                        <code class="c1">// the implicit `return`</code>
                        <code class="k">return</code> <code class="kc">undefined</code><code class="p">;</code>
        
                    <code class="c1">// no need to handle state `2`</code>
                <code class="p">}</code>
            <code class="p">}</code>
        
            <code class="kd">var</code> <code class="nx">state</code> <code class="o">=</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">x</code><code class="p">;</code>
        
            <code class="k">return</code> <code class="p">{</code>
                <code class="nx">next</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code> <code class="p">{</code>
                    <code class="kd">var</code> <code class="nx">ret</code> <code class="o">=</code> <code class="nx">nextState</code><code class="p">(</code> <code class="nx">v</code> <code class="p">);</code>
        
                    <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">ret</code><code class="p">,</code> <code class="nx">done</code><code class="o">:</code> <code class="p">(</code><code class="nx">state</code> <code class="o">==</code> <code class="mi">2</code><code class="p">)</code> <code class="p">};</code>
                <code class="p">}</code>
        
                <code class="c1">// we'll skip `return(..)` and `throw(..)`</code>
            <code class="p">};</code>
        <code class="p">}</code></pre>
        
        <p>And finally, let’s test our pre-ES6 “generator”:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">();</code>              <code class="c1">// { value: 42, done: false }</code>
        
        <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="mi">10</code> <code class="p">);</code>          <code class="c1">// 10</code>
                                <code class="c1">// { value: undefined, done: true }</code></pre>
        
        <p>Not bad, huh? Hopefully this exercise solidifies in your mind that
        generators are actually just simple syntax for state machine logic. That
        makes them widely applicable.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Generator Uses"><div class="sect2" id="idm45967364875848">
        <h2>Generator Uses</h2>
        
        <p>So, now that we much more deeply understand how generators work, what
        are they useful for?</p>
        
        <p>We’ve seen two major patterns:</p>
        <dl>
        <dt><em>Producing a series of values</em></dt>
        <dd>
        <p>This usage can be simple (e.g., random
        strings or incremented numbers), or it can represent more structured
        data access (e.g., iterating over rows returned from a database query).</p>
        
        <p>Either way, we use the iterator to control a generator so that some
        logic can be invoked for each call to <code>next(..)</code>. Normal iterators on
        data structures merely pull values without any controlling logic.</p>
        </dd>
        <dt><em>Queue of tasks to perform serially</em></dt>
        <dd>
        <p>This usage often represents flow
        control for the steps in an algorithm, where each step requires
        retrieval of data from some external source. The fulfillment of each
        piece of data may be immediate, or may be asynchronously delayed.</p>
        
        <p>From the perspective of the code inside the generator, the details of
        sync or async at a <code>yield</code> point are entirely opaque. Moreover, these
        details are intentionally abstracted away, such as not to obscure the
        natural sequential expression of steps with such implementation
        complications. Abstraction also means the implementations can be
        swapped/refactored often without touching the code in the generator at
        all.</p>
        </dd>
        </dl>
        
        <p>When generators are viewed in light of these uses, they become a lot
        more than just a different or nicer syntax for a manual state machine.
        They are a powerful abstraction tool for organizing and controlling
        orderly production and consumption of data.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Modules"><div class="sect1" id="modulessect">
        <h1>Modules</h1>
        
        <p>I don’t think it’s an exaggeration to suggest that the single most
        important code organization pattern in all of JavaScript is, and always
        has been, the module. For myself, and I think for a large cross-section
        of the community, the module pattern drives the vast majority of code.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="The Old Way"><div class="sect2" id="idm45967364537576">
        <h2>The Old Way</h2>
        
        <p>The traditional module pattern is based on an outer function with inner
        variables and functions, and a returned “public API” with methods that
        have closure over the inner data and capabilities. It’s often expressed
        like this:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">Hello</code><code class="p">(</code><code class="nx">name</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">function </code><code class="nx">greeting</code><code class="p">()</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"Hello "</code> <code class="o">+</code> <code class="nx">name</code> <code class="o">+</code> <code class="s2">"!"</code> <code class="p">);</code>
            <code class="p">}</code>
        
            <code class="c1">// public API</code>
            <code class="k">return</code> <code class="p">{</code>
                <code class="nx">greeting</code><code class="o">:</code> <code class="nx">greeting</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">me</code> <code class="o">=</code> <code class="nx">Hello</code><code class="p">(</code> <code class="s2">"Kyle"</code> <code class="p">);</code>
        <code class="nx">me</code><code class="p">.</code><code class="nx">greeting</code><code class="p">();</code>          <code class="c1">// Hello Kyle!</code></pre>
        
        <p>This <code>Hello(..)</code> module can produce multiple instances by being called
        subsequent times. Sometimes, a module is only called for as a singleton
        (i.e., it just needs one instance), in which case a slight variation on
        the previous snippet, using an IIFE, is common:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">me</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function </code><code class="nx">Hello</code><code class="p">(</code><code class="nx">name</code><code class="p">){</code>
            <code class="kd">function </code><code class="nx">greeting</code><code class="p">()</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"Hello "</code> <code class="o">+</code> <code class="nx">name</code> <code class="o">+</code> <code class="s2">"!"</code> <code class="p">);</code>
            <code class="p">}</code>
        
            <code class="c1">// public API</code>
            <code class="k">return</code> <code class="p">{</code>
                <code class="nx">greeting</code><code class="o">:</code> <code class="nx">greeting</code>
            <code class="p">};</code>
        <code class="p">})(</code> <code class="s2">"Kyle"</code> <code class="p">);</code>
        
        <code class="nx">me</code><code class="p">.</code><code class="nx">greeting</code><code class="p">();</code>          <code class="c1">// Hello Kyle!</code></pre>
        
        <p>This pattern is tried and tested. It’s also flexible enough to have a
        wide assortment of variations for a number of different scenarios.</p>
        
        <p>One of the most common is the Asynchronous Module Definition (AMD), and
        another is the Universal Module Definition (UMD). We won’t cover the
        particulars of these patterns and techniques here, but they’re explained
        extensively in many places online.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Moving Forward"><div class="sect2" id="idm45967364400008">
        <h2>Moving Forward</h2>
        
        <p>As of ES6, we no longer need to rely on the enclosing function and
        closure to provide us with module support. ES6 modules have first class
        syntactic and functional support.</p>
        
        <p>Before we get into the specific syntax, it’s important to understand
        some fairly significant conceptual differences with ES6 modules compared
        to how you may have dealt with modules in the past:</p>
        
        <ul>
        <li>
        <p>ES6 uses file-based modules, meaning one module per file. At this
        time, there is no standardized way of combining multiple modules into a
        single file.</p>
        
        <p>That means that if you are going to load ES6 modules directly into a
        browser web application, you will be loading them individually, not as a
        large bundle in a single file as has been common in performance
        optimization efforts.</p>
        
        <p>It’s expected that the contemporaneous advent of HTTP/2 will
        significantly mitigate any such performance concerns, as it operates on
        a persistent socket connection and thus can very efficiently load many
        smaller files in parallel and interleaved with one another.</p>
        </li>
        <li>
        <p>The API of an ES6 module is static. That is, you define statically what all the
        top-level exports are on your module’s public API, and those cannot be
        amended later.</p>
        
        <p>Some uses are accustomed to being able to provide dynamic API
        definitions, where methods can be added/removed/replaced in response to
        runtime conditions. Either these uses will have to change to fit with
        ES6 static APIs, or they will have to restrain the dynamic changes to
        properties/methods of a second-level object.</p>
        </li>
        <li>
        <p>ES6 modules are singletons. That is, there’s only one instance of the module, which
        maintains its state. Every time you import that module into another
        module, you get a reference to the one centralized instance. If you want
        to be able to produce multiple module instances, your module will need
        to provide some sort of factory to do it.</p>
        </li>
        <li>
        <p>The properties and methods you expose on a module’s public API are not
        just normal assignments of values or references. They are actual bindings
        (almost like pointers) to the identifiers in your inner module definition.</p>
        
        <p>In pre-ES6 modules, if you put a property on your public API that holds
        a primitive value like a number or string, that property assignment was
        by value-copy, and any internal update of a corresponding variable would
        be separate and not affect the public copy on the API object.</p>
        
        <p>With ES6, exporting a local private variable, even if it currently holds
        a primitive string/number/etc., exports a binding to the variable. If the
        module changes the variable’s value, the external import binding now
        resolves to that new value.</p>
        </li>
        <li>
        <p>Importing a module is the same thing as statically requesting it to load
        (if it hasn’t already). If you’re in a browser, that implies a blocking load
        over the network. If you’re on a server (i.e., Node.js), it’s a blocking load
        from the filesystem.</p>
        
        <p>However, don’t panic about the performance implications. Because ES6
        modules have static definitions, the import requirements can be
        statically scanned, and loads will happen preemptively, even before
        you’ve used the module.</p>
        
        <p>ES6 doesn’t actually specify or handle the mechanics of how these load
        requests work. There’s a separate notion of a Module Loader, where each
        hosting environment (browser, Node.js, etc.) provides a default Loader
        appropriate to the environment. The importing of a module uses a string
        value to represent where to get the module (URL, file path, etc.), but
        this value is opaque in your program and only meaningful to the Loader
        itself.</p>
        
        <p>You can define your own custom Loader if you want more fine-grained
        control than the default Loader affords—which is basically none, as
        it’s totally hidden from your program’s code.</p>
        </li>
        </ul>
        
        <p>As you can see, ES6 modules will serve the overall use case of
        organizing code with encapsulation, controlling public APIs, and
        referencing dependency imports. But they have a very particular way of
        doing so, and that may or may not fit very closely with how you’ve
        already been doing modules for years.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="CommonJS"><div class="sect3" id="idm45967364385320">
        <h3>CommonJS</h3>
        
        <p>There’s a similar, but not fully compatible, module syntax called
        CommonJS, which is familiar to those in the Node.js ecosystem.</p>
        
        <p>For lack of a more tactful way to say this, in the long run, ES6 modules
        essentially are bound to supercede all previous formats and standards
        for modules, even CommonJS, as they are built on syntactic support in
        the language. This will, in time, inevitably win out as the superior
        approach, if for no other reason than ubiquity.</p>
        
        <p>We face a fairly long road to get to that point, though. There are
        literally hundreds of thousands of CommonJS style modules in the
        server-side JavaScript world, and 10 times that many modules of varying
        format standards (UMD, AMD, ad hoc) in the browser world. It will take
        many years for the transitions to make any significant progress.</p>
        
        <p>In the interim, module transpilers/converters will be an absolute
        necessity. You might as well just get used to that new reality. Whether
        you author in regular modules, AMD, UMD, CommonJS, or ES6, these tools
        will have to parse and convert to a format that is suitable for whatever
        environment your code will run in.</p>
        
        <p>For Node.js, that probably means (for now) that the target is CommonJS.
        For the browser, it’s probably UMD or AMD. Expect lots of flux on this
        over the next few years as these tools mature and best practices emerge.</p>
        
        <p>From here on out, my best advice on modules is this: whatever format
        you’ve been religiously attached to with strong affinity, also develop
        an appreciation for and understanding of ES6 modules, such as they are,
        and let your other module tendencies fade. They <em>are</em> the future of
        modules in JS, even if that reality is a bit of a ways off.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="The New Way"><div class="sect2" id="idm45967364379432">
        <h2>The New Way</h2>
        
        <p>The two main new keywords that enable ES6 modules are <code>import</code> and
        <code>export</code>. There’s lots of nuance to the
        syntax, so let’s take a deeper look.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>An important detail that’s easy to overlook: both <code>import</code>
        and <code>export</code> must always appear in the top-level scope of their
        respective usage. For example, you cannot put either an <code>import</code> or
        <code>export</code> inside an <code>if</code> conditional; they must appear outside of all
        blocks and functions.</p>
        </div>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Exporting API Members"><div class="sect3" id="exportingAPImembers">
        <h3>Exporting API Members</h3>
        
        <p>The <code>export</code> keyword is either put in front of a declaration, or used as
        an operator (of sorts) with a special list of bindings to export.
        Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">export</code> <code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code>
        
        <code class="k">export</code> <code class="kd">var</code> <code class="nx">awesome</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">bar</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        <code class="k">export</code> <code class="p">{</code> <code class="nx">bar</code> <code class="p">};</code></pre>
        
        <p>Another way of expressing the same exports:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">awesome</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">bar</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        
        <code class="k">export</code> <code class="p">{</code> <code class="nx">foo,</code> <code class="nx">awesome,</code> <code class="nx">bar</code> <code class="p">};</code></pre>
        
        <p>These are all called <em>named exports</em>, as you are in effect exporting the
        name bindings of the variables/functions/etc.</p>
        
        <p>Anything you don’t <em>label</em> with <code>export</code> stays private inside the scope
        of the module. That is, although something like <code>var bar = ..</code> looks
        like it’s declaring at the top-level global scope, the top-level scope
        is actually the module itself; there is no global scope in modules.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>Modules <em>do</em> still have access to <code>window</code> and all the “globals”
        that hang off it, just not as lexical top-level scope. However, you
        really should stay away from the globals in your modules if at all
        possible.</p>
        </div>
        
        <p>You can also “rename” (aka alias) a module member during named export:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        
        <code class="k">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="k">as</code> <code class="nx">bar</code> <code class="p">};</code></pre>
        
        <p>When this module is imported, only the <code>bar</code> member name is available to
        import; <code>foo</code> stays hidden inside the module.</p>
        
        <p>Module exports are not just normal assignments of values or references,
        as you’re accustomed to with the <code>=</code> assignment operator. Actually, when
        you export something, you’re exporting a binding (kinda like a pointer)
        to that thing (variable, etc.).</p>
        
        <p>Within your module, if you change the value of a variable you already
        exported a binding to, even if it’s already been imported (see the next
        section), the imported binding will resolve to the current (updated)
        value.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">awesome</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
        <code class="k">export</code> <code class="p">{</code> <code class="nx">awesome</code> <code class="p">};</code>
        
        <code class="c1">// later</code>
        <code class="nx">awesome</code> <code class="o">=</code> <code class="mi">100</code><code class="p">;</code></pre>
        
        <p>When this module is imported, regardless of whether that’s before or
        after the <code>awesome = 100</code> setting, once that assignment has happened,
        the imported binding resolves to the <code>100</code> value, not <code>42</code>.</p>
        
        <p>That’s because the binding is, in essence, a reference to, or a pointer
        to, the <code>awesome</code> variable itself, rather than a copy of its value. This
        is a mostly unprecedented concept for JS introduced with ES6 module
        bindings.</p>
        
        <p>Though you can clearly use <code>export</code> multiple times inside a module’s
        definition, ES6 definitely prefers the approach that a module has a
        single export, which is known as a <em>default export</em>. In the words of
        some members of the TC39 committee, you’re “rewarded with simpler
        <code>import</code> syntax” if you follow that pattern, and conversely “penalized”
        with more verbose syntax if you don’t.</p>
        
        <p>A default export sets a particular exported binding to be the default
        when importing the module. The name of the binding is literally
        <code>default</code>. As you’ll see later, when importing module bindings you can
        also rename them, as you commonly will with a default export.</p>
        
        <p>There can only be one <code>default</code> per module definition. We’ll cover
        <code>import</code> in the next section, and you’ll see how the <code>import</code> syntax is
        more concise if the module has a default export.</p>
        
        <p>There’s a subtle nuance to default export syntax that you should pay
        close attention to. Compare these two snippets:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(..)</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code>
        
        <code class="k">export</code> <code class="k">default</code> <code class="nx">foo</code><code class="p">;</code></pre>
        
        <p>And this one:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(..)</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code>
        
        <code class="k">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="k">as</code> <code class="k">default</code> <code class="p">};</code></pre>
        
        <p>In the first snippet, you are exporting a binding to the function
        expression value at that moment, <em>not</em> to the identifier <code>foo</code>. In other
        words, <code>export default ..</code> takes an expression. If you later assign
        <code>foo</code> to a different value inside your module, the module import still
        reveals the function originally exported, not the new value.</p>
        
        <p class="pagebreak-before">By the way, the first snippet could also have been written as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">export</code> <code class="k">default</code> <code class="kd">function </code><code class="nx">foo</code><code class="p">(..)</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Although the <code>function foo..</code> part here is technically a
        function expression, for the purposes of the internal scope of the
        module, it’s treated like a function declaration, in that the <code>foo</code> name
        is bound in the module’s top-level scope (often called “hoisting”). The
        same is true for <code>export default class Foo..</code>. However, while you <em>can</em>
        do <code>export var foo = ..</code>, you currently cannot do
        <code>export default var foo = ..</code> (or <code>let</code> or <code>const</code>), in a frustrating
        case of inconsistency. At the time of this writing, there’s already
        discussion of adding that capability in soon, post-ES6, for consistency’s
        sake.</p>
        </div>
        
        <p>Recall the second snippet again:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(..)</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code>
        
        <code class="k">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="k">as</code> <code class="k">default</code> <code class="p">};</code></pre>
        
        <p>In this version of the module export, the default export binding is
        actually to the <code>foo</code> identifier rather than its value, so you get the
        previously described binding behavior (i.e., if you later change <code>foo</code>’s
        value, the value seen on the import side will also be updated).</p>
        
        <p>Be very careful of this subtle gotcha in default export syntax,
        especially if your logic calls for export values to be updated. If you
        never plan to update a default export’s value, <code>export default ..</code> is
        fine. If you do plan to update the value, you must use
        <code>export { .. as default }</code>. Either way, make sure to comment your code
        to explain your intent!</p>
        
        <p>Because there can only be one <code>default</code> per module, you may be tempted
        to design your module with one default export of an object with all your
        API methods on it, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6" class="pagebreak-before"><code class="k">export</code> <code class="k">default</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">},</code>
            <code class="nx">bar</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">},</code>
            <code class="p">..</code>
        <code class="p">};</code></pre>
        
        <p>That pattern seems to map closely to how a lot of developers have
        already structured their pre-ES6 modules, so it seems like a natural
        approach. Unfortunately, it has some downsides and is officially
        discouraged.</p>
        
        <p>In particular, the JS engine cannot statically analyze the contents of a
        plain object, which means it cannot do some optimizations for static
        <code>import</code> performance. The advantage of having each member individually
        and explicitly exported is that the engine <em>can</em> do the static analysis
        and optimization.</p>
        
        <p>If your API has more than one member already, it seems like these
        principles—one default export per module, and all API members as
        named exports—are in conflict, doesn’t it? But you <em>can</em> have a
        single default export as well as other named exports; they are not
        mutually exclusive.</p>
        
        <p>So, instead of this (discouraged) pattern:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">export</code> <code class="k">default</code> <code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">.</code><code class="nx">bar</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">};</code>
        <code class="nx">foo</code><code class="p">.</code><code class="nx">baz</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">};</code></pre>
        
        <p>You can do:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">export</code> <code class="k">default</code> <code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        
        <code class="k">export</code> <code class="kd">function </code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="k">export</code> <code class="kd">function </code><code class="nx">baz</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>In this previous snippet, I used the name <code>foo</code> for the function
        that <code>default</code> labels. That <code>foo</code> name, however, is ignored for the
        purposes of export—<code>default</code> is actually the exported name. When you
        import this default binding, you can give it whatever name you want, as
        you’ll see in the next section.</p>
        </div>
        
        <p>Alternatively, some will prefer:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="kd">function </code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="kd">function </code><code class="nx">baz</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        
        <code class="k">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="k">as</code> <code class="k">default</code><code class="nx">,</code> <code class="nx">bar,</code> <code class="nx">baz,</code> <code class="nx">..</code> <code class="p">};</code></pre>
        
        <p>The effects of mixing default and named exports will be more clear when
        we cover <code>import</code> shortly. But essentially it means that the most
        concise default import form would only retrieve the <code>foo()</code> function.
        The user could additionally manually list <code>bar</code> and <code>baz</code> as named
        imports, if they want them.</p>
        
        <p>You can probably imagine how tedious that’s going to be for consumers of
        your module if you have lots of named export bindings. There is a
        wildcard import form where you import all of a module’s exports within a
        single namespace object, but there’s no way to wildcard import to
        top-level bindings.</p>
        
        <p>Again, the ES6 module mechanism is intentionally designed to discourage
        modules with lots of exports; relatively speaking, it’s desired that
        such approaches be a little more difficult, as a sort of social
        engineering to encourage simple module design in favor of large/complex
        module design.</p>
        
        <p>I would probably recommend that you avoid mixing default export with named
        exports, especially if you have a large API and refactoring to separate
        modules isn’t practical or desired. In that case, just use all named
        exports, and document that consumers of your module should probably use
        the <code>import * as ..</code> (namespace import, discussed in the next section)
        approach to bring the whole API in at once on a single namespace.</p>
        
        <p>We mentioned this earlier, but let’s come back to it in more detail.
        Other than the <code>export default ...</code> form that exports an expression
        value binding, all other export forms are exporting bindings to local
        identifiers. For those bindings, if you change the value of a variable
        inside a module after exporting, the external imported binding will
        access the updated value:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">foo</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
        <code class="k">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="k">as</code> <code class="k">default</code> <code class="p">};</code>
        
        <code class="k">export</code> <code class="kd">var</code> <code class="nx">bar</code> <code class="o">=</code> <code class="s2">"hello world"</code><code class="p">;</code>
        
        <code class="nx">foo</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>
        <code class="nx">bar</code> <code class="o">=</code> <code class="s2">"cool"</code><code class="p">;</code></pre>
        
        <p>When you import this module, the <code>default</code> and <code>bar</code> exports will be
        bound to the local variables <code>foo</code> and <code>bar</code>, meaning they will reveal
        the updated <code>10</code> and <code>"cool"</code> values. The values at time of export are
        irrelevant. The values at time of import are irrelevant. The bindings
        are live links, so all that matters is what the current value is when
        you access the binding.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Two-way bindings are not allowed. If you import a <code>foo</code> from
        a module, and try to change the value of your imported <code>foo</code> variable,
        an error will be thrown! We’ll revisit that in the next <span class="keep-together">section</span>.</p>
        </div>
        
        <p>You can also re-export another module’s exports, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">export</code> <code class="p">{</code> <code class="nx">foo,</code> <code class="nx">bar</code> <code class="p">}</code> <code class="k">from</code> <code class="s2">"baz"</code><code class="p">;</code>
        <code class="k">export</code> <code class="p">{</code> <code class="nx">foo</code> <code class="k">as</code> <code class="nx">FOO,</code> <code class="nx">bar</code> <code class="k">as</code> <code class="nx">BAR</code> <code class="p">}</code> <code class="k">from</code> <code class="s2">"baz"</code><code class="p">;</code>
        <code class="k">export</code> <code class="nx">*</code> <code class="k">from</code> <code class="s2">"baz"</code><code class="p">;</code></pre>
        
        <p>Those forms are similar to just first importing from the <code>"baz"</code> module
        then listing its members explicitly for export from your module.
        However, in these forms, the members of the <code>"baz"</code> module are never
        imported to your module’s local scope; they sort of pass through
        untouched.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Importing API Members"><div class="sect3" id="idm45967364371912">
        <h3>Importing API Members</h3>
        
        <p>To import a module, unsurprisingly you use the <code>import</code> statement. Just
        as <code>export</code> has several nuanced variations, so does <code>import</code>, so spend
        plenty of time considering the following issues and experimenting with
        your options.</p>
        
        <p>If you want to import certain specific named members of a module’s API
        into your top-level scope, you use this syntax:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="p">{</code> <code class="nx">foo</code><code class="p">,</code> <code class="nx">bar</code><code class="p">,</code> <code class="nx">baz</code> <code class="p">}</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>The <code>{ .. }</code> syntax here may look like an object literal, or
        even an object destructuring syntax. However, its form is special just
        for modules, so be careful not to confuse it with other <code>{ .. }</code>
        patterns elsewhere.</p>
        </div>
        
        <p>The <code>"foo"</code> string is called a <em>module specifier</em>. Because the whole
        goal is statically analyzable syntax, the module specifier must be a
        string literal; it cannot be a variable holding the string value.</p>
        
        <p>From the perspective of your ES6 code and the JS engine itself, the
        contents of this string literal are completely opaque and meaningless.
        The module loader will interpret this string as an instruction of where
        to find the desired module, either as a URL path or a local <span class="keep-together">filesystem</span> path.</p>
        
        <p>The <code>foo</code>, <code>bar</code>, and <code>baz</code> identifiers listed must match named exports
        on the module’s API (static analysis and error assertion apply). They
        are bound as top-level identifiers in your current scope:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="p">{</code> <code class="nx">foo</code> <code class="p">}</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code>
        
        <code class="nx">foo</code><code class="p">();</code></pre>
        
        <p>You can rename the bound identifiers imported, as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="p">{</code> <code class="nx">foo</code> <code class="k">as</code> <code class="nx">theFooFunc</code> <code class="p">}</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code>
        
        <code class="nx">theFooFunc</code><code class="p">();</code></pre>
        
        <p>If the module has just a default export that you want to import and bind
        to an identifier, you can opt to skip the <code>{ .. }</code> surrounding syntax
        for that binding. The <code>import</code> in this preferred case gets the nicest
        and most concise of the <code>import</code> syntax forms:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">foo</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code>
        
        <code class="c1">// or:</code>
        <code class="k">import</code> <code class="p">{</code> <code class="k">default</code> <code class="k">as</code> <code class="nx">foo</code> <code class="p">}</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>As explained in the previous section, the <code>default</code> keyword in a
        module’s <code>export</code> specifies a named export where the name is actually
        <code>default</code>, as is illustrated by the second more verbose syntax option.
        The renaming from <code>default</code> to, in this case, <code>foo</code>, is explicit in the
        latter syntax and is identical yet implicit in the former syntax.</p>
        </div>
        
        <p>You can also import a default export along with other named exports, if
        the module has such a definition. Recall this module definition from
        earlier:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">export</code> <code class="k">default</code> <code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        
        <code class="k">export</code> <code class="kd">function </code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="k">export</code> <code class="kd">function </code><code class="nx">baz</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code></pre>
        
        <p>To import that module’s default export and its two named exports:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">FOOFN</code><code class="p">,</code> <code class="p">{</code> <code class="nx">bar</code><code class="p">,</code> <code class="nx">baz</code> <code class="k">as</code> <code class="nx">BAZ</code> <code class="p">}</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code>
        
        <code class="nx">FOOFN</code><code class="p">();</code>
        <code class="nx">bar</code><code class="p">();</code>
        <code class="nx">BAZ</code><code class="p">();</code></pre>
        
        <p>The strongly suggested approach from ES6’s module philosophy is that you
        only import the specific bindings from a module that you need. If a
        module provides 10 API methods, but you only need two of them, some
        believe it wasteful to bring in the entire set of API bindings.</p>
        
        <p>One benefit, besides code being more explicit, is that narrow imports
        make static analysis and error detection (accidentally using the wrong
        binding name, for instance) more robust.</p>
        
        <p>Of course, that’s just the standard position influenced by ES6 design
        philosophy; there’s nothing that requires adherence to that approach.</p>
        
        <p>Many developers would be quick to point out that such approaches can be
        more tedious, requiring you to regularly revisit and update your
        <code>import</code> statement(s) each time you realize you need something else from
        a module. The trade-off is in exchange for convenience.</p>
        
        <p>In that light, the preference might be to import everything from the
        module into a single namespace, rather than importing individual
        members, each directly into the scope. Fortunately, the <code>import</code>
        statement has a syntax variation that can support this style of module
        consumption, called <em>namespace import</em>.</p>
        
        <p>Consider a <code>"foo"</code> module exported as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">export</code> <code class="kd">function </code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="k">export</code> <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
        <code class="k">export</code> <code class="kd">function </code><code class="nx">baz</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code></pre>
        
        <p>You can import that entire API to a single module namespace binding:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">*</code> <code class="k">as</code> <code class="nx">foo</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code>
        
        <code class="nx">foo</code><code class="p">.</code><code class="nx">bar</code><code class="p">();</code>
        <code class="nx">foo</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>          <code class="c1">// 42</code>
        <code class="nx">foo</code><code class="p">.</code><code class="nx">baz</code><code class="p">();</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>The <code>* as ..</code> clause requires the <code>*</code> wildcard. In other words,
        you cannot do something like <code>import { bar, x } as foo from "foo"</code> to
        bring in only part of the API but still bind to the <code>foo</code> namespace. I
        would have liked something like that, but for ES6 it’s all or nothing
        with the namespace import.</p>
        </div>
        
        <p>If the module you’re importing with <code>* as ..</code> has a default export, it
        is named <code>default</code> in the namespace specified. You can additionally name
        the default import outside of the namespace binding, as a top-level
        identifier. Consider a <code>"world"</code> module exported as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">export</code> <code class="k">default</code> <code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="k">export</code> <code class="kd">function </code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="k">export</code> <code class="kd">function </code><code class="nx">baz</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code></pre>
        
        <p>And this <code>import</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">foofn</code><code class="p">,</code> <code class="nx">*</code> <code class="k">as</code> <code class="nx">hello</code> <code class="k">from</code> <code class="s2">"world"</code><code class="p">;</code>
        
        <code class="nx">foofn</code><code class="p">();</code>
        <code class="nx">hello</code><code class="p">.</code><code class="nx">default</code><code class="p">();</code>
        <code class="nx">hello</code><code class="p">.</code><code class="nx">bar</code><code class="p">();</code>
        <code class="nx">hello</code><code class="p">.</code><code class="nx">baz</code><code class="p">();</code></pre>
        
        <p>While this syntax is valid, it can be rather confusing that one method
        of the module (the default export) is bound at the top-level of your
        scope, whereas the rest of the named exports (and one called <code>default</code>)
        are bound as properties on a differently named (<code>hello</code>) identifier
        namespace.</p>
        
        <p>As I mentioned earlier, my suggestion would be to avoid designing your
        module exports in this way, to reduce the chances that your module’s
        users will suffer these strange quirks.</p>
        
        <p>All imported bindings are immutable and/or read-only. Consider the
        previous import; all of these subsequent assignment attempts will throw
        <code>TypeError</code>s:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">foofn</code><code class="p">,</code> <code class="nx">*</code> <code class="k">as</code> <code class="nx">hello</code> <code class="k">from</code> <code class="s2">"world"</code><code class="p">;</code>
        
        <code class="nx">foofn</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>         <code class="c1">// (runtime) TypeError!</code>
        <code class="nx">hello</code><code class="p">.</code><code class="nx">default</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code> <code class="c1">// (runtime) TypeError!</code>
        <code class="nx">hello</code><code class="p">.</code><code class="nx">bar</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>     <code class="c1">// (runtime) TypeError!</code>
        <code class="nx">hello</code><code class="p">.</code><code class="nx">baz</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>     <code class="c1">// (runtime) TypeError!</code></pre>
        
        <p>Recall earlier in <a data-type="xref" href="#exportingAPImembers">“Exporting API Members”</a> that we talked
        about how the <code>bar</code> and <code>baz</code> bindings are bound to the actual
        identifiers inside the <code>"world"</code> module. That means if the module
        changes those values, <code>hello.bar</code> and <code>hello.baz</code> now reference the
        updated values.</p>
        
        <p>But the immutable/read-only nature of your local imported bindings
        enforces that you cannot change them from the imported bindings, hence
        the <code>TypeError</code>s. That’s pretty important, because without those
        protections, your changes would end up affecting all other consumers of
        the module (remember: singleton), which could create some very
        surprising side effects!</p>
        
        <p>Moreover, though a module <em>can</em> change its API members from the inside,
        you should be very cautious of intentionally designing your modules in
        that fashion. ES6 modules are <em>intended</em> to be static, so deviations
        from that principle should be rare and should be carefully and verbosely
        documented.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>There are module design philosophies where you actually
        intend to let a consumer change the value of a property on your API, or
        module APIs designed to be “extended” by having other “plug-ins” added
        to the API namespace. As we just asserted, ES6 module APIs should be
        thought of and designed as static and unchangeable, which strongly
        restricts and discourages these alternative module design patterns. You
        can get around these limitations by exporting a plain object, which of
        course can then be changed at will. But be careful and think twice
        before going down that road.</p>
        </div>
        
        <p>Declarations that occur as a result of an <code>import</code> are “hoisted” (see
        the <em>Scope &amp; Closures</em> title of this series). Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">foo</code><code class="p">();</code>
        
        <code class="k">import</code> <code class="p">{</code> <code class="nx">foo</code> <code class="p">}</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code></pre>
        
        <p><code>foo()</code> can run because not only did the static resolution of the
        <code>import ..</code> statement figure out what <code>foo</code> is during compilation, but
        it also “hoisted” the declaration to the top of the module’s scope, thus
        making it available throughout the module.</p>
        
        <p>Finally, the most basic form of the <code>import</code> looks like this:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="s2">"foo"</code><code class="p">;</code></pre>
        
        <p>This form does not actually import any of the module’s bindings into
        your scope. It loads (if not already loaded), compiles (if not already
        compiled), and evaluates (if not already run) the <code>"foo"</code> module.</p>
        
        <p>In general, that sort of import is probably not going to be terribly
        useful. There may be niche cases where a module’s definition has side
        effects (such as assigning things to the <code>window</code>/global object). You
        could also envision using <code>import "foo"</code> as a sort of preload for a
        module that may be needed later.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Circular Module Dependency"><div class="sect2" id="idm45967363707784">
        <h2>Circular Module Dependency</h2>
        
        <p>A imports B. B imports A. How does this actually work?</p>
        
        <p>I’ll state off the bat that designing systems with intentional circular
        dependency is generally something I try to avoid. That having been said,
        I recognize there are reasons people do this and it can solve some
        sticky design situations.</p>
        
        <p>Let’s consider how ES6 handles this. First, module <code>"A"</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">bar</code> <code class="k">from</code> <code class="s2">"B"</code><code class="p">;</code>
        
        <code class="k">export</code> <code class="k">default</code> <code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="mi">10</code><code class="p">)</code> <code class="k">return</code> <code class="nx">bar</code><code class="p">(</code> <code class="nx">x</code> <code class="o">-</code> <code class="mi">1</code> <code class="p">);</code>
            <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>Now, module <code>"B"</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">foo</code> <code class="k">from</code> <code class="s2">"A"</code><code class="p">;</code>
        
        <code class="k">export</code> <code class="k">default</code> <code class="kd">function </code><code class="nx">bar</code><code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">y</code> <code class="o">&gt;</code> <code class="mi">5</code><code class="p">)</code> <code class="k">return</code> <code class="nx">foo</code><code class="p">(</code> <code class="nx">y</code> <code class="o">/</code> <code class="mi">2</code> <code class="p">);</code>
            <code class="k">return</code> <code class="nx">y</code> <code class="o">*</code> <code class="mi">3</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>These two functions, <code>foo(..)</code> and <code>bar(..)</code>, would work as standard
        function declarations if they were in the same scope, because the
        declarations are “hoisted” to the whole scope and thus available to each
        other regardless of authoring order.</p>
        
        <p>With modules, you have declarations in entirely different scopes, so ES6
        has to do extra work to help make these circular references work.</p>
        
        <p>In a rough conceptual sense, this is how circular <code>import</code> dependencies
        are validated and resolved:</p>
        
        <ul>
        <li>
        <p>If the <code>"A"</code> module is loaded first, the first step is to scan the
        file and analyze all the exports, so it can register all those bindings
        available for import. Then it processes the <code>import .. from "B"</code>, which
        signals that it needs to go fetch <code>"B"</code>.</p>
        </li>
        <li>
        <p>Once the engine loads <code>"B"</code>, it does the same analysis of its export
        bindings. When it sees the <code>import .. from "A"</code>, it knows the API of
        <code>"A"</code> already, so it can verify the <code>import</code> is valid. Now that it knows
        the <code>"B"</code> API, it can also validate the <code>import .. from "B"</code> in the
        waiting <code>"A"</code> module.</p>
        </li>
        </ul>
        
        <p>In essence, the mutual imports, along with the static verification
        that’s done to validate both <code>import</code> statements, virtually composes the
        two separate module scopes (via the bindings), such that <code>foo(..)</code> can
        call <code>bar(..)</code> and vice versa. This is symmetric to if they had
        originally been declared in the same scope.</p>
        
        <p>Now let’s try using the two modules together. First, we’ll try
        <code>foo(..)</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">foo</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">25</code> <code class="p">);</code>              <code class="c1">// 11</code></pre>
        
        <p>Or we can try <code>bar(..)</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">bar</code> <code class="k">from</code> <code class="s2">"bar"</code><code class="p">;</code>
        <code class="nx">bar</code><code class="p">(</code> <code class="mi">25</code> <code class="p">);</code>              <code class="c1">// 11.5</code></pre>
        
        <p>By the time either the <code>foo(25)</code> or <code>bar(25)</code> calls are executed, all
        the analysis/compilation of all modules has completed. That means
        <code>foo(..)</code> internally knows directly about <code>bar(..)</code> and <code>bar(..)</code>
        internally knows directly about <code>foo(..)</code>.</p>
        
        <p>If all we need is to interact with <code>foo(..)</code>, then we only need to
        import the <code>"foo"</code> module. Likewise with <code>bar(..)</code> and the <code>"bar"</code>
        module.</p>
        
        <p>Of course, we <em>can</em> import and use both of them if we want to:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">import</code> <code class="nx">foo</code> <code class="k">from</code> <code class="s2">"foo"</code><code class="p">;</code>
        <code class="k">import</code> <code class="nx">bar</code> <code class="k">from</code> <code class="s2">"bar"</code><code class="p">;</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">25</code> <code class="p">);</code>              <code class="c1">// 11</code>
        <code class="nx">bar</code><code class="p">(</code> <code class="mi">25</code> <code class="p">);</code>              <code class="c1">// 11.5</code></pre>
        
        <p>The static loading semantics of the <code>import</code> statement mean a
        <code>"foo"</code> and <code>"bar"</code> that mutually depend on each other via <code>import</code> will
        ensure that both are loaded, parsed, and compiled before either of them
        runs. So their circular dependency is statically resolved and this works
        as you’d expect.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Module Loading"><div class="sect2" id="idm45967363172680">
        <h2>Module Loading</h2>
        
        <p>We asserted at the beginning of <a data-type="xref" href="#modulessect">“Modules”</a> that the <code>import</code>
        statement uses a separate mechanism, provided by the hosting environment
        (browser, Node.js, etc.), to actually resolve the module specifier
        string into some useful instruction for finding and loading the desired
        module. That mechanism is the system <em>Module Loader</em>.</p>
        
        <p>The default module loader provided by the environment will interpret a
        module specifier as a URL if in the browser, and (generally) as a local
        filesystem path if on a server such as Node.js. The default behavior is
        to assume the loaded file is authored in the ES6 standard module format.</p>
        
        <p>Moreover, you will be able to load a module into the browser via an HTML
        tag, similar to how current script programs are loaded. At the time of
        this writing, it’s not fully clear if this tag will be
        <code>&lt;script type="module"&gt;</code> or <code>&lt;module&gt;</code>. ES6 doesn’t control that
        decision, but discussions in the appropriate standards bodies are
        already well along in parallel of ES6.</p>
        
        <p>Whatever the tag looks like, you can be sure that under the covers it
        will use the default loader (or a customized one you’ve prespecified,
        as we’ll discuss in the next section).</p>
        
        <p>Just like the tag you’ll use in markup, the module loader itself is not
        specified by ES6. It is a <a href="http://whatwg.github.io/loader/">separate, parallel standard</a> controlled currently by the WHATWG
        browser standards group.</p>
        
        <p>At the time of this writing, the following discussions reflect an early
        pass at the API design, and things are likely to change.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Loading Modules Outside of Modules"><div class="sect3" id="idm45967362844456">
        <h3>Loading Modules Outside of Modules</h3>
        
        <p>One use for interacting directly with the module loader is if a
        non-module needs to load a module. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="c1">// normal script loaded in browser via `&lt;script&gt;`,</code>
        <code class="c1">// `import` is illegal here</code>
        
        <code class="nb">Reflect</code><code class="p">.</code><code class="nx">Loader</code><code class="p">.</code><code class="nx">import</code><code class="p">(</code> <code class="s2">"foo"</code> <code class="p">)</code> <code class="c1">// returns a promise for `"foo"`</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code> <code class="kd">function</code><code class="p">(</code><code class="nx">foo</code><code class="p">){</code>
            <code class="nx">foo</code><code class="p">.</code><code class="nx">bar</code><code class="p">();</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>The <code>Reflect.Loader.import(..)</code> utility imports the entire module onto
        the named parameter (as a namespace), just like the <code>import * as foo ..</code>
        namespace import we discussed earlier.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>The <code>Reflect.Loader.import(..)</code> utility returns a promise that
        is fulfilled once the module is ready. To import multiple modules, you
        can compose promises from multiple <code>Reflect.Loader.import(..)</code> calls
        using <code>Promise.all([ .. ])</code>. For more information about Promises, see
        <a data-type="xref" href="ch04.html#promises-sect">“Promises”</a> in <a data-type="xref" href="ch04.html#chapter-4-async-flow-control">Chapter&nbsp;4</a>.</p>
        </div>
        
        <p>You can also use <code>Reflect.Loader.import(..)</code> in a real module to
        dynamically/conditionally load a module, where <code>import</code> itself would not
        work. You might, for instance, choose to load a module containing a
        polyfill for some ES7+ feature if a feature test reveals it’s not
        defined by the current engine.</p>
        
        <p>For performance reasons, you’ll want to avoid dynamic loading whenever
        possible, as it hampers the ability of the JS engine to fire off early
        fetches from its static analysis.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Customized Loading"><div class="sect3" id="idm45967362785256">
        <h3>Customized Loading</h3>
        
        <p>Another use for directly interacting with the module loader is if you
        want to customize its behavior through configuration or even
        redefinition.</p>
        
        <p>At the time of this writing, there’s a <a href="https://github.com/ModuleLoader/es6-module-loader">polyfill for the module loader
        API being developed</a>.
        While details are scarce and highly subject to change, we can explore
        what possibilities may eventually land.</p>
        
        <p>The <code>Reflect.Loader.import(..)</code> call may support a second argument for
        specifying various options to customize the import/load task. For
        example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">Reflect</code><code class="p">.</code><code class="nx">Loader</code><code class="p">.</code><code class="nx">import</code><code class="p">(</code> <code class="s2">"foo"</code><code class="p">,</code> <code class="p">{</code> <code class="nx">address</code><code class="o">:</code> <code class="s2">"/path/to/foo.js"</code> <code class="p">}</code> <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code> <code class="kd">function</code><code class="p">(</code><code class="nx">foo</code><code class="p">){</code>
            <code class="c1">// ..</code>
        <code class="p">}</code> <code class="p">)</code></pre>
        
        <p>It’s also expected that a customization will be provided (through some
        means) for hooking into the process of loading a module, where a
        translation/transpilation could occur after load but before the engine
        compiles the module.</p>
        
        <p>For example, you could load something that’s not already an
        ES6-compliant module format (e.g., CoffeeScript, TypeScript, CommonJS,
        AMD). Your translation step could then convert it to an ES6-compliant
        module for the engine to then process.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Classes"><div class="sect1" id="class-sect">
        <h1>Classes</h1>
        
        <p>From nearly the beginning of JavaScript, syntax and development patterns
        have all strived (read: struggled) to put on a facade of supporting
        class-oriented development. With things like <code>new</code> and <code>instanceof</code> and
        a <code>.constructor</code> property, who couldn’t help but be teased that JS
        had classes hidden somewhere inside its prototype system?</p>
        
        <p>Of course, JS “classes” aren’t nearly the same as classical classes. The
        differences are well documented, so I won’t belabor that point any
        further here.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>To learn more about the patterns used in JS to fake “classes,”
        and an alternative view of prototypes called “delegation,” see the
        second half of the <em>this &amp; Object Prototypes</em> title of this series.</p>
        </div>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="class"><div class="sect2" id="idm45967362727624">
        <h2>class</h2>
        
        <p>Although JS’s prototype mechanism doesn’t work like traditional classes,
        that doesn’t stop the strong tide of demand on the language to extend
        the syntactic sugar so that expressing “classes” looks more like real
        classes. Enter the ES6 <code>class</code> keyword and its associated mechanism.</p>
        
        <p>This feature is the result of a highly contentious and drawn-out debate,
        and represents a smaller subset compromise from several strongly opposed
        views on how to approach JS classes. Most developers who want full
        classes in JS will find parts of the new syntax quite inviting, but will
        find important bits still missing. Don’t worry, though. TC39 is already
        working on additional features to augment classes in the post-ES6
        timeframe.</p>
        
        <p>At the heart of the new ES6 class mechanism is the <code>class</code> keyword,
        which identifies a <em>block</em> where the contents define the members of a
        function’s prototype. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="nx">a</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="nx">b</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="nx">gimmeXY</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>Some things to note:</p>
        
        <ul>
        <li>
        <p><code>class Foo</code> implies creating a (special) function of the name <code>Foo</code>,
        much like you did pre-ES6.</p>
        </li>
        <li>
        <p><code>constructor(..)</code> identifies the signature of that <code>Foo(..)</code> function,
        as well as its body contents.</p>
        </li>
        <li>
        <p>Class methods use the same “concise method” syntax available to object
        literals, as discussed in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a>. This also includes the concise
        generator form as discussed earlier in this chapter, as well as the ES5
        getter/setter syntax. However, class methods are non-enumerable whereas object methods are by default enumerable.</p>
        </li>
        <li>
        <p>Unlike object literals, there are no commas separating members in a
        <code>class</code> body! In fact, they’re not even allowed.</p>
        </li>
        </ul>
        
        <p>The <code>class</code> syntax definition in the previous snippet can be roughly
        thought of as this pre-ES6 equivalent, which probably will look fairly
        familiar to those who’ve done prototype-style coding before:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">Foo</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="nx">a</code><code class="p">;</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="nx">b</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="nx">Foo</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">gimmeXY</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>In either the pre-ES6 form or the new ES6 <code>class</code> form, this “class” can
        now be instantiated and used just as you’d expect:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">f</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Foo</code><code class="p">(</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">15</code> <code class="p">);</code>
        
        <code class="nx">f</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>                        <code class="c1">// 5</code>
        <code class="nx">f</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>                        <code class="c1">// 15</code>
        <code class="nx">f</code><code class="p">.</code><code class="nx">gimmeXY</code><code class="p">();</code>                <code class="c1">// 75</code></pre>
        
        <p>Caution! Though <code>class Foo</code> seems much like <code>function Foo()</code>, there are
        important differences:</p>
        
        <ul>
        <li>
        <p>A <code>Foo(..)</code> call of <code>class Foo</code> <em>must</em> be made with <code>new</code>, as the
        pre-ES6 option of <code>Foo.call( obj )</code> will <em>not</em> work.</p>
        </li>
        <li>
        <p>While <code>function Foo</code> is “hoisted” (see the <em>Scope &amp; Closures</em> title of
        this series), <code>class Foo</code> is not; the <code>extends ..</code> clause specifies an
        expression that cannot be “hoisted.” So, you must declare a <code>class</code>
        before you can instantiate it.</p>
        </li>
        <li>
        <p><code>class Foo</code> in the top global scope creates a lexical <code>Foo</code> identifier
        in that scope, but unlike <code>function Foo</code> does not create a global object
        property of that name.</p>
        </li>
        </ul>
        
        <p>The established <code>instanceof</code> operator still works with ES6 classes,
        because <code>class</code> just creates a constructor function of the same name.
        However, ES6 introduces a way to customize how <code>instanceof</code> works, using
        <code>Symbol.hasInstance</code> (see <a data-type="xref" href="ch07.html#well-knownSymbols">“Well-Known Symbols”</a> in <a data-type="xref" href="ch07.html#chapter-7-meta-programming">Chapter&nbsp;7</a>).</p>
        
        <p>Another way of thinking about <code>class</code>, which I find more convenient, is
        as a <em>macro</em> that is used to automatically populate a <code>prototype</code>
        object. Optionally, it also wires up the <code>[[Prototype]]</code> relationship if
        using <code>extends</code> (see the next section).</p>
        
        <p>An ES6 <code>class</code> isn’t really an entity itself, but a meta concept that
        wraps around other concrete entities, such as functions and properties,
        and ties them together.</p>
        <div data-type="tip"><h6>Tip</h6>
        <p>In addition to the declaration form, a <code>class</code> can also be an
        expression, as in: <code>var x = class Y { .. }</code>. This is primarily useful
        for passing a class definition (technically, the constructor itself) as
        a function argument or assigning it to an object property.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="extends and super"><div class="sect2" id="idm45967362727000">
        <h2>extends and super</h2>
        
        <p>ES6 classes also have syntactic sugar for establishing the
        <code>[[Prototype]]</code> delegation link between two function prototypes—commonly mislabeled “inheritance” or confusingly labeled “prototype
        inheritance”—using the class-oriented familiar terminology <code>extends</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">Bar</code> <code class="k">extends</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code class="nx">b</code><code class="p">,</code><code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">super</code><code class="p">(</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code> <code class="p">);</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">z</code> <code class="o">=</code> <code class="nx">c</code><code class="p">;</code>
            <code class="p">}</code>
        
            <code class="nx">gimmeXYZ</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">super</code><code class="p">.</code><code class="nx">gimmeXY</code><code class="p">()</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">z</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Bar</code><code class="p">(</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">15</code><code class="p">,</code> <code class="mi">25</code> <code class="p">);</code>
        
        <code class="nx">b</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>                        <code class="c1">// 5</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">y</code><code class="p">;</code>                        <code class="c1">// 15</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">z</code><code class="p">;</code>                        <code class="c1">// 25</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">gimmeXYZ</code><code class="p">();</code>               <code class="c1">// 1875</code></pre>
        
        <p>A significant new addition is <code>super</code>, which is actually something not
        directly possible pre-ES6 (without some unfortunate hack trade-offs). In the
        constructor, <code>super</code> automatically refers to the “parent constructor,”
        which in the previous example is <code>Foo(..)</code>. In a method, it refers to
        the “parent object,” such that you can then make a property/method
        access off it, such as <code>super.gimmeXY()</code>.</p>
        
        <p><code>Bar extends Foo</code> of course means to link the <code>[[Prototype]]</code> of
        <code>Bar.prototype</code> to <code>Foo.prototype</code>. So, <code>super</code> in a method like
        <code>gimmeXYZ()</code> specifically means <code>Foo.prototype</code>, whereas <code>super</code> means
        <code>Foo</code> when used in the <code>Bar</code> constructor.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><code>super</code> is not limited to <code>class</code> declarations. It also works in
        object literals, in much the same way we’re discussing here. See <a data-type="xref" href="ch02.html#object-super">“Object super”</a> in <a data-type="xref" href="ch02.html#chapter-2-syntax">Chapter&nbsp;2</a> for more information.</p>
        </div>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="There Be super Dragons"><div class="sect3" id="idm45967362396952">
        <h3>There Be super Dragons</h3>
        
        <p>It is not insignificant to note that <code>super</code> behaves differently
        depending on where it appears. In fairness, most of the time, that won’t
        be a problem. But surprises await if you deviate from a narrow norm.</p>
        
        <p>There may be cases where in the constructor you would want to reference
        the <code>Foo.prototype</code>, such as to directly access one of its
        properties/methods. However, <code>super</code> in the constructor cannot be used
        in that way; <code>super.prototype</code> will not work. <code>super(..)</code> means roughly
        to call <code>new Foo(..)</code>, but isn’t actually a usable reference to <code>Foo</code>
        itself.</p>
        
        <p>Symmetrically, you may want to reference the <code>Foo(..)</code> function from
        inside a nonconstructor method. <code>super.constructor</code> will point at
        <code>Foo(..)</code> the function, but beware that this function can <em>only</em> be
        invoked with <code>new</code>. <code>new super.constructor(..)</code> would be valid, but it
        wouldn’t be terribly useful in most cases, because you can’t make that
        call use or reference the current <code>this</code> object context, which is likely
        what you’d want.</p>
        
        <p>Also, <code>super</code> looks like it might be driven by a function’s context just
        like <code>this</code>—that is, that they’d both be dynamically bound. However,
        <code>super</code> is not dynamic like <code>this</code> is. When a constructor or method
        makes a <code>super</code> reference inside it at declaration time (in the <code>class</code>
        body), that <code>super</code> is statically bound to that specific class
        hierarchy, and cannot be overridden (at least in ES6).</p>
        
        <p>What does that mean? It means that if you’re in the habit of taking a
        method from one “class” and “borrowing” it for another class by
        overriding its <code>this</code>, say with <code>call(..)</code> or <code>apply(..)</code>, that may very
        well create surprises if the method you’re borrowing has a <code>super</code> in
        it. Consider this class hierarchy:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">ParentA</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="o">=</code> <code class="s2">"a"</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"ParentA:"</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="p">);</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="k">class</code> <code class="nx">ParentB</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="o">=</code> <code class="s2">"b"</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"ParentB:"</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="p">);</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="k">class</code> <code class="nx">ChildA</code> <code class="k">extends</code> <code class="nx">ParentA</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">super</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"ChildA:"</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="k">class</code> <code class="nx">ChildB</code> <code class="k">extends</code> <code class="nx">ParentB</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">super</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"ChildB:"</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">id</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ChildA</code><code class="p">();</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code>                    <code class="c1">// ParentA: a</code>
                                    <code class="c1">// ChildA: a</code>
        <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">ChildB</code><code class="p">();</code>       <code class="c1">// ParentB: b</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code>                    <code class="c1">// ChildB: b</code></pre>
        
        <p>All seems fairly natural and expected in this previous snippet. However,
        if you try to borrow <code>b.foo()</code> and use it in the context of <code>a</code>—by
        virtue of dynamic <code>this</code> binding, such borrowing is quite common and
        used in many different ways, including mixins most notably—you may
        find this result an ugly surprise:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="c1">// borrow `b.foo()` to use in `a` context</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">foo</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>            <code class="c1">// ParentB: a</code>
                                    <code class="c1">// ChildB: a</code></pre>
        
        <p>As you can see, the <code>this.id</code> reference was dynamically rebound so that
        <code>: a</code> is reported in both cases instead of <code>: b</code>. But <code>b.foo()</code>’s
        <code>super.foo()</code> reference wasn’t dynamically rebound, so it still reported
        <code>ParentB</code> instead of the expected <code>ParentA</code>.</p>
        
        <p>Because <code>b.foo()</code> references <code>super</code>, it is statically bound to the
        <code>ChildB</code>/<code>ParentB</code> hierarchy and cannot be used against the
        <code>ChildA</code>/<code>ParentA</code> hierarchy. There is no ES6 solution to this
        limitation.</p>
        
        <p><code>super</code> seems to work intuitively if you have a static class hierarchy
        with no cross-pollination. But in all fairness, one of the main benefits
        of doing <code>this</code>-aware coding is exactly that sort of flexibility.
        Simply, <code>class</code> + <code>super</code> requires you to avoid such techniques.</p>
        
        <p>The choice boils down to narrowing your object design to these static
        hierarchies—<code>class</code>, <code>extends</code>, and <code>super</code> will be quite nice—or
        dropping all attempts to “fake” classes and instead embrace dynamic and
        flexible, classless objects and <code>[[Prototype]]</code> delegation (see the
        <em>this &amp; Object Prototypes</em> title of this series).</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Subclass Constructor"><div class="sect3" id="idm45967362396328">
        <h3>Subclass Constructor</h3>
        
        <p>Constructors are not required for classes or subclasses; a default
        constructor is substituted in both cases if omitted. However, the
        default substituted constructor is different for a direct class versus
        an extended class.</p>
        
        <p>Specifically, the default subclass constructor automatically calls the
        parent constructor, and passes along any arguments. In other words, you
        could think of the default subclass constructor sort of like this:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">constructor</code><code class="p">(</code><code class="o">...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">super</code><code class="p">(</code><code class="o">...</code><code class="nx">args</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>This is an important detail to note. Not all class languages have the
        subclass constructor automatically call the parent constructor. C++
        does, but Java does not. But more importantly, in pre-ES6 classes, such
        automatic “parent constructor” calling does not happen. Be careful when
        converting to the ES6 <code>class</code> if you’ve been relying on such calls <em>not</em>
        happening.</p>
        
        <p>Another perhaps surprising deviation/limitation of ES6 subclass
        constructors: in a constructor of a subclass, you cannot access <code>this</code>
        until <code>super(..)</code> has been called. The reason is nuanced and
        complicated, but it boils down to the fact that the parent constructor
        is actually the one creating/initializing your instance’s <code>this</code>.
        Pre-ES6, it works oppositely; the <code>this</code> object is created by the
        “subclass constructor,” and then you call a “parent constructor” with
        the context of the “subclass” <code>this</code>.</p>
        
        <p>Let’s illustrate. This works pre-ES6:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">Foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">a</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">function </code><code class="nx">Bar</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">this</code><code class="p">.</code><code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
            <code class="nx">Foo</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code> <code class="k">this</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="c1">// `Bar` "extends" `Foo`</code>
        <code class="nx">Bar</code><code class="p">.</code><code class="nx">prototype</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code> <code class="nx">Foo</code><code class="p">.</code><code class="nx">prototype</code> <code class="p">);</code></pre>
        
        <p>But this ES6 equivalent is not allowed:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">a</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="k">class</code> <code class="nx">Bar</code> <code class="k">extends</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">b</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>         <code class="c1">// not allowed before `super()`</code>
                <code class="k">super</code><code class="p">();</code>            <code class="c1">// to fix swap these two statements</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>In this case, the fix is simple. Just swap the two statements in the
        subclass <code>Bar</code> constructor. However, if you’ve been relying pre-ES6 on
        being able to skip calling the “parent constructor,” beware because that
        won’t be allowed anymore.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="extending Natives"><div class="sect3" id="idm45967362153544">
        <h3>extending Natives</h3>
        
        <p>One of the most heralded benefits to the new <code>class</code> and <code>extend</code> design
        is the ability to (finally!) subclass the built-in natives, like
        <code>Array</code>. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">MyCoolArray</code> <code class="k">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="nx">first</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="mi">0</code><code class="p">];</code> <code class="p">}</code>
            <code class="nx">last</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">[</code><code class="k">this</code><code class="p">.</code><code class="nx">length</code> <code class="o">-</code> <code class="mi">1</code><code class="p">];</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyCoolArray</code><code class="p">(</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code> <code class="p">);</code>
        
        <code class="nx">a</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                   <code class="c1">// 3</code>
        <code class="nx">a</code><code class="p">;</code>                          <code class="c1">// [1,2,3]</code>
        
        <code class="nx">a</code><code class="p">.</code><code class="nx">first</code><code class="p">();</code>                  <code class="c1">// 1</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">last</code><code class="p">();</code>                   <code class="c1">// 3</code></pre>
        
        <p>Prior to ES6, a fake “subclass” of <code>Array</code> using manual object creation
        and linking to <code>Array.prototype</code> only partially worked. It missed out on
        the special behaviors of a real array, such as the automatically
        updating <code>length</code> property. ES6 subclasses should fully work with
        “inherited” and augmented behaviors as expected!</p>
        
        <p>Another common pre-ES6 “subclass” limitation is with the <code>Error</code> object,
        in creating custom error “subclasses.” When genuine <code>Error</code> objects are
        created, they automatically capture special <code>stack</code> information,
        including the line number and file where the error is created. Pre-ES6
        custom error “subclasses” have no such special behavior, which severely
        limits their usefulness.</p>
        
        <p>ES6 to the rescue:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">Oops</code> <code class="k">extends</code> <code class="nb">Error</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">(</code><code class="nx">reason</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">oops</code> <code class="o">=</code> <code class="nx">reason</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// later:</code>
        <code class="kd">var</code> <code class="nx">ouch</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Oops</code><code class="p">(</code> <code class="s2">"I messed up!"</code> <code class="p">);</code>
        <code class="k">throw</code> <code class="nx">ouch</code><code class="p">;</code></pre>
        
        <p>The <code>ouch</code> custom error object in this previous snippet will behave like
        any other genuine error object, including capturing <code>stack</code>. That’s a
        big improvement!</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="new.target"><div class="sect2" id="newtarget_sect">
        <h2>new.target</h2>
        
        <p>ES6 introduces a new concept called a <em>meta property</em> (see <a data-type="xref" href="ch07.html#chapter-7-meta-programming">Chapter&nbsp;7</a>),
        in the form of <code>new.target</code>.</p>
        
        <p>If that looks strange, it is; pairing a keyword with a <code>.</code> and a
        property name is definitely an out-of-the-ordinary pattern for JS.</p>
        
        <p><code>new.target</code> is a new “magical” value available in all functions, though
        in normal functions it will always be <code>undefined</code>. In any constructor,
        <code>new.target</code> always points at the constructor that <code>new</code> actually
        directly invoked, even if the constructor is in a parent class and was
        delegated to by a <code>super(..)</code> call from a child constructor. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"Foo: "</code><code class="p">,</code> <code class="k">new</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">name</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="k">class</code> <code class="nx">Bar</code> <code class="k">extends</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="nx">constructor</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">super</code><code class="p">();</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"Bar: "</code><code class="p">,</code> <code class="k">new</code><code class="p">.</code><code class="nx">target</code><code class="p">.</code><code class="nx">name</code> <code class="p">);</code>
            <code class="p">}</code>
            <code class="nx">baz</code><code class="p">()</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"baz: "</code><code class="p">,</code> <code class="k">new</code><code class="p">.</code><code class="nx">target</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Foo</code><code class="p">();</code>
        <code class="c1">// Foo: Foo</code>
        
        <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Bar</code><code class="p">();</code>
        <code class="c1">// Foo: Bar   &lt;-- respects the `new` call-site</code>
        <code class="c1">// Bar: Bar</code>
        
        <code class="nx">b</code><code class="p">.</code><code class="nx">baz</code><code class="p">();</code>
        <code class="c1">// baz: undefined</code></pre>
        
        <p>The <code>new.target</code> meta property doesn’t have much purpose in class
        constructors, except accessing a static property/method (see the next
        section).</p>
        
        <p>If <code>new.target</code> is <code>undefined</code>, you know the function was not called
        with <code>new</code>. You can then force a <code>new</code> invocation if that’s necessary.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="static"><div class="sect2" id="idm45967361652520">
        <h2>static</h2>
        
        <p>When a subclass <code>Bar</code> extends a parent class <code>Foo</code>, we already observed
        that <code>Bar.prototype</code> is <code>[[Prototype]]</code>-linked to <code>Foo.prototype</code>. But
        additionally, <code>Bar()</code> is <code>[[Prototype]]</code>-linked to <code>Foo()</code>. That part
        may not have such an obvious reasoning.</p>
        
        <p>However, it’s quite useful in the case where you declare <code>static</code>
        methods (not just properties) for a class, as these are added directly to that
        class’s function object, not to the function object’s <code>prototype</code>
        object. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="k">static</code> <code class="nx">cool</code><code class="p">()</code> <code class="p">{</code> <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"cool"</code> <code class="p">);</code> <code class="p">}</code>
            <code class="nx">wow</code><code class="p">()</code> <code class="p">{</code> <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"wow"</code> <code class="p">);</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="k">class</code> <code class="nx">Bar</code> <code class="k">extends</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="k">static</code> <code class="nx">awesome</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">super</code><code class="p">.</code><code class="nx">cool</code><code class="p">();</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"awesome"</code> <code class="p">);</code>
            <code class="p">}</code>
            <code class="nx">neat</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">super</code><code class="p">.</code><code class="nx">wow</code><code class="p">();</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"neat"</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="nx">Foo</code><code class="p">.</code><code class="nx">cool</code><code class="p">();</code>                 <code class="c1">// "cool"</code>
        <code class="nx">Bar</code><code class="p">.</code><code class="nx">cool</code><code class="p">();</code>                 <code class="c1">// "cool"</code>
        <code class="nx">Bar</code><code class="p">.</code><code class="nx">awesome</code><code class="p">();</code>              <code class="c1">// "cool"</code>
                                    <code class="c1">// "awesome"</code>
        
        <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Bar</code><code class="p">();</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">neat</code><code class="p">();</code>                   <code class="c1">// "wow"</code>
                                    <code class="c1">// "neat"</code>
        
        <code class="nx">b</code><code class="p">.</code><code class="nx">awesome</code><code class="p">;</code>                  <code class="c1">// undefined</code>
        <code class="nx">b</code><code class="p">.</code><code class="nx">cool</code><code class="p">;</code>                     <code class="c1">// undefined</code></pre>
        
        <p>Be careful not to get confused that <code>static</code> members are on the class’s
        prototype chain. They’re actually on the dual/parallel chain between the
        function constructors.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Symbol.species Constructor Getter"><div class="sect3" id="idm45967361643112">
        <h3>Symbol.species Constructor Getter</h3>
        
        <p>One place where <code>static</code> can be useful is in setting the
        <code>Symbol.species</code> getter (known internally in the specification as
        <code>@@species</code>) for a derived (child) class. This capability allows a child
        class to signal to a parent class what constructor should be used—when not intending the child class’s constructor itself—if any parent
        class method needs to vend a new instance.</p>
        
        <p>For example, many methods on <code>Array</code> create and return a new <code>Array</code>
        instance. If you define a derived class from <code>Array</code>, but you want those
        methods to continue to vend actual <code>Array</code> instances instead of from your
        derived class, this works:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">MyCoolArray</code> <code class="k">extends</code> <code class="nb">Array</code> <code class="p">{</code>
            <code class="c1">// force `species` to be parent constructor</code>
            <code class="k">static</code> <code class="nx">get</code> <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Array</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">MyCoolArray</code><code class="p">(</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code> <code class="p">),</code>
            <code class="nx">b</code> <code class="o">=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="kd">function</code><code class="p">(</code><code class="nx">v</code><code class="p">){</code> <code class="k">return</code> <code class="nx">v</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code> <code class="p">}</code> <code class="p">);</code>
        
        <code class="nx">b</code> <code class="k">instanceof</code> <code class="nx">MyCoolArray</code><code class="p">;</code>   <code class="c1">// false</code>
        <code class="nx">b</code> <code class="k">instanceof</code> <code class="nb">Array</code><code class="p">;</code>         <code class="c1">// true</code></pre>
        
        <p>To illustrate how a parent class method can use a child’s species
        declaration somewhat like <code>Array#map(..)</code> is doing, consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">class</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="c1">// defer `species` to derived constructor</code>
            <code class="k">static</code> <code class="nx">get</code> <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">;</code> <code class="p">}</code>
            <code class="nx">spawn</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">return</code> <code class="k">new</code> <code class="k">this</code><code class="p">.</code><code class="nx">constructor</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">]();</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="k">class</code> <code class="nx">Bar</code> <code class="k">extends</code> <code class="nx">Foo</code> <code class="p">{</code>
            <code class="c1">// force `species` to be parent constructor</code>
            <code class="k">static</code> <code class="nx">get</code> <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">species</code><code class="p">]()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">Foo</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Foo</code><code class="p">();</code>
        <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">spawn</code><code class="p">();</code>
        <code class="nx">b</code> <code class="k">instanceof</code> <code class="nx">Foo</code><code class="p">;</code>                   <code class="c1">// true</code>
        
        <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Bar</code><code class="p">();</code>
        <code class="kd">var</code> <code class="nx">y</code> <code class="o">=</code> <code class="nx">x</code><code class="p">.</code><code class="nx">spawn</code><code class="p">();</code>
        <code class="nx">y</code> <code class="k">instanceof</code> <code class="nx">Bar</code><code class="p">;</code>                   <code class="c1">// false</code>
        <code class="nx">y</code> <code class="k">instanceof</code> <code class="nx">Foo</code><code class="p">;</code>                   <code class="c1">// true</code></pre>
        
        <p>The parent class <code>Symbol.species</code> does <code>return this</code> to defer to any
        derived class, as you’d normally expect. <code>Bar</code> then overrides to
        manually declare <code>Foo</code> to be used for such instance creation. Of course,
        a derived class can still vend instances of itself using
        <code>new this.constructor(..)</code>.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Review"><div class="sect1" id="idm45967361263592">
        <h1>Review</h1>
        
        <p>ES6 introduces several new features that aid in code organization:</p>
        
        <ul>
        <li>
        <p>Iterators provide sequential access to data or operations. They can be
        consumed by new language features like <code>for..of</code> and <code>...</code>.</p>
        </li>
        <li>
        <p>Generators are locally pause/resume capable functions controlled by an
        iterator. They can be used to programmatically (and interactively,
        through <code>yield</code>/<code>next(..)</code> message passing) <em>generate</em> values to be
        consumed via iteration.</p>
        </li>
        <li>
        <p>Modules allow private encapsulation of implementation details with a
        publicly exported API. Module definitions are file-based, singleton
        instances, and statically resolved at compile time.</p>
        </li>
        <li>
        <p>Classes provide cleaner syntax around prototype-based coding. The
        addition of <code>super</code> also solves tricky issues with relative references
        in the <code>[[Prototype]]</code> chain.</p>
        </li>
        </ul>
        
        <p>These new tools should be your first stop when trying to improve the
        architecture of your JS projects by embracing ES6.</p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781491905241/files/epub.css" crossorigin="anonymous"></div>
</div>

https://learning.oreilly.com