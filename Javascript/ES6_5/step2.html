<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <div id="book-content" class=""><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 2. Syntax"><div class="chapter" id="chapter-2-syntax">
        <h1><span class="label">Chapter 2. </span>Syntax</h1>
        
        
        <p>If you’ve been writing JS for any length of time, odds are the syntax is
        pretty familiar to you. There are certainly many quirks, but overall
        it’s a fairly reasonable and straightforward syntax that draws many
        similarities from other languages.</p>
        
        <p>However, ES6 adds quite a few new syntactic forms that take some getting
        used to. In this chapter, we’ll tour through them to find out what’s in
        store.</p>
        <div data-type="tip"><h6>Tip</h6>
        <p>At the time of this writing, some of the features discussed in
        this book have been implemented in various browsers (Firefox, Chrome,
        etc.), but some have only been partially implemented and many others
        have not been implemented at all. Your experience may be mixed trying
        these examples directly. If so, try them out with transpilers, as most
        of these features are covered by those tools.</p>
        
        <p><a href="http://www.es6fiddle.net/">ES6Fiddle</a> is a great, easy-to-use playground for trying out ES6, as is the online REPL for the <a href="http://babeljs.io/repl/">Babel transpiler</a>.</p>
        </div>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Block-Scoped Declarations"><div class="sect1" id="block-scope-declar">
        <h1>Block-Scoped Declarations</h1>
        
        <p>You’re probably aware that the fundamental unit of variable scoping in
        JavaScript has always been the <code>function</code>. If you needed to create a
        block of scope, the most prevalent way to do so other than a regular
        function declaration was the immediately invoked function expression
        (IIFE). For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
        
        <code class="p">(</code><code class="kd">function </code><code class="nx">IIFE</code><code class="p">(){</code>
            <code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>   <code class="c1">// 3</code>
        <code class="p">})();</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>       <code class="c1">// 2</code></pre>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="let Declarations"><div class="sect2" id="let-declarations">
        <h2>let Declarations</h2>
        
        <p>However, we can now create declarations that are bound to any block,
        called (unsurprisingly) <em>block scoping</em>. This means all we need is a
        pair of <code>{ .. }</code> to create a scope. Instead of using <code>var</code>, which always
        declares variables attached to the enclosing function (or global, if top
        level) scope, use <code>let</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
        
        <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>   <code class="c1">// 3</code>
        <code class="p">}</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>       <code class="c1">// 2</code></pre>
        
        <p>It’s not very common or idiomatic thus far in JS to use a standalone
        <code>{ .. }</code> block, but it’s always been valid. And developers from other
        languages that have <em>block scoping</em> will readily recognize that pattern.</p>
        
        <p>I believe this is the best way to create block-scoped variables, with a
        dedicated <code>{ .. }</code> block. Moreover, you should always put the <code>let</code>
        declaration(s) at the very top of that block. If you have more than one
        to declare, I’d recommend using just one <code>let</code>.</p>
        
        <p>Stylistically, I even prefer to put the <code>let</code> on the same line as the
        opening <code>{</code>, to make it clearer that this block is only for the purpose
        of declaring the scope for those variables.</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="p">{</code>   <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">;</code>
            <code class="c1">// ..</code>
        <code class="p">}</code></pre>
        
        <p>Now, that’s going to look strange and it’s not likely going to match the
        recommendations given in most other ES6 literature. But I have reasons
        for my madness.</p>
        
        <p>There’s another experimental (not standardized) form of the <code>let</code>
        declaration called the <code>let</code>-block, which looks like:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">let</code> <code class="p">(</code><code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code></pre>
        
        <p>That form is what I call <em>explicit</em> block scoping, whereas the
        <code>let ..</code> declaration form that mirrors <code>var</code> is more <em>implicit</em>, as it
        kind of hijacks whatever <code>{ .. }</code> pair it’s found in. Generally
        developers find <em>explicit</em> mechanisms a bit more preferable than
        <em>implicit</em> mechanisms, and I claim this is one of those cases.</p>
        
        <p>If you compare the previous two snippet forms, they’re very similar, and
        in my opinion both qualify stylistically as <em>explicit</em> block scoping.
        Unfortunately, the <code>let (..) { .. }</code> form, the most <em>explicit</em> of the
        options, was not adopted in ES6. That may be revisited post-ES6, but for
        now the former option is our best bet, I think.</p>
        
        <p>To reinforce the <em>implicit</em> nature of <code>let ..</code> declarations, consider
        these usages:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
        
        <code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">&gt;</code> <code class="mi">1</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">*</code> <code class="mi">3</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">b</code> <code class="p">);</code>       <code class="c1">// 6</code>
        
            <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">a</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="nx">b</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="kd">let</code> <code class="nx">j</code> <code class="o">=</code> <code class="nx">i</code> <code class="o">+</code> <code class="mi">10</code><code class="p">;</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">j</code> <code class="p">);</code>
            <code class="p">}</code>
            <code class="c1">// 12 13 14 15 16</code>
        
            <code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">+</code> <code class="nx">b</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">c</code> <code class="p">);</code>       <code class="c1">// 8</code>
        <code class="p">}</code></pre>
        
        <p>Quick quiz without looking back at that snippet: which variable(s) exist
        only inside the <code>if</code> statement, and which variable(s) exist only inside
        the <code>for</code> loop?</p>
        
        <p>The answers: the <code>if</code> statement contains <code>b</code> and <code>c</code> block-scoped
        variables, and the <code>for</code> loop contains <code>i</code> and <code>j</code> block-scoped
        variables.</p>
        
        <p>Did you have to think about it for a moment? Does it surprise you that
        <code>i</code> isn’t added to the enclosing <code>if</code> statement scope? That mental pause
        and questioning—I call it a “mental tax”—comes from the fact that
        this <code>let</code> mechanism is not only new to us, but it’s also <em>implicit</em>.</p>
        
        <p>There’s also a hazard in the <code>let c = ..</code> declaration appearing so far
        down in the scope. Unlike traditional <code>var</code>-declared variables, which
        are attached to the entire enclosing function scope regardless of where
        they appear, <code>let</code> declarations attach to the block scope but are not
        initialized until they appear in the block.</p>
        
        <p>Accessing a <code>let</code>-declared variable earlier than its <code>let ..</code>
        declaration/initialization causes an error, whereas with <code>var</code>
        declarations the ordering doesn’t matter (except stylistically).</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>   <code class="c1">// undefined</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">b</code> <code class="p">);</code>   <code class="c1">// ReferenceError!</code>
        
            <code class="kd">var</code> <code class="nx">a</code><code class="p">;</code>
            <code class="kd">let</code> <code class="nx">b</code><code class="p">;</code>
        <code class="p">}</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>This <code>ReferenceError</code> from accessing too-early <code>let</code>-declared
        references is technically called a <em>Temporal Dead Zone (TDZ)</em> error—you’re accessing a variable that’s been declared but not yet
        initialized. This will not be the only time we see TDZ errors—they
        crop up in several places in ES6. Also, note that “initialized” doesn’t
        require explicitly assigning a value in your code, as <code>let b;</code> is
        totally valid. A variable that’s not given an assignment at declaration
        time is assumed to have been assigned the <code>undefined</code> value, so <code>let b;</code>
        is the same as <code>let b = undefined;</code>. Explicit assignment or not, you
        cannot access <code>b</code> until the <code>let b</code> statement is run.</p>
        </div>
        
        <p>One last gotcha: <code>typeof</code> behaves differently with TDZ variables than it
        does with undeclared (or declared!) variables. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="p">{</code>
            <code class="c1">// `a` is not declared</code>
            <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">a</code> <code class="o">===</code> <code class="s2">"undefined"</code><code class="p">)</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"cool"</code> <code class="p">);</code>
            <code class="p">}</code>
        
            <code class="c1">// `b` is declared, but in its TDZ</code>
            <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">b</code> <code class="o">===</code> <code class="s2">"undefined"</code><code class="p">)</code> <code class="p">{</code>     <code class="c1">// ReferenceError!</code>
                <code class="c1">// ..</code>
            <code class="p">}</code>
        
            <code class="c1">// ..</code>
        
            <code class="kd">let</code> <code class="nx">b</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>The <code>a</code> is not declared, so <code>typeof</code> is the only safe way to check for
        its existence or not. But <code>typeof b</code> throws the TDZ error because
        farther down in the code there happens to be a <code>let b</code> declaration.
        Oops.</p>
        
        <p>Now it should be clearer why I insist that <code>let</code> declarations should all
        be at the top of their scope. That totally avoids the accidental errors
        of accessing too early. It also makes it more <em>explicit</em> when you look
        at the start of a block, any block, what variables it contains.</p>
        
        <p>Your blocks (<code>if</code> statements, <code>while</code> loops, etc.) don’t have to share
        their original behavior with scoping behavior.</p>
        
        <p>This explicitness on your part, which is up to you to maintain with
        discipline, will save you lots of refactor headaches and footguns down
        the line.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>For more information on <code>let</code> and block scoping, see Chapter 3
        of the <em>Scope &amp; Closures</em> title of this series.</p>
        </div>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="let + for"><div class="sect3" id="idm45967384479512">
        <h3>let + for</h3>
        
        <p>The only exception I’d make to the preference for the <em>explicit</em> form of
        <code>let</code> declaration blocking is a <code>let</code> that appears in the header of a
        <code>for</code> loop. The reason may seem nuanced, but I believe it to be one of
        the more important ES6 features.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[];</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">funcs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code> <code class="kd">function</code><code class="p">(){</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">i</code> <code class="p">);</code>
            <code class="p">}</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">funcs</code><code class="p">[</code><code class="mi">3</code><code class="p">]();</code>     <code class="c1">// 3</code></pre>
        
        <p>The <code>let i</code> in the <code>for</code> header declares an <code>i</code> not just for the <code>for</code>
        loop itself, but it redeclares a new <code>i</code> for each iteration of the loop.
        That means that closures created inside the loop iteration close over
        those per-iteration variables the way you’d expect.</p>
        
        <p>If you tried that same snippet but with <code>var i</code> in the <code>for</code> loop
        header, you’d get <code>5</code> instead of <code>3</code>, because there’d only be one <code>i</code> in
        the outer scope that was closed over, instead of a new <code>i</code> for each
        iteration’s function to close over.</p>
        
        <p>You could also have accomplished the same thing slightly more verbosely:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[];</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">5</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">j</code> <code class="o">=</code> <code class="nx">i</code><code class="p">;</code>
            <code class="nx">funcs</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code> <code class="kd">function</code><code class="p">(){</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">j</code> <code class="p">);</code>
            <code class="p">}</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">funcs</code><code class="p">[</code><code class="mi">3</code><code class="p">]();</code>     <code class="c1">// 3</code></pre>
        
        <p>Here, we forcibly create a new <code>j</code> for each iteration, and then the
        closure works the same way. I prefer the former approach; that extra
        special capability is why I endorse the <code>for (let .. ) ..</code> form. It
        could be argued that it’s somewhat more <em>implicit</em>, but it’s <em>explicit</em>
        enough, and useful enough, for my tastes.</p>
        
        <p><code>let</code> also works the same way with <code>for..in</code> and <code>for..of</code> loops (see <a data-type="xref" href="#forofloops-sect">“for..of Loops”</a>).</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="const Declarations"><div class="sect2" id="idm45967384857320">
        <h2>const Declarations</h2>
        
        <p>There’s one other form of block-scoped declaration to consider: the
        <code>const</code>, which creates <em>constants</em>.</p>
        
        <p>What exactly is a constant? It’s a variable that’s read-only after its
        initial value is set. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6" class="pagebreak-before"><code class="p">{</code>
            <code class="kd">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>   <code class="c1">// 2</code>
        
            <code class="nx">a</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>              <code class="c1">// TypeError!</code>
        <code class="p">}</code></pre>
        
        <p>You are not allowed to change the value the variable holds once it’s
        been set, at declaration time. A <code>const</code> declaration must have an
        explicit initialization. If you wanted a <em>constant</em> with the <code>undefined</code>
        value, you’d have to declare <code>const a = undefined</code> to get it.</p>
        
        <p>Constants are not a restriction on the value itself, but on the
        variable’s assignment of that value. In other words, the value is not
        frozen or immutable because of <code>const</code>, just the assignment of it. If
        the value is complex, such as an object or array, the contents of the
        value can still be modified:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="p">{</code>
            <code class="kd">const</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
            <code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code> <code class="mi">4</code> <code class="p">);</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>       <code class="c1">// [1,2,3,4]</code>
        
            <code class="nx">a</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>                 <code class="c1">// TypeError!</code>
        <code class="p">}</code></pre>
        
        <p>The <code>a</code> variable doesn’t actually hold a constant array; rather, it
        holds a constant reference to the array. The array itself is freely
        mutable.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Assigning an object or array as a constant means that value
        will not be able to be garbage collected until that constant’s lexical
        scope goes away, as the reference to the value can never be unset. That
        may be desirable, but be careful if it’s not your intent!</p>
        </div>
        
        <p>Essentially, <code>const</code> declarations enforce what we’ve stylistically
        signaled with our code for years, where we declared a variable name of
        all uppercase letters and assigned it some literal value that we took
        care never to change. There’s no enforcement on a <code>var</code> assignment, but
        there is now with a <code>const</code> assignment, which can help you catch
        unintended changes.</p>
        
        <p><code>const</code> <em>can</em> be used with variable declarations of <code>for</code>, <code>for..in</code>, and <code>for..of</code> loops (see <a data-type="xref" href="#forofloops-sect">“for..of Loops”</a>). However, an error will be thrown if there’s any attempt to reassign, such as the typical <span class="keep-together"><code>i++</code></span> clause of a <code>for</code> loop.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="const Or Not"><div class="sect3" id="idm45967384217320">
        <h3>const Or Not</h3>
        
        <p>There’s some rumored assumptions that a <code>const</code> could be more
        optimizable by the JS engine in certain scenarios than a <code>let</code> or <code>var</code>
        would be. Theoretically, the engine more easily knows the variable’s
        value/type will never change, so it can eliminate some possible
        tracking.</p>
        
        <p>Whether <code>const</code> really helps here or this is just our own fantasies and
        intuitions, the much more important decision to make is if you intend
        constant behavior or not. Remember: one of the most important roles for
        source code is to communicate clearly, not only to you, but your future
        self and other code collaborators, what your intent is.</p>
        
        <p>Some developers prefer to start out every variable declaration as a
        <code>const</code> and then relax a declaration back to a <code>let</code> if it becomes
        necessary for its value to change in the code. This is an interesting
        perspective, but it’s not clear that it genuinely improves the
        readability or reason-ability of code.</p>
        
        <p>It’s not really a <em>protection</em>, as many believe, because any later
        developer who wants to change a value of a <code>const</code> can just blindly
        change <code>const</code> to <code>let</code> on the declaration. At best, it protects
        accidental change. But again, other than our intuitions and
        sensibilities, there doesn’t appear to be an objective and clear measure of
        what constitutes “accidents” or prevention thereof. Similar mindsets
        exist around type enforcement.</p>
        
        <p>My advice: to avoid potentially confusing code, only use <code>const</code> for
        variables that you’re intentionally and obviously signaling will not
        change. In other words, don’t <em>rely on</em> <code>const</code> for code behavior, but
        instead use it as a tool for signaling intent, when intent can be
        signaled clearly.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Block-Scoped Functions"><div class="sect2" id="idm45967384346280">
        <h2>Block-Scoped Functions</h2>
        
        <p>Starting with ES6, function declarations that occur inside of blocks are
        now specified to be scoped to that block. Prior to ES6, the
        specification did not call for this, but many implementations did it
        anyway. So now the specification meets reality.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="p">{</code>
            <code class="nx">foo</code><code class="p">();</code>                  <code class="c1">// works!</code>
        
            <code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
                <code class="c1">// ..</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">();</code>                      <code class="c1">// ReferenceError</code></pre>
        
        <p>The <code>foo()</code> function is declared inside the <code>{ .. }</code> block, and as of
        ES6 is block-scoped there. So it’s not available outside that block. But
        also note that it is “hoisted” within the block, as opposed to <code>let</code>
        declarations, which suffer the TDZ error trap mentioned earlier.</p>
        
        <p>Block-scoping of function declarations could be a problem if you’ve ever
        written code like this before, and relied on the old legacy
        non-block-scoped behavior:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">if</code> <code class="p">(</code><code class="nx">something</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"1"</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        <code class="k">else</code> <code class="p">{</code>
            <code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"2"</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">();</code>      <code class="c1">// ??</code></pre>
        
        <p>In pre-ES6 environments, <code>foo()</code> would print <code>"2"</code> regardless of the
        value of <code>something</code>, because both function declarations were hoisted
        out of the blocks, and the second one always wins.</p>
        
        <p>In ES6, that last line throws a <code>ReferenceError</code>.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Spread/Rest"><div class="sect1" id="spread-rest-sect">
        <h1>Spread/Rest</h1>
        
        <p>ES6 introduces a new <code>...</code> operator that’s typically referred to as the
        <em>spread</em> or <em>rest</em> operator, depending on where/how it’s used. Let’s
        take a look:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">,</code><code class="nx">z</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="o">...</code><code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">]</code> <code class="p">);</code>              <code class="c1">// 1 2 3</code></pre>
        
        <p>When <code>...</code> is used in front of an array (actually, any <em>iterable</em>, which
        we cover in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>), it acts to “spread” it out into its individual
        values.</p>
        
        <p>You’ll typically see that usage as is shown in that previous snippet,
        when spreading out an array as a set of arguments to a function call. In
        this usage, <code>...</code> acts to give us a simpler syntactic replacement for
        the <code>apply(..)</code> method, which we would typically have used pre-ES6 as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">foo</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code> <code class="kc">null</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">]</code> <code class="p">);</code>     <code class="c1">// 1 2 3</code></pre>
        
        <p>But <code>...</code> can be used to spread out/expand a value in other contexts as
        well, such as inside another array declaration:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">];</code>
        <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[</code> <code class="mi">1</code><code class="p">,</code> <code class="o">...</code><code class="nx">a</code><code class="p">,</code> <code class="mi">5</code> <code class="p">];</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">b</code> <code class="p">);</code>                   <code class="c1">// [1,2,3,4,5]</code></pre>
        
        <p>In this usage, <code>...</code> is basically replacing <code>concat(..)</code>, as it behaves
        like <code>[1].concat( a, [5] )</code> here.</p>
        
        <p>The other common usage of <code>...</code> can be seen as essentially the opposite;
        instead of spreading a value out, the <code>...</code> <em>gathers</em> a set of values
        together into an array. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="o">...</code><code class="nx">z</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code> <code class="p">);</code>           <code class="c1">// 1 2 [3,4,5]</code></pre>
        
        <p>The <code>...z</code> in this snippet is essentially saying: “gather the <em>rest</em> of
        the arguments (if any) into an array called <code>z</code>.” Because <code>x</code> was
        assigned <code>1</code>, and <code>y</code> was assigned <code>2</code>, the rest of the arguments <code>3</code>,
        <code>4</code>, and <code>5</code> were gathered into <code>z</code>.</p>
        
        <p>Of course, if you don’t have any named parameters, the <code>...</code> gathers all
        arguments:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="o">...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">args</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">);</code>            <code class="c1">// [1,2,3,4,5]</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>The <code>...args</code> in the <code>foo(..)</code> function declaration is usually
        called “rest parameters,” because you’re collecting the rest of the
        parameters. I prefer “gather,” because it’s more descriptive of what it
        does rather than what it contains.</p>
        </div>
        
        <p>The best part about this usage is that it provides a very solid
        alternative to using the long-since-deprecated <code>arguments</code> array—actually, it’s not really an array, but an array-like object. Because
        <code>args</code> (or whatever you call it—a lot of people prefer <code>r</code> or <code>rest</code>)
        is a real array, we can get rid of lots of silly pre-ES6 tricks we
        jumped through to make <code>arguments</code> into something we can treat as an
        array.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="c1">// doing things the new ES6 way</code>
        <code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="o">...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// `args` is already a real array</code>
        
            <code class="c1">// discard first element in `args`</code>
            <code class="nx">args</code><code class="p">.</code><code class="nx">shift</code><code class="p">();</code>
        
            <code class="c1">// pass along all of `args` as arguments</code>
            <code class="c1">// to `console.log(..)`</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="o">...</code><code class="nx">args</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="c1">// doing things the old-school pre-ES6 way</code>
        <code class="kd">function </code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
            <code class="c1">// turn `arguments` into a real array</code>
            <code class="kd">var</code> <code class="nx">args</code> <code class="o">=</code> <code class="nb">Array</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">slice</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code> <code class="nx">arguments</code> <code class="p">);</code>
        
            <code class="c1">// add some elements on the end</code>
            <code class="nx">args</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code> <code class="p">);</code>
        
            <code class="c1">// filter out odd numbers</code>
            <code class="nx">args</code> <code class="o">=</code> <code class="nx">args</code><code class="p">.</code><code class="nx">filter</code><code class="p">(</code> <code class="kd">function</code><code class="p">(</code><code class="nx">v</code><code class="p">){</code>
                <code class="k">return</code> <code class="nx">v</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">==</code> <code class="mi">0</code><code class="p">;</code>
            <code class="p">}</code> <code class="p">);</code>
        
            <code class="c1">// pass along all of `args` as arguments</code>
            <code class="c1">// to `foo(..)`</code>
            <code class="nx">foo</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code> <code class="kc">null</code><code class="p">,</code> <code class="nx">args</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">bar</code><code class="p">(</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code> <code class="p">);</code>                  <code class="c1">// 2 4</code></pre>
        
        <p>The <code>...args</code> in the <code>foo(..)</code> function declaration gathers arguments,
        and the <code>...args</code> in the <code>console.log(..)</code> call spreads them out. That’s
        a good illustration of the symmetric but opposite uses of the <code>...</code>
        operator.</p>
        
        <p>Besides the <code>...</code> usage in a function declaration, there’s another case
        where <code>...</code> is used for gathering values, and we’ll look at it in <a data-type="xref" href="#toomany_toofew">“Too Many, Too Few, Just Enough”</a> later in this chapter.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Default Parameter Values"><div class="sect1" id="idm45967384095128">
        <h1>Default Parameter Values</h1>
        
        <p>Perhaps one of the most common idioms in JavaScript relates to setting a
        default value for a function parameter. The way we’ve done this for
        years should look quite familiar:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">x</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">||</code> <code class="mi">11</code><code class="p">;</code>
            <code class="nx">y</code> <code class="o">=</code> <code class="nx">y</code> <code class="o">||</code> <code class="mi">31</code><code class="p">;</code>
        
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">();</code>              <code class="c1">// 42</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code> <code class="p">);</code>        <code class="c1">// 11</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">5</code> <code class="p">);</code>           <code class="c1">// 36</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="kc">null</code><code class="p">,</code> <code class="mi">6</code> <code class="p">);</code>     <code class="c1">// 17</code></pre>
        
        <p>Of course, if you’ve used this pattern before, you know that it’s both
        helpful and a little bit dangerous if, for example, you need to be able
        to pass in what would otherwise be considered a falsy value for one of
        the parameters. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">foo</code><code class="p">(</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">42</code> <code class="p">);</code>       <code class="c1">// 53 &lt;-- Oops, not 42</code></pre>
        
        <p>Why? Because the <code>0</code> is falsy, and so the <code>x || 11</code> results in <code>11</code>, not
        the directly passed in <code>0</code>.</p>
        
        <p>To fix this gotcha, some people will instead write the check more
        verbosely like this:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">x</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code> <code class="o">!==</code> <code class="kc">undefined</code><code class="p">)</code> <code class="o">?</code> <code class="nx">x</code> <code class="o">:</code> <code class="mi">11</code><code class="p">;</code>
            <code class="nx">y</code> <code class="o">=</code> <code class="p">(</code><code class="nx">y</code> <code class="o">!==</code> <code class="kc">undefined</code><code class="p">)</code> <code class="o">?</code> <code class="nx">y</code> <code class="o">:</code> <code class="mi">31</code><code class="p">;</code>
        
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">42</code> <code class="p">);</code>           <code class="c1">// 42</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="kc">undefined</code><code class="p">,</code> <code class="mi">6</code> <code class="p">);</code>    <code class="c1">// 17</code></pre>
        
        <p>Of course, that means any value except <code>undefined</code> can be directly
        passed in. However, <code>undefined</code> will be assumed to signal, “I didn’t
        pass this in.” That works great unless you actually need to be able to
        pass <code>undefined</code> in.</p>
        
        <p>In that case, you could test to see if the argument is actually omitted,
        by it actually not being present in the <code>arguments</code> array, perhaps like
        this:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">x</code> <code class="o">=</code> <code class="p">(</code><code class="mi">0</code> <code class="k">in</code> <code class="nx">arguments</code><code class="p">)</code> <code class="o">?</code> <code class="nx">x</code> <code class="o">:</code> <code class="mi">11</code><code class="p">;</code>
            <code class="nx">y</code> <code class="o">=</code> <code class="p">(</code><code class="mi">1</code> <code class="k">in</code> <code class="nx">arguments</code><code class="p">)</code> <code class="o">?</code> <code class="nx">y</code> <code class="o">:</code> <code class="mi">31</code><code class="p">;</code>
        
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">5</code> <code class="p">);</code>               <code class="c1">// 36</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">5</code><code class="p">,</code> <code class="kc">undefined</code> <code class="p">);</code>    <code class="c1">// NaN</code></pre>
        
        <p>But how would you omit the first <code>x</code> argument without the ability to
        pass in any kind of value (not even <code>undefined</code>) that signals “I’m
        omitting this argument”?</p>
        
        <p><code>foo(,5)</code> is tempting, but it’s invalid syntax. <code>foo.apply(null,[,5])</code>
        seems like it should do the trick, but <code>apply(..)</code>’s quirks here mean
        the arguments are treated as <code>[undefined,5]</code>, which of course
        doesn’t omit.</p>
        
        <p>If you investigate further, you’ll find you can only omit arguments on
        the end (i.e., righthand side) by simply passing fewer arguments than
        “expected,” but you cannot omit arguments in the middle or at the
        beginning of the arguments list. It’s just not possible.</p>
        
        <p>There’s a principle applied to JavaScript’s design here that is
        important to remember: <code>undefined</code> means <em>missing</em>. That is, there’s no
        difference between <code>undefined</code> and <em>missing</em>, at least as far as
        function arguments go.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>There are, confusingly, other places in JS where this particular
        design principle doesn’t apply, such as for arrays with empty slots. See
        the <em>Types &amp; Grammar</em> title of this series for more information.</p>
        </div>
        
        <p>With all this in mind, we can now examine a nice helpful syntax added as of
        ES6 to streamline the assignment of default values to missing arguments:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">11</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">31</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">();</code>                  <code class="c1">// 42</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code> <code class="p">);</code>            <code class="c1">// 11</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">0</code><code class="p">,</code> <code class="mi">42</code> <code class="p">);</code>           <code class="c1">// 42</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">5</code> <code class="p">);</code>               <code class="c1">// 36</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">5</code><code class="p">,</code> <code class="kc">undefined</code> <code class="p">);</code>    <code class="c1">// 36 &lt;-- `undefined` is missing</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">5</code><code class="p">,</code> <code class="kc">null</code> <code class="p">);</code>         <code class="c1">// 5  &lt;-- null coerces to `0`</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="kc">undefined</code><code class="p">,</code> <code class="mi">6</code> <code class="p">);</code>    <code class="c1">// 17 &lt;-- `undefined` is missing</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="kc">null</code><code class="p">,</code> <code class="mi">6</code> <code class="p">);</code>         <code class="c1">// 6  &lt;-- null coerces to `0`</code></pre>
        
        <p>Notice the results and how they imply both subtle differences and
        similarities to the earlier approaches.</p>
        
        <p><code>x = 11</code> in a function declaration is more like
        <code>x !== undefined ? x : 11</code> than the much more common idiom <code>x || 11</code>, so
        you’ll need to be careful in converting your pre-ES6 code to this ES6
        default parameter value syntax.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>A rest/gather parameter (see <a data-type="xref" href="#spread-rest-sect">“Spread/Rest”</a>) cannot have a
        default value. So, while <code>function foo(...vals=[1,2,3]) {</code> might seem like an
        intriguing capability, it’s not valid syntax. You’ll need to continue to
        apply that sort of logic manually if necessary.</p>
        </div>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Default Value Expressions"><div class="sect2" id="idm45967378629208">
        <h2>Default Value Expressions</h2>
        
        <p>Function default values can be more than just simple values like <code>31</code>;
        they can be any valid expression, even a function call:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">bar</code><code class="p">(</code><code class="nx">val</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"bar called!"</code> <code class="p">);</code>
            <code class="k">return</code> <code class="nx">y</code> <code class="o">+</code> <code class="nx">val</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code> <code class="o">=</code> <code class="nx">y</code> <code class="o">+</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">(</code> <code class="nx">x</code> <code class="p">))</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">5</code><code class="p">;</code>
        <code class="nx">foo</code><code class="p">();</code>                              <code class="c1">// "bar called"</code>
                                            <code class="c1">// 8 13</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">10</code> <code class="p">);</code>                          <code class="c1">// "bar called"</code>
                                            <code class="c1">// 10 15</code>
        <code class="nx">y</code> <code class="o">=</code> <code class="mi">6</code><code class="p">;</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="kc">undefined</code><code class="p">,</code> <code class="mi">10</code> <code class="p">);</code>               <code class="c1">// 9 10</code></pre>
        
        <p>As you can see, the default value expressions are lazily evaluated,
        meaning they’re only run if and when they’re needed—that is, when a
        parameter’s argument is omitted or is <code>undefined</code>.</p>
        
        <p>It’s a subtle detail, but the formal parameters in a function
        declaration are in their own scope (think of it as a scope bubble-wrapped around just the <code>( .. )</code> of the function declaration), not in
        the function body’s scope. That means a reference to an identifier in a
        default value expression first matches the formal parameters’ scope
        before looking to an outer scope. See the <em>Scope &amp; Closures</em> title of
        this series for more information.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">w</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
        
        <code class="kd">function </code><code class="nx">foo</code><code class="p">(</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">w</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="nx">z</code> <code class="o">+</code> <code class="mi">1</code> <code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">();</code>                  <code class="c1">// ReferenceError</code></pre>
        
        <p>The <code>w</code> in the <code>w + 1</code> default value expression looks for <code>w</code> in the
        formal parameters’ scope, but does not find it, so the outer scope’s <code>w</code>
        is used. Next, the <code>x</code> in the <code>x + 1</code> default value expression finds <code>x</code>
        in the formal parameters’ scope, and luckily <code>x</code> has already been
        initialized, so the assignment to <code>y</code> works fine.</p>
        
        <p>However, the <code>z</code> in <code>z + 1</code> finds <code>z</code> as a
        not-yet-initialized-at-that-moment parameter variable, so it never tries
        to find the <code>z</code> from the outer scope.</p>
        
        <p>As we mentioned in <a data-type="xref" href="#let-declarations">“let Declarations”</a> earlier in this
        chapter, ES6 has a TDZ, which prevents a variable from being accessed in
        its uninitialized state. As such, the <code>z + 1</code> default value expression
        throws a TDZ <code>ReferenceError</code> error.</p>
        
        <p>Though it’s not necessarily a good idea for code clarity, a default
        value expression can even be an inline function expression call—commonly referred to as an immediately invoked function expression
        (IIFE):</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code> <code class="nx">x</code> <code class="o">=</code>
            <code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">v</code><code class="p">){</code> <code class="k">return</code> <code class="nx">v</code> <code class="o">+</code> <code class="mi">11</code><code class="p">;</code> <code class="p">})(</code> <code class="mi">31</code> <code class="p">)</code>
        <code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">();</code>          <code class="c1">// 42</code></pre>
        
        <p>There will very rarely be any cases where an IIFE (or any other executed
        inline function expression) will be appropriate for default value
        expressions. If you find yourself tempted to do this, take a step back
        and reevaluate!</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>If the IIFE had tried to access the <code>x</code> identifier and had
        not declared its own <code>x</code>, this would also have been a TDZ error, just as
        discussed before.</p>
        </div>
        
        <p>The default value expression in the previous snippet is an IIFE in that
        in the sense that it’s a function that’s executed right inline, via
        <code>(31)</code>. If we had left that part off, the default value assigned to <code>x</code>
        would have just been a function reference itself, perhaps like a default
        callback. There will probably be cases where that pattern will be quite
        useful, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">ajax</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code> <code class="nx">cb</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(){})</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">}</code>
        
        <code class="nx">ajax</code><code class="p">(</code> <code class="s2">"http://some.url.1"</code> <code class="p">);</code></pre>
        
        <p>In this case, we essentially want to default <code>cb</code> to be a no-op empty
        function call if not otherwise specified. The function expression is
        just a function reference, not a function call itself (no invoking <code>()</code>
        on the end of it), which accomplishes that goal.</p>
        
        <p>Since the early days of JS, there’s been a little-known but useful quirk
        available to us: <code>Function.prototype</code> is itself an empty no-op function.
        So, the declaration could have been <code>cb = Function.prototype</code> and saved
        the inline function expression creation.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Destructuring"><div class="sect1" id="destructuring-sect">
        <h1>Destructuring</h1>
        
        <p>ES6 introduces a new syntactic feature called <em>destructuring</em>, which may
        be a little less confusing if you instead think of it as a <em>structured
        assignment</em>. To understand this meaning, consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">tmp</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">(),</code>
            <code class="nx">a</code> <code class="o">=</code> <code class="nx">tmp</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">b</code> <code class="o">=</code> <code class="nx">tmp</code><code class="p">[</code><code class="mi">1</code><code class="p">],</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">tmp</code><code class="p">[</code><code class="mi">2</code><code class="p">];</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">);</code>             <code class="c1">// 1 2 3</code></pre>
        
        <p>As you can see, we created a manual assignment of the values in the
        array that <code>foo()</code> returns to individual variables <code>a</code>, <code>b</code>, and <code>c</code>,
        and to do so we (unfortunately) needed the <code>tmp</code> variable.</p>
        
        <p>Similarly, we can do the following with objects:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code>
                <code class="nx">x</code><code class="o">:</code> <code class="mi">4</code><code class="p">,</code>
                <code class="nx">y</code><code class="o">:</code> <code class="mi">5</code><code class="p">,</code>
                <code class="nx">z</code><code class="o">:</code> <code class="mi">6</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">tmp</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">(),</code>
            <code class="nx">x</code> <code class="o">=</code> <code class="nx">tmp</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="nx">tmp</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="nx">tmp</code><code class="p">.</code><code class="nx">z</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>             <code class="c1">// 4 5 6</code></pre>
        
        <p>The <code>tmp.x</code> property value is assigned to the <code>x</code> variable, and likewise
        for <code>tmp.y</code> to <code>y</code> and <code>tmp.z</code> to <code>z</code>.</p>
        
        <p>Manually assigning indexed values from an array or properties from an object can be thought of as <em>structured assignment</em>. ES6 adds a dedicated syntax for <em>destructuring</em>, specifically <em>array destructuring</em> and <em>object destructuring</em>. This syntax eliminates the need for the <code>tmp</code> variable in the previous snippets, making them much cleaner. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">[</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">]</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        <code class="kd">var</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="nx">z</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">();</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">);</code>             <code class="c1">// 1 2 3</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>             <code class="c1">// 4 5 6</code></pre>
        
        <p>You’re likely more accustomed to seeing syntax like <code>[a,b,c]</code> on the
        righthand side of an <code>=</code> assignment, as the value being assigned.</p>
        
        <p>Destructuring symmetrically flips that pattern, so that <code>[a,b,c]</code> on the
        lefthand side of the <code>=</code> assignment is treated as a kind of “pattern”
        for decomposing the righthand side array value into separate variable
        assignments.</p>
        
        <p>Similarly, <code>{ x: x, y: y, z: z }</code> specifies a “pattern” to decompose the
        object value from <code>bar()</code> into separate variable assignments.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Object Property Assignment Pattern"><div class="sect2" id="idm45967378045400">
        <h2>Object Property Assignment Pattern</h2>
        
        <p>Let’s dig into that <code>{ x: x, .. }</code> syntax from the previous snippet. If
        the property name being matched is the same as the variable you want to
        declare, you can actually shorten the syntax:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">();</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>             <code class="c1">// 4 5 6</code></pre>
        
        <p>Pretty cool, right?</p>
        
        <p>But is <code>{ x, .. }</code> leaving off the <code>x:</code> part or leaving off the <code>: x</code>
        part? We’re actually leaving off the <code>x:</code> part
        when we use the shorter syntax. That may not seem like an important
        detail, but you’ll understand its importance in just a moment.</p>
        
        <p>If you can write the shorter form, why would you ever write out the
        longer form? Because that longer form actually allows you to assign a
        property to a different variable name, which can sometimes be quite
        useful:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">bam</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">baz</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="nx">bap</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">();</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">bam</code><code class="p">,</code> <code class="nx">baz</code><code class="p">,</code> <code class="nx">bap</code> <code class="p">);</code>       <code class="c1">// 4 5 6</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>             <code class="c1">// ReferenceError</code></pre>
        
        <p>There’s a subtle but super-important quirk to understand about this
        variation of the object destructuring form. To illustrate why it can be
        a gotcha you need to be careful of, let’s consider the “pattern” of how
        normal object literals are specified:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">X</code> <code class="o">=</code> <code class="mi">10</code><code class="p">,</code> <code class="nx">Y</code> <code class="o">=</code> <code class="mi">20</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="nx">X</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="nx">Y</code> <code class="p">};</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">o</code><code class="p">.</code><code class="nx">a</code><code class="p">,</code> <code class="nx">o</code><code class="p">.</code><code class="nx">b</code> <code class="p">);</code>            <code class="c1">// 10 20</code></pre>
        
        <p>In <code>{ a: X, b: Y }</code>, we know that <code>a</code> is the object property, and <code>X</code> is
        the source value that gets assigned to it. In other words, the syntactic
        pattern is <code>target: source</code>, or more obviously, <code>property-alias: value</code>.
        We intuitively understand this because it’s the same as <code>=</code> assignment,
        where the pattern is <code>target = source</code>.</p>
        
        <p>However, when you use object destructuring assignment—that is,
        putting the <code>{ .. }</code> object literal-looking syntax on the lefthand side
        of the <code>=</code> operator—you invert that <code>target: source</code> pattern.</p>
        
        <p>Recall:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">bam</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">baz</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="nx">bap</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">();</code></pre>
        
        <p>The syntactic pattern here is <code>source: target</code> (or
        <code>value: variable-alias</code>). <code>x: bam</code> means the <code>x</code> property is the source
        value and <code>bam</code> is the target variable to assign to. In other words,
        object literals are <code>target &lt;-- source</code>, and object destructuring
        assignments are <code>source --&gt; target</code>. See how that’s flipped?</p>
        
        <p>There’s another way to think about this syntax though, which may help
        ease the confusion. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">aa</code> <code class="o">=</code> <code class="mi">10</code><code class="p">,</code> <code class="nx">bb</code> <code class="o">=</code> <code class="mi">20</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">aa</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">bb</code> <code class="p">};</code>
        <code class="kd">var</code>     <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">AA</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">BB</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">o</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">AA</code><code class="p">,</code> <code class="nx">BB</code> <code class="p">);</code>              <code class="c1">// 10 20</code></pre>
        
        <p>In the <code>{ x: aa, y: bb }</code> line, the <code>x</code> and <code>y</code> represent the object
        properties. In the <code>{ x: AA, y: BB }</code> line, the <code>x</code> and <code>y</code> <em>also</em>
        represent the object properties.</p>
        
        <p>Recall how earlier I asserted that <code>{ x, .. }</code> was leaving off the <code>x:</code>
        part? In those two lines, if you erase the <code>x:</code> and <code>y:</code> parts in that
        snippet, you’re left only with <code>aa, bb</code> and <code>AA, BB</code>, which in
        effect—only conceptually, not actually—are assignments from <code>aa</code> to <code>AA</code> and from <code>bb</code> to <code>BB</code>.</p>
        
        <p>So, that symmetry may help to explain why the syntactic pattern was
        intentionally flipped for this ES6 feature.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>I would have preferred the syntax to be <code>{ AA: x , BB: y }</code> for
        the destructuring assignment, as that would have preserved consistency
        of the more familiar <code>target: source</code> pattern for both usages. Alas, I’m
        having to train my brain for the inversion, as some readers may also
        have to do.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Not Just Declarations"><div class="sect2" id="idm45967378044456">
        <h2>Not Just Declarations</h2>
        
        <p>So far, we’ve used destructuring assignment with <code>var</code> declarations (of
        course, they could also use <code>let</code> and <code>const</code>), but destructuring is a
        general assignment operation, not just a declaration.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">;</code>
        
        <code class="p">[</code><code class="nx">a</code><code class="p">,</code><code class="nx">b</code><code class="p">,</code><code class="nx">c</code><code class="p">]</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        <code class="p">(</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">()</code> <code class="p">);</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">);</code>             <code class="c1">// 1 2 3</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>             <code class="c1">// 4 5 6</code></pre>
        
        <p>The variables can already be declared, and then the destructuring only
        does assignments, exactly as we’ve already seen.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>For the object destructuring form specifically, when leaving off
        a <code>var</code>/<code>let</code>/<code>const</code> declarator, we had to surround the whole
        assignment expression in <code>( )</code>, because otherwise the <code>{ .. }</code> on the
        lefthand side as the first element in the statement is taken to be a
        block statement instead of an object.</p>
        </div>
        
        <p>In fact, the assignment expressions (<code>a</code>, <code>y</code>, etc.) don’t actually need
        to be just variable identifiers. Anything that’s a valid assignment
        expression is allowed. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{};</code>
        
        <code class="p">[</code><code class="nx">o</code><code class="p">.</code><code class="nx">a</code><code class="p">,</code> <code class="nx">o</code><code class="p">.</code><code class="nx">b</code><code class="p">,</code> <code class="nx">o</code><code class="p">.</code><code class="nx">c</code><code class="p">]</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        <code class="p">(</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">o</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="nx">o</code><code class="p">.</code><code class="nx">z</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">()</code> <code class="p">);</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">o</code><code class="p">.</code><code class="nx">a</code><code class="p">,</code> <code class="nx">o</code><code class="p">.</code><code class="nx">b</code><code class="p">,</code> <code class="nx">o</code><code class="p">.</code><code class="nx">c</code> <code class="p">);</code>       <code class="c1">// 1 2 3</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">o</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">o</code><code class="p">.</code><code class="nx">z</code> <code class="p">);</code>       <code class="c1">// 4 5 6</code></pre>
        
        <p>You can even use computed property expressions in the destructuring.
        Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">which</code> <code class="o">=</code> <code class="s2">"x"</code><code class="p">,</code>
            <code class="nx">o</code> <code class="o">=</code> <code class="p">{};</code>
        
        <code class="p">(</code> <code class="p">{</code> <code class="p">[</code><code class="nx">which</code><code class="p">]</code><code class="o">:</code> <code class="nx">o</code><code class="p">[</code><code class="nx">which</code><code class="p">]</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">()</code> <code class="p">);</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code> <code class="p">);</code>                 <code class="c1">// 4</code></pre>
        
        <p>The <code>[which]:</code> part is the computed property, which results in <code>x</code>—the property to destructure from the object in question as the source of
        the assignment. The <code>o[which]</code> part is just a normal object key
        reference, which equates to <code>o.x</code> as the target of the assignment.</p>
        
        <p>You can use the general assignments to create object
        mappings/transformations, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="mi">3</code> <code class="p">},</code>
            <code class="nx">o2</code> <code class="o">=</code> <code class="p">{};</code>
        
        <code class="p">(</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">z</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">o1</code> <code class="p">);</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">z</code> <code class="p">);</code>    <code class="c1">// 1 2 3</code></pre>
        
        <p>Or you can map an object to an array, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code> <code class="mi">3</code> <code class="p">},</code>
            <code class="nx">a2</code> <code class="o">=</code> <code class="p">[];</code>
        
        <code class="p">(</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="nx">a2</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">b</code><code class="o">:</code> <code class="nx">a2</code><code class="p">[</code><code class="mi">1</code><code class="p">],</code> <code class="nx">c</code><code class="o">:</code> <code class="nx">a2</code><code class="p">[</code><code class="mi">2</code><code class="p">]</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">o1</code> <code class="p">);</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a2</code> <code class="p">);</code>                  <code class="c1">// [1,2,3]</code></pre>
        
        <p>Or the other way around:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a1</code> <code class="o">=</code> <code class="p">[</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code> <code class="p">],</code>
            <code class="nx">o2</code> <code class="o">=</code> <code class="p">{};</code>
        
        <code class="p">[</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">a</code><code class="p">,</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">b</code><code class="p">,</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">c</code> <code class="p">]</code> <code class="o">=</code> <code class="nx">a1</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">a</code><code class="p">,</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">b</code><code class="p">,</code> <code class="nx">o2</code><code class="p">.</code><code class="nx">c</code> <code class="p">);</code>    <code class="c1">// 1 2 3</code></pre>
        
        <p>Or you could reorder one array to another:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a1</code> <code class="o">=</code> <code class="p">[</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code> <code class="p">],</code>
            <code class="nx">a2</code> <code class="o">=</code> <code class="p">[];</code>
        
        <code class="p">[</code> <code class="nx">a2</code><code class="p">[</code><code class="mi">2</code><code class="p">],</code> <code class="nx">a2</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">a2</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="p">]</code> <code class="o">=</code> <code class="nx">a1</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a2</code> <code class="p">);</code>                  <code class="c1">// [2,3,1]</code></pre>
        
        <p>You can even solve the traditional “swap two variables” task without a
        temporary variable:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">10</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">20</code><code class="p">;</code>
        
        <code class="p">[</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">x</code> <code class="p">]</code> <code class="o">=</code> <code class="p">[</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">];</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">);</code>                <code class="c1">// 20 10</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Be careful: you shouldn’t mix in declaration with
        assignment unless you want all of the assignment expressions <em>also</em> to
        be treated as declarations. Otherwise, you’ll get syntax errors. That’s
        why in the earlier example I had to do <code>var a2 = []</code> separately from the
        <code>[ a2[0], .. ] = ..</code> destructuring assignment. It wouldn’t make any
        sense to try <code>var [ a2[0], .. ] = ..</code>, because <code>a2[0]</code> isn’t a valid
        declaration identifier; it also obviously couldn’t implicitly create a
        <code>var a2 = []</code> declaration.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Repeated Assignments"><div class="sect2" id="idm45967377695464">
        <h2>Repeated Assignments</h2>
        
        <p>The object destructuring form allows a source property (holding any value type) to be listed multiple times. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="nx">X</code><code class="p">,</code> <code class="nx">a</code><code class="o">:</code> <code class="nx">Y</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="mi">1</code> <code class="p">};</code>
        
        <code class="nx">X</code><code class="p">;</code>  <code class="c1">// 1</code>
        <code class="nx">Y</code><code class="p">;</code>  <code class="c1">// 1</code></pre>
        
        <p>That also means you can both destructure a sub-object/array property and also capture the sub-object/array’s value itself. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">X</code><code class="p">,</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">Y</code> <code class="p">},</code> <code class="nx">a</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code> <code class="p">}</code> <code class="p">};</code>
        
        <code class="nx">X</code><code class="p">;</code>  <code class="c1">// 1</code>
        <code class="nx">Y</code><code class="p">;</code>  <code class="c1">// 1</code>
        <code class="nx">a</code><code class="p">;</code>  <code class="c1">// { x: 1 }</code>
        
        <code class="p">(</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="nx">X</code><code class="p">,</code> <code class="nx">a</code><code class="o">:</code> <code class="nx">Y</code><code class="p">,</code> <code class="nx">a</code><code class="o">:</code> <code class="p">[</code> <code class="nx">Z</code> <code class="p">]</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="p">[</code> <code class="mi">1</code> <code class="p">]</code> <code class="p">}</code> <code class="p">);</code>
        
        <code class="nx">X</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code> <code class="mi">2</code> <code class="p">);</code>
        <code class="nx">Y</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>
        
        <code class="nx">X</code><code class="p">;</code>  <code class="c1">// [10,2]</code>
        <code class="nx">Y</code><code class="p">;</code>  <code class="c1">// [10,2]</code>
        <code class="nx">Z</code><code class="p">;</code>  <code class="c1">// 1</code></pre>
        
        <p>A word of caution about destructuring: it may be tempting to list destructuring assignments all on a single line as has been done thus far in our discussion. However, it’s a much better idea to spread destructuring assignment patterns over multiple lines, using proper indentation—much like you would in JSON or with an object literal value—for readability’s sake.</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="c1">// harder to read:</code>
        <code class="kd">var</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code> <code class="p">{</code> <code class="nx">b</code><code class="o">:</code> <code class="p">[</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">d</code> <code class="p">],</code> <code class="nx">e</code><code class="o">:</code> <code class="p">{</code> <code class="nx">f</code> <code class="p">}</code> <code class="p">},</code> <code class="nx">g</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">;</code>
        
        <code class="c1">// better:</code>
        <code class="kd">var</code> <code class="p">{</code>
            <code class="nx">a</code><code class="o">:</code> <code class="p">{</code>
                <code class="nx">b</code><code class="o">:</code> <code class="p">[</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">d</code> <code class="p">],</code>
                <code class="nx">e</code><code class="o">:</code> <code class="p">{</code> <code class="nx">f</code> <code class="p">}</code>
            <code class="p">},</code>
            <code class="nx">g</code>
        <code class="p">}</code> <code class="o">=</code> <code class="nx">obj</code><code class="p">;</code></pre>
        
        <p>Remember: the purpose of destructuring is not just less typing, but more declarative readability.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Destructuring Assignment Expressions"><div class="sect3" id="idm45967376846216">
        <h3>Destructuring Assignment Expressions</h3>
        
        <p>The assignment expression with object or array destructuring has as its
        completion value the full righthand object/array value. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code><code class="mi">1</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code><code class="mi">2</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code><code class="mi">3</code> <code class="p">},</code>
            <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">p</code><code class="p">;</code>
        
        <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">o</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">);</code>         <code class="c1">// 1 2 3</code>
        <code class="nx">p</code> <code class="o">===</code> <code class="nx">o</code><code class="p">;</code>                        <code class="c1">// true</code></pre>
        
        <p>In the previous snippet, <code>p</code> was assigned the <code>o</code> object reference, not
        one of the <code>a</code>, <code>b</code>, or <code>c</code> values. The same is true of array
        destructuring:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">],</code>
            <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">p</code><code class="p">;</code>
        
        <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">o</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">);</code>         <code class="c1">// 1 2 3</code>
        <code class="nx">p</code> <code class="o">===</code> <code class="nx">o</code><code class="p">;</code>                        <code class="c1">// true</code></pre>
        
        <p>By carrying the object/array value through as the completion, you can
        chain destructuring assignment expressions together:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">a</code><code class="o">:</code><code class="mi">1</code><code class="p">,</code> <code class="nx">b</code><code class="o">:</code><code class="mi">2</code><code class="p">,</code> <code class="nx">c</code><code class="o">:</code><code class="mi">3</code> <code class="p">},</code>
            <code class="nx">p</code> <code class="o">=</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">6</code><code class="p">],</code>
            <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">;</code>
        
        <code class="p">(</code> <code class="p">{</code><code class="nx">a</code><code class="p">}</code> <code class="o">=</code> <code class="p">{</code><code class="nx">b</code><code class="p">,</code><code class="nx">c</code><code class="p">}</code> <code class="o">=</code> <code class="nx">o</code> <code class="p">);</code>
        <code class="p">[</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">z</code><code class="p">]</code> <code class="o">=</code> <code class="nx">p</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">);</code>         <code class="c1">// 1 2 3</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>         <code class="c1">// 4 5 4</code></pre>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Too Many, Too Few, Just Enough"><div class="sect2" id="toomany_toofew">
        <h2>Too Many, Too Few, Just Enough</h2>
        
        <p>With both array destructuring assignment and object destructuring
        assignment, you do not have to assign all the values that are present.
        For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">[,</code><code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        <code class="kd">var</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">z</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">();</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>             <code class="c1">// 2 4 6</code></pre>
        
        <p>The <code>1</code> and <code>3</code> values that came back from <code>foo()</code> are discarded, as is
        the <code>5</code> value from <code>bar()</code>.</p>
        
        <p>Similarly, if you try to assign more values than are present in the
        value you’re destructuring/decomposing, you get graceful fallback to
        <code>undefined</code>, as you’d expect:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">[,,</code><code class="nx">c</code><code class="p">,</code><code class="nx">d</code><code class="p">]</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        <code class="kd">var</code> <code class="p">{</code> <code class="nx">w</code><code class="p">,</code> <code class="nx">z</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">();</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">z</code> <code class="p">);</code>                <code class="c1">// 3 6</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">d</code><code class="p">,</code> <code class="nx">w</code> <code class="p">);</code>                <code class="c1">// undefined undefined</code></pre>
        
        <p>This behavior follows symmetrically from the earlier stated “<code>undefined</code>
        is missing” principle.</p>
        
        <p>We examined the <code>...</code> operator earlier in this chapter, and saw that it
        can sometimes be used to spread an array value out into its separate
        values, and sometimes it can be used to do the opposite: to gather a set
        of values together into an array.</p>
        
        <p>In addition to the gather/rest usage in function declarations, <code>...</code> can
        perform the same behavior in destructuring assignments. To illustrate,
        let’s recall a snippet from earlier in this chapter:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">];</code>
        <code class="kd">var</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[</code> <code class="mi">1</code><code class="p">,</code> <code class="o">...</code><code class="nx">a</code><code class="p">,</code> <code class="mi">5</code> <code class="p">];</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">b</code> <code class="p">);</code>                   <code class="c1">// [1,2,3,4,5]</code></pre>
        
        <p>Here we see that <code>...a</code> is spreading <code>a</code> out, because it appears in the
        array <code>[ .. ]</code> value position. If <code>...a</code> appears in an array
        destructuring position, it performs the gather behavior:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">];</code>
        <code class="kd">var</code> <code class="p">[</code> <code class="nx">b</code><code class="p">,</code> <code class="o">...</code><code class="nx">c</code> <code class="p">]</code> <code class="o">=</code> <code class="nx">a</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code> <code class="p">);</code>                <code class="c1">// 2 [3,4]</code></pre>
        
        <p>The <code>var [ .. ] = a</code> destructuring assignment spreads <code>a</code> out to be
        assigned to the pattern described inside the <code>[ .. ]</code>. The first part
        names <code>b</code> for the first value in <code>a</code> (<code>2</code>). But then <code>...c</code> gathers the
        rest of the values (<code>3</code> and <code>4</code>) into an array and calls it <code>c</code>.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>We’ve seen how <code>...</code> works with arrays, but what about with
        objects? It’s not an ES6 feature, but see <a data-type="xref" href="ch08.html#chapter-8-beyond-es6">Chapter&nbsp;8</a> for discussion of a
        possible “beyond ES6” feature where <code>...</code> works with spreading or
        gathering objects.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Default Value Assignment"><div class="sect2" id="idm45967376575240">
        <h2>Default Value Assignment</h2>
        
        <p>Both forms of destructuring can offer a default value option for an
        assignment, using the <code>=</code> syntax similar to the default function
        argument values discussed earlier.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">[</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">b</code> <code class="o">=</code> <code class="mi">6</code><code class="p">,</code> <code class="nx">c</code> <code class="o">=</code> <code class="mi">9</code><code class="p">,</code> <code class="nx">d</code> <code class="o">=</code> <code class="mi">12</code> <code class="p">]</code> <code class="o">=</code> <code class="nx">foo</code><code class="p">();</code>
        <code class="kd">var</code> <code class="p">{</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">5</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">10</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="mi">15</code><code class="p">,</code> <code class="nx">w</code> <code class="o">=</code> <code class="mi">20</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">();</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">d</code> <code class="p">);</code>          <code class="c1">// 1 2 3 12</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">,</code> <code class="nx">w</code> <code class="p">);</code>          <code class="c1">// 4 5 6 20</code></pre>
        
        <p>You can combine the default value assignment with the alternative
        assignment expression syntax covered earlier. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">,</code> <code class="nx">w</code><code class="o">:</code> <code class="nx">WW</code> <code class="o">=</code> <code class="mi">20</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">bar</code><code class="p">();</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">,</code> <code class="nx">WW</code> <code class="p">);</code>         <code class="c1">// 4 5 6 20</code></pre>
        
        <p>Be careful about confusing yourself (or other developers who read your
        code) if you use an object or array as the default value in a destructuring.
        You can create some really hard-to-understand code:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">200</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">300</code><code class="p">,</code> <code class="nx">z</code> <code class="o">=</code> <code class="mi">100</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">42</code> <code class="p">},</code> <code class="nx">z</code><code class="o">:</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">z</code> <code class="p">}</code> <code class="p">};</code>
        
        <code class="p">(</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">x</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y</code> <code class="p">}</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">o1</code> <code class="p">);</code>
        <code class="p">(</code> <code class="p">{</code> <code class="nx">z</code><code class="o">:</code> <code class="nx">y</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">z</code> <code class="p">}</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">o1</code> <code class="p">);</code>
        <code class="p">(</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">z</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">x</code> <code class="p">}</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">o1</code> <code class="p">);</code></pre>
        
        <p>Can you tell from that snippet what values <code>x</code>, <code>y</code>, and <code>z</code> have at the
        end? Takes a moment of pondering, I would imagine. I’ll end the
        suspense:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">y</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">.</code><code class="nx">y</code> <code class="p">);</code>       <code class="c1">// 300 100 42</code></pre>
        
        <p>The takeaway here: destructuring is great and can be very useful, but
        it’s also a sharp sword that can cause injury (to someone’s brain) if
        used unwisely.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Nested Destructuring"><div class="sect2" id="idm45967376199480">
        <h2>Nested Destructuring</h2>
        
        <p>If the values you’re destructuring have nested objects or arrays, you
        can destructure those nested values as well:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a1</code> <code class="o">=</code> <code class="p">[</code> <code class="mi">1</code><code class="p">,</code> <code class="p">[</code><code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code> <code class="mi">5</code> <code class="p">];</code>
        <code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="p">{</code> <code class="nx">z</code><code class="o">:</code> <code class="mi">6</code> <code class="p">}</code> <code class="p">}</code> <code class="p">};</code>
        
        <code class="kd">var</code> <code class="p">[</code> <code class="nx">a</code><code class="p">,</code> <code class="p">[</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">d</code> <code class="p">],</code> <code class="nx">e</code> <code class="p">]</code> <code class="o">=</code> <code class="nx">a1</code><code class="p">;</code>
        <code class="kd">var</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="p">{</code> <code class="nx">z</code><code class="o">:</code> <code class="nx">w</code> <code class="p">}</code> <code class="p">}</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">o1</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">c</code><code class="p">,</code> <code class="nx">d</code><code class="p">,</code> <code class="nx">e</code> <code class="p">);</code>       <code class="c1">// 1 2 3 4 5</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">w</code> <code class="p">);</code>                   <code class="c1">// 6</code></pre>
        
        <p>Nested destructuring can be a simple way to flatten out object
        namespaces. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">App</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">model</code><code class="o">:</code> <code class="p">{</code>
                <code class="nx">User</code><code class="o">:</code> <code class="kd">function</code><code class="p">(){</code> <code class="p">..</code> <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="c1">// instead of:</code>
        <code class="c1">// var User = App.model.User;</code>
        
        <code class="kd">var</code> <code class="p">{</code> <code class="nx">model</code><code class="o">:</code> <code class="p">{</code> <code class="nx">User</code> <code class="p">}</code> <code class="p">}</code> <code class="o">=</code> <code class="nx">App</code><code class="p">;</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Destructuring Parameters"><div class="sect2" id="idm45967375719896">
        <h2>Destructuring Parameters</h2>
        
        <p>In the following snippet, can you spot the assignment?</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="mi">42</code> <code class="p">);</code></pre>
        
        <p>The assignment is kinda hidden: <code>42</code> (the argument) is assigned to <code>x</code>
        (the parameter) when <code>foo(42)</code> is executed. If parameter/argument
        pairing is an assignment, then it stands to reason that it’s an
        assignment that could be destructured, right? Of course!</p>
        
        <p>Consider array destructuring for parameters:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code> <code class="p">[</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">]</code> <code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="p">[</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code> <code class="p">]</code> <code class="p">);</code>                    <code class="c1">// 1 2</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="p">[</code> <code class="mi">1</code> <code class="p">]</code> <code class="p">);</code>                       <code class="c1">// 1 undefined</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="p">[]</code> <code class="p">);</code>                          <code class="c1">// undefined undefined</code></pre>
        
        <p>Object destructuring for parameters works, too:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">}</code> <code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">foo</code><code class="p">(</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">2</code> <code class="p">}</code> <code class="p">);</code>              <code class="c1">// 2 1</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">42</code> <code class="p">}</code> <code class="p">);</code>                   <code class="c1">// undefined 42</code>
        <code class="nx">foo</code><code class="p">(</code> <code class="p">{}</code> <code class="p">);</code>                          <code class="c1">// undefined undefined</code></pre>
        
        <p>This technique is an approximation of named arguments (a long requested
        feature for JS!), in that the properties on the object map to the
        destructured parameters of the same names. That also means that we get
        optional parameters (in any position) for free; as you can see, leaving
        off the <code>x</code> “parameter” worked as we’d expect.</p>
        
        <p>Of course, all the previously discussed variations of destructuring are
        available to us with parameter destructuring, including nested
        destructuring, default values, and more. Destructuring also mixes fine
        with other ES6 function parameter capabilities, like default parameter
        values and rest/gather parameters.</p>
        
        <p>Consider these quick illustrations (certainly not exhaustive of the
        possible variations):</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">f1</code><code class="p">([</code> <code class="nx">x</code><code class="o">=</code><code class="mi">2</code><code class="p">,</code> <code class="nx">y</code><code class="o">=</code><code class="mi">3</code><code class="p">,</code> <code class="nx">z</code> <code class="p">])</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="kd">function </code><code class="nx">f2</code><code class="p">([</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="o">...</code><code class="nx">z</code><code class="p">],</code> <code class="nx">w</code><code class="p">)</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="kd">function </code><code class="nx">f3</code><code class="p">([</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="o">...</code><code class="nx">z</code><code class="p">],</code> <code class="o">...</code><code class="nx">w</code><code class="p">)</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        
        <code class="kd">function </code><code class="nx">f4</code><code class="p">({</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">X</code><code class="p">,</code> <code class="nx">y</code> <code class="p">})</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="kd">function </code><code class="nx">f5</code><code class="p">({</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">X</code> <code class="o">=</code> <code class="mi">10</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">20</code> <code class="p">})</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="kd">function </code><code class="nx">f6</code><code class="p">({</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">10</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{},</code> <code class="p">{</code> <code class="nx">y</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">10</code> <code class="p">})</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code></pre>
        
        <p>Let’s take one example from this snippet and examine it, for
        illustration purposes:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">f3</code><code class="p">([</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="o">...</code><code class="nx">z</code><code class="p">],</code> <code class="o">...</code><code class="nx">w</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="p">,</code> <code class="nx">w</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">f3</code><code class="p">(</code> <code class="p">[]</code> <code class="p">);</code>                           <code class="c1">// undefined undefined [] []</code>
        <code class="nx">f3</code><code class="p">(</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">],</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code> <code class="p">);</code>              <code class="c1">// 1 2 [3,4] [5,6]</code></pre>
        
        <p>There are two <code>...</code> operators in use here, and they’re both gathering
        values in arrays (<code>z</code> and <code>w</code>), though <code>...z</code> gathers from the rest of
        the values left over in the first array argument, while <code>...w</code> gathers
        from the rest of the main arguments left over after the first.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Destructuring Defaults + Parameter Defaults"><div class="sect3" id="idm45967375186872">
        <h3>Destructuring Defaults + Parameter Defaults</h3>
        
        <p>There’s one subtle point you should be particularly careful to notice—the difference in behavior between a destructuring default value and a
        function parameter default value. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">f6</code><code class="p">({</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">10</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{},</code> <code class="p">{</code> <code class="nx">y</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">10</code> <code class="p">})</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">f6</code><code class="p">();</code>                               <code class="c1">// 10 10</code></pre>
        
        <p>At first, it would seem that we’ve declared a default value of <code>10</code> for
        both the <code>x</code> and <code>y</code> parameters, but in two different ways. However,
        these two different approaches will behave differently in certain cases,
        and the difference is awfully subtle.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">f6</code><code class="p">(</code> <code class="p">{},</code> <code class="p">{}</code> <code class="p">);</code>                       <code class="c1">// 10 undefined</code></pre>
        
        <p>Wait, why did that happen? It’s pretty clear that named parameter <code>x</code> is
        defaulting to <code>10</code> if not passed as a property of that same name in the
        first argument’s object.</p>
        
        <p>But what about <code>y</code> being <code>undefined</code>? The <code>{ y: 10 }</code> value is an object
        as a function parameter default value, not a destructuring default
        value. As such, it only applies if the second argument is not passed at
        all, or is passed as <code>undefined</code>.</p>
        
        <p>In the previous snippet, we <em>are</em> passing a second argument (<code>{}</code>), so
        the default <code>{ y: 10 }</code> value is not used, and the <code>{ y }</code> destructuring
        occurs against the passed-in <code>{}</code> empty object value.</p>
        
        <p>Now, compare <code>{ y } = { y: 10 }</code> to <code>{ x = 10 } = {}</code>.</p>
        
        <p>For the <code>x</code>’s form usage, if the first function argument is omitted or
        <code>undefined</code>, the <code>{}</code> empty object default applies. Then, whatever value
        is in the first argument position—either the default <code>{}</code> or whatever
        you passed in—is destructured with the <code>{ x = 10 }</code>, which checks to
        see if an <code>x</code> property is found, and if not found (or <code>undefined</code>), the
        <code>10</code> default value is applied to the <code>x</code> named <span class="keep-together">parameter</span>.</p>
        
        <p>Deep breath. Read back over those last few paragraphs a couple of times.
        Let’s review via code:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">f6</code><code class="p">({</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">10</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{},</code> <code class="p">{</code> <code class="nx">y</code> <code class="p">}</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">10</code> <code class="p">})</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">f6</code><code class="p">();</code>                               <code class="c1">// 10 10</code>
        <code class="nx">f6</code><code class="p">(</code> <code class="kc">undefined</code><code class="p">,</code> <code class="kc">undefined</code> <code class="p">);</code>         <code class="c1">// 10 10</code>
        <code class="nx">f6</code><code class="p">(</code> <code class="p">{},</code> <code class="kc">undefined</code> <code class="p">);</code>                <code class="c1">// 10 10</code>
        
        <code class="nx">f6</code><code class="p">(</code> <code class="p">{},</code> <code class="p">{}</code> <code class="p">);</code>                       <code class="c1">// 10 undefined</code>
        <code class="nx">f6</code><code class="p">(</code> <code class="kc">undefined</code><code class="p">,</code> <code class="p">{}</code> <code class="p">);</code>                <code class="c1">// 10 undefined</code>
        
        <code class="nx">f6</code><code class="p">(</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code> <code class="p">{</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">3</code> <code class="p">}</code> <code class="p">);</code>           <code class="c1">// 2 3</code></pre>
        
        <p>It would generally seem that the defaulting behavior of the <code>x</code>
        parameter is probably the more desirable and sensible case compared to
        that of <code>y</code>. As such, it’s important to understand why and how
        <code>{ x = 10 } = {}</code> form is different from <code>{ y } = { y: 10 }</code> form.</p>
        
        <p>If that’s still a bit fuzzy, go back and read it again, and play with
        this yourself. Your future self will thank you for taking the time to
        get this very subtle gotcha nuance detail straight.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Nested Defaults: Destructured and Restructured"><div class="sect3" id="idm45967375186248">
        <h3>Nested Defaults: Destructured and Restructured</h3>
        
        <p>Although it may at first be difficult to grasp, an interesting idiom
        emerges for setting defaults for a nested object’s properties: using
        object destructuring along with what I’d call <em>restructuring</em>.</p>
        
        <p>Consider a set of defaults in a nested object structure, like the
        following:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="c1">// taken from:</code>
        <code class="c1">// http://es-discourse.com/t/partial-default-arguments/120/7</code>
        
        <code class="kd">var</code> <code class="nx">defaults</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">options</code><code class="o">:</code> <code class="p">{</code>
                <code class="nx">remove</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
                <code class="nx">enable</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
                <code class="nx">instance</code><code class="o">:</code> <code class="p">{}</code>
            <code class="p">},</code>
            <code class="nx">log</code><code class="o">:</code> <code class="p">{</code>
                <code class="nx">warn</code><code class="o">:</code> <code class="kc">true</code><code class="p">,</code>
                <code class="nx">error</code><code class="o">:</code> <code class="kc">true</code>
            <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>Now, let’s say you have an object called <code>config</code>, which has some
        of these applied, but perhaps not all, and you’d like to set all the
        defaults into this object in the missing spots, but not override
        specific settings already present:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">config</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">options</code><code class="o">:</code> <code class="p">{</code>
                <code class="nx">remove</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code>
                <code class="nx">instance</code><code class="o">:</code> <code class="kc">null</code>
            <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>You can of course do so manually, as you might have done in the past:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">config</code><code class="p">.</code><code class="nx">options</code> <code class="o">=</code> <code class="nx">config</code><code class="p">.</code><code class="nx">options</code> <code class="o">||</code> <code class="p">{};</code>
        <code class="nx">config</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">remove</code> <code class="o">=</code> <code class="p">(</code><code class="nx">config</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">remove</code> <code class="o">!==</code> <code class="kc">undefined</code><code class="p">)</code> <code class="o">?</code>
            <code class="nx">config</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">remove</code> <code class="o">:</code> <code class="nx">defaults</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">remove</code><code class="p">;</code>
        <code class="nx">config</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">enable</code> <code class="o">=</code> <code class="p">(</code><code class="nx">config</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">enable</code> <code class="o">!==</code> <code class="kc">undefined</code><code class="p">)</code> <code class="o">?</code>
            <code class="nx">config</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">enable</code> <code class="o">:</code> <code class="nx">defaults</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">enable</code><code class="p">;</code>
        <code class="o">...</code></pre>
        
        <p>Yuck.</p>
        
        <p>Others may prefer the assign-overwrite approach to this task. You might
        be tempted by the ES6 <code>Object.assign(..)</code> utility (see <a data-type="xref" href="ch06.html#chapter-6-api-additions">Chapter&nbsp;6</a>) to
        clone the properties first from <code>defaults</code> and then overwritten with the
        cloned properties from <code>config</code>, as so:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">config</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code> <code class="p">{},</code> <code class="nx">defaults</code><code class="p">,</code> <code class="nx">config</code> <code class="p">);</code></pre>
        
        <p>That looks way nicer, huh? But there’s a major problem!
        <code>Object.assign(..)</code> is shallow, which means when it copies
        <code>defaults.options</code>, it just copies that object reference, not deep
        cloning that object’s properties to a <code>config.options</code> object.
        <code>Object.assign(..)</code> would need to be applied (sort of “recursively”) at
        all levels of your object’s tree to get the deep cloning you’re
        expecting.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>Many JS utility libraries/frameworks provide their own option
        for deep cloning of an object, but those approaches and their gotchas
        are beyond our scope to discuss here.</p>
        </div>
        
        <p>So let’s examine if ES6 object destructuring with defaults can help at
        all:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">config</code><code class="p">.</code><code class="nx">options</code> <code class="o">=</code> <code class="nx">config</code><code class="p">.</code><code class="nx">options</code> <code class="o">||</code> <code class="p">{};</code>
        <code class="nx">config</code><code class="p">.</code><code class="nx">log</code> <code class="o">=</code> <code class="nx">config</code><code class="p">.</code><code class="nx">log</code> <code class="o">||</code> <code class="p">{};</code>
        <code class="p">{</code>
            <code class="nx">options</code><code class="o">:</code> <code class="p">{</code>
                <code class="nx">remove</code><code class="o">:</code> <code class="nx">config</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">remove</code> <code class="o">=</code> <code class="k">default</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">remove</code><code class="p">,</code>
                <code class="nx">enable</code><code class="o">:</code> <code class="nx">config</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">enable</code> <code class="o">=</code> <code class="k">default</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">enable</code><code class="p">,</code>
                <code class="nx">instance</code><code class="o">:</code> <code class="nx">config</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">instance</code> <code class="o">=</code>
                              <code class="k">default</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">instance</code>
            <code class="p">}</code> <code class="o">=</code> <code class="p">{},</code>
            <code class="nx">log</code><code class="o">:</code> <code class="p">{</code>
                <code class="nx">warn</code><code class="o">:</code> <code class="nx">config</code><code class="p">.</code><code class="nx">log</code><code class="p">.</code><code class="nx">warn</code> <code class="o">=</code> <code class="k">default</code><code class="p">.</code><code class="nx">log</code><code class="p">.</code><code class="nx">warn</code><code class="p">,</code>
                <code class="nx">error</code><code class="o">:</code> <code class="nx">config</code><code class="p">.</code><code class="nx">log</code><code class="p">.</code><code class="nx">error</code> <code class="o">=</code> <code class="k">default</code><code class="p">.</code><code class="nx">log</code><code class="p">.</code><code class="nx">error</code>
            <code class="p">}</code> <code class="o">=</code> <code class="p">{}</code>
        <code class="p">}</code> <code class="o">=</code> <code class="nx">config</code><code class="p">;</code></pre>
        
        <p>Not as nice as the false promise of <code>Object.assign(..)</code> (being that it’s
        shallow only), but it’s better than the manual approach by a fair bit, I
        think. It is still unfortunately verbose and repetitive, though.</p>
        
        <p>The previous snippet’s approach works because I’m hacking the
        destructuring and defaults mechanism to do the property <code>=== undefined</code>
        checks and assignment decisions for me. It’s a trick in that I’m
        destructuring <code>config</code> (see the <code>= config</code> at the end of the snippet),
        but I’m reassigning all the destructured values right back into
        <span class="keep-together"><code>config</code></span>, with the <code>config.options.enable</code> assignment references.</p>
        
        <p>Still too much, though. Let’s see if we can make anything better.</p>
        
        <p>The following trick works best if you know that all the various
        properties you’re destructuring are uniquely named. You can still do it
        even if that’s not the case, but it’s not as nice—you’ll have to do
        the destructuring in stages, or create unique local variables as
        temporary aliases.</p>
        
        <p>If we fully destructure all the properties into top-level variables, we
        can then immediately restructure to reconstitute the original nested
        object structure.</p>
        
        <p>But all those temporary variables hanging around would pollute scope.
        So, let’s use block scoping (see <a data-type="xref" href="#block-scope-declar">“Block-Scoped Declarations”</a> earlier in
        this chapter) with a general <code>{ }</code> enclosing block:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="c1">// merge `defaults` into `config`</code>
        <code class="p">{</code>
            <code class="c1">// destructure (with default value assignments)</code>
            <code class="kd">let</code> <code class="p">{</code>
                <code class="nx">options</code><code class="o">:</code> <code class="p">{</code>
                    <code class="nx">remove</code> <code class="o">=</code> <code class="nx">defaults</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">remove</code><code class="p">,</code>
                    <code class="nx">enable</code> <code class="o">=</code> <code class="nx">defaults</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">enable</code><code class="p">,</code>
                    <code class="nx">instance</code> <code class="o">=</code> <code class="nx">defaults</code><code class="p">.</code><code class="nx">options</code><code class="p">.</code><code class="nx">instance</code>
                <code class="p">}</code> <code class="o">=</code> <code class="p">{},</code>
                <code class="nx">log</code><code class="o">:</code> <code class="p">{</code>
                    <code class="nx">warn</code> <code class="o">=</code> <code class="nx">defaults</code><code class="p">.</code><code class="nx">log</code><code class="p">.</code><code class="nx">warn</code><code class="p">,</code>
                    <code class="nx">error</code> <code class="o">=</code> <code class="nx">defaults</code><code class="p">.</code><code class="nx">log</code><code class="p">.</code><code class="nx">error</code>
                <code class="p">}</code> <code class="o">=</code> <code class="p">{}</code>
            <code class="p">}</code> <code class="o">=</code> <code class="nx">config</code><code class="p">;</code>
        
            <code class="c1">// restructure</code>
            <code class="nx">config</code> <code class="o">=</code> <code class="p">{</code>
                <code class="nx">options</code><code class="o">:</code> <code class="p">{</code> <code class="nx">remove</code><code class="p">,</code> <code class="nx">enable</code><code class="p">,</code> <code class="nx">instance</code> <code class="p">},</code>
                <code class="nx">log</code><code class="o">:</code> <code class="p">{</code> <code class="nx">warn</code><code class="p">,</code> <code class="nx">error</code> <code class="p">}</code>
            <code class="p">};</code>
        <code class="p">}</code></pre>
        
        <p>That seems a fair bit nicer, huh?</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>You could also accomplish the scope enclosure with an arrow IIFE
        instead of the general <code>{ }</code> block and <code>let</code> declarations. Your
        destructuring assignments/defaults would be in the parameter list and
        your restructuring would be the <code>return</code> statement in the function body.</p>
        </div>
        
        <p>The <code>{ warn, error }</code> syntax in the restructuring part may look new to
        you; that’s called “concise properties” and we cover it in the next
        section!</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Object Literal Extensions"><div class="sect1" id="objectliteralExtensions">
        <h1>Object Literal Extensions</h1>
        
        <p>ES6 adds a number of important convenience extensions to the humble
        <code>{ .. }</code> object literal.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Concise Properties"><div class="sect2" id="idm45967374462648">
        <h2>Concise Properties</h2>
        
        <p>You’re certainly familiar with declaring object literals in this form:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">3</code><code class="p">,</code>
            <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
                <code class="nx">x</code><code class="o">:</code> <code class="nx">x</code><code class="p">,</code>
                <code class="nx">y</code><code class="o">:</code> <code class="nx">y</code>
            <code class="p">};</code></pre>
        
        <p>If it’s always felt redundant to say <code>x: x</code> all over, there’s good news.
        If you need to define a property that is the same name as a lexical
        identifier, you can shorten it from <code>x: x</code> to <code>x</code>. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">3</code><code class="p">,</code>
            <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
                <code class="nx">x</code><code class="p">,</code>
                <code class="nx">y</code>
            <code class="p">};</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Concise Methods"><div class="sect2" id="concisemethod_sect">
        <h2>Concise Methods</h2>
        
        <p>In a similar spirit to concise properties we just examined, functions
        attached to properties in object literals also have a concise form, for
        convenience.</p>
        
        <p>The old way:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">x</code><code class="o">:</code> <code class="kd">function</code><code class="p">(){</code>
                <code class="c1">// ..</code>
            <code class="p">},</code>
            <code class="nx">y</code><code class="o">:</code> <code class="kd">function</code><code class="p">(){</code>
                <code class="c1">// ..</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        
        <p>And as of ES6:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">x</code><code class="p">()</code> <code class="p">{</code>
                <code class="c1">// ..</code>
            <code class="p">},</code>
            <code class="nx">y</code><code class="p">()</code> <code class="p">{</code>
                <code class="c1">// ..</code>
            <code class="p">}</code>
        <code class="p">}</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>While <code>x() { .. }</code> seems to just be shorthand for
        <code>x: function(){ .. }</code>, concise methods have special behaviors that their
        older counterparts don’t; specifically, the allowance for <code>super</code> (see
        <a data-type="xref" href="#object-super">“Object super”</a> later in this chapter).</p>
        </div>
        
        <p>Generators (see <a data-type="xref" href="ch04.html#chapter-4-async-flow-control">Chapter&nbsp;4</a>) also have a concise method form:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="o">*</code><code class="nx">foo</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        <code class="p">};</code></pre>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Concisely Unnamed"><div class="sect3" id="idm45967374259720">
        <h3>Concisely Unnamed</h3>
        
        <p>While that convenience shorthand is quite attractive, there’s a subtle
        gotcha to be aware of. To illustrate, let’s examine pre-ES6 code like
        the following, which you might try to refactor to use concise <span class="keep-together">methods</span>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">runSomething</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">(),</code>
                <code class="nx">y</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">();</code>
        
            <code class="k">return</code> <code class="nx">o</code><code class="p">.</code><code class="nx">something</code><code class="p">(</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nx">runSomething</code><code class="p">(</code> <code class="p">{</code>
            <code class="nx">something</code><code class="o">:</code> <code class="kd">function </code><code class="nx">something</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
                    <code class="c1">// recursively call with `x`</code>
                    <code class="c1">// and `y` swapped</code>
                    <code class="k">return</code> <code class="nx">something</code><code class="p">(</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">x</code> <code class="p">);</code>
                <code class="p">}</code>
        
                <code class="k">return</code> <code class="nx">y</code> <code class="o">-</code> <code class="nx">x</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>This obviously silly code just generates two random numbers and
        subtracts the smaller from the bigger. But what’s important here isn’t
        what it does, but rather how it’s defined. Let’s focus on the object
        literal and function definition, as we see here:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">runSomething</code><code class="p">(</code> <code class="p">{</code>
            <code class="nx">something</code><code class="o">:</code> <code class="kd">function </code><code class="nx">something</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// ..</code>
            <code class="p">}</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>Why do we say both <code>something:</code> and <code>function something</code>? Isn’t that
        redundant? Actually, no, both are needed for different purposes. The
        property <code>something</code> is how we can call <code>o.something(..)</code>, sort of like
        its public name. But the second <code>something</code> is a lexical name to refer
        to the function from inside itself, for recursion purposes.</p>
        
        <p>Can you see why the line <code>return something(y,x)</code> needs the name
        <code>something</code> to refer to the function? There’s no lexical name for the
        object, such that it could have said <code>return o.something(y,x)</code> or
        something of that sort.</p>
        
        <p>That’s actually a pretty common practice when the object literal does
        have an identifying name, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">controller</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">makeRequest</code><code class="o">:</code> <code class="kd">function</code><code class="p">(..){</code>
                <code class="c1">// ..</code>
                <code class="nx">controller</code><code class="p">.</code><code class="nx">makeRequest</code><code class="p">(..);</code>
            <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>Is this a good idea? Perhaps, perhaps not. You’re assuming that the name
        <code>controller</code> will always point to the object in question. But it very
        well may not—the <code>makeRequest(..)</code> function doesn’t control the outer
        code and so can’t force that to be the case. This could come back to
        bite you.</p>
        
        <p>Others prefer to use <code>this</code> to define such things:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">controller</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">makeRequest</code><code class="o">:</code> <code class="kd">function</code><code class="p">(..){</code>
                <code class="c1">// ..</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">makeRequest</code><code class="p">(..);</code>
            <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>That looks fine, and should work if you always invoke the method as
        <code>controller.makeRequest(..)</code>. But you now have a <code>this</code> binding gotcha
        if you do something like:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">btn</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code> <code class="s2">"click"</code><code class="p">,</code> <code class="nx">controller</code><code class="p">.</code><code class="nx">makeRequest</code><code class="p">,</code> <code class="kc">false</code> <code class="p">);</code></pre>
        
        <p>Of course, you can solve that by passing
        <code>controller.makeRequest.bind(controller)</code> as the handler reference to
        bind the event to. But yuck—it isn’t very appealing.</p>
        
        <p>Or what if your inner <code>this.makeRequest(..)</code> call needs to be made from
        a nested function? You’ll have another <code>this</code> binding hazard, which
        people will often solve with the hacky <code>var self = this</code>, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">controller</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">makeRequest</code><code class="o">:</code> <code class="kd">function</code><code class="p">(..){</code>
                <code class="kd">var</code> <code class="nb">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
        
                <code class="nx">btn</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code> <code class="s2">"click"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(){</code>
                    <code class="c1">// ..</code>
                    <code class="nb">self</code><code class="p">.</code><code class="nx">makeRequest</code><code class="p">(..);</code>
                <code class="p">},</code> <code class="kc">false</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>More yuck.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>For more information on <code>this</code> binding rules and gotchas, see
        Chapters 1–2 of the <em>this &amp; Object Prototypes</em> title of this series.</p>
        </div>
        
        <p>OK, what does all this have to do with concise methods? Recall our
        <code>something(..)</code> method definition:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">runSomething</code><code class="p">(</code> <code class="p">{</code>
            <code class="nx">something</code><code class="o">:</code> <code class="kd">function </code><code class="nx">something</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// ..</code>
            <code class="p">}</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>The second <code>something</code> here provides a super convenient lexical
        identifier that will always point to the function itself, giving us the
        perfect reference for recursion, event binding/unbinding, and so on—no messing around with <code>this</code> or trying to use an untrustable object
        reference.</p>
        
        <p>Great!</p>
        
        <p>So, now we try to refactor that function reference to this ES6 concise
        method form:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">runSomething</code><code class="p">(</code> <code class="p">{</code>
            <code class="nx">something</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">return</code> <code class="nx">something</code><code class="p">(</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">x</code> <code class="p">);</code>
                <code class="p">}</code>
        
                <code class="k">return</code> <code class="nx">y</code> <code class="o">-</code> <code class="nx">x</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>Seems fine at first glance, except this code will break. The
        <code>return something(..)</code> call will not find a <code>something</code> identifier, so
        you’ll get a <code>ReferenceError</code>. Oops. But why?</p>
        
        <p>The above ES6 snippet is interpreted as meaning:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">runSomething</code><code class="p">(</code> <code class="p">{</code>
            <code class="nx">something</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">){</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&gt;</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">return</code> <code class="nx">something</code><code class="p">(</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">x</code> <code class="p">);</code>
                <code class="p">}</code>
        
                <code class="k">return</code> <code class="nx">y</code> <code class="o">-</code> <code class="nx">x</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>Look closely. Do you see the problem? The concise method definition
        implies <code>something: function(x,y)</code>. See how the second <code>something</code> we
        were relying on has been omitted? In other words, concise methods imply
        anonymous function expressions.</p>
        
        <p>Yeah, yuck.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>You may be tempted to think that <code>=&gt;</code> arrow functions are a good
        solution here, but they’re equally insufficient, as they’re also
        anonymous function expressions. We’ll cover them in <a data-type="xref" href="#arrow-functions">“Arrow Functions”</a>
        later in this chapter.</p>
        </div>
        
        <p>The partially redeeming news is that our <code>something(x,y)</code> concise method
        won’t be totally anonymous. See <a data-type="xref" href="ch07.html#functionNamessect">“Function Names”</a> in <a data-type="xref" href="ch07.html#chapter-7-meta-programming">Chapter&nbsp;7</a> for
        information about ES6 function name inference rules. That won’t help us
        for our recursion, but it helps with debugging at least.</p>
        
        <p>So what are we left to conclude about concise methods? They’re short and
        sweet, and a nice convenience. But you should only use them if you’re
        never going to need them to do recursion or event binding/unbinding.
        Otherwise, stick to your old-school <code>something: function something(..)</code>
        method definitions.</p>
        
        <p>A lot of your methods are probably going to benefit from concise method
        definitions, so that’s great news! Just be careful of the few where
        there’s an un-naming hazard.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="ES5 Getter/Setter"><div class="sect3" id="idm45967374267848">
        <h3>ES5 Getter/Setter</h3>
        
        <p>Technically, ES5 defined getter/setter literals forms, but they didn’t
        seem to get used much, mostly due to the lack of transpilers to handle
        that new syntax (the only major new syntax added in ES5, really). So
        while it’s not a new ES6 feature, we’ll briefly refresh on that form, as
        it’s probably going to be much more useful with ES6 going forward.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">__id</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code>
            <code class="k">get</code><code class="nx"> id</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">__id</code><code class="o">++</code><code class="p">;</code> <code class="p">},</code>
            <code class="k">set</code><code class="nx"> id</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">__id</code> <code class="o">=</code> <code class="nx">v</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="nx">o</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>           <code class="c1">// 10</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>           <code class="c1">// 11</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">id</code> <code class="o">=</code> <code class="mi">20</code><code class="p">;</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">id</code><code class="p">;</code>           <code class="c1">// 20</code>
        
        <code class="c1">// and:</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">__id</code><code class="p">;</code>         <code class="c1">// 21</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">__id</code><code class="p">;</code>         <code class="c1">// 21--still!</code></pre>
        
        <p>These getter and setter literal forms are also present in classes; see
        <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>It may not be obvious, but the setter literal must have
        exactly one declared parameter; omitting it or listing others is illegal
        syntax. The single required parameter <em>can</em> use destructuring and
        defaults (e.g., <code>set id({ id: v = 0 }) { .. }</code>), but the gather/rest
        <code>...</code> is not allowed (<code>set id(...v) { .. }</code>).</p>
        </div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Computed Property Names"><div class="sect2" id="idm45967374426632">
        <h2>Computed Property Names</h2>
        
        <p>You’ve probably been in a situation like the following snippet, where
        you have one or more property names that come from some sort of
        expression and thus can’t be put into the object literal:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">prefix</code> <code class="o">=</code> <code class="s2">"user_"</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">baz</code><code class="o">:</code> <code class="kd">function</code><code class="p">(..){</code> <code class="p">..</code> <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="nx">o</code><code class="p">[</code> <code class="nx">prefix</code> <code class="o">+</code> <code class="s2">"foo"</code> <code class="p">]</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(..){</code> <code class="p">..</code> <code class="p">};</code>
        <code class="nx">o</code><code class="p">[</code> <code class="nx">prefix</code> <code class="o">+</code> <code class="s2">"bar"</code> <code class="p">]</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(..){</code> <code class="p">..</code> <code class="p">};</code>
        <code class="p">..</code></pre>
        
        <p>ES6 adds a syntax to the object literal definition that allows you to
        specify an expression that should be computed, whose result is the
        property name assigned. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">prefix</code> <code class="o">=</code> <code class="s2">"user_"</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">baz</code><code class="o">:</code> <code class="kd">function</code><code class="p">(..){</code> <code class="p">..</code> <code class="p">},</code>
            <code class="p">[</code> <code class="nx">prefix</code> <code class="o">+</code> <code class="s2">"foo"</code> <code class="p">]</code><code class="o">:</code> <code class="kd">function</code><code class="p">(..){</code> <code class="p">..</code> <code class="p">},</code>
            <code class="p">[</code> <code class="nx">prefix</code> <code class="o">+</code> <code class="s2">"bar"</code> <code class="p">]</code><code class="o">:</code> <code class="kd">function</code><code class="p">(..){</code> <code class="p">..</code> <code class="p">}</code>
            <code class="p">..</code>
        <code class="p">};</code></pre>
        
        <p>Any valid expression can appear inside the <code>[ .. ]</code> that sits in the
        property name position of the object literal definition.</p>
        
        <p>Probably the most common use of computed property names will be with
        <code>Symbol</code>s (which we cover in <a data-type="xref" href="#symbolSect">“Symbols”</a> later in this chapter), such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">toStringTag</code><code class="p">]</code><code class="o">:</code> <code class="s2">"really cool thing"</code><code class="p">,</code>
            <code class="p">..</code>
        <code class="p">};</code></pre>
        
        <p><code>Symbol.toStringTag</code> is a special built-in value, which we evaluate with
        the <code>[ .. ]</code> syntax, so we can assign the <code>"really cool thing"</code> value to
        the special property name.</p>
        
        <p>Computed property names can also appear as the name of a concise method
        or a concise generator:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="p">[</code><code class="s2">"f"</code> <code class="o">+</code> <code class="s2">"oo"</code><code class="p">]()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>   <code class="c1">// computed concise method</code>
            <code class="o">*</code><code class="p">[</code><code class="s2">"b"</code> <code class="o">+</code> <code class="s2">"ar"</code><code class="p">]()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>  <code class="c1">// computed concise generator</code>
        <code class="p">};</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Setting [[Prototype]]"><div class="sect2" id="settingprototypes">
        <h2>Setting [[Prototype]]</h2>
        
        <p>We won’t cover prototypes in detail here, so for more information, see
        the <em>this &amp; Object Prototypes</em> title of this series.</p>
        
        <p>Sometimes it will be helpful to assign the <code>[[Prototype]]</code> of an object
        at the same time you’re declaring its object literal. The following has
        been a nonstandard extension in many JS engines for a while, but is
        standardized as of ES6:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">};</code>
        
        <code class="kd">var</code> <code class="nx">o2</code> <code class="o">=</code> <code class="p">{</code>
            <code class="bp">__proto__</code><code class="o">:</code> <code class="nx">o1</code><code class="p">,</code>
            <code class="c1">// ..</code>
        <code class="p">};</code></pre>
        
        <p><code>o2</code> is declared with a normal object literal, but it’s also
        <code>[[Prototype]]</code>-linked to <code>o1</code>. The <code>__proto__</code> property name here can
        also be a string <code>"__proto__"</code>, but note that it <em>cannot</em> be the result
        of a computed property name (see the previous section).</p>
        
        <p><code>__proto__</code> is controversial, to say the least. It’s a decades-old
        proprietary extension to JS that is finally standardized, somewhat
        begrudgingly it seems, in ES6. Many developers feel it shouldn’t ever be
        used. In fact, it’s in “Annex B” of ES6, which is the section that lists
        things JS feels it has to standardize for compatibility reasons only.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Though I’m narrowly endorsing <code>__proto__</code> as a key in an
        object literal definition, I definitely do not endorse using it in its
        object property form, like <code>o.__proto__</code>. That form is both a getter and
        setter (again for compatibility reasons), but there are definitely
        better options. See the <em>this &amp; Object Prototypes</em> title of this series
        for more information.</p>
        </div>
        
        <p>For setting the <code>[[Prototype]]</code> of an existing object, you can use the
        ES6 utility <code>Object.setPrototypeOf(..)</code>. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">};</code>
        
        <code class="kd">var</code> <code class="nx">o2</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// ..</code>
        <code class="p">};</code>
        
        <code class="nb">Object</code><code class="p">.</code><code class="nx">setPrototypeOf</code><code class="p">(</code> <code class="nx">o2</code><code class="p">,</code> <code class="nx">o1</code> <code class="p">);</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>We’ll discuss <code>Object</code> again in <a data-type="xref" href="ch06.html#chapter-6-api-additions">Chapter&nbsp;6</a>.
        “<code>Object.setPrototypeOf(..)</code> Static Function” provides additional
        details on <code>Object.setPrototypeOf(..)</code>. Also see <a data-type="xref" href="ch06.html#objectassign_sf-sect">“Object.assign(..) Static Function”</a> for another form that relates <code>o2</code> prototypically to
        <code>o1</code>.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Object super"><div class="sect2" id="object-super">
        <h2>Object super</h2>
        
        <p><code>super</code> is typically thought of as being only related to classes.
        However, due to JS’s classless-objects-with-prototypes nature, <code>super</code>
        is equally effective, and nearly the same in behavior, with plain
        objects’ concise methods.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o1</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"o1:foo"</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="kd">var</code> <code class="nx">o2</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">super</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="s2">"o2:foo"</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="nb">Object</code><code class="p">.</code><code class="nx">setPrototypeOf</code><code class="p">(</code> <code class="nx">o2</code><code class="p">,</code> <code class="nx">o1</code> <code class="p">);</code>
        
        <code class="nx">o2</code><code class="p">.</code><code class="nx">foo</code><code class="p">();</code>       <code class="c1">// o1:foo</code>
                        <code class="c1">// o2:foo</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p><code>super</code> is only allowed in concise methods, not regular
        function expression properties. It also is only allowed in <code>super.XXX</code>
        form (for property/method access), not in <code>super()</code> form.</p>
        </div>
        
        <p>The <code>super</code> reference in the <code>o2.foo()</code> method is locked statically to
        <code>o2</code>, and specifically to the <code>[[Prototype]]</code> of <code>o2</code>. <code>super</code> here
        would basically be <code>Object.getPrototypeOf(o2)</code>—resolves to <code>o1</code> of
        course—which is how it finds and calls <code>o1.foo()</code>.</p>
        
        <p>For complete details on <code>super</code>, see <a data-type="xref" href="ch03.html#class-sect">“Classes”</a> in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Template Literals"><div class="sect1" id="idm45967373171944">
        <h1>Template Literals</h1>
        
        <p>At the very outset of this section, I’m going to have to call out the
        name of this ES6 feature as being awfully… misleading, depending on
        your experiences with what the word <em>template</em> means.</p>
        
        <p>Many developers think of templates as being reusable renderable pieces
        of text, such as the capability provided by most template engines
        (Mustache, Handlebars, etc.). ES6’s use of the word <em>template</em> would
        imply something similar, like a way to declare inline template literals
        that can be re-rendered. However, that’s not at all the right way to
        think about this feature.</p>
        
        <p>So, before we go on, I’m renaming it to what it should have been called:
        <em>interpolated string literals</em> (or <em>interpoliterals</em> for short).</p>
        
        <p>You’re already well aware of declaring string literals with <code>"</code> or <code>'</code>
        delimiters, and you also know that these are not <em>smart strings</em> (as
        some languages have), where the contents would be parsed for
        interpolation expressions.</p>
        
        <p>However, ES6 introduces a new type of string literal, using the <code>`</code>
        backtick as the delimiter. These string literals allow basic string
        interpolation expressions to be embedded, which are then automatically
        parsed and evaluated.</p>
        
        <p>Here’s the old pre-ES6 way:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Kyle"</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">greeting</code> <code class="o">=</code> <code class="s2">"Hello "</code> <code class="o">+</code> <code class="nx">name</code> <code class="o">+</code> <code class="s2">"!"</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">greeting</code> <code class="p">);</code>            <code class="c1">// "Hello Kyle!"</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="k">typeof</code> <code class="nx">greeting</code> <code class="p">);</code>     <code class="c1">// "string"</code></pre>
        
        <p>Now, consider the new ES6 way:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Kyle"</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">greeting</code> <code class="o">=</code> <code class="sb">`Hello </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">!`</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">greeting</code> <code class="p">);</code>            <code class="c1">// "Hello Kyle!"</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="k">typeof</code> <code class="nx">greeting</code> <code class="p">);</code>     <code class="c1">// "string"</code></pre>
        
        <p>As you can see, we used the <code>`..`</code> around a series of characters,
        which are interpreted as a string literal, but any expressions of the
        form <code>${..}</code> are parsed and evaluated inline immediately. The fancy term
        for such parsing and evaluating is <em>interpolation</em> (much more accurate
        than templating).</p>
        
        <p>The result of the interpolated string literal expression is just a plain
        old normal string, assigned to the <code>greeting</code> variable.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p><code>typeof greeting == "string"</code> illustrates why it’s important
        not to think of these entities as special template values, as you cannot
        assign the unevaluated form of the literal to something and reuse it.
        The <code>`..`</code> string literal is more like an IIFE in the sense that it’s
        automatically evaluated inline. The result of a <code>`..`</code> string literal
        is, simply, just a string.</p>
        </div>
        
        <p>One really nice benefit of interpolated string literals is they are
        allowed to split across multiple lines:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code>
        <code class="sb">`Now is the time for all good men</code>
        <code class="sb">to come to the aid of their</code>
        <code class="sb">country!`</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">text</code> <code class="p">);</code>
        <code class="c1">// Now is the time for all good men</code>
        <code class="c1">// to come to the aid of their</code>
        <code class="c1">// country!</code></pre>
        
        <p>The line breaks (newlines) in the interpolated string literal were preserved in the string value.</p>
        
        <p>Unless appearing as explicit escape sequences in the literal value, the value of the <code>\r</code> carriage return character (code point <code>U+000D</code>) or the value of the <code>\r\n</code> carriage return + line feed sequence (code points <code>U+000D</code> and <code>U+000A</code>) are both normalized to a <code>\n</code> line feed character (code point <code>U+000A</code>). Don’t worry though; this normalization is rare and would likely only happen if copy-pasting text into your JS file.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Interpolated Expressions"><div class="sect2" id="idm45967372992072">
        <h2>Interpolated Expressions</h2>
        
        <p>Any valid expression is allowed to appear inside <code>${..}</code> in an
        interpolated string literal, including function calls, inline function
        expression calls, and even other interpolated string literals!</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">upper</code><code class="p">(</code><code class="nx">s</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">s</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">who</code> <code class="o">=</code> <code class="s2">"reader"</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code>
        <code class="sb">`A very </code><code class="si">${</code><code class="nx">upper</code><code class="p">(</code> <code class="s2">"warm"</code> <code class="p">)</code><code class="si">}</code><code class="sb"> welcome</code>
        <code class="sb">to all of you </code><code class="si">${</code><code class="nx">upper</code><code class="p">(</code> <code class="sb">`</code><code class="si">${</code><code class="nx">who</code><code class="si">}</code><code class="sb">s`</code> <code class="p">)</code><code class="si">}</code><code class="sb">!`</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">text</code> <code class="p">);</code>
        <code class="c1">// A very WARM welcome</code>
        <code class="c1">// to all of you READERS!</code></pre>
        
        <p>Here, the inner <code>`${who}s`</code> interpolated string literal was a little
        bit nicer convenience for us when combining the <code>who</code> variable with the
        <code>"s"</code> string, as opposed to <code>who + "s"</code>. There will be cases where
        nesting interpolated string literals is helpful, but be wary if you find
        yourself doing that kind of thing often, or if you find yourself nesting
        several levels deep.</p>
        
        <p>If that’s the case, the odds are good that your string value production
        could benefit from some abstractions.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>As a word of caution, be very careful about the readability
        of your code with such newfound power. Just like with default value
        expressions and destructuring assignment expressions, just because you
        <em>can</em> do something doesn’t mean you <em>should</em> do it. Never go so
        overboard with new ES6 tricks that your code becomes more clever than
        you or your other team members.</p>
        </div>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Expression Scope"><div class="sect3" id="idm45967372919544">
        <h3>Expression Scope</h3>
        
        <p>One quick note about the scope that is used to resolve variables in
        expressions. I mentioned earlier that an interpolated string literal is
        kind of like an IIFE, and it turns out thinking about it like that
        explains the scoping behavior as well.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">str</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"foo"</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="kd">function </code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"bar"</code><code class="p">;</code>
            <code class="nx">foo</code><code class="p">(</code> <code class="sb">`Hello from </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">!`</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">name</code> <code class="o">=</code> <code class="s2">"global"</code><code class="p">;</code>
        
        <code class="nx">bar</code><code class="p">();</code>                  <code class="c1">// "Hello from bar!"</code></pre>
        
        <p>At the moment the <code>`..`</code> string literal is expressed, inside the
        <code>bar()</code> function, the scope available to it finds <code>bar()</code>’s <code>name</code>
        variable with value <code>"bar"</code>. Neither the global <code>name</code> nor <code>foo(..)</code>’s
        <code>name</code> matter. In other words, an interpolated string literal is just
        lexically scoped where it appears, not dynamically scoped in any way.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Tagged Template Literals"><div class="sect2" id="idm45967372833512">
        <h2>Tagged Template Literals</h2>
        
        <p>Again, renaming the feature for sanity sake: <em>tagged string literals</em>.</p>
        
        <p>To be honest, this is one of the cooler tricks that ES6 offers. It may
        seem a little strange, and perhaps not all that generally practical at
        first. But once you’ve spent some time with it, tagged string literals
        may just surprise you in their usefulness.</p>
        
        <p>For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">strings</code><code class="p">,</code> <code class="o">...</code><code class="nx">values</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">strings</code> <code class="p">);</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">values</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">desc</code> <code class="o">=</code> <code class="s2">"awesome"</code><code class="p">;</code>
        
        <code class="nt">foo</code><code class="sb">`Everything is </code><code class="si">${</code><code class="nx">desc</code><code class="si">}</code><code class="sb">!`</code><code class="p">;</code>
        <code class="c1">// [ "Everything is ", "!"]</code>
        <code class="c1">// [ "awesome" ]</code></pre>
        
        <p>Let’s take a moment to consider what’s happening in the previous
        snippet. First, the most jarring thing that jumps out is
        <code>foo`Everything…`;</code>. That doesn’t look like anything we’ve seen
        before. What is it?</p>
        
        <p>It’s essentially a special kind of function call that doesn’t need the
        <code>( .. )</code>. The <em>tag</em>—the <code>foo</code> part before the <code>`..`</code> string literal—is a function value that should be called. Actually, it can be any
        expression that results in a function, even a function call that returns
        another function, like:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">bar</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">strings</code><code class="p">,</code> <code class="o">...</code><code class="nx">values</code><code class="p">)</code> <code class="p">{</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">strings</code> <code class="p">);</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">values</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">desc</code> <code class="o">=</code> <code class="s2">"awesome"</code><code class="p">;</code>
        
        <code class="nt">bar()</code><code class="sb">`Everything is </code><code class="si">${</code><code class="nx">desc</code><code class="si">}</code><code class="sb">!`</code><code class="p">;</code>
        <code class="c1">// [ "Everything is ", "!"]</code>
        <code class="c1">// [ "awesome" ]</code></pre>
        
        <p>But what gets passed to the <code>foo(..)</code> function when invoked as a tag for
        a string literal?</p>
        
        <p>The first argument—we called it <code>strings</code>—is an array of all the
        plain strings (the stuff between any interpolated expressions). We get
        two values in the <code>strings</code> array: <code>"Everything is "</code> and <code>"!"</code>.</p>
        
        <p>For convenience sake in our example, we then gather up all subsequent
        arguments into an array called <code>values</code> using the <code>...</code> gather/rest
        operator (see <a data-type="xref" href="#spread-rest-sect">“Spread/Rest”</a> earlier in this chapter), though
        you could of course have left them as individually named parameters
        following the <code>strings</code> parameter.</p>
        
        <p>The argument(s) gathered into our <code>values</code> array are the results of the
        already-evaluated interpolation expressions found in the string literal.
        So obviously the only element in <code>values</code> in our example is <code>"awesome"</code>.</p>
        
        <p>You can think of these two arrays as: the values in <code>values</code> are the
        separators if you were to splice them in between the values in
        <code>strings</code>, and then if you joined everything together, you’d get the
        complete interpolated string value.</p>
        
        <p>A tagged string literal is like a processing step after the
        interpolation expressions are evaluated but before the final string value is
        compiled, allowing you more control over generating the string from the
        literal.</p>
        
        <p>Typically, the string literal tag function (<code>foo(..)</code> in the previous
        snippets) should compute an appropriate string value and return it, so
        that you can use the tagged string literal as a value just like untagged
        string literals:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">tag</code><code class="p">(</code><code class="nx">strings</code><code class="p">,</code> <code class="o">...</code><code class="nx">values</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">strings</code><code class="p">.</code><code class="nx">reduce</code><code class="p">(</code> <code class="kd">function</code><code class="p">(</code><code class="nx">s</code><code class="p">,</code><code class="nx">v</code><code class="p">,</code><code class="nx">idx</code><code class="p">){</code>
                <code class="k">return</code> <code class="nx">s</code> <code class="o">+</code> <code class="p">(</code><code class="nx">idx</code> <code class="o">&gt;</code> <code class="mi">0</code> <code class="o">?</code> <code class="nx">values</code><code class="p">[</code><code class="nx">idx</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code> <code class="o">:</code> <code class="s2">""</code><code class="p">)</code> <code class="o">+</code> <code class="nx">v</code><code class="p">;</code>
            <code class="p">},</code> <code class="s2">""</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">desc</code> <code class="o">=</code> <code class="s2">"awesome"</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code> <code class="nt">tag</code><code class="sb">`Everything is </code><code class="si">${</code><code class="nx">desc</code><code class="si">}</code><code class="sb">!`</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">text</code> <code class="p">);</code>            <code class="c1">// Everything is awesome!</code></pre>
        
        <p>In this snippet, <code>tag(..)</code> is a pass-through operation, in that it
        doesn’t perform any special modifications, but just uses <code>reduce(..)</code> to loop over and splice/interleave <code>strings</code> and <code>values</code> together the same way an
        untagged string literal would have done.</p>
        
        <p>So what are some practical uses? There are many advanced ones that are
        beyond our scope to discuss here. But here’s a simple idea that formats
        numbers as U.S. dollars (sort of like basic localization):</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">dollabillsyall</code><code class="p">(</code><code class="nx">strings</code><code class="p">,</code> <code class="o">...</code><code class="nx">values</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">strings</code><code class="p">.</code><code class="nx">reduce</code><code class="p">(</code> <code class="kd">function</code><code class="p">(</code><code class="nx">s</code><code class="p">,</code><code class="nx">v</code><code class="p">,</code><code class="nx">idx</code><code class="p">){</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">idx</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">values</code><code class="p">[</code><code class="nx">idx</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code> <code class="o">==</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>
                        <code class="c1">// look, also using interpolated</code>
                        <code class="c1">// string literals!</code>
                        <code class="nx">s</code> <code class="o">+=</code> <code class="sb">`$${values[idx-1].toFixed( 2 )}`</code><code class="p">;</code>
                    <code class="p">}</code>
                    <code class="k">else</code> <code class="p">{</code>
                        <code class="nx">s</code> <code class="o">+=</code> <code class="nx">values</code><code class="p">[</code><code class="nx">idx</code><code class="o">-</code><code class="mi">1</code><code class="p">];</code>
                    <code class="p">}</code>
                <code class="p">}</code>
        
                <code class="k">return</code> <code class="nx">s</code> <code class="o">+</code> <code class="nx">v</code><code class="p">;</code>
            <code class="p">},</code> <code class="s2">""</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">amt1</code> <code class="o">=</code> <code class="mf">11.99</code><code class="p">,</code>
            <code class="nx">amt2</code> <code class="o">=</code> <code class="nx">amt1</code> <code class="o">*</code> <code class="mf">1.08</code><code class="p">,</code>
            <code class="nx">name</code> <code class="o">=</code> <code class="s2">"Kyle"</code><code class="p">;</code>
        
        <code class="kd">var</code> <code class="nx">text</code> <code class="o">=</code> <code class="nx">dollabillsyall</code>
        <code class="sb">`Thanks for your purchase, </code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">! Your</code>
        <code class="sb">product cost was </code><code class="si">${</code><code class="nx">amt1</code><code class="si">}</code><code class="sb">, which with tax</code>
        <code class="sb">comes out to </code><code class="si">${</code><code class="nx">amt2</code><code class="si">}</code><code class="sb">.`</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">text</code> <code class="p">);</code>
        <code class="c1">// Thanks for your purchase, Kyle! Your</code>
        <code class="c1">// product cost was $11.99, which with tax</code>
        <code class="c1">// comes out to $12.95.</code></pre>
        
        <p>If a <code>number</code> value is encountered in the <code>values</code> array, we put <code>"$"</code>
        in front of it and format it to two decimal places with <code>toFixed(2)</code>.
        Otherwise, we let the value pass-through untouched.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Raw Strings"><div class="sect3" id="idm45967372566744">
        <h3>Raw Strings</h3>
        
        <p>In the previous snippets, our tag functions receive the first argument
        we called <code>strings</code>, which is an array. But there’s an additional bit of
        data included: the raw unprocessed versions of all the strings. You can
        access those raw string values using the <code>.raw</code> property, like this:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">showraw</code><code class="p">(</code><code class="nx">strings</code><code class="p">,</code> <code class="o">...</code><code class="nx">values</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">strings</code> <code class="p">);</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">strings</code><code class="p">.</code><code class="nx">raw</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="nt">showraw</code><code class="sb">`Hello\nWorld`</code><code class="p">;</code>
        <code class="c1">// [ "Hello</code>
        <code class="c1">// World" ]</code>
        <code class="c1">// [ "Hello\nWorld" ]</code></pre>
        
        <p>The raw version of the value preserves the raw escaped <code>\n</code> sequence (the <code>\</code> and the <code>n</code> are separate characters), while the processed version considers it a single newline character. However, the earlier mentioned line-ending normalization is applied to both values.</p>
        
        <p>ES6 comes with a built-in function that can be used as a string literal
        tag: <code>String.raw(..)</code>. It simply passes through the raw versions of the
        <code>strings</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="sb">`Hello\nWorld`</code> <code class="p">);</code>
        <code class="c1">// Hello</code>
        <code class="c1">// World</code>
        
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nt">String.raw</code><code class="sb">`Hello\nWorld`</code> <code class="p">);</code>
        <code class="c1">// Hello\nWorld</code>
        
        <code class="nt">String.raw</code><code class="sb">`Hello\nWorld`</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
        <code class="c1">// 12</code></pre>
        
        <p>Other uses for string literal tags include special processing for
        internationalization, localization, and more!</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Arrow Functions"><div class="sect1" id="arrow-functions">
        <h1>Arrow Functions</h1>
        
        <p>We’ve touched on <code>this</code> binding complications with functions earlier in
        this chapter, and they’re covered at length in the <em>this &amp; Object
        Prototypes</em> title of this series. It’s important to understand the
        frustrations that <code>this</code>-based programming with normal functions brings,
        because that is the primary motivation for the new ES6 <code>=&gt;</code> arrow
        function feature.</p>
        
        <p>Let’s first illustrate what an arrow function looks like, as compared to
        normal functions:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">foo</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="c1">// versus</code>
        
        <code class="kd">var</code> <code class="nx">foo</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">;</code></pre>
        
        <p>The arrow function definition consists of a parameter list (of zero or
        more parameters, and surrounding <code>( .. )</code> if there’s not exactly one
        parameter), followed by the <code>=&gt;</code> marker, followed by a function body.</p>
        
        <p>So, in the previous snippet, the arrow function is just the
        <code>(x,y) =&gt; x + y</code> part, and that function reference happens to be
        assigned to the variable <code>foo</code>.</p>
        
        <p>The body only needs to be enclosed by <code>{ .. }</code> if there’s more than one
        expression, or if the body consists of a non-expression statement. If
        there’s only one expression, and you omit the surrounding <code>{ .. }</code>,
        there’s an implied <code>return</code> in front of the expression, as illustrated
        in the previous snippet.</p>
        
        <p>Here’s some other arrow function variations to consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">f1</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">12</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">f2</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">f3</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">z</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">*</code> <code class="mi">2</code> <code class="o">+</code> <code class="nx">y</code><code class="p">;</code>
            <code class="nx">y</code><code class="o">++</code><code class="p">;</code>
            <code class="nx">x</code> <code class="o">*=</code> <code class="mi">3</code><code class="p">;</code>
            <code class="k">return</code> <code class="p">(</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="nx">z</code><code class="p">)</code> <code class="o">/</code> <code class="mi">2</code><code class="p">;</code>
        <code class="p">};</code></pre>
        
        <p>Arrow functions are <em>always</em> function expressions; there is no arrow
        function declaration. It also should be clear that they are anonymous
        function expressions—they have no named reference for the purposes of
        recursion or event binding/unbinding—though <a data-type="xref" href="ch07.html#functionNamessect">“Function Names”</a> in
        <a data-type="xref" href="ch07.html#chapter-7-meta-programming">Chapter&nbsp;7</a> will describe ES6’s function name inference rules for
        debugging purposes.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>All the capabilities of normal function parameters are available
        to arrow functions, including default values, destructuring, rest
        parameters, and so on.</p>
        </div>
        
        <p>Arrow functions have a nice, shorter syntax, which makes them on the
        surface very attractive for writing terser code. Indeed, nearly all
        literature on ES6 (other than the titles in this series) seems to
        immediately and exclusively adopt the arrow function as “the new
        function.”</p>
        
        <p>It is telling that nearly all examples in our discussion of arrow functions
        are short single statement utilities, such as those passed as callbacks
        to various utilities. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        
        <code class="nx">a</code> <code class="o">=</code> <code class="nx">a</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code> <code class="nx">v</code> <code class="o">=&gt;</code> <code class="nx">v</code> <code class="o">*</code> <code class="mi">2</code> <code class="p">);</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>               <code class="c1">// [2,4,6,8,10]</code></pre>
        
        <p>In those cases, where you have such inline function expressions, and
        they fit the pattern of computing a quick calculation in a single
        statement and returning that result, arrow functions indeed look to be
        an attractive and lightweight alternative to the more verbose <code>function</code>
        keyword and syntax.</p>
        
        <p>Most people tend to <em>ooh and aah</em> at nice terse examples like that, as I
        imagine you just did!</p>
        
        <p>However, I would caution you that it would seem to me somewhat a
        misapplication of this feature to use arrow function syntax with
        otherwise normal, multistatement functions, especially those that would
        otherwise be naturally expressed as function declarations.</p>
        
        <p>Recall the <code>dollabillsyall(..)</code> string literal tag function from earlier
        in this chapter—let’s change it to use <code>=&gt;</code> syntax:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">dollabillsyall</code> <code class="o">=</code> <code class="p">(</code><code class="nx">strings</code><code class="p">,</code> <code class="o">...</code><code class="nx">values</code><code class="p">)</code> <code class="o">=&gt;</code>
            <code class="nx">strings</code><code class="p">.</code><code class="nx">reduce</code><code class="p">(</code> <code class="p">(</code><code class="nx">s</code><code class="p">,</code><code class="nx">v</code><code class="p">,</code><code class="nx">idx</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">idx</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">values</code><code class="p">[</code><code class="nx">idx</code><code class="o">-</code><code class="mi">1</code><code class="p">]</code> <code class="o">==</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>
                        <code class="c1">// look, also using interpolated</code>
                        <code class="c1">// string literals!</code>
                        <code class="nx">s</code> <code class="o">+=</code> <code class="sb">`$${values[idx-1].toFixed( 2 )}`</code><code class="p">;</code>
                    <code class="p">}</code>
                    <code class="k">else</code> <code class="p">{</code>
                        <code class="nx">s</code> <code class="o">+=</code> <code class="nx">values</code><code class="p">[</code><code class="nx">idx</code><code class="o">-</code><code class="mi">1</code><code class="p">];</code>
                    <code class="p">}</code>
                <code class="p">}</code>
        
                <code class="k">return</code> <code class="nx">s</code> <code class="o">+</code> <code class="nx">v</code><code class="p">;</code>
            <code class="p">},</code> <code class="s2">""</code> <code class="p">);</code></pre>
        
        <p>In this example, the only modifications I made were the removal of
        <code>function</code>, <code>return</code>, and some <code>{ .. }</code>, and then the insertion of <code>=&gt;</code>
        and a <code>var</code>. Is this a significant improvement in the readability of the
        code? Meh.</p>
        
        <p>I’d actually argue that the lack of <code>return</code> and outer <code>{ .. }</code>
        partially obscures the fact that the <code>reduce(..)</code> call is the only
        statement in the <code>dollabillsyall(..)</code> function and that its result is
        the intended result of the call. Also, the trained eye, which is so used
        to hunting for the word <code>function</code> in code to find scope boundaries, now
        needs to look for the <code>=&gt;</code> marker, which can definitely be harder to
        find in the thick of the code.</p>
        
        <p>While not a hard-and-fast rule, I’d say that the readability gains from
        <code>=&gt;</code> arrow function conversion are inversely proportional to the length
        of the function being converted. The longer the function, the less <code>=&gt;</code>
        helps; the shorter the function, the more <code>=&gt;</code> can shine.</p>
        
        <p>I think it’s probably more sensible and reasonable to adopt <code>=&gt;</code> for the
        places in code where you do need short inline function expressions, but
        leave your normal-length main functions as is.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Not Just Shorter Syntax, But this"><div class="sect2" id="idm45967371946552">
        <h2>Not Just Shorter Syntax, But this</h2>
        
        <p>Most of the popular attention toward <code>=&gt;</code> has been on saving those
        precious keystrokes by dropping <code>function</code>, <code>return</code>, and <code>{ .. }</code> from
        your code.</p>
        
        <p>But there’s a big detail we’ve skipped over so far. I said at the
        beginning of the section that <code>=&gt;</code> functions are closely related to
        <code>this</code> binding behavior. In fact, <code>=&gt;</code> arrow functions are <em>primarily
        designed</em> to alter <code>this</code> behavior in a specific way, solving a
        particular and common pain point with <code>this</code>-aware coding.</p>
        
        <p>The saving of keystrokes is a red herring, a misleading sideshow at
        best.</p>
        
        <p>Let’s revisit another example from earlier in this chapter:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">controller</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">makeRequest</code><code class="o">:</code> <code class="kd">function</code><code class="p">(..){</code>
                <code class="kd">var</code> <code class="nb">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>
        
                <code class="nx">btn</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code> <code class="s2">"click"</code><code class="p">,</code> <code class="kd">function</code><code class="p">(){</code>
                    <code class="c1">// ..</code>
                    <code class="nb">self</code><code class="p">.</code><code class="nx">makeRequest</code><code class="p">(..);</code>
                <code class="p">},</code> <code class="kc">false</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>We used the <code>var self = this</code> hack, and then referenced
        <code>self.makeRequest(..)</code>, because inside the callback function we’re
        passing to <code>addEventListener(..)</code>, the <code>this</code> binding will not be the
        same as it is in <code>makeRequest(..)</code> itself. In other words, because
        <code>this</code> bindings are dynamic, we fall back to the predictability of
        lexical scope via the <code>self</code> variable.</p>
        
        <p>Herein we finally can see the primary design characteristic of <code>=&gt;</code>
        arrow functions. Inside arrow functions, the <code>this</code> binding is not
        dynamic, but is instead lexical. In the previous snippet, if we used an
        arrow function for the callback, <code>this</code> will be predictably what we
        wanted it to be.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">controller</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">makeRequest</code><code class="o">:</code> <code class="kd">function</code><code class="p">(..){</code>
                <code class="nx">btn</code><code class="p">.</code><code class="nx">addEventListener</code><code class="p">(</code> <code class="s2">"click"</code><code class="p">,</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
                    <code class="c1">// ..</code>
                    <code class="k">this</code><code class="p">.</code><code class="nx">makeRequest</code><code class="p">(..);</code>
                <code class="p">},</code> <code class="kc">false</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>Lexical <code>this</code> in the arrow function callback in the previous snippet
        now points to the same value as in the enclosing <code>makeRequest(..)</code>
        function. In other words, <code>=&gt;</code> is a syntactic stand-in for
        <code>var self = this</code>.</p>
        
        <p>In cases where <code>var self = this</code> (or, alternatively, a function
        <code>.bind(this)</code> call) would normally be helpful, <code>=&gt;</code> arrow functions are
        a nicer alternative operating on the same principle. Sounds great,
        right?</p>
        
        <p>Not quite so simple.</p>
        
        <p>If <code>=&gt;</code> replaces <code>var self = this</code> or <code>.bind(this)</code> and it helps, guess
        what happens if you use <code>=&gt;</code> with a <code>this</code>-aware function that <em>doesn’t</em>
        need <code>var self = this</code> to work? You might be able to guess that it’s
        going to mess things up. Yeah.</p>
        
        <p class="pagebreak-before">Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">controller</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">makeRequest</code><code class="o">:</code> <code class="p">(..)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="c1">// ..</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">helper</code><code class="p">(..);</code>
            <code class="p">},</code>
            <code class="nx">helper</code><code class="o">:</code> <code class="p">(..)</code> <code class="o">=&gt;</code> <code class="p">{</code>
                <code class="c1">// ..</code>
            <code class="p">}</code>
        <code class="p">};</code>
        
        <code class="nx">controller</code><code class="p">.</code><code class="nx">makeRequest</code><code class="p">(..);</code></pre>
        
        <p>Although we invoke as <code>controller.makeRequest(..)</code>, the <code>this.helper</code>
        reference fails, because <code>this</code> here doesn’t point to <code>controller</code> as it
        normally would. Where does it point? It lexically inherits <code>this</code> from
        the surrounding scope. In this previous snippet, that’s the global
        scope, where <code>this</code> points to the global object. Ugh.</p>
        
        <p>In addition to lexical <code>this</code>, arrow functions also have lexical
        <code>arguments</code>—they don’t have their own <code>arguments</code> array but instead
        inherit from their parent—as well as lexical <code>super</code> and <code>new.target</code>
        (see <a data-type="xref" href="ch03.html#class-sect">“Classes”</a> in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>).</p>
        
        <p>So now we can conclude a more nuanced set of rules for when <code>=&gt;</code> is
        appropriate and when it is not:</p>
        
        <ul>
        <li>
        <p>If you have a short, single-statement inline function expression,
        where the only statement is a <code>return</code> of some computed value, <em>and</em>
        that function doesn’t already make a <code>this</code> reference inside it, <em>and</em>
        there’s no self-reference (recursion, event binding/unbinding), <em>and</em>
        you don’t reasonably expect the function to ever be that way, you can
        probably safely refactor it to be an <code>=&gt;</code> arrow function.</p>
        </li>
        <li>
        <p>If you have an inner function expression that’s relying on a
        <code>var self = this</code> hack or a <code>.bind(this)</code> call on it in the enclosing
        function to ensure proper <code>this</code> binding, that inner function expression
        can probably safely become an <code>=&gt;</code> arrow function.</p>
        </li>
        </ul>
        
        <ul class="pagebreak-before">
        <li>
        <p>If you have an inner function expression that’s relying on something
        like <code>var args = Array.prototype.slice.call(arguments)</code> in the enclosing
        function to make a lexical copy of <code>arguments</code>, that inner function
        expression can probably safely become an <code>=&gt;</code> arrow function.</p>
        </li>
        <li>
        <p>For everything else—normal function declarations, longer
        multistatement function expressions, functions that need a lexical name
        identifier self-reference (recursion, etc.), and any other function that
        doesn’t fit the previous characteristics—you should probably avoid
        <code>=&gt;</code> function syntax.</p>
        </li>
        </ul>
        
        <p>Bottom line: <code>=&gt;</code> is about lexical binding of <code>this</code>, <code>arguments</code>, and
        <code>super</code>. These are intentional features designed to fix some common
        problems, not bugs, quirks, or mistakes in ES6.</p>
        
        <p>Don’t believe any hype that <code>=&gt;</code> is primarily, or even mostly, about
        fewer keystrokes. Whether you save keystrokes or waste them, you should
        know exactly what you are intentionally doing with every character
        typed.</p>
        <div data-type="tip"><h6>Tip</h6>
        <p>If you have a function that for any of these articulated reasons
        is not a good match for an <code>=&gt;</code> arrow function, but it’s being declared
        as part of an object literal, recall from <a data-type="xref" href="#concisemethod_sect">“Concise Methods”</a> earlier in
        this chapter that there’s another option for shorter function syntax.</p>
        </div>
        
        <p>If you prefer a visual decision chart for how/why to pick an arrow
        function:</p>
        
        <figure><div class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491905241/files/assets/ydnk_0101.png" alt="ydnk 0101" width="1529" height="2241">
        <h6></h6>
        </div></figure>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="for..of Loops"><div class="sect1" id="forofloops-sect">
        <h1>for..of Loops</h1>
        
        <p>Joining the <code>for</code> and <code>for..in</code> loops from the JavaScript we’re all
        familiar with, ES6 adds a <code>for..of</code> loop, which loops over the set of
        values produced by an <em>iterator</em>.</p>
        
        <p>The value you loop over with <code>for..of</code> must be an <em>iterable</em>, or it must
        be a value that can be coerced/boxed to an object (see the <em>Types &amp;
        Grammar</em> title of this series) that is an iterable. An iterable is
        simply an object that is able to produce an iterator, which the loop
        then uses.</p>
        
        <p>Let’s compare <code>for..of</code> to <code>for..in</code> to illustrate the difference:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"a"</code><code class="p">,</code><code class="s2">"b"</code><code class="p">,</code><code class="s2">"c"</code><code class="p">,</code><code class="s2">"d"</code><code class="p">,</code><code class="s2">"e"</code><code class="p">];</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">idx</code> <code class="k">in</code> <code class="nx">a</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">idx</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// 0 1 2 3 4</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">val</code> <code class="k">of</code> <code class="nx">a</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">val</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// "a" "b" "c" "d" "e"</code></pre>
        
        <p>As you can see, <code>for..in</code> loops over the keys/indexes in the <code>a</code> array,
        while <code>for..of</code> loops over the values in <code>a</code>.</p>
        
        <p>Here’s the pre-ES6 version of the <code>for..of</code> from that previous <span class="keep-together">snippet</span>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"a"</code><code class="p">,</code><code class="s2">"b"</code><code class="p">,</code><code class="s2">"c"</code><code class="p">,</code><code class="s2">"d"</code><code class="p">,</code><code class="s2">"e"</code><code class="p">],</code>
            <code class="nx">k</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code> <code class="nx">a</code> <code class="p">);</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">k</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">val</code> <code class="o">=</code> <code class="nx">a</code><code class="p">[</code> <code class="nx">k</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="p">];</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">val</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// "a" "b" "c" "d" "e"</code></pre>
        
        <p>And here’s the ES6 but non-<code>for..of</code> equivalent, which also gives a
        glimpse at manually iterating an iterator (see <a data-type="xref" href="ch03.html#iterSect">“Iterators”</a> in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>):</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="s2">"a"</code><code class="p">,</code><code class="s2">"b"</code><code class="p">,</code><code class="s2">"c"</code><code class="p">,</code><code class="s2">"d"</code><code class="p">,</code><code class="s2">"e"</code><code class="p">];</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">val</code><code class="p">,</code> <code class="nx">ret</code><code class="p">,</code> <code class="nx">it</code> <code class="o">=</code> <code class="nx">a</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">]();</code>
            <code class="p">(</code><code class="nx">ret</code> <code class="o">=</code> <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">())</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">ret</code><code class="p">.</code><code class="nx">done</code><code class="p">;</code>
        <code class="p">)</code> <code class="p">{</code>
            <code class="nx">val</code> <code class="o">=</code> <code class="nx">ret</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">val</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// "a" "b" "c" "d" "e"</code></pre>
        
        <p>Under the covers, the <code>for..of</code> loop asks the iterable for an iterator
        (using the built-in <code>Symbol.iterator</code>; see <a data-type="xref" href="ch07.html#well-knownSymbols">“Well-Known Symbols”</a> in
        <a data-type="xref" href="ch07.html#chapter-7-meta-programming">Chapter&nbsp;7</a>), then it repeatedly calls the iterator and assigns its
        produced value to the loop iteration variable.</p>
        
        <p>Standard built-in values in JavaScript that are by default iterables (or
        provide them) include:</p>
        
        <ul>
        <li>
        <p>Arrays</p>
        </li>
        <li>
        <p>Strings</p>
        </li>
        <li>
        <p>Generators (see <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>)</p>
        </li>
        <li>
        <p>Collections / TypedArrays (see <a data-type="xref" href="ch05.html#chapter-5-collections">Chapter&nbsp;5</a>)</p>
        </li>
        </ul>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Plain objects are not by default suitable for <code>for..of</code>
        looping. That’s because they don’t have a default iterator, which is
        intentional, not a mistake. However, we won’t go any further into those
        nuanced reasonings here. In <a data-type="xref" href="ch03.html#iterSect">“Iterators”</a> in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a>, we’ll see how to
        define iterators for our own objects, which lets <code>for..of</code> loop over any
        object to get a set of values we define.</p>
        </div>
        
        <p>Here’s how to loop over the characters in a primitive string:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="k">for</code> <code class="p">(</code><code class="kd">var</code> <code class="nx">c</code> <code class="k">of</code> <code class="s2">"hello"</code><code class="p">)</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">c</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// "h" "e" "l" "l" "o"</code></pre>
        
        <p>The <code>"hello"</code> primitive string value is coerced/boxed to the <code>String</code> object wrapper equivalent, which is an iterable by default.</p>
        
        <p>In <code>for (XYZ of ABC)..</code>, the <code>XYZ</code> clause can either be an assignment
        expression or a declaration, identical to that same clause in <code>for</code> and
        <code>for..in</code> loops. So you can do stuff like this:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{};</code>
        
        <code class="k">for</code> <code class="p">(</code><code class="nx">o</code><code class="p">.</code><code class="nx">a</code> <code class="k">of</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">])</code> <code class="p">{</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">o</code><code class="p">.</code><code class="nx">a</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// 1 2 3</code>
        
        <code class="k">for</code> <code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="nx">o</code><code class="p">.</code><code class="nx">a</code><code class="p">}</code> <code class="k">of</code> <code class="p">[</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">2</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">3</code><code class="p">}</code> <code class="p">])</code> <code class="p">{</code>
          <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">o</code><code class="p">.</code><code class="nx">a</code> <code class="p">);</code>
        <code class="p">}</code>
        <code class="c1">// 1 2 3</code></pre>
        
        <p><code>for..of</code> loops can be prematurely stopped, just like other loops, with
        <code>break</code>, <code>continue</code>, <code>return</code> (if in a function), and thrown exceptions.
        In any of these cases, the iterator’s <code>return(..)</code> function is
        automatically called (if one exists) to let the iterator perform cleanup
        tasks, if necessary.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>See <a data-type="xref" href="ch03.html#iterSect">“Iterators”</a> in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a> for more complete coverage on
        iterables and iterators.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Regular Expressions"><div class="sect1" id="idm45967371718312">
        <h1>Regular Expressions</h1>
        
        <p>Let’s face it: regular expressions haven’t changed much in JS in a long
        time. So it’s a great thing that they’ve finally learned a couple of new
        tricks in ES6. We’ll briefly cover the additions here, but the overall
        topic of regular expressions is so dense that you’ll need to turn to
        chapters/books dedicated to it (of which there are many!) if you need a
        refresher.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Unicode Flag"><div class="sect2" id="unicode-flag">
        <h2>Unicode Flag</h2>
        
        <p>We’ll cover the topic of Unicode in more detail in <a data-type="xref" href="#unicode_sect">“Unicode”</a> later in
        this chapter. Here, we’ll just look briefly at the new <code>u</code> flag for ES6+
        regular expressions, which turns on Unicode matching for that
        expression.</p>
        
        <p>JavaScript strings are typically interpreted as sequences of 16-bit
        characters, which correspond to the characters in the <a href="http://en.wikipedia.org/wiki/Plane_%28Unicode%29"><em>Basic
        Multilingual Plane (BMP)</em></a>. But there are many
        UTF-16 characters that fall outside this range, and so strings may have
        these multibyte characters in them.</p>
        
        <p>Prior to ES6, regular expressions could only be matched based on BMP
        characters, which means that those extended characters were treated as
        two separate characters for matching purposes. This is often not ideal.</p>
        
        <p>So, as of ES6, the <code>u</code> flag tells a regular expression to process a
        string with the interpretation of Unicode (UTF-16) characters, such that
        such an extended character will be matched as a single entity.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Despite the name implication, “UTF-16” doesn’t strictly mean
        16 bits. Modern Unicode uses 21 bits, and standards like UTF-8 and
        UTF-16 refer roughly to how many bits are used in the representation of
        a character.</p>
        </div>
        
        <p>An example (straight from the ES6 specification): <code>𝄞</code> the musical symbol
        G-clef) is Unicode point U+1D11E (0x1D11E).</p>
        
        <p>If this character appears in a regular expression pattern (like <code>/𝄞/</code>),
        the standard BMP interpretation would be that it’s two separate
        characters (0xD834 and 0xDD1E) to match with. But the new ES6
        Unicode-aware mode means that <code>/𝄞/u</code> (or the escaped Unicode form
        <code>/\u{1D11E}/u</code>) will match <code>"𝄞"</code> in a string as a single matched
        character.</p>
        
        <p>You might be wondering why this matters? In non-Unicode BMP mode, the
        pattern is treated as two separate characters, but would still find the
        match in a string with the <code>"𝄞"</code> character in it, as you can see if you
        try:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="sr">/𝄞/</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="s2">"𝄞-clef"</code> <code class="p">);</code>           <code class="c1">// true</code></pre>
        
        <p>The length of the match is what matters. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="sr">/^.-clef/</code> <code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="s2">"𝄞-clef"</code> <code class="p">);</code>        <code class="c1">// false</code>
        <code class="sr">/^.-clef/u</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="s2">"𝄞-clef"</code> <code class="p">);</code>        <code class="c1">// true</code></pre>
        
        <p>The <code>^.-clef</code> in the pattern says to match only a single character at
        the beginning before the normal <code>"-clef"</code> text. In standard BMP mode,
        the match fails (two characters), but with <code>u</code> Unicode mode flagged on,
        the match succeeds (one character).</p>
        
        <p>It’s also important to note that <code>u</code> makes quantifiers like <code>+</code> and <code>*</code>
        apply to the entire Unicode code point as a single character, not just
        the <em>lower surrogate</em> (aka rightmost half of the symbol) of the
        character. The same goes for Unicode characters appearing in character
        classes, like <code>/[💩-💫]/u</code>.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>There’s plenty more nitty-gritty details about <code>u</code> behavior in
        regular expressions, which <a href="https://twitter.com/mathias">Mathias Bynens</a> has <a href="https://mathiasbynens.be/notes/es6-unicode-regex">written extensively about</a>.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Sticky Flag"><div class="sect2" id="idm45967371264280">
        <h2>Sticky Flag</h2>
        
        <p>Another flag mode added to ES6 regular expressions is <code>y</code>, which is
        often called “sticky mode.” <em>Sticky</em> essentially means the regular
        expression has a virtual anchor at its beginning that keeps it rooted to
        matching at only the position indicated by the regular expression’s
        <code>lastIndex</code> property.</p>
        
        <p>To illustrate, let’s consider two regular expressions—the first without
        sticky mode and the second with:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re1</code> <code class="o">=</code> <code class="sr">/foo/</code><code class="p">,</code>
            <code class="nx">str</code> <code class="o">=</code> <code class="s2">"++foo++"</code><code class="p">;</code>
        
        <code class="nx">re1</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>          <code class="c1">// 0</code>
        <code class="nx">re1</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>        <code class="c1">// true</code>
        <code class="nx">re1</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>          <code class="c1">// 0--not updated</code>
        
        <code class="nx">re1</code><code class="p">.</code><code class="nx">lastIndex</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>
        <code class="nx">re1</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>        <code class="c1">// true--ignored `lastIndex`</code>
        <code class="nx">re1</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>          <code class="c1">// 4--not updated</code></pre>
        
        <p>Three things to observe about this snippet:</p>
        
        <ul>
        <li>
        <p><code>test(..)</code> doesn’t pay any attention to <code>lastIndex</code>’s value, and
        always just performs its match from the beginning of the input string.</p>
        </li>
        <li>
        <p>Because our pattern does not have a <code>^</code> start-of-input anchor, the
        search for <code>"foo"</code> is free to move ahead through the whole string
        looking for a match.</p>
        </li>
        <li>
        <p><code>lastIndex</code> is not updated by <code>test(..)</code>.</p>
        </li>
        </ul>
        
        <p>Now, let’s try a sticky mode regular expression:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re2</code> <code class="o">=</code> <code class="sr">/foo/y</code><code class="p">,</code>    <code class="c1">// &lt;-- notice the `y` sticky flag</code>
            <code class="nx">str</code> <code class="o">=</code> <code class="s2">"++foo++"</code><code class="p">;</code>
        
        <code class="nx">re2</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>       <code class="c1">// 0</code>
        <code class="nx">re2</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>     <code class="c1">// false--"foo" not found at `0`</code>
        <code class="nx">re2</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>       <code class="c1">// 0</code>
        
        <code class="nx">re2</code><code class="p">.</code><code class="nx">lastIndex</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
        <code class="nx">re2</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>     <code class="c1">// true</code>
        <code class="nx">re2</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>       <code class="c1">// 5--updated to after previous match</code>
        
        <code class="nx">re2</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>     <code class="c1">// false</code>
        <code class="nx">re2</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>       <code class="c1">// 0--reset after previous match failure</code></pre>
        
        <p>And so our new observations about sticky mode:</p>
        
        <ul>
        <li>
        <p><code>test(..)</code> uses <code>lastIndex</code> as the exact and only position in <code>str</code> to
        look to make a match. There is no moving ahead to look for the match—it’s either there at the <code>lastIndex</code> position or not.</p>
        </li>
        <li>
        <p>If a match is made, <code>test(..)</code> updates <code>lastIndex</code> to point to the
        character immediately following the match. If a match fails, <code>test(..)</code>
        resets <code>lastIndex</code> back to <code>0</code>.</p>
        </li>
        </ul>
        
        <p>Normal nonsticky patterns that aren’t otherwise <code>^</code>-rooted to the
        start-of-input are free to move ahead in the input string looking for a
        match. But sticky mode restricts the pattern to matching just at the
        position of <code>lastIndex</code>.</p>
        
        <p>As I suggested at the beginning of this section, another way of looking
        at this is that <code>y</code> implies a virtual anchor at the beginning of the
        pattern that is relative (aka constrains the start of the match) to
        exactly the <code>lastIndex</code> position.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>In previous literature on the topic, it has alternatively
        been asserted that this behavior is like <code>y</code> implying a <code>^</code>
        (start-of-input) anchor in the pattern. This is inaccurate. We’ll
        explain in further detail in <a data-type="xref" href="#anchor_sticky">“Anchored Sticky”</a>.</p>
        </div>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Sticky Positioning"><div class="sect3" id="idm45967371000808">
        <h3>Sticky Positioning</h3>
        
        <p>It may seem strangely limiting that to use <code>y</code> for repeated matches, you
        have to manually ensure <code>lastIndex</code> is in the exact right position, as
        it has no move-ahead capability for matching.</p>
        
        <p>Here’s one possible scenario: if you know that the match you care about
        is always going to be at a position that’s a multiple of a number (e.g.,
        <code>0</code>, <code>10</code>, <code>20</code>, etc.), you can just construct a limited pattern
        matching what you care about, but then manually set <code>lastIndex</code> each
        time before matching to those fixed positions.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re</code> <code class="o">=</code> <code class="sr">/f../y</code><code class="p">,</code>
            <code class="nx">str</code> <code class="o">=</code> <code class="s2">"foo       far       fad"</code><code class="p">;</code>
        
        <code class="nx">str</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code> <code class="nx">re</code> <code class="p">);</code>        <code class="c1">// ["foo"]</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>
        <code class="nx">str</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code> <code class="nx">re</code> <code class="p">);</code>        <code class="c1">// ["far"]</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code> <code class="o">=</code> <code class="mi">20</code><code class="p">;</code>
        <code class="nx">str</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code> <code class="nx">re</code> <code class="p">);</code>        <code class="c1">// ["fad"]</code></pre>
        
        <p>However, if you’re parsing a string that isn’t formatted in fixed
        positions like that, figuring out what to set <code>lastIndex</code> to before each
        match is likely going to be untenable.</p>
        
        <p>There’s a saving nuance to consider here. <code>y</code> requires that <code>lastIndex</code>
        be in the exact position for a match to occur. But it doesn’t strictly
        require that <em>you</em> manually set <code>lastIndex</code>.</p>
        
        <p>Instead, you can construct your expressions in such a way that they
        capture in each main match everything before and after the thing you
        care about, up to right before the next thing you’ll care to match.</p>
        
        <p>Because <code>lastIndex</code> will set to the next character beyond the end of a
        match, if you’ve matched everything up to that point, <code>lastIndex</code> will
        always be in the correct position for the <code>y</code> pattern to start from the
        next time.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>If you can’t predict the structure of the input string in a
        sufficiently patterned way like that, this technique may not be suitable
        and you may not be able to use <code>y</code>.</p>
        </div>
        
        <p>Having structured string input is likely the most practical scenario
        where <code>y</code> will be capable of performing repeated matching throughout a
        string. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re</code> <code class="o">=</code> <code class="sr">/\d+\.\s(.*?)(?:\s|$)/y</code>
            <code class="nx">str</code> <code class="o">=</code> <code class="s2">"1. foo 2. bar 3. baz"</code><code class="p">;</code>
        
        <code class="nx">str</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code> <code class="nx">re</code> <code class="p">);</code>        <code class="c1">// [ "1. foo ", "foo" ]</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>           <code class="c1">// 7--correct position!</code>
        <code class="nx">str</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code> <code class="nx">re</code> <code class="p">);</code>        <code class="c1">// [ "2. bar ", "bar" ]</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>           <code class="c1">// 14--correct position!</code>
        <code class="nx">str</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code> <code class="nx">re</code> <code class="p">);</code>        <code class="c1">// ["3. baz", "baz"]</code></pre>
        
        <p>This works because I knew something ahead of time about the structure of
        the input string: there is always a numeral prefix like <code>"1. "</code> before
        the desired match (<code>"foo"</code>, etc.), and either a space after it, or the
        end of the string (<code>$</code> anchor). So the regular expression I constructed
        captures all of that in each main match, and then I use a matching group
        <code>( )</code> so that the stuff I really care about is separated out for
        convenience.</p>
        
        <p>After the first match (<code>"1. foo "</code>), the <code>lastIndex</code> is <code>7</code>, which is
        already the position needed to start the next match, for <code>"2. bar "</code>,
        and so on.</p>
        
        <p>If you’re going to use <code>y</code> sticky mode for repeated matches, you’ll
        probably want to look for opportunities to have <code>lastIndex</code>
        automatically positioned as we’ve just demonstrated.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Sticky Versus Global"><div class="sect3" id="idm45967370859144">
        <h3>Sticky Versus Global</h3>
        
        <p>Some readers may be aware that you can emulate something like this
        <code>lastIndex</code>-relative matching with the <code>g</code> global match flag and the
        <code>exec(..)</code> method, as so:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re</code> <code class="o">=</code> <code class="sr">/o+./g</code><code class="p">,</code>        <code class="c1">// &lt;-- look, `g`!</code>
            <code class="nx">str</code> <code class="o">=</code> <code class="s2">"foot book more"</code><code class="p">;</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>         <code class="c1">// ["oot"]</code>
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>           <code class="c1">// 4</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>         <code class="c1">// ["ook"]</code>
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>           <code class="c1">// 9</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>         <code class="c1">// ["or"]</code>
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>           <code class="c1">// 13</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>         <code class="c1">// null--no more matches!</code>
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>           <code class="c1">// 0--starts over now!</code></pre>
        
        <p>While it’s true that <code>g</code> pattern matches with <code>exec(..)</code> start their
        matching from <code>lastIndex</code>’s current value, and also update <code>lastIndex</code>
        after each match (or failure), this is not the same thing as <code>y</code>’s
        behavior.</p>
        
        <p>Notice in the previous snippet that <code>"ook"</code>, located at position <code>6</code>,
        was matched and found by the second <code>exec(..)</code> call, even though at the
        time, <code>lastIndex</code> was <code>4</code> (from the end of the previous match). Why?
        Because as we said earlier, nonsticky matches are free to move ahead in
        their matching. A sticky mode expression would have failed here, because
        it would not be allowed to move ahead.</p>
        
        <p>In addition to perhaps undesired move-ahead matching behavior, another
        downside to just using <code>g</code> instead of <code>y</code> is that <code>g</code> changes the
        behavior of some matching methods, like <code>str.match(re)</code>.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re</code> <code class="o">=</code> <code class="sr">/o+./g</code><code class="p">,</code>        <code class="c1">// &lt;-- look, `g`!</code>
            <code class="nx">str</code> <code class="o">=</code> <code class="s2">"foot book more"</code><code class="p">;</code>
        
        <code class="nx">str</code><code class="p">.</code><code class="nx">match</code><code class="p">(</code> <code class="nx">re</code> <code class="p">);</code>        <code class="c1">// ["oot","ook","or"]</code></pre>
        
        <p>See how all the matches were returned at once? Sometimes that’s OK, but
        sometimes that’s not what you want.</p>
        
        <p>The <code>y</code> sticky flag will give you one-at-a-time progressive matching
        with utilities like <code>test(..)</code> and <code>match(..)</code>. Just make sure the
        <code>lastIndex</code> is always in the right position for each match!</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Anchored Sticky"><div class="sect3" id="anchor_sticky">
        <h3>Anchored Sticky</h3>
        
        <p>As we warned earlier, it’s inaccurate to think of sticky mode as
        implying a pattern starts with <code>^</code>. The <code>^</code> anchor has a distinct
        meaning in regular expressions, which is <em>not altered</em> by sticky mode.
        <code>^</code> is an anchor that <em>always</em> refers to the beginning of the input, and
        <em>is not</em> in any way relative to <code>lastIndex</code>.</p>
        
        <p>Besides poor/inaccurate documentation on this topic, the confusion is
        unfortunately strengthened further because an older pre-ES6 experiment
        with sticky mode in Firefox <em>did</em> make <code>^</code> relative to <code>lastIndex</code>, so
        that behavior has been around for years.</p>
        
        <p>ES6 elected not to do it that way. <code>^</code> in a pattern means start-of-input
        absolutely and only.</p>
        
        <p>As a consequence, a pattern like <code>/^foo/y</code> will always and only find a
        <code>"foo"</code> match at the beginning of a string, <em>if it’s allowed to match
        there</em>. If <code>lastIndex</code> is not <code>0</code>, the match will fail. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re</code> <code class="o">=</code> <code class="sr">/^foo/y</code><code class="p">,</code>
            <code class="nx">str</code> <code class="o">=</code> <code class="s2">"foo"</code><code class="p">;</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>         <code class="c1">// true</code>
        <code class="nx">re</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>         <code class="c1">// false</code>
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>           <code class="c1">// 0--reset after failure</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="nx">re</code><code class="p">.</code><code class="nx">test</code><code class="p">(</code> <code class="nx">str</code> <code class="p">);</code>         <code class="c1">// false--failed for positioning</code>
        <code class="nx">re</code><code class="p">.</code><code class="nx">lastIndex</code><code class="p">;</code>           <code class="c1">// 0--reset after failure</code></pre>
        
        <p>Bottom line: <code>y</code> plus <code>^</code> plus <code>lastIndex &gt; 0</code> is an incompatible
        combination that will always cause a failed match.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>While <code>y</code> does not alter the meaning of <code>^</code> in any way, the <code>m</code>
        multiline mode <em>does</em>, such that <code>^</code> means start-of-input <em>or</em> start of
        text after a newline. So, if you combine <code>y</code> and <code>m</code> flags together for
        a pattern, you can find multiple <code>^</code>-rooted matches in a string. But
        remember: because it’s <code>y</code> sticky, you’ll have to make sure <code>lastIndex</code>
        is pointing at the correct new line position (likely by matching to the
        end of the line) each subsequent time, or no subsequent matches will be
        made.</p>
        </div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Regular Expression flags"><div class="sect2" id="idm45967371168584">
        <h2>Regular Expression flags</h2>
        
        <p>Prior to ES6, if you wanted to examine a regular expression object to
        see what flags it had applied, you needed to parse them out—ironically, probably with another regular expression—from the content
        of the <code>source</code> property, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re</code> <code class="o">=</code> <code class="sr">/foo/ig</code><code class="p">;</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code>          <code class="c1">// "/foo/ig"</code>
        
        <code class="kd">var</code> <code class="nx">flags</code> <code class="o">=</code> <code class="nx">re</code><code class="p">.</code><code class="nx">toString</code><code class="p">().</code><code class="nx">match</code><code class="p">(</code> <code class="sr">/\/([gim]*)$/</code> <code class="p">)[</code><code class="mi">1</code><code class="p">];</code>
        
        <code class="nx">flags</code><code class="p">;</code>                  <code class="c1">// "ig"</code></pre>
        
        <p>As of ES6, you can now get these values directly, with the new <code>flags</code>
        property:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re</code> <code class="o">=</code> <code class="sr">/foo/ig</code><code class="p">;</code>
        
        <code class="nx">re</code><code class="p">.</code><code class="nx">flags</code><code class="p">;</code>               <code class="c1">// "gi"</code></pre>
        
        <p>It’s a small nuance, but the ES6 specification calls for the
        expression’s flags to be listed in this order: <code>"gimuy"</code>, regardless of
        what order the original pattern was specified with. That’s the reason for the
        difference between <code>/ig</code> and <code>"gi"</code>.</p>
        
        <p>No, the order of flags specified or listed doesn’t matter.</p>
        
        <p>Another tweak from ES6 is that the <code>RegExp(..)</code> constructor is now
        <code>flags</code>-aware if you pass it an existing regular expression:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">re1</code> <code class="o">=</code> <code class="sr">/foo*/y</code><code class="p">;</code>
        <code class="nx">re1</code><code class="p">.</code><code class="nx">source</code><code class="p">;</code>                         <code class="c1">// "foo*"</code>
        <code class="nx">re1</code><code class="p">.</code><code class="nx">flags</code><code class="p">;</code>                          <code class="c1">// "y"</code>
        
        <code class="kd">var</code> <code class="nx">re2</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code> <code class="nx">re1</code> <code class="p">);</code>
        <code class="nx">re2</code><code class="p">.</code><code class="nx">source</code><code class="p">;</code>                         <code class="c1">// "foo*"</code>
        <code class="nx">re2</code><code class="p">.</code><code class="nx">flags</code><code class="p">;</code>                          <code class="c1">// "y"</code>
        
        <code class="kd">var</code> <code class="nx">re3</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">RegExp</code><code class="p">(</code> <code class="nx">re1</code><code class="p">,</code> <code class="s2">"ig"</code> <code class="p">);</code>
        <code class="nx">re3</code><code class="p">.</code><code class="nx">source</code><code class="p">;</code>                         <code class="c1">// "foo*"</code>
        <code class="nx">re3</code><code class="p">.</code><code class="nx">flags</code><code class="p">;</code>                          <code class="c1">// "gi"</code></pre>
        
        <p>Prior to ES6, the <code>re3</code> construction would throw an error, but as of ES6
        you can override the flags when duplicating.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Number Literal Extensions"><div class="sect1" id="idm45967370574712">
        <h1>Number Literal Extensions</h1>
        
        <p>Prior to ES5, number literals looked like the following—the octal
        form was not officially specified, only allowed as an extension that
        browsers had come to de facto agreement on:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">dec</code> <code class="o">=</code> <code class="mi">42</code><code class="p">,</code>
            <code class="nx">oct</code> <code class="o">=</code> <code class="mi">052</code><code class="p">,</code>
            <code class="nx">hex</code> <code class="o">=</code> <code class="mh">0x2a</code><code class="p">;</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>Though you are specifying a number in different bases, the
        number’s mathematic value is what is stored, and the default output
        interpretation is always base-10. The three variables in the previous
        snippet all have the <code>42</code> value stored in them.</p>
        </div>
        
        <p>To further illustrate that <code>052</code> was a nonstandard form extension,
        consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">Number</code><code class="p">(</code> <code class="s2">"42"</code> <code class="p">);</code>             <code class="c1">// 42</code>
        <code class="nb">Number</code><code class="p">(</code> <code class="s2">"052"</code> <code class="p">);</code>            <code class="c1">// 52</code>
        <code class="nb">Number</code><code class="p">(</code> <code class="s2">"0x2a"</code> <code class="p">);</code>           <code class="c1">// 42</code></pre>
        
        <p>ES5 continued to permit the browser-extended octal form (including such
        inconsistencies), except that in strict mode, the octal literal (<code>052</code>)
        form is disallowed. This restriction was done mainly because many
        developers had the habit (from other languages) of seemingly innocuously
        prefixing otherwise base-10 numbers with `0`s for code alignment
        purposes, and then running into the accidental fact that they’d changed
        the number value entirely!</p>
        
        <p>ES6 continues the legacy of changes/variations to how number literals
        outside base-10 numbers can be represented. There’s now an official
        octal form, an amended hexadecimal form, and a brand-new binary form.
        For web compatibility reasons, the old octal <code>052</code> form will continue to
        be legal (though unspecified) in nonstrict mode, but should really
        never be used anymore.</p>
        
        <p>Here are the new ES6 number literal forms:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">dec</code> <code class="o">=</code> <code class="mi">42</code><code class="p">,</code>
            <code class="nx">oct</code> <code class="o">=</code> <code class="mo">0o52</code><code class="p">,</code>         <code class="c1">// or `0O52` :(</code>
            <code class="nx">hex</code> <code class="o">=</code> <code class="mh">0x2a</code><code class="p">,</code>         <code class="c1">// or `0X2a` :/</code>
            <code class="nx">bin</code> <code class="o">=</code> <code class="mb">0b101010</code><code class="p">;</code>     <code class="c1">// or `0B101010` :/</code></pre>
        
        <p>The only decimal form allowed is base-10. Octal, hexadecimal, and binary
        are all integer forms.</p>
        
        <p>And the string representations of these forms are all able to be
        coerced/converted to their number equivalent:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">Number</code><code class="p">(</code> <code class="s2">"42"</code> <code class="p">);</code>         <code class="c1">// 42</code>
        <code class="nb">Number</code><code class="p">(</code> <code class="s2">"0o52"</code> <code class="p">);</code>       <code class="c1">// 42</code>
        <code class="nb">Number</code><code class="p">(</code> <code class="s2">"0x2a"</code> <code class="p">);</code>       <code class="c1">// 42</code>
        <code class="nb">Number</code><code class="p">(</code> <code class="s2">"0b101010"</code> <code class="p">);</code>   <code class="c1">// 42</code></pre>
        
        <p>Though not strictly new to ES6, it’s a little-known fact that you can
        actually go the opposite direction of conversion (well, sort of):</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
        
        <code class="nx">a</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code>           <code class="c1">// "42"--also `a.toString( 10 )`</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code> <code class="mi">8</code> <code class="p">);</code>        <code class="c1">// "52"</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code> <code class="mi">16</code> <code class="p">);</code>       <code class="c1">// "2a"</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">toString</code><code class="p">(</code> <code class="mi">2</code> <code class="p">);</code>        <code class="c1">// "101010"</code></pre>
        
        <p>In fact, you can represent a number this way in any base from <code>2</code> to
        <code>36</code>, though it’d be rare that you’d go outside the standard bases: 2,
        8, 10, and 16.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Unicode"><div class="sect1" id="unicode_sect">
        <h1>Unicode</h1>
        
        <p>Let me just say that this section is not an exhaustive
        everything-you-ever-wanted-to-know-about-Unicode resource. I want to
        cover what you need to know that’s <em>changing</em> for Unicode in ES6, but we
        won’t go much deeper than that. <a href="http://twitter.com/mathias">Mathias Bynens</a> has written/spoken extensively and
        brilliantly about JS and Unicode (see
        <a href="https://mathiasbynens.be/notes/javascript-unicode"><em class="hyperlink">https://mathiasbynens.be/notes/javascript-unicode</em></a> and
        <a href="http://fluentconf.com/javascript-html-2015/public/content/2015/02/18-javascript-loves-unicode)"><em class="hyperlink">http://fluentconf.com/javascript-html-2015/public/content/2015/02/18-javascript-loves-unicode)</em></a>.</p>
        
        <p>The Unicode characters that range from <code>0x0000</code> to <code>0xFFFF</code> contain all
        the standard printed characters (in various languages) that you’re
        likely to have seen or interacted with. This group of characters is
        called the <em>Basic Multilingual Plane (BMP)</em>. The BMP even contains fun
        symbols like this cool snowman: ☃ (U+2603).</p>
        
        <p>There are lots of other extended Unicode characters beyond this BMP set,
        which range up to <code>0x10FFFF</code>. These symbols are often referred to as
        <em>astral</em> symbols, as that’s the name given to the set of 16 <em>planes</em>
        (e.g., layers/groupings) of characters beyond the BMP. Examples of
        astral symbols include <code>𝄞</code> U+1D11E) and 💩 U+1F4A9).</p>
        
        <p>Prior to ES6, JavaScript strings could specify Unicode characters using
        Unicode escaping, such as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">snowman</code> <code class="o">=</code> <code class="s2">"\u2603"</code><code class="p">;</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">snowman</code> <code class="p">);</code>         <code class="c1">// "☃"</code></pre>
        
        <p>However, the <code>\uXXXX</code> Unicode escaping only supports four hexadecimal
        characters, so you can only represent the BMP set of characters in this
        way. To represent an astral character using Unicode escaping prior to
        ES6, you need to use a <em>surrogate pair</em>—basically two specially
        calculated Unicode-escaped characters side by side, which JS interprets
        together as a single astral character:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">gclef</code> <code class="o">=</code> <code class="s2">"\uD834\uDD1E"</code><code class="p">;</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">gclef</code> <code class="p">);</code>           <code class="c1">// "𝄞"</code></pre>
        
        <p>As of ES6, we now have a new form for Unicode escaping (in strings and
        regular expressions), called Unicode <em>code point escaping</em>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">gclef</code> <code class="o">=</code> <code class="s2">"\u{1D11E}"</code><code class="p">;</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">gclef</code> <code class="p">);</code>           <code class="c1">// "𝄞"</code></pre>
        
        <p>As you can see, the difference is the presence of the <code>{ }</code> in the
        escape sequence, which allows it to contain any number of hexadecimal
        characters. Because you only need six to represent the highest possible
        code point value in Unicode (i.e., 0x10FFFF), this is sufficient.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Unicode-Aware String Operations"><div class="sect2" id="ua_stringOps">
        <h2>Unicode-Aware String Operations</h2>
        
        <p>By default, JavaScript string operations and methods are not sensitive
        to astral symbols in string values. So, they treat each BMP character
        individually, even the two surrogate halves that make up an otherwise
        single astral character. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">snowman</code> <code class="o">=</code> <code class="s2">"☃"</code><code class="p">;</code>
        <code class="nx">snowman</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                 <code class="c1">// 1</code>
        
        <code class="kd">var</code> <code class="nx">gclef</code> <code class="o">=</code> <code class="s2">"𝄞"</code><code class="p">;</code>
        <code class="nx">gclef</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                   <code class="c1">// 2</code></pre>
        
        <p>So, how do we accurately calculate the length of such a string? In this
        scenario, the following trick will work:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">gclef</code> <code class="o">=</code> <code class="s2">"𝄞"</code><code class="p">;</code>
        
        <code class="p">[</code><code class="o">...</code><code class="nx">gclef</code><code class="p">].</code><code class="nx">length</code><code class="p">;</code>              <code class="c1">// 1</code>
        <code class="nb">Array</code><code class="p">.</code><code class="nx">from</code><code class="p">(</code> <code class="nx">gclef</code> <code class="p">).</code><code class="nx">length</code><code class="p">;</code>     <code class="c1">// 1</code></pre>
        
        <p>Recall from <a data-type="xref" href="#forofloops-sect">“for..of Loops”</a> earlier in this chapter that
        ES6 strings have built-in iterators. This iterator happens to be
        Unicode-aware, meaning it will automatically output an astral symbol as
        a single value. We take advantage of that using the <code>...</code> spread
        operator in an array literal, which creates an array of the string’s
        symbols. Then we just inspect the length of that resultant array. ES6’s
        <code>Array.from(..)</code> does basically the same thing as <code>[...XYZ]</code>, but we’ll
        cover that utility in detail in <a data-type="xref" href="ch06.html#chapter-6-api-additions">Chapter&nbsp;6</a>.</p>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>It should be noted that constructing and exhausting an
        iterator just to get the length of a string is quite expensive on
        performance, relatively speaking, compared to what a theoretically
        optimized native utility/property would do.</p>
        </div>
        
        <p>Unfortunately, the full answer is not as simple or straightforward. In
        addition to the surrogate pairs (which the string iterator takes care
        of), there are special Unicode code points that behave in other special
        ways, which is much harder to account for. For example, there’s a set of
        code points that modify the previous adjacent character, known as
        <em>Combining Diacritical Marks</em>.</p>
        
        <p>Consider these two string outputs:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">s1</code> <code class="p">);</code>              <code class="c1">// "é"</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">s2</code> <code class="p">);</code>              <code class="c1">// "é"</code></pre>
        
        <p>They look the same, but they’re not! Here’s how we created <code>s1</code> and
        <code>s2</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s1</code> <code class="o">=</code> <code class="s2">"\xE9"</code><code class="p">,</code>
            <code class="nx">s2</code> <code class="o">=</code> <code class="s2">"e\u0301"</code><code class="p">;</code></pre>
        
        <p>As you can probably guess, our previous <code>length</code> trick doesn’t work with
        <code>s2</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="p">[</code><code class="o">...</code><code class="nx">s1</code><code class="p">].</code><code class="nx">length</code><code class="p">;</code>                 <code class="c1">// 1</code>
        <code class="p">[</code><code class="o">...</code><code class="nx">s2</code><code class="p">].</code><code class="nx">length</code><code class="p">;</code>                 <code class="c1">// 2</code></pre>
        
        <p>So what can we do? In this case, we can perform a <em>Unicode
        normalization</em> on the value before inquiring about its length, using the
        ES6 <code>String#normalize(..)</code> utility (which we’ll cover more in <a data-type="xref" href="ch06.html#chapter-6-api-additions">Chapter&nbsp;6</a>):</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s1</code> <code class="o">=</code> <code class="s2">"\xE9"</code><code class="p">,</code>
            <code class="nx">s2</code> <code class="o">=</code> <code class="s2">"e\u0301"</code><code class="p">;</code>
        
        <code class="nx">s1</code><code class="p">.</code><code class="nx">normalize</code><code class="p">().</code><code class="nx">length</code><code class="p">;</code>          <code class="c1">// 1</code>
        <code class="nx">s2</code><code class="p">.</code><code class="nx">normalize</code><code class="p">().</code><code class="nx">length</code><code class="p">;</code>          <code class="c1">// 1</code>
        
        <code class="nx">s1</code> <code class="o">===</code> <code class="nx">s2</code><code class="p">;</code>                      <code class="c1">// false</code>
        <code class="nx">s1</code> <code class="o">===</code> <code class="nx">s2</code><code class="p">.</code><code class="nx">normalize</code><code class="p">();</code>          <code class="c1">// true</code></pre>
        
        <p>Essentially, <code>normalize(..)</code> takes a sequence like <code>"e\u0301"</code> and
        normalizes it to <code>"\xE9"</code>. Normalization can even combine multiple
        adjacent combining marks if there’s a suitable Unicode character they
        combine to:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s1</code> <code class="o">=</code> <code class="s2">"o\u0302\u0300"</code><code class="p">,</code>
            <code class="nx">s2</code> <code class="o">=</code> <code class="nx">s1</code><code class="p">.</code><code class="nx">normalize</code><code class="p">(),</code>
            <code class="nx">s3</code> <code class="o">=</code> <code class="s2">"ồ"</code><code class="p">;</code>
        
        <code class="nx">s1</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                      <code class="c1">// 3</code>
        <code class="nx">s2</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                      <code class="c1">// 1</code>
        <code class="nx">s3</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>                      <code class="c1">// 1</code>
        
        <code class="nx">s2</code> <code class="o">===</code> <code class="nx">s3</code><code class="p">;</code>                      <code class="c1">// true</code></pre>
        
        <p>Unfortunately, normalization isn’t fully perfect here, either. If you
        have multiple combining marks modifying a single character, you may not
        get the length count you’d expect, because there may not be a single
        defined normalized character that represents the combination of all the
        marks. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s1</code> <code class="o">=</code> <code class="s2">"e\u0301\u0330"</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">s1</code> <code class="p">);</code>              <code class="c1">// "ḛ́"</code>
        
        <code class="nx">s1</code><code class="p">.</code><code class="nx">normalize</code><code class="p">().</code><code class="nx">length</code><code class="p">;</code>          <code class="c1">// 2</code></pre>
        
        <p>The further you go down this rabbit hole, the more you realize that it’s
        difficult to get one precise definition for “length.” What we see
        visually rendered as a single character—more precisely called a
        <em>grapheme</em>—doesn’t always strictly relate to a single “character” in
        the program processing sense.</p>
        <div data-type="tip"><h6>Tip</h6>
        <p>If you want to see just how deep this rabbit hole goes, check out
        the <a href="http://www.Unicode.org/reports/tr29/#Grapheme_Cluster_Boundaries">“Grapheme Cluster Boundaries” algorithm</a>.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Character Positioning"><div class="sect2" id="idm45967370047832">
        <h2>Character Positioning</h2>
        
        <p>Similar to length complications, what does it actually mean to ask,
        “what is the character at position 2?” The naive pre-ES6 answer comes from <code>charAt(..)</code>, which will not respect the atomicity of
        an astral character, nor will it take into account combining marks.</p>
        
        <p>Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s1</code> <code class="o">=</code> <code class="s2">"abc\u0301d"</code><code class="p">,</code>
            <code class="nx">s2</code> <code class="o">=</code> <code class="s2">"ab\u0107d"</code><code class="p">,</code>
            <code class="nx">s3</code> <code class="o">=</code> <code class="s2">"ab\u{1d49e}d"</code><code class="p">;</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">s1</code> <code class="p">);</code>              <code class="c1">// "abćd"</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">s2</code> <code class="p">);</code>              <code class="c1">// "abćd"</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">s3</code> <code class="p">);</code>              <code class="c1">// "ab𝒞d"</code>
        
        <code class="nx">s1</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code> <code class="mi">2</code> <code class="p">);</code>                 <code class="c1">// "c"</code>
        <code class="nx">s2</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code> <code class="mi">2</code> <code class="p">);</code>                 <code class="c1">// "ć"</code>
        <code class="nx">s3</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code> <code class="mi">2</code> <code class="p">);</code>                 <code class="c1">// "" &lt;-- unprintable surrogate</code>
        <code class="nx">s3</code><code class="p">.</code><code class="nx">charAt</code><code class="p">(</code> <code class="mi">3</code> <code class="p">);</code>                 <code class="c1">// "" &lt;-- unprintable surrogate</code></pre>
        
        <p>So, is ES6 giving us a Unicode-aware version of <code>charAt(..)</code>?
        Unfortunately, no. At the time of this writing, there’s a proposal for
        such a utility that’s under consideration for post-ES6.</p>
        
        <p>But with what we explored in the previous section (and of course with
        the limitations noted thereof!), we can hack an ES6 answer:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s1</code> <code class="o">=</code> <code class="s2">"abc\u0301d"</code><code class="p">,</code>
            <code class="nx">s2</code> <code class="o">=</code> <code class="s2">"ab\u0107d"</code><code class="p">,</code>
            <code class="nx">s3</code> <code class="o">=</code> <code class="s2">"ab\u{1d49e}d"</code><code class="p">;</code>
        
        <code class="p">[</code><code class="o">...</code><code class="nx">s1</code><code class="p">.</code><code class="nx">normalize</code><code class="p">()][</code><code class="mi">2</code><code class="p">];</code>         <code class="c1">// "ć"</code>
        <code class="p">[</code><code class="o">...</code><code class="nx">s2</code><code class="p">.</code><code class="nx">normalize</code><code class="p">()][</code><code class="mi">2</code><code class="p">];</code>         <code class="c1">// "ć"</code>
        <code class="p">[</code><code class="o">...</code><code class="nx">s3</code><code class="p">.</code><code class="nx">normalize</code><code class="p">()][</code><code class="mi">2</code><code class="p">];</code>         <code class="c1">// "𝒞"</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>Reminder of an earlier warning: constructing and exhausting
        an iterator each time you want to get at a single character is… very
        not ideal, performance-wise. Let’s hope we get a built-in and optimized
        utility for this soon, post-ES6.</p>
        </div>
        
        <p>What about a Unicode-aware version of the <code>charCodeAt(..)</code> utility? ES6
        gives us <code>codePointAt(..)</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s1</code> <code class="o">=</code> <code class="s2">"abc\u0301d"</code><code class="p">,</code>
            <code class="nx">s2</code> <code class="o">=</code> <code class="s2">"ab\u0107d"</code><code class="p">,</code>
            <code class="nx">s3</code> <code class="o">=</code> <code class="s2">"ab\u{1d49e}d"</code><code class="p">;</code>
        
        <code class="nx">s1</code><code class="p">.</code><code class="nx">normalize</code><code class="p">().</code><code class="nx">codePointAt</code><code class="p">(</code> <code class="mi">2</code> <code class="p">).</code><code class="nx">toString</code><code class="p">(</code> <code class="mi">16</code> <code class="p">);</code>
        <code class="c1">// "107"</code>
        
        <code class="nx">s2</code><code class="p">.</code><code class="nx">normalize</code><code class="p">().</code><code class="nx">codePointAt</code><code class="p">(</code> <code class="mi">2</code> <code class="p">).</code><code class="nx">toString</code><code class="p">(</code> <code class="mi">16</code> <code class="p">);</code>
        <code class="c1">// "107"</code>
        
        <code class="nx">s3</code><code class="p">.</code><code class="nx">normalize</code><code class="p">().</code><code class="nx">codePointAt</code><code class="p">(</code> <code class="mi">2</code> <code class="p">).</code><code class="nx">toString</code><code class="p">(</code> <code class="mi">16</code> <code class="p">);</code>
        <code class="c1">// "1d49e"</code></pre>
        
        <p>What about the other direction? A Unicode-aware version of
        <code>String.fromCharCode(..)</code> is ES6’s <code>String.fromCodePoint(..)</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code> <code class="mh">0x107</code> <code class="p">);</code>      <code class="c1">// "ć"</code>
        
        <code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code> <code class="mh">0x1d49e</code> <code class="p">);</code>    <code class="c1">// "𝒞"</code></pre>
        
        <p>So wait, can we just combine <code>String.fromCodePoint(..)</code> and
        <code>codePointAt(..)</code> to get a better version of a Unicode-aware
        <code>charAt(..)</code> from earlier? Yep!</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s1</code> <code class="o">=</code> <code class="s2">"abc\u0301d"</code><code class="p">,</code>
            <code class="nx">s2</code> <code class="o">=</code> <code class="s2">"ab\u0107d"</code><code class="p">,</code>
            <code class="nx">s3</code> <code class="o">=</code> <code class="s2">"ab\u{1d49e}d"</code><code class="p">;</code>
        
        <code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code> <code class="nx">s1</code><code class="p">.</code><code class="nx">normalize</code><code class="p">().</code><code class="nx">codePointAt</code><code class="p">(</code> <code class="mi">2</code> <code class="p">)</code> <code class="p">);</code>
        <code class="c1">// "ć"</code>
        
        <code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code> <code class="nx">s2</code><code class="p">.</code><code class="nx">normalize</code><code class="p">().</code><code class="nx">codePointAt</code><code class="p">(</code> <code class="mi">2</code> <code class="p">)</code> <code class="p">);</code>
        <code class="c1">// "ć"</code>
        
        <code class="nb">String</code><code class="p">.</code><code class="nx">fromCodePoint</code><code class="p">(</code> <code class="nx">s3</code><code class="p">.</code><code class="nx">normalize</code><code class="p">().</code><code class="nx">codePointAt</code><code class="p">(</code> <code class="mi">2</code> <code class="p">)</code> <code class="p">);</code>
        <code class="c1">// "𝒞"</code></pre>
        
        <p>There’s quite a few other string methods we haven’t addressed here,
        including <code>toUpperCase()</code>, <code>toLowerCase()</code>, <code>substring(..)</code>,
        <code>indexOf(..)</code>, <code>slice(..)</code>, and a dozen others. None of these have been
        changed or augmented for full Unicode awareness, so you should be very
        careful—probably just avoid them!—when working with strings
        containing astral symbols.</p>
        
        <p>There are also several string methods that use regular expressions for
        their behavior, like <code>replace(..)</code> and <code>match(..)</code>. Thankfully, ES6
        brings Unicode awareness to regular expressions, as we covered in
        <a data-type="xref" href="#unicode-flag">“Unicode Flag”</a>.</p>
        
        <p>OK, there we have it! JavaScript’s Unicode string support is
        significantly better over pre-ES6 (though still not perfect) with the
        various additions we’ve just covered.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Unicode Identifier Names"><div class="sect2" id="idm45967369619080">
        <h2>Unicode Identifier Names</h2>
        
        <p>Unicode can also be used in identifier names (variables, properties,
        etc.). Prior to ES6, you could do this with Unicode-escapes, like:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">\u03A9</code> <code class="o">=</code> <code class="mi">42</code><code class="p">;</code>
        
        <code class="c1">// same as: var Ω = 42;</code></pre>
        
        <p>As of ES6, you can also use the earlier explained code point escape
        syntax:</p>
        <pre data-type="programlisting" data-code-language="js"><code class="kd">var</code><code> </code><code class="err">\</code><code class="nx">u</code><code class="p">{</code><code class="mi">2</code><code class="nx">B400</code><code class="p">}</code><code> </code><code class="o">=</code><code> </code><code class="mi">42</code><code class="p">;</code><code>
        
        </code><code class="c1">// same as: var </code><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491905241/files/assets/unicodecharacter.png" width="33" height="33"><code class="c1"> = 42;</code></pre>
        
        <p>There’s a complex set of rules around exactly which Unicode characters
        are allowed. Furthermore, some are allowed only if they’re not the first
        character of the identifier name.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>Mathias Bynens has a <a href="https://mathiasbynens.be/notes/javascript-identifiers-es6">great post</a> on all the
        nitty-gritty details.</p>
        </div>
        
        <p>The reasons for using such unusual characters in identifier names are
        rather rare and academic. You typically won’t be best served by writing
        code that relies on these esoteric capabilities.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Symbols"><div class="sect1" id="symbolSect">
        <h1>Symbols</h1>
        
        <p>With ES6, for the first time in quite a while, a new primitive type has
        been added to JavaScript: the <code>symbol</code>. Unlike the other primitive
        types, however, symbols don’t have a literal form.</p>
        
        <p>Here’s how you create a symbol:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">sym</code> <code class="o">=</code> <code class="nb">Symbol</code><code class="p">(</code> <code class="s2">"some optional description"</code> <code class="p">);</code>
        
        <code class="k">typeof</code> <code class="nx">sym</code><code class="p">;</code>     <code class="c1">// "symbol"</code></pre>
        
        <p>Some things to note:</p>
        
        <ul>
        <li>
        <p>You cannot and should not use <code>new</code> with <code>Symbol(..)</code>. It’s not a
        constructor, nor are you producing an object.</p>
        </li>
        <li>
        <p>The parameter passed to <code>Symbol(..)</code> is optional. If passed, it should
        be a string that gives a friendly description for the symbol’s purpose.</p>
        </li>
        <li>
        <p>The <code>typeof</code> output is a new value (<code>"symbol"</code>) that is the primary
        way to identify a symbol.</p>
        </li>
        </ul>
        
        <p>The description, if provided, is solely used for the stringification
        representation of the symbol:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">sym</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code>     <code class="c1">// "Symbol(some optional description)"</code></pre>
        
        <p>Similar to how primitive string values are not instances of <code>String</code>,
        symbols are also not instances of <code>Symbol</code>. If, for some reason, you
        want to construct a boxed wrapper object form of a symbol value, you can
        do the following:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">sym</code> <code class="k">instanceof</code> <code class="nb">Symbol</code><code class="p">;</code>      <code class="c1">// false</code>
        
        <code class="kd">var</code> <code class="nx">symObj</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">(</code> <code class="nx">sym</code> <code class="p">);</code>
        <code class="nx">symObj</code> <code class="k">instanceof</code> <code class="nb">Symbol</code><code class="p">;</code>   <code class="c1">// true</code>
        
        <code class="nx">symObj</code><code class="p">.</code><code class="nx">valueOf</code><code class="p">()</code> <code class="o">===</code> <code class="nx">sym</code><code class="p">;</code>   <code class="c1">// true</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p><code>symObj</code> in this snippet is interchangeable with <code>sym</code>; either
        form can be used in all places symbols are utilized. There’s not much
        reason to use the boxed wrapper object form (<code>symObj</code>) instead of the
        primitive form (<code>sym</code>). Keeping with similar advice for other
        primitives, it’s probably best to prefer <code>sym</code> over <code>symObj</code>.</p>
        </div>
        
        <p>The internal value of a symbol itself—referred to as its <code>name</code>—is
        hidden from the code and cannot be obtained. You can think of this
        symbol value as an automatically generated, unique (within your
        application) string value.</p>
        
        <p>But if the value is hidden and unobtainable, what’s the point of having
        a symbol at all?</p>
        
        <p>The main point of a symbol is to create a string-like value that can’t
        collide with any other value. So, for example, consider using a symbol
        as a constant representing an event name:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">const</code> <code class="nx">EVT_LOGIN</code> <code class="o">=</code> <code class="nb">Symbol</code><code class="p">(</code> <code class="s2">"event.login"</code> <code class="p">);</code></pre>
        
        <p>You’d then use <code>EVT_LOGIN</code> in place of a generic string literal like
        <code>"event.login"</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">evthub</code><code class="p">.</code><code class="nx">listen</code><code class="p">(</code> <code class="nx">EVT_LOGIN</code><code class="p">,</code> <code class="kd">function</code><code class="p">(</code><code class="nx">data</code><code class="p">){</code>
            <code class="c1">// ..</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>The benefit here is that <code>EVT_LOGIN</code> holds a value that cannot be
        duplicated (accidentally or otherwise) by any other value, so it is
        impossible for there to be any confusion of which event is being
        dispatched or handled.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>Under the covers, the <code>evthub</code> utility assumed in the previous
        snippet would almost certainly be using the symbol value from the
        <code>EVT_LOGIN</code> argument directly as the property/key in some internal
        object (hash) that tracks event handlers. If <code>evthub</code> instead needed to
        use the symbol value as a real string, it would need to explicitly
        coerce with <code>String(..)</code> or <code>toString()</code>, as implicit string coercion of
        symbols is not allowed.</p>
        </div>
        
        <p>You may use a symbol directly as a property name/key in an object, such
        as a special property you want to treat as hidden or meta in usage.
        It’s important to know that although you intend to treat it as such, it
        is not <em>actually</em> a hidden or untouchable property.</p>
        
        <p>Consider this module that implements the <em>singleton</em> pattern behavior—that is, it only allows itself to be created once:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">const</code> <code class="nx">INSTANCE</code> <code class="o">=</code> <code class="nb">Symbol</code><code class="p">(</code> <code class="s2">"instance"</code> <code class="p">);</code>
        
        <code class="kd">function </code><code class="nx">HappyFace</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">HappyFace</code><code class="p">[</code><code class="nx">INSTANCE</code><code class="p">])</code> <code class="k">return</code> <code class="nx">HappyFace</code><code class="p">[</code><code class="nx">INSTANCE</code><code class="p">];</code>
        
            <code class="kd">function </code><code class="nx">smile</code><code class="p">()</code> <code class="p">{</code> <code class="p">..</code> <code class="p">}</code>
        
            <code class="k">return</code> <code class="nx">HappyFace</code><code class="p">[</code><code class="nx">INSTANCE</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code>
                <code class="nx">smile</code><code class="o">:</code> <code class="nx">smile</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="kd">var</code> <code class="nx">me</code> <code class="o">=</code> <code class="nx">HappyFace</code><code class="p">(),</code>
            <code class="nx">you</code> <code class="o">=</code> <code class="nx">HappyFace</code><code class="p">();</code>
        
        <code class="nx">me</code> <code class="o">===</code> <code class="nx">you</code><code class="p">;</code>			<code class="c1">// true</code></pre>
        
        <p>The <code>INSTANCE</code> symbol value here is a special, almost hidden, meta-like
        property stored statically on the <code>HappyFace()</code> function object.</p>
        
        <p>It could alternatively have been a plain old property like <code>__instance</code>,
        and the behavior would have been identical. The usage of a symbol simply
        improves the metaprogramming style, keeping this <code>INSTANCE</code> property set
        apart from any other normal properties.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Symbol Registry"><div class="sect2" id="idm45967368863576">
        <h2>Symbol Registry</h2>
        
        <p>One mild downside to using symbols as in the last few examples is that
        the <code>EVT_LOGIN</code> and <code>INSTANCE</code> variables had to be stored in an outer
        scope (perhaps even the global scope), or otherwise somehow stored in a
        publicly available location, so that all parts of the code that need to
        use the symbols can access them.</p>
        
        <p>To aid in organizing code with access to these symbols, you can create
        symbol values with the <em>global symbol registry</em>. For example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">const</code> <code class="nx">EVT_LOGIN</code> <code class="o">=</code> <code class="nb">Symbol</code><code class="p">.</code><code class="nx">for</code><code class="p">(</code> <code class="s2">"event.login"</code> <code class="p">);</code>
        
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">EVT_LOGIN</code> <code class="p">);</code>       <code class="c1">// Symbol(event.login)</code></pre>
        
        <p>And:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">HappyFace</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">const</code> <code class="nx">INSTANCE</code> <code class="o">=</code> <code class="nb">Symbol</code><code class="p">.</code><code class="nx">for</code><code class="p">(</code> <code class="s2">"instance"</code> <code class="p">);</code>
        
            <code class="k">if</code> <code class="p">(</code><code class="nx">HappyFace</code><code class="p">[</code><code class="nx">INSTANCE</code><code class="p">])</code> <code class="k">return</code> <code class="nx">HappyFace</code><code class="p">[</code><code class="nx">INSTANCE</code><code class="p">];</code>
        
            <code class="c1">// ..</code>
        
            <code class="k">return</code> <code class="nx">HappyFace</code><code class="p">[</code><code class="nx">INSTANCE</code><code class="p">]</code> <code class="o">=</code> <code class="p">{</code> <code class="p">..</code> <code class="p">};</code>
        <code class="p">}</code></pre>
        
        <p><code>Symbol.for(..)</code> looks in the global symbol registry to see if a symbol
        is already stored with the provided description text, and returns it if
        so. If not, it creates one to return. In other words, the global symbol
        registry treats symbol values, by description text, as singletons
        themselves.</p>
        
        <p>But that also means that any part of your application can retrieve the
        symbol from the registry using <code>Symbol.for(..)</code>, as long as the matching
        description name is used.</p>
        
        <p>Ironically, symbols are basically intended to replace the use of <em>magic
        strings</em> (arbitrary string values given special meaning) in your
        application. But you precisely use <em>magic</em> description string values to
        uniquely identify/locate them in the global symbol registry!</p>
        
        <p>To avoid accidental collisions, you’ll probably want to make your symbol
        descriptions quite unique. One easy way of doing that is to include
        prefix/context/namespacing information in them.</p>
        
        <p>For example, consider a utility such as the following:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">extractValues</code><code class="p">(</code><code class="nx">str</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">key</code> <code class="o">=</code> <code class="nb">Symbol</code><code class="p">.</code><code class="nx">for</code><code class="p">(</code> <code class="s2">"extractValues.parse"</code> <code class="p">),</code>
                <code class="nx">re</code> <code class="o">=</code> <code class="nx">extractValues</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">||</code>
                    <code class="sr">/[^=&amp;]+?=([^&amp;]+?)(?=&amp;|$)/g</code><code class="p">,</code>
                <code class="nx">values</code> <code class="o">=</code> <code class="p">[],</code> <code class="nx">match</code><code class="p">;</code>
        
            <code class="k">while</code> <code class="p">(</code><code class="nx">match</code> <code class="o">=</code> <code class="nx">re</code><code class="p">.</code><code class="nx">exec</code><code class="p">(</code> <code class="nx">str</code> <code class="p">))</code> <code class="p">{</code>
                <code class="nx">values</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code> <code class="nx">match</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="p">);</code>
            <code class="p">}</code>
        
            <code class="k">return</code> <code class="nx">values</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>We use the magic string value <code>"extractValues.parse"</code> because it’s quite
        unlikely that any other symbol in the registry would ever collide with
        that description.</p>
        
        <p>If a user of this utility wants to override the parsing regular
        expression, they can also use the symbol registry:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">extractValues</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">for</code><code class="p">(</code> <code class="s2">"extractValues.parse"</code> <code class="p">)]</code> <code class="o">=</code>
            <code class="sr">/..some pattern../g</code><code class="p">;</code>
        
        <code class="nx">extractValues</code><code class="p">(</code> <code class="s2">"..some string.."</code> <code class="p">);</code></pre>
        
        <p class="pagebreak-before">Aside from the assistance the symbol registry provides in globally
        storing these values, everything we’re seeing here could have been done
        by just actually using the magic string <code>"extractValues.parse"</code> as the
        key, rather than the symbol. The improvements exist at the
        metaprogramming level more than the functional level.</p>
        
        <p>You may have occasion to use a symbol value that has been stored in the
        registry to look up what description text (key) it’s stored under. For
        example, you may need to signal to another part of your application how
        to locate a symbol in the registry because you cannot pass the symbol
        value itself.</p>
        
        <p>You can retrieve a registered symbol’s description text (key) using
        <code>Symbol.keyFor(..)</code>:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">s</code> <code class="o">=</code> <code class="nb">Symbol</code><code class="p">.</code><code class="nx">for</code><code class="p">(</code> <code class="s2">"something cool"</code> <code class="p">);</code>
        
        <code class="kd">var</code> <code class="nx">desc</code> <code class="o">=</code> <code class="nb">Symbol</code><code class="p">.</code><code class="nx">keyFor</code><code class="p">(</code> <code class="nx">s</code> <code class="p">);</code>
        <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">desc</code> <code class="p">);</code>            <code class="c1">// "something cool"</code>
        
        <code class="c1">// get the symbol from the registry again</code>
        <code class="kd">var</code> <code class="nx">s2</code> <code class="o">=</code> <code class="nb">Symbol</code><code class="p">.</code><code class="nx">for</code><code class="p">(</code> <code class="nx">desc</code> <code class="p">);</code>
        
        <code class="nx">s2</code> <code class="o">===</code> <code class="nx">s</code><code class="p">;</code>                       <code class="c1">// true</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Symbols as Object Properties"><div class="sect2" id="idm45967368862952">
        <h2>Symbols as Object Properties</h2>
        
        <p>If a symbol is used as a property/key of an object, it’s stored in a
        special way so that the property will not show up in a normal
        enumeration of the object’s properties:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">foo</code><code class="o">:</code> <code class="mi">42</code><code class="p">,</code>
            <code class="p">[</code> <code class="nb">Symbol</code><code class="p">(</code> <code class="s2">"bar"</code> <code class="p">)</code> <code class="p">]</code><code class="o">:</code> <code class="s2">"hello world"</code><code class="p">,</code>
            <code class="nx">baz</code><code class="o">:</code> <code class="kc">true</code>
        <code class="p">};</code>
        
        <code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertyNames</code><code class="p">(</code> <code class="nx">o</code> <code class="p">);</code>    <code class="c1">// [ "foo","baz" ]</code></pre>
        
        <p>To retrieve an object’s symbol properties:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">Object</code><code class="p">.</code><code class="nx">getOwnPropertySymbols</code><code class="p">(</code> <code class="nx">o</code> <code class="p">);</code>  <code class="c1">// [ Symbol(bar) ]</code></pre>
        
        <p>This makes it clear that a property symbol is not actually hidden or
        inaccessible, as you can always see it in the
        <code>Object.getOwnPropertySymbols(..)</code> list.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Built-In Symbols"><div class="sect3" id="builtinsym-sect">
        <h3>Built-In Symbols</h3>
        
        <p>ES6 comes with a number of predefined built-in symbols that expose
        various meta behaviors on JavaScript object values. However, these
        symbols are <em>not</em> registered in the global symbol registry, as one might
        expect.</p>
        
        <p>Instead, they’re stored as properties on the <code>Symbol</code> function object.
        For example, in <a data-type="xref" href="#forofloops-sect">“for..of Loops”</a> earlier in this chapter, we
        introduced the <code>Symbol.iterator</code> value:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>
        
        <code class="nx">a</code><code class="p">[</code><code class="nb">Symbol</code><code class="p">.</code><code class="nx">iterator</code><code class="p">];</code>         <code class="c1">// native function</code></pre>
        
        <p>The specification uses the <code>@@</code> prefix notation to refer to the built-in
        symbols, the most common ones being: <code>@@iterator</code>, <code>@@toStringTag</code>,
        <code>@@toPrimitive</code>. Several others are defined as well, though they
        probably won’t be used as often.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>See <a data-type="xref" href="ch07.html#well-knownSymbols">“Well-Known Symbols”</a> in <a data-type="xref" href="ch07.html#chapter-7-meta-programming">Chapter&nbsp;7</a> for detailed information
        about how these built-in symbols are used for meta programming purposes.</p>
        </div>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Review"><div class="sect1 noOutline" id="idm45967369159016" tabindex="-1">
        <h1>Review</h1>
        
        <p>ES6 adds a heap of new syntax forms to JavaScript, so there’s plenty to
        learn!</p>
        
        <p>Most of these are designed to ease the pain points of common programming
        idioms, such as setting default values to function parameters and
        gathering the “rest” of the parameters into an array. Destructuring is a
        powerful tool for more concisely expressing assignments of values from
        arrays and nested objects.</p>
        
        <p>While features like <code>=&gt;</code> arrow functions appear to also be all about
        shorter and nicer-looking syntax, they actually have very specific
        behaviors that you should intentionally use only in appropriate
        situations.</p>
        
        <p>Expanded Unicode support, new tricks for regular expressions, and even a
        new primitive <code>symbol</code> type round out the syntactic evolution of ES6.</p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781491905241/files/epub.css" crossorigin="anonymous"></div>
</div>

https://learning.oreilly.com