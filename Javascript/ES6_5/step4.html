<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Async Flow Control"><div class="chapter" id="chapter-4-async-flow-control">
        <h1><span class="label">Chapter 4. </span>Async Flow Control</h1>
        
        
        <p>It’s no secret if you’ve written any significant amount of JavaScript
        that asynchronous programming is a required skill. The primary mechanism
        for managing asynchrony has been the function callback.</p>
        
        <p>However, ES6 adds a new feature that helps address significant
        shortcomings in the callbacks-only approach to async: <em>Promises</em>. In
        addition, we can revisit generators (from the previous chapter) and see
        a pattern for combining the two that’s a major step forward in async
        flow control programming in JavaScript.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Promises"><div class="sect1" id="promises-sect">
        <h1>Promises</h1>
        
        <p>Let’s clear up some misconceptions: Promises are not about replacing
        callbacks. Promises provide a trustable intermediary—that is, between
        your calling code and the async code that will perform the task—to
        manage callbacks.</p>
        
        <p>Another way of thinking about a Promise is as an event listener, upon
        which you can register to listen for an event that lets you know when a
        task has completed. It’s an event that will only ever fire once, but it
        can be thought of as an event nonetheless.</p>
        
        <p>Promises can be chained together, which can sequence a series of
        asychronously completing steps. Together with higher-level abstractions
        like the <code>all(..)</code> method (in classic terms, a “gate”) and the
        <code>race(..)</code> method (in classic terms, a “latch”), promise chains provide
        an approximation of async flow control.</p>
        
        <p>Yet another way of conceptualizing a Promise is that it’s a <em>future
        value</em>, a time-independent container wrapped around a value. This
        container can be reasoned about identically whether the underlying value
        is final or not. Observing the resolution of a Promise extracts this
        value once available. In other words, a Promise is said to be the async
        version of a sync function’s return value.</p>
        
        <p>A Promise can only have one of two possible resolution outcomes:
        fulfilled or rejected, with an optional single value. If a Promise is
        fulfilled, the final value is called a fulfillment. If it’s rejected,
        the final value is called a reason (as in, a “reason for rejection”).
        Promises can only be resolved (fulfillment or rejection) <em>once</em>. Any
        further attempts to fulfill or reject are simply ignored. Thus, once a
        Promise is resolved, it’s an immutable value that cannot be changed.</p>
        
        <p>Clearly, there are several different ways to think about what a Promise
        is. No single perspective is fully sufficient, but each provides a
        separate aspect of the whole. The big takeaway is that they offer a
        significant improvement over callbacks-only async, namely that they
        provide order, predictability, and trustability.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Making and Using Promises"><div class="sect2" id="idm45967361242808">
        <h2>Making and Using Promises</h2>
        
        <p>To construct a promise instance, use the <code>Promise(..)</code> constructor:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">p</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code> <code class="kd">function</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code><code class="nx">reject</code><code class="p">){</code>
            <code class="c1">// ..</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>The two parameters provided to the <code>Promise(..)</code> constructor are
        functions, and are generally named <code>resolve(..)</code> and <code>reject(..)</code>,
        respectively. They are used as:</p>
        
        <ul>
        <li>
        <p>If you call <code>reject(..)</code>, the promise is rejected, and if any value is
        passed to <code>reject(..)</code>, it is set as the reason for rejection.</p>
        </li>
        <li>
        <p>If you call <code>resolve(..)</code> with no value, or any nonpromise value, the
        promise is fulfilled.</p>
        </li>
        <li>
        <p>If you call <code>resolve(..)</code> and pass another promise, this promise
        simply adopts the state—whether immediate or eventual—of the
        passed promise (either fulfillment or rejection).</p>
        </li>
        </ul>
        
        <p>Here’s how you’d typically use a promise to refactor a callback-reliant
        function call. If you start out with an <code>ajax(..)</code> utility that expects
        to be able to call an error-first style callback:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">ajax</code><code class="p">(</code><code class="nx">url</code><code class="p">,</code><code class="nx">cb</code><code class="p">)</code> <code class="p">{</code>
            <code class="c1">// make request, eventually call `cb(..)`</code>
        <code class="p">}</code>
        
        <code class="c1">// ..</code>
        
        <code class="nx">ajax</code><code class="p">(</code> <code class="s2">"http://some.url.1"</code><code class="p">,</code> <code class="kd">function </code><code class="nx">handler</code><code class="p">(</code><code class="nx">err</code><code class="p">,</code><code class="nx">contents</code><code class="p">){</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// handle ajax error</code>
            <code class="p">}</code>
            <code class="k">else</code> <code class="p">{</code>
                <code class="c1">// handle `contents` success</code>
            <code class="p">}</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>You can convert it to:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">ajax</code><code class="p">(</code><code class="nx">url</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code> <code class="kd">function </code><code class="nx">pr</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code><code class="nx">reject</code><code class="p">){</code>
                <code class="c1">// make request, eventually call</code>
                <code class="c1">// either `resolve(..)` or `reject(..)`</code>
            <code class="p">}</code> <code class="p">);</code>
        <code class="p">}</code>
        
        <code class="c1">// ..</code>
        
        <code class="nx">ajax</code><code class="p">(</code> <code class="s2">"http://some.url.1"</code> <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code>
            <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(</code><code class="nx">contents</code><code class="p">){</code>
                <code class="c1">// handle `contents` success</code>
            <code class="p">},</code>
            <code class="kd">function </code><code class="nx">rejected</code><code class="p">(</code><code class="nx">reason</code><code class="p">){</code>
                <code class="c1">// handle ajax error reason</code>
            <code class="p">}</code>
        <code class="p">);</code></pre>
        
        <p>Promises have a <code>then(..)</code> method that accepts one or two callback
        functions. The first function (if present) is treated as the handler to
        call if the promise is fulfilled successfully. The second function (if
        present) is treated as the handler to call if the promise is rejected
        explicitly, or if any error/exception is caught during resolution.</p>
        
        <p>If one of the arguments is omitted or otherwise not a valid function—typically you’ll use <code>null</code> instead—a default placeholder equivalent
        is used. The default success callback passes its fulfillment value along
        and the default error callback propagates its rejection reason along.</p>
        
        <p>The shorthand for calling <code>then(null,handleRejection)</code> is
        <code>catch(handleRejection)</code>.</p>
        
        <p>Both <code>then(..)</code> and <code>catch(..)</code> automatically construct and return
        another promise instance, which is wired to receive the resolution from
        whatever the return value is from the original promise’s fulfillment or
        rejection handler (whichever is actually called). Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">ajax</code><code class="p">(</code> <code class="s2">"http://some.url.1"</code> <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code>
            <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(</code><code class="nx">contents</code><code class="p">){</code>
                <code class="k">return</code> <code class="nx">contents</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code>
            <code class="p">},</code>
            <code class="kd">function </code><code class="nx">rejected</code><code class="p">(</code><code class="nx">reason</code><code class="p">){</code>
                <code class="k">return</code> <code class="s2">"DEFAULT VALUE"</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code> <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(</code><code class="nx">data</code><code class="p">){</code>
            <code class="c1">// handle data from original promise's</code>
            <code class="c1">// handlers</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>In this snippet, we’re returning an immediate value from either
        <code>fulfilled(..)</code> or <code>rejected(..)</code>, which then is received on the next
        event turn in the second <code>then(..)</code>’s <code>fulfilled(..)</code>. If we instead
        return a new promise, that new promise is subsumed and adopted as the
        resolution:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">ajax</code><code class="p">(</code> <code class="s2">"http://some.url.1"</code> <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code>
            <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(</code><code class="nx">contents</code><code class="p">){</code>
                <code class="k">return</code> <code class="nx">ajax</code><code class="p">(</code>
                    <code class="s2">"http://some.url.2?v="</code> <code class="o">+</code> <code class="nx">contents</code>
                <code class="p">);</code>
            <code class="p">},</code>
            <code class="kd">function </code><code class="nx">rejected</code><code class="p">(</code><code class="nx">reason</code><code class="p">){</code>
                <code class="k">return</code> <code class="nx">ajax</code><code class="p">(</code>
                    <code class="s2">"http://backup.url.3?err="</code> <code class="o">+</code> <code class="nx">reason</code>
                <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code> <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(</code><code class="nx">contents</code><code class="p">){</code>
            <code class="c1">// `contents` comes from the subsequent</code>
            <code class="c1">// `ajax(..)` call, whichever it was</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>It’s important to note that an exception (or rejected promise) in the
        first <code>fulfilled(..)</code> will <em>not</em> result in the first <code>rejected(..)</code>
        being called, as that handler only responds to the resolution of the
        first original promise. Instead, the second promise, which the second
        <code>then(..)</code> is called against, receives that rejection.</p>
        
        <p>In this previous snippet, we are not listening for that rejection, which
        means it will be silently held onto for future observation. If you never
        observe it by calling a <code>then(..)</code> or <code>catch(..)</code>, then it will go
        unhandled. Some browser developer consoles may detect these unhandled
        rejections and report them, but this is not reliably guaranteed; you
        should always observe promise rejections.</p>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>This was just a brief overview of Promise theory and behavior.
        For a much more in-depth exploration, see Chapter 3 of the <em>Async &amp;
        Performance</em> title of this series.</p>
        </div>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Thenables"><div class="sect2" id="idm45967361242184">
        <h2>Thenables</h2>
        
        <p>Promises are genuine instances of the <code>Promise(..)</code> constructor.
        However, there are promise-like objects called <em>thenables</em> that
        generally can interoperate with the Promise mechanisms.</p>
        
        <p>Any object (or function) with a <code>then(..)</code> function on it is assumed to
        be a thenable. Any place where the Promise mechanisms can accept and
        adopt the state of a genuine promise, they can also handle a thenable.</p>
        
        <p>Thenables are basically a general label for any promise-like value that
        may have been created by some other system than the actual <code>Promise(..)</code>
        constructor. In that perspective, a thenable is generally less trustable
        than a genuine Promise. Consider this misbehaving thenable, for example:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">th</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">then</code><code class="o">:</code> <code class="kd">function </code><code class="nx">thener</code><code class="p">(</code> <code class="nx">fulfilled</code> <code class="p">)</code> <code class="p">{</code>
                <code class="c1">// call `fulfilled(..)` once every 100ms forever</code>
                <code class="nb">setInterval</code><code class="p">(</code> <code class="nx">fulfilled</code><code class="p">,</code> <code class="mi">100</code> <code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>If you received that thenable and chained it with <code>th.then(..)</code>, you’d
        likely be surprised that your fulfillment handler is called repeatedly,
        when normal Promises are supposed to only ever be resolved once.</p>
        
        <p>Generally, if you’re receiving what purports to be a promise or thenable
        back from some other system, you shouldn’t just trust it blindly. In the
        next section, we’ll see a utility included with ES6 Promises that helps
        address this trust concern.</p>
        
        <p>But to further understand the perils of this issue, consider that <em>any</em>
        object in <em>any</em> piece of code that’s ever been defined to have a method
        on it called <code>then(..)</code> can be potentially confused as a thenable—if
        used with Promises, of course—regardless of if that thing was ever
        intended to even remotely be related to Promise-style async coding.</p>
        
        <p>Prior to ES6, there was never any special reservation made on methods
        called <code>then(..)</code>, and as you can imagine there’s been at least a few
        cases where that method name has been chosen prior to Promises ever
        showing up on the radar screen. The most likely case of mistaken
        thenable will be async libraries that use <code>then(..)</code> but which are not
        strictly Promises-compliant—there are several out in the wild.</p>
        
        <p>The onus will be on you to guard against directly using values with the
        Promise mechanism that would be incorrectly assumed to be a thenable.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Promise API"><div class="sect2" id="idm45967360877432">
        <h2>Promise API</h2>
        
        <p>The <code>Promise</code> API also provides some static methods for working with
        Promises.</p>
        
        <p><code>Promise.resolve(..)</code> creates a promise resolved to the value passed in.
        Let’s compare how it works to the more manual approach:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">p1</code> <code class="o">=</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code> <code class="mi">42</code> <code class="p">);</code>
        
        <code class="kd">var</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code> <code class="kd">function </code><code class="nx">pr</code><code class="p">(</code><code class="nx">resolve</code><code class="p">){</code>
            <code class="nx">resolve</code><code class="p">(</code> <code class="mi">42</code> <code class="p">);</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p><code>p1</code> and <code>p2</code> will have essentially identical behavior. The same goes
        for resolving with a promise:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">theP</code> <code class="o">=</code> <code class="nx">ajax</code><code class="p">(</code> <code class="p">..</code> <code class="p">);</code>
        
        <code class="kd">var</code> <code class="nx">p1</code> <code class="o">=</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code> <code class="nx">theP</code> <code class="p">);</code>
        
        <code class="kd">var</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code> <code class="kd">function </code><code class="nx">pr</code><code class="p">(</code><code class="nx">resolve</code><code class="p">){</code>
            <code class="nx">resolve</code><code class="p">(</code> <code class="nx">theP</code> <code class="p">);</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        <div data-type="tip"><h6>Tip</h6>
        <p><code>Promise.resolve(..)</code> is the solution to the thenable trust issue
        raised in the previous section. Any value that you are not already
        certain is a trustable promise—even if it could be an immediate value—can be normalized by passing it to <code>Promise.resolve(..)</code>. If the
        value is already a recognizable promise or thenable, its
        state/resolution will simply be adopted, insulating you from
        misbehavior. If it’s instead an immediate value, it will be “wrapped” in
        a genuine promise, thereby normalizing its behavior to be async.</p>
        </div>
        
        <p><code>Promise.reject(..)</code> creates an immediately rejected promise, the same
        as its <code>Promise(..)</code> constructor counterpart:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">p1</code> <code class="o">=</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">reject</code><code class="p">(</code> <code class="s2">"Oops"</code> <code class="p">);</code>
        
        <code class="kd">var</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code> <code class="kd">function </code><code class="nx">pr</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code><code class="nx">reject</code><code class="p">){</code>
            <code class="nx">reject</code><code class="p">(</code> <code class="s2">"Oops"</code> <code class="p">);</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>While <code>resolve(..)</code> and <code>Promise.resolve(..)</code> can accept a promise and
        adopt its state/resolution, <code>reject(..)</code> and <code>Promise.reject(..)</code> do not
        differentiate what value they receive. So, if you reject with a promise
        or thenable, the promise/thenable itself will be set as the rejection
        reason, not its underlying value.</p>
        
        <p><code>Promise.all([ .. ])</code> accepts an array of one or more values (e.g.,
        immediate values, promises, thenables). It returns a promise back that
        will be fulfilled if all the values fulfill, or reject immediately once
        the first of any of them rejects.</p>
        
        <p>Starting with these values/promises:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">var</code> <code class="nx">p1</code> <code class="o">=</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code> <code class="mi">42</code> <code class="p">);</code>
        <code class="kd">var</code> <code class="nx">p2</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code> <code class="kd">function </code><code class="nx">pr</code><code class="p">(</code><code class="nx">resolve</code><code class="p">){</code>
            <code class="nb">setTimeout</code><code class="p">(</code> <code class="kd">function</code><code class="p">(){</code>
                <code class="nx">resolve</code><code class="p">(</code> <code class="mi">43</code> <code class="p">);</code>
            <code class="p">},</code> <code class="mi">100</code> <code class="p">);</code>
        <code class="p">}</code> <code class="p">);</code>
        <code class="kd">var</code> <code class="nx">v3</code> <code class="o">=</code> <code class="mi">44</code><code class="p">;</code>
        <code class="kd">var</code> <code class="nx">p4</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Promise</code><code class="p">(</code> <code class="kd">function </code><code class="nx">pr</code><code class="p">(</code><code class="nx">resolve</code><code class="p">,</code><code class="nx">reject</code><code class="p">){</code>
            <code class="nb">setTimeout</code><code class="p">(</code> <code class="kd">function</code><code class="p">(){</code>
                <code class="nx">reject</code><code class="p">(</code> <code class="s2">"Oops"</code> <code class="p">);</code>
            <code class="p">},</code> <code class="mi">10</code> <code class="p">);</code>
        <code class="p">}</code> <code class="p">);</code></pre>
        
        <p>Let’s consider how <code>Promise.all([ .. ])</code> works with combinations of
        those values:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">(</code> <code class="p">[</code><code class="nx">p1</code><code class="p">,</code><code class="nx">p2</code><code class="p">,</code><code class="nx">v3</code><code class="p">]</code> <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code> <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(</code><code class="nx">vals</code><code class="p">){</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">vals</code> <code class="p">);</code>            <code class="c1">// [42,43,44]</code>
        <code class="p">}</code> <code class="p">);</code>
        
        <code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">(</code> <code class="p">[</code><code class="nx">p1</code><code class="p">,</code><code class="nx">p2</code><code class="p">,</code><code class="nx">v3</code><code class="p">,</code><code class="nx">p4</code><code class="p">]</code> <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code>
            <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(</code><code class="nx">vals</code><code class="p">){</code>
                <code class="c1">// never gets here</code>
            <code class="p">},</code>
            <code class="kd">function </code><code class="nx">rejected</code><code class="p">(</code><code class="nx">reason</code><code class="p">){</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">reason</code> <code class="p">);</code>      <code class="c1">// Oops</code>
            <code class="p">}</code>
        <code class="p">);</code></pre>
        
        <p>While <code>Promise.all([ .. ])</code> waits for all fulfillments (or the first
        rejection), <code>Promise.race([ .. ])</code> waits only for either the first
        fulfillment or rejection. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="c1">// NOTE: re-setup all test values to</code>
        <code class="c1">// avoid timing issues misleading you!</code>
        
        <code class="nb">Promise</code><code class="p">.</code><code class="nx">race</code><code class="p">(</code> <code class="p">[</code><code class="nx">p2</code><code class="p">,</code><code class="nx">p1</code><code class="p">,</code><code class="nx">v3</code><code class="p">]</code> <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code> <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(</code><code class="nx">val</code><code class="p">){</code>
            <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">val</code> <code class="p">);</code>             <code class="c1">// 42</code>
        <code class="p">}</code> <code class="p">);</code>
        
        <code class="nb">Promise</code><code class="p">.</code><code class="nx">race</code><code class="p">(</code> <code class="p">[</code><code class="nx">p2</code><code class="p">,</code><code class="nx">p4</code><code class="p">]</code> <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code>
            <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(</code><code class="nx">val</code><code class="p">){</code>
                <code class="c1">// never gets here</code>
            <code class="p">},</code>
            <code class="kd">function </code><code class="nx">rejected</code><code class="p">(</code><code class="nx">reason</code><code class="p">){</code>
                <code class="nb">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code> <code class="nx">reason</code> <code class="p">);</code>      <code class="c1">// Oops</code>
            <code class="p">}</code>
        <code class="p">);</code></pre>
        <div data-type="warning" epub:type="warning"><h6>Warning</h6>
        <p>While <code>Promise.all([])</code> will fulfill right away (with no
        values), <code>Promise.race([])</code> will hang forever. This is a strange
        inconsistency, and speaks to the suggestion that you should never use
        these methods with empty arrays.</p>
        </div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Generators + Promises"><div class="sect1" id="genandpromises">
        <h1>Generators + Promises</h1>
        
        <p>It <em>is</em> possible to express a series of promises in a chain to represent
        the async flow control of your program. Consider:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">step1</code><code class="p">()</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code>
            <code class="nx">step2</code><code class="p">,</code>
            <code class="nx">step2Failed</code>
        <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code>
            <code class="kd">function</code><code class="p">(</code><code class="nx">msg</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">(</code> <code class="p">[</code>
                    <code class="nx">step3a</code><code class="p">(</code> <code class="nx">msg</code> <code class="p">),</code>
                    <code class="nx">step3b</code><code class="p">(</code> <code class="nx">msg</code> <code class="p">),</code>
                    <code class="nx">step3c</code><code class="p">(</code> <code class="nx">msg</code> <code class="p">)</code>
                <code class="p">]</code> <code class="p">)</code>
            <code class="p">}</code>
        <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code><code class="nx">step4</code><code class="p">);</code></pre>
        
        <p>However, there’s a much better option for expressing async flow control,
        and it will probably be much more preferable in terms of coding style
        than long promise chains. We can use what we learned in <a data-type="xref" href="ch03.html#chapter-3-organization">Chapter&nbsp;3</a> about
        generators to express our async flow control.</p>
        
        <p>The important pattern to recognize: a generator can yield a promise, and
        that promise can then be wired to resume the generator with its
        fulfillment value.</p>
        
        <p>Consider the previous snippet’s async flow control expressed with a
        generator:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function *</code><code class="nx">main</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">ret</code> <code class="o">=</code> <code class="kd">yield </code><code class="nx">step1</code><code class="p">();</code>
        
            <code class="k">try</code> <code class="p">{</code>
                <code class="nx">ret</code> <code class="o">=</code> <code class="kd">yield </code><code class="nx">step2</code><code class="p">(</code> <code class="nx">ret</code> <code class="p">);</code>
            <code class="p">}</code>
            <code class="k">catch</code> <code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">ret</code> <code class="o">=</code> <code class="kd">yield </code><code class="nx">step2Failed</code><code class="p">(</code> <code class="nx">err</code> <code class="p">);</code>
            <code class="p">}</code>
        
            <code class="nx">ret</code> <code class="o">=</code> <code class="kd">yield </code><code class="nb">Promise</code><code class="p">.</code><code class="nx">all</code><code class="p">(</code> <code class="p">[</code>
                <code class="nx">step3a</code><code class="p">(</code> <code class="nx">ret</code> <code class="p">),</code>
                <code class="nx">step3b</code><code class="p">(</code> <code class="nx">ret</code> <code class="p">),</code>
                <code class="nx">step3c</code><code class="p">(</code> <code class="nx">ret</code> <code class="p">)</code>
            <code class="p">]</code> <code class="p">);</code>
        
            <code class="kd">yield </code><code class="nx">step4</code><code class="p">(</code> <code class="nx">ret</code> <code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>On the surface, this snippet may seem more verbose than the promise
        chain equivalent in the earlier snippet. However, it offers a much more
        attractive—and more importantly, a more understandable and
        reason-able—synchronous-looking coding style (with <code>=</code> assignment of
        “return” values, etc.) That’s especially true in that <code>try..catch</code> error
        handling can be used across those hidden async boundaries.</p>
        
        <p>Why are we using Promises with the generator? It’s certainly possible to
        do async generator coding without Promises.</p>
        
        <p>Promises are a trustable system that uninverts the inversion of control
        of normal callbacks or thunks (see the <em>Async &amp; Performance</em> title of
        this series). So, combining the trustability of Promises and the
        synchronicity of code in generators effectively addresses all the major
        deficiencies of callbacks. Also, utilities like <code>Promise.all([ .. ])</code>
        are a nice, clean way to express concurrency at a generator’s single
        <code>yield</code> step.</p>
        
        <p>So how does this magic work? We’re going to need a <em>runner</em> that can run
        our generator, receive a <code>yield</code>ed promise, and wire it up to resume the
        generator with either the fulfillment success value, or throw an error
        into the generator with the rejection reason.</p>
        
        <p>Many async-capable utilities/libraries have such a “runner”; for
        example, <code>Q.spawn(..)</code> and my asynquence’s <code>runner(..)</code> plug-in. But
        here’s a stand-alone runner to illustrate how the process works:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="kd">function </code><code class="nx">run</code><code class="p">(</code><code class="nx">gen</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">var</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[].</code><code class="nx">slice</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code> <code class="nx">arguments</code><code class="p">,</code> <code class="mi">1</code><code class="p">),</code> <code class="nx">it</code><code class="p">;</code>
        
            <code class="nx">it</code> <code class="o">=</code> <code class="nx">gen</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code> <code class="k">this</code><code class="p">,</code> <code class="nx">args</code> <code class="p">);</code>
        
            <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">()</code>
                <code class="p">.</code><code class="nx">then</code><code class="p">(</code> <code class="kd">function </code><code class="nx">handleNext</code><code class="p">(</code><code class="nx">value</code><code class="p">){</code>
                    <code class="kd">var</code> <code class="nx">next</code> <code class="o">=</code> <code class="nx">it</code><code class="p">.</code><code class="nx">next</code><code class="p">(</code> <code class="nx">value</code> <code class="p">);</code>
        
                    <code class="k">return</code> <code class="p">(</code><code class="kd">function </code><code class="nx">handleResult</code><code class="p">(</code><code class="nx">next</code><code class="p">){</code>
                        <code class="k">if</code> <code class="p">(</code><code class="nx">next</code><code class="p">.</code><code class="nx">done</code><code class="p">)</code> <code class="p">{</code>
                            <code class="k">return</code> <code class="nx">next</code><code class="p">.</code><code class="nx">value</code><code class="p">;</code>
                        <code class="p">}</code>
                        <code class="k">else</code> <code class="p">{</code>
                            <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code> <code class="nx">next</code><code class="p">.</code><code class="nx">value</code> <code class="p">)</code>
                                <code class="p">.</code><code class="nx">then</code><code class="p">(</code>
                                    <code class="nx">handleNext</code><code class="p">,</code>
                                    <code class="kd">function </code><code class="nx">handleErr</code><code class="p">(</code><code class="nx">err</code><code class="p">)</code> <code class="p">{</code>
                                        <code class="k">return</code> <code class="nb">Promise</code><code class="p">.</code><code class="nx">resolve</code><code class="p">(</code>
                                            <code class="nx">it</code><code class="p">.</code><code class="nx">throw</code><code class="p">(</code> <code class="nx">err</code> <code class="p">)</code>
                                        <code class="p">)</code>
                                        <code class="p">.</code><code class="nx">then</code><code class="p">(</code> <code class="nx">handleResult</code> <code class="p">);</code>
                                    <code class="p">}</code>
                                <code class="p">);</code>
                        <code class="p">}</code>
                    <code class="p">})(</code> <code class="nx">next</code> <code class="p">);</code>
                <code class="p">}</code> <code class="p">);</code>
        <code class="p">}</code></pre>
        <div data-type="note" epub:type="note"><h6>Note</h6>
        <p>For a more prolifically commented version of this utility, see
        the <em>Async &amp; Performance</em> title of this series. Also, the run utilities
        provided with various async libraries are often more powerful/capable
        than what we’ve shown here. For example, asynquence’s <code>runner(..)</code> can
        handle <code>yield</code>ed promises, sequences, thunks, and immediate
        (nonpromise) values, giving you ultimate flexibility.</p>
        </div>
        
        <p>So now running <code>*main()</code> as listed in the earlier snippet is as easy as:</p>
        
        <pre data-type="programlisting" data-code-language="es6"><code class="nx">run</code><code class="p">(</code> <code class="nx">main</code> <code class="p">)</code>
        <code class="p">.</code><code class="nx">then</code><code class="p">(</code>
            <code class="kd">function </code><code class="nx">fulfilled</code><code class="p">(){</code>
                <code class="c1">// `*main()` completed successfully</code>
            <code class="p">},</code>
            <code class="kd">function </code><code class="nx">rejected</code><code class="p">(</code><code class="nx">reason</code><code class="p">){</code>
                <code class="c1">// Oops, something went wrong</code>
            <code class="p">}</code>
        <code class="p">);</code></pre>
        
        <p>Essentially, anywhere that you have more than two asynchronous steps of
        flow control logic in your program, you can <em>and should</em> use a
        promise-yielding generator driven by a run utility to express the flow
        control in a synchronous fashion. This will make for much easier to
        understand and maintain code.</p>
        
        <p>This yield-a-promise-resume-the-generator pattern is going to be so
        common and so powerful, the next version of JavaScript is almost
        certainly going to introduce a new function type that will do it
        automatically without needing the run utility. We’ll cover
        <code>async function</code>s (as they’re expected to be called) in <a data-type="xref" href="ch08.html#chapter-8-beyond-es6">Chapter&nbsp;8</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Review"><div class="sect1" id="idm45967360305976">
        <h1>Review</h1>
        
        <p>As JavaScript continues to mature and grow in its widespread adoption,
        asynchronous programming is more and more of a central concern.
        Callbacks are not fully sufficient for these tasks, and totally fall
        down the more sophisticated the need.</p>
        
        <p>Thankfully, ES6 adds Promises to address one of the major shortcomings
        of callbacks: lack of trust in predictable behavior. Promises represent
        the future completion value from a potentially async task, normalizing
        behavior across sync and async boundaries.</p>
        
        <p>But it’s the combination of Promises with generators that fully realizes
        the benefits of rearranging our async flow control code to de-emphasize
        and abstract away that ugly callback soup (aka “hell”).</p>
        
        <p>Right now, we can manage these interactions with the aide of various
        async libraries’ runners, but JavaScript is eventually going to support
        this interaction pattern with dedicated syntax alone!</p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781491905241/files/epub.css" crossorigin="anonymous"></div>
</div>

https://learning.oreilly.com