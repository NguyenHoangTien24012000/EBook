<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section epub:type="chapter">
        <h2 class="ch2" id="ch13"><span epub:type="pagebreak" id="page_268"></span>Chapter 13. An Introduction to TypeScript</h2>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/queen.jpg" alt="Images" width="85" height="85">
        </figure>
        <div class="outline">
        <p class="outh"><strong>Topics in This Chapter</strong></p>
        <p class="chap-lev1"><a href="#ch13lev1sec1">13.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type Annotations</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec2">13.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Running TypeScript</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec3">13.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type Terminology</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec4">13.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Primitive Types</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec5">13.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Composite Types</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec6">13.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Type Inference</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec7">13.7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Subtypes</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec8">13.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Classes</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec9">13.9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Structural Typing</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec10">13.10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Interfaces</a></p>
        <p class="chap-lev1i"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/catc.jpg" alt="Images" width="23" height="23"></span>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ch13lev1sec11">13.11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indexed Properties</a></p>
        <p class="chap-lev1i"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/catc.jpg" alt="Images" width="23" height="23"></span>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ch13lev1sec12">13.12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Complex Function Parameters</a></p>
        <p class="chap-lev1i"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/catc.jpg" alt="Images" width="23" height="23"></span>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ch13lev1sec13">13.13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Generic Programming</a></p>
        <p class="chap-lev1"><a href="#ch13lev1sec14">Exercises</a></p>
        </div>
        <p class="noindent"><span epub:type="pagebreak" id="page_269"></span>TypeScript is a superset of JavaScript that adds compile-time typing. You annotate variables and functions with their expected types, and TypeScript reports an error whenever your code violates the type rules. Generally, that is a good thing. It is far less costly to fix compile-time errors than to debug a misbehaving program. Moreover, when you provide type information, your development tools can give you better support with autocompletion and refactoring.</p>
        <p class="noindent">This chapter contains a concise introduction into the main features of TypeScript. As with the rest of the book, I focus on modern features and mention legacy constructs only in passing. The aim of this chapter is to give you sufficient information so you can decide whether to use TypeScript on top of JavaScript.</p>
        <p class="noindent">Why wouldn’t everyone want to use TypeScript? Unlike ECMAScript, which is governed by a standards committee composed of many companies, TypeScript is produced by a single vendor, Microsoft. Unlike ECMAScript, where standards documents describe the correct behavior in mind-numbing detail, the TypeScript documentation is sketchy and inconclusive. TypeScript is—just like JavaScript—sometimes messy and inconsistent, giving you another potential source of grief and confusion. TypeScript evolves on a different schedule than ECMAScript, so there is yet another moving part. And, finally, you have yet another part in your tool chain that can act up.</p>
        <p class="noindent"><span epub:type="pagebreak" id="page_270"></span>You will have to weigh the advantages and drawbacks. This chapter will give you a flavor of TypeScript so you can make an informed decision.</p>
        <div class="tip">
        <p class="tip-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/tip.jpg" alt="Images" width="36" height="33"></span> Tip</p>
        <p class="noindent">If, after reading this chapter, you come to the conclusion that you want static type checking but you aren’t sure about TypeScript, check out Flow (<a href="https://flow.org">https://flow.org</a>) and see if you prefer its type system, syntax, and tooling.</p>
        </div>
        <section>
        <h3 class="h3" id="ch13lev1sec1">13.1 Type Annotations</h3>
        <p class="noindent">Consider the following JavaScript function computing the average of two numbers:</p>
        <p class="codelink"><a id="rch13pr01" href="ch13_images.xhtml#ch13pr01">Click here to view code image</a></p>
        <pre class="pre">const average = (x, y) =&gt; (x + y) / 2</pre>
        <p class="noindent">What happens when you call</p>
        <pre class="pre">const result = average('3', '4')</pre>
        <p class="noindent">Here, <code>'3'</code> and
              <code>'4'</code> are concatenated to <code>'34'</code>, which is then converted to the number <code>34</code> and divided by 2, yielding <code>17</code>. That is surely not what you intended.</p>
        <p class="noindent">In situations like that, JavaScript provides no error messages. The program silently computes the wrong result and keeps running. In all likelihood, something will eventually go wrong elsewhere.</p>
        <p class="noindent">In TypeScript, you annotate parameters, like this:</p>
        <p class="codelink"><a id="rch13pr02" href="ch13_images.xhtml#ch13pr02">Click here to view code image</a></p>
        <pre class="pre">const average = (x<strong>: number</strong>, y<strong>: number</strong>) =&gt; (x + y) / 2</pre>
        <p class="noindent">Now it is clear that the <code>average</code> function is intended to compute the average of two <em>numbers</em>. If you call</p>
        <p class="codelink"><a id="rch13pr03" href="ch13_images.xhtml#ch13pr03">Click here to view code image</a></p>
        <pre class="pre">const result = average('3', '4') // <span class="cite">TypeScript: Compile-time error</span></pre>
        <p class="noindent">the TypeScript compiler reports an error.</p>
        <p class="noindent">That is the promise of TypeScript: You provide type annotations, and TypeScript detects type errors before your program runs. Therefore, you spend far less time with the debugger.</p>
        <p class="noindent">In this example, the annotation process is very straightforward. Let us consider a more complex example. Suppose you want to allow an argument that is either a number or an array of numbers. In TypeScript, you express this with a <em>union type</em> <code>number | number[]</code>. Here, we want to replace a target value, or multiple target values, with another value:<span epub:type="pagebreak" id="page_271"></span></p>
        <p class="codelink"><a id="rch13pr04" href="ch13_images.xhtml#ch13pr04">Click here to view code image</a></p>
        <pre class="pre">const replace = (arr: number[], target<strong>: number | number[]</strong>, replacement: number) =&gt; {
          for (let i = 0; i &lt; arr.length; i++) {
            if (Array.isArray(target) &amp;&amp; target.includes(arr[i])
                || !Array.isArray(target) &amp;&amp; target === arr[i]) {
              arr[i] = replacement
            }
          }
        }</pre>
        <p class="noindent">TypeScript can now check whether your calls are correct:</p>
        <p class="codelink"><a id="rch13pr05" href="ch13_images.xhtml#ch13pr05">Click here to view code image</a></p>
        <pre class="pre">const a = [11, 12, 13, 14, 15, 16]
        replace(a, 13, 0) // <span class="cite">OK</span>
        replace(a, [13, 14], 0) // <span class="cite">OK</span>
        replace(a, 13, 14, 0) // <span class="cite">Error</span></pre>
        <div class="caution">
        <p class="caution-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">TypeScript knows about the types of the JavaScript library methods, but as I write this, the online playground is misconfigured and doesn’t recognize the <code>includes</code> method of the <code>Array</code> class. Hopefully this will be fixed by the time you read this book. If not, replace <code>target.includes(arr[i])</code> with <code>target.indexOf(arr[i]) &gt;= 0</code>.</p>
        </div>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">In these examples, I used arrow functions. The annotations work in exactly the same way with the <code>function</code> keyword:</p>
        <p class="codelink"><a id="rch13pr06" href="ch13_images.xhtml#ch13pr06">Click here to view code image</a></p>
        <pre class="pre">function average(x<strong>: number</strong>, y<strong>: number</strong>) { return (x + y) / 2 }</pre>
        </div>
        <p class="noindent">To use TypeScript effectively, you need to learn how to express types such as “array of type <code>T</code>” and “type <code>T</code> or type <code>U</code>” in the TypeScript syntax. This is simple in many common situations. However, type descriptions can get fairly complex, and there are situations where you need to intervene in the typechecking process. All real-world type systems are like that. You need to expend a certain amount of upfront effort before you can reap the reward—error detection at compile time.</p>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec2">13.2 Running TypeScript</h3>
        <p class="noindent">The easiest way to experiment with TypeScript is the “playground” at <a href="https://www.typescriptlang.org/play">https://www.typescriptlang.org/play</a>. Simply type in your code and run it. If you mouse over a value, its type is displayed. Errors are shown as wiggly underlines—see <a href="ch13.xhtml#ch13fig01">Figure 13-1</a>.<span epub:type="pagebreak" id="page_272"></span></p>
        <figure class="figure" id="ch13fig01">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/pg272_Image_744.jpg" alt="Images" width="730" height="359">
        <figcaption><p class="fig-title"><strong>Figure 13-1</strong>&nbsp;&nbsp;&nbsp;&nbsp;The TypeScript playground</p></figcaption>
        </figure>
        <p class="noindent">Visual Studio Code (<code><a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a></code>) has excellent support for TypeScript, as do other editors and integrated development environments.</p>
        <p class="noindent">To work with TypeScript on the command line, install it with the <code>npm</code> package manager. Here is the command for a global installation:</p>
        <pre class="pre">npm install -g typescript</pre>
        <p class="noindent">In this chapter, I will always assume that TypeScript operates in the <em>strict mode</em> and targets the latest version of ECMAScript. Similar to plain JavaScript, TypeScript’s strict mode outlaws “sloppy” legacy behavior. To activate these settings, include a file <code>tsconfig.json</code> in your project directory with the following contents:</p>
        <p class="codelink"><a id="rch13pr07" href="ch13_images.xhtml#ch13pr07">Click here to view code image</a></p>
        <pre class="pre">{
          "compilerOptions": {
            "target": "ES2020",
            "strict": true,
            "sourceMap": true
          },
          "filesGlob": [
            "*.ts"
          ]
        }</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_273"></span>To compile TypeScript files to JavaScript, run</p>
        <pre class="pre">tsc</pre>
        <p class="noindent">in the directory that contains TypeScript files and <code>tsconfig.json</code>. Each TypeScript file is translated to JavaScript. You can run the resulting files with <code>node</code>.</p>
        <p class="noindent">To start up a REPL, run</p>
        <pre class="pre">ts-node</pre>
        <p class="noindent">in a directory with a <code>tsconfig.json</code> file, or</p>
        <p class="codelink"><a id="rch13pr08" href="ch13_images.xhtml#ch13pr08">Click here to view code image</a></p>
        <pre class="pre">ts-node -O '{ "target": "es2020", "strict": true }'</pre>
        <p class="noindent">in any directory.</p>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec3">13.3 Type Terminology</h3>
        <p class="noindent">Let us step back and think about types. A type describes a set of values that have something in common. In TypeScript, the <code>number</code> type consists of all values that are JavaScript numbers: regular numbers such as <code>0</code>, <code>3.141592653589793</code>, and so on, as well as <code>Infinity</code>, <code>-Infinity</code>, and <code>NaN</code>. We say that all these values are <em>instances</em> of the <code>number</code> type. However, the value <code>'one'</code> is not.</p>
        <p class="noindent">As you saw already, the type <code>number[]</code> denotes arrays of numbers. The value <code>[0, 3.141592653589793, NaN]</code> is an instance of the <code>number[]</code> type, but the value <code>[0, 'one']</code> is not.</p>
        <p class="noindent">A type such as <code>number[]</code> is called a <em>composite</em> type. You can form arrays of any type: <code>number[]</code>, <code>string[]</code>, and so on. Union types are another example of composite types. The union type</p>
        <pre class="pre">number | number[]</pre>
        <p class="noindent">is composed of two simpler types: <code>number</code> and <code>number[]</code>.</p>
        <p class="noindent">In contrast, types that are not composed of simpler types are <em>primitive</em>. TypeScript has primitive types <code>number</code>, <code>string</code>, <code>boolean</code>, as well as a few others that you will encounter in the following section.</p>
        <p class="noindent">Composite types can get complex. You can use a <em>type alias</em> to make them easier to read and reuse. Suppose you like to write functions that accept either a single number or an array. Simply define a type alias:</p>
        <pre class="pre">type Numbers = number | number[]</pre>
        <p class="noindent">Use the alias as a shortcut for the type:</p>
        <p class="codelink"><a id="rch13pr09" href="ch13_images.xhtml#ch13pr09">Click here to view code image</a></p>
        <pre class="pre">const replace = (arr: number[], target<strong>: Numbers</strong>, replacement: number) =&gt; . . .</pre>
        <div class="note">
        <p class="note-caption"><span epub:type="pagebreak" id="page_274"></span><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">The <code>typeof</code> operator yields the value of a variable or property. You can use that type to declare another variable of the same type:</p>
        <p class="codelink"><a id="rch13pr10" href="ch13_images.xhtml#ch13pr10">Click here to view code image</a></p>
        <pre class="pre">let values = [1, 7, 2, 9]
        let moreValues<strong>: typeof values</strong> = []
          // <code>typeof values</code> <span class="cite">is the same as</span> <code>number[]</code>
        let anotherElement<strong>: typeof values[0]</strong> = 42
          // <code>typeof values[0]</code> <span class="cite">is the same as</span> <code>number</code></pre>
        </div>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec4">13.4 Primitive Types</h3>
        <p class="noindent">Every JavaScript primitive type is also a primitive type in TypeScript. That is, TypeScript has primitive types <code>number</code>, <code>boolean</code>, <code>string</code>, <code>symbol</code>, <code>null</code>, and <code>undefined</code>.</p>
        <p class="noindent">The <code>undefined</code> type has one instance—the value <code>undefined</code>. Similarly, the value <code>null</code> is the sole instance of the <code>null</code> type. You won’t want to use these types by themselves, but they are very useful in union types. An instance of the type</p>
        <pre class="pre">string | undefined</pre>
        <p class="noindent">is either a string or the <code>undefined</code> value.</p>
        <p class="noindent">The <code>void</code> type can only be used as the return type of a function. It denotes the fact that the function returns no value (see <a href="#ch13ex02">Exercise 2</a>).</p>
        <p class="noindent">The <code>never</code> type denotes the fact that a function won’t ever return because it always throws an exception. Since you don’t normally write such functions, it is very unlikely that you will use the <code>never</code> type for a type annotation. <a href="ch13.xhtml#ch13lev2sec16">Section 13.13.6</a>, “<a href="ch13.xhtml#ch13lev2sec16">Conditional Types</a>” (<a href="ch13.xhtml#page_303">page 303</a>), has another application of the <code>never</code> type.</p>
        <p class="noindent">The <code>unknown</code> type denotes any JavaScript value at all. You can convert any value to <code>unknown</code>, but a value of type <code>unknown</code> is not compatible with any other type. This makes sense for parameter types of very generic functions (such as <code>console.log</code>), or when you need to interface with external JavaScript code. There is an even looser type <code>any</code>. Any conversion to <em>or from</em> the <code>any</code> type is allowed. You should minimize the use of the <code>any</code> type because it effectively turns off type checking.</p>
        <p class="noindent">A literal value denotes another type with a single instance—that same value. For example, the string literal <code>'Mon'</code> is a TypeScript type. That type has just one value—the string <code>'Mon'</code>. By itself, such a type isn’t very useful, but you can form a union type, such as</p>
        <p class="codelink"><a id="rch13pr11" href="ch13_images.xhtml#ch13pr11">Click here to view code image</a></p>
        <pre class="pre">'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri' | 'Sat' | 'Sun'</pre>
        <p class="noindent">This is a type with seven instances—the names of the weekdays.</p>
        <p class="noindent"><span epub:type="pagebreak" id="page_275"></span>With a type like this, you will usually want to use a type alias:</p>
        <p class="codelink"><a id="rch13pr12" href="ch13_images.xhtml#ch13pr12">Click here to view code image</a></p>
        <pre class="pre">type Weekday = 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri' | 'Sat' | 'Sun'</pre>
        <p class="noindent">Now you can annotate a variable as <code>Weekday</code>:</p>
        <p class="codelink"><a id="rch13pr13" href="ch13_images.xhtml#ch13pr13">Click here to view code image</a></p>
        <pre class="pre">let w<strong>: Weekday</strong> = 'Mon' // <span class="cite">OK</span>
        w = 'Mo' // <span class="cite">Error</span></pre>
        <p class="noindent">A type such as <code>Weekday</code> describes a finite set of values. The values can be literals of any type:</p>
        <p class="codelink"><a id="rch13pr14" href="ch13_images.xhtml#ch13pr14">Click here to view code image</a></p>
        <pre class="pre">type Falsish = false | 0 | 0n | null | undefined | '' | []</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">If you want constants with nicer names, TypeScript lets you define an enumerated type. Here is a simple example:</p>
        <p class="codelink"><a id="rch13pr15" href="ch13_images.xhtml#ch13pr15">Click here to view code image</a></p>
        <pre class="pre">enum Weekday { MON, TUE, WED, THU, FRI, SAT, SUN }</pre>
        <p class="noindent">You can refer to these constants as <code>Weekday.MON</code>, <code>Weekday.TUE</code>, and so on. These are synonyms for the numbers 0, 1, 2, 3, 4, 5, and 6. You can also assign values:</p>
        <p class="codelink"><a id="rch13pr16" href="ch13_images.xhtml#ch13pr16">Click here to view code image</a></p>
        <pre class="pre">enum Color { RED = 4, GREEN = 2, BLUE = 1 }</pre>
        <p class="noindent">String values are OK too:</p>
        <p class="codelink"><a id="rch13pr17" href="ch13_images.xhtml#ch13pr17">Click here to view code image</a></p>
        <pre class="pre">enum Quarter { Q1 = 'Winter', Q2 = 'Spring', Q3 = 'Summer', Q4 = 'Fall' }</pre>
        </div>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec5">13.5 Composite Types</h3>
        <p class="noindent">TypeScript provides several ways of building more complex types out of simpler ones. This section describes all of them.</p>
        <p class="noindent">Given any type, there is an array type:</p>
        <p class="codelink"><a id="rch13pr18" href="ch13_images.xhtml#ch13pr18">Click here to view code image</a></p>
        <pre class="pre">number[] // <span class="cite">Array of</span> <code>number</code>
        string[] // <span class="cite">Array of</span> <code>string</code>
        number[][] // <span class="cite">Array of</span> <code>number[]</code></pre>
        <p class="noindent">These types describe arrays whose elements all have the same type. For example, a <code>number[]</code> array can only hold numbers, not a mixture of numbers and strings.</p>
        <p class="noindent">Of course, JavaScript programmers often use arrays whose elements have mixed types, such as <code>[404, 'not found']</code>. In TypeScript, you describe such an array as an instance of a <em>tuple type</em> <code>[number, string]</code>. A tuple type is a list of types enclosed in brackets. It denotes fixed-length arrays whose elements have the specified types. In our example, the value <code>[404, 'not found']</code> is an instance of the tuple type <code>[number, string]</code>, but <code>['not found', 404]</code> or <code>[404, 'error', 'not found']</code> are not.</p>
        <div class="note">
        <p class="note-caption"><span epub:type="pagebreak" id="page_276"></span><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">The type for an array that starts out with a number and a string and then has other elements is</p>
        <pre class="pre">[string, number, ...unknown[]]</pre>
        </div>
        <p class="noindent">Just as a tuple type describes the element types of arrays, an <em>object type</em> defines the property names and types of objects. Here is an example of such a type:</p>
        <pre class="pre">{ x: number, y: number }</pre>
        <p class="noindent">You can use a type alias to make this declaration easier to reuse:</p>
        <pre class="pre">type Point = { x: number, y: number }</pre>
        <p class="noindent">Now you can define functions whose parameters are <code>Point</code> instances:</p>
        <p class="codelink"><a id="rch13pr19" href="ch13_images.xhtml#ch13pr19">Click here to view code image</a></p>
        <pre class="pre">const distanceFromOrigin = (p: Point) =&gt; Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2))</pre>
        <p class="noindent">A <em>function type</em> describes the parameter and return types of a function. For example,</p>
        <p class="codelink"><a id="rch13pr20" href="ch13_images.xhtml#ch13pr20">Click here to view code image</a></p>
        <pre class="pre">(arg1: number, arg2: number) =&gt; number</pre>
        <p class="noindent">is the type of all functions with two <code>number</code> parameters and a <code>number</code> return value.</p>
        <p class="noindent">The <code>Math.pow</code> function is an instance of this type, but <code>Math.sqrt</code> is not, since it only has one parameter.</p>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">In JavaScript, you must provide names with the parameter types of a function type, such as <code>arg1</code> and <code>arg2</code> in the preceding example. These names are ignored, with one exception. A method is indicated by naming the first parameter <code>this</code>—see <a href="ch13.xhtml#ch13lev2sec5">Section 13.8.2</a>, “<a href="ch13.xhtml#ch13lev2sec5">The Instance Type of a Class</a>” (<a href="ch13.xhtml#page_285">page 285</a>). In all other cases, I will use <code>arg1</code>, <code>arg2</code>, and so on in a function type so you can see right away that it is a type, not an actual function. For a rest parameter, I will use <code>rest</code>.</p>
        </div>
        <p class="noindent">You have already seen union types. The values of the union type <em>T</em> | <em>U</em> are the instances of <em>T</em> or <em>U</em>. For example, an instance of</p>
        <pre class="pre">number | string</pre>
        <p class="noindent">is either a number or a string, and</p>
        <pre class="pre">(number | string)[]</pre>
        <p class="noindent">describes arrays whose elements are numbers or strings.</p>
        <p class="noindent">An <em>intersection type T</em> &amp; <em>U</em> has instances that combine the requirements of <em>T</em> and <em>U</em>. Here is an example:<span epub:type="pagebreak" id="page_277"></span></p>
        <pre class="pre">Point &amp; { color: string }</pre>
        <p class="noindent">To be an instance of this type, an object must have numeric <code>x</code> and <code>y</code> properties (which makes it a <code>Point</code>) as well as a string-valued <code>color</code> property.</p>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec6">13.6 Type Inference</h3>
        <p class="noindent">Consider a call to our <code>average</code> function:</p>
        <p class="codelink"><a id="rch13pr21" href="ch13_images.xhtml#ch13pr21">Click here to view code image</a></p>
        <pre class="pre">const average = (x<strong>: number</strong>, y<strong>: number</strong>) =&gt; (x + y) / 2
        . . .
        const a = 3
        const b = 4
        let result = average(a, b)</pre>
        <p class="noindent">Only the function parameters require a type annotation. The type of the other variables is <em>inferred</em>. From the initialization, TypeScript can tell that <code>a</code> and <code>b</code> must have type <code>number</code>. By analyzing the code of the <code>average</code> function, TypeScript infers that the return type is also <code>number</code>, and so is the type of <code>result</code>.</p>
        <p class="noindent">Generally, type inference works well, but sometimes you have to help TypeScript along.</p>
        <p class="noindent">The initial value of a variable may not suffice to determine the type that you intend. For example, suppose you declare a type for error codes.</p>
        <pre class="pre">type ErrorCode = [number, string]</pre>
        <p class="noindent">Now you want to declare a variable of that type. This declaration does not suffice:</p>
        <pre class="pre">let code = [404, 'not found']</pre>
        <p class="noindent">TypeScript infers the type <code>(number | string)[]</code> from the right-hand side: arrays of arbitrary length where each element can be a number or string. That is a much more general type than <code>ErrorCode</code>.</p>
        <div class="tip">
        <p class="tip-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/tip.jpg" alt="Images" width="36" height="33"></span> Tip</p>
        <p class="noindent">To see the inferred type, use a development environment that displays type information. <a href="ch13.xhtml#ch13fig02">Figure 13-2</a> shows how Visual Studio Code displays inferred types.</p>
        </div>
        <figure class="figure" id="ch13fig02">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/pg278_Image_766.jpg" alt="Images" width="730" height="408">
        <figcaption><p class="fig-title"><strong>Figure 13-2</strong> Type information in Visual Studio Code</p></figcaption>
        </figure>
        <p class="noindent">The remedy is to use a type annotation with the variable:</p>
        <pre class="pre">let code<strong>: ErrorCode</strong> = [404, 'not found']</pre>
        <p class="noindent">You face the same problem when a function returns a value whose type is ambiguous, such as the following:<span epub:type="pagebreak" id="page_278"></span></p>
        <p class="codelink"><a id="rch13pr22" href="ch13_images.xhtml#ch13pr22">Click here to view code image</a></p>
        <pre class="pre">const root = (x: number) =&gt; {
          if (x &gt;= 0) return Math.sqrt(x)
          else return [404, 'not found']
        }</pre>
        <p class="noindent">The inferred return type is <code>number | (number | string)[]</code>. If you want <code>number | ErrorCode</code>, put a return type annotation behind the parameter list:</p>
        <p class="codelink"><a id="rch13pr23" href="ch13_images.xhtml#ch13pr23">Click here to view code image</a></p>
        <pre class="pre">const root = (x: number)<strong>: number | ErrorCode</strong> =&gt; {
          if (x &gt;= 0) return Math.sqrt(x)
          else return [404, 'not found']
        }</pre>
        <p class="noindent">Here is the same function with the <code>function</code> syntax:</p>
        <p class="codelink"><a id="rch13pr24" href="ch13_images.xhtml#ch13pr24">Click here to view code image</a></p>
        <pre class="pre">function root(x: number)<strong>: number | ErrorCode</strong> {
          if (x &gt;= 0) return Math.sqrt(x)
           else return [404, 'not found']
        }</pre>
        <p class="noindent">A type annotation is also needed when you initialize a variable with <code>undefined</code>:</p>
        <pre class="pre">let result = undefined</pre>
        <p class="noindent">Without an annotation, TypeScript infers the type <code>any</code>. (It would be pointless to infer the type <code>undefined</code>—then the variable could never change.) Therefore, you should specify the intended type:</p>
        <p class="codelink"><a id="rch13pr25" href="ch13_images.xhtml#ch13pr25">Click here to view code image</a></p>
        <pre class="pre">let result<strong>: number | undefined</strong> = undefined</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_279"></span>Later, you can store a number in <code>result</code>, but not a string:</p>
        <pre class="pre">result = 3 // <span class="cite">OK</span>
        result = '3' // <span class="cite">Error</span></pre>
        <p class="noindent">Sometimes you know more about the type of an expression than TypeScript can infer. For example, you might have just received a JSON object and you know its type. Then use a <em>type assertion</em>:</p>
        <p class="codelink"><a id="rch13pr26" href="ch13_images.xhtml#ch13pr26">Click here to view code image</a></p>
        <pre class="pre">let target = JSON.parse(response) <strong>as Point</strong></pre>
        <p class="noindent">A type assertion is similar to a cast in Java or C#, but no exception occurs if the value doesn’t actually conform to the target type.</p>
        <p class="noindent">When you process union types, TypeScript follows the decision flow to ensure that a value is of the correct type in each branch. Consider this example:</p>
        <p class="codelink"><a id="rch13pr27" href="ch13_images.xhtml#ch13pr27">Click here to view code image</a></p>
        <pre class="pre">const less = (x: number | number[] | string | Date | null) =&gt; {
          if (typeof x === 'number')
            return x - 1;
          else if (Array.isArray(x))
            return x.splice(0, 1)
          else if (x instanceof Date)
            return new Date(x.getTime() - 1000)
          else if (x === null)
            return x
          else
            return x.substring(1)
        }</pre>
        <p class="noindent">TypeScript understands the <code>typeof</code>, <code>instanceof</code>, and <code>in</code> operators, the <code>Array.isArray</code> function, and tests for <code>null</code> and <code>undefined</code>. Therefore, the type of <code>x</code> is inferred as <code>number</code>, <code>number[]</code>, <code>Date</code>, and <code>null</code> in the first four branches. In the fifth branch, only the <code>string</code> alternative remains, and TypeScript allows the call to <code>substring</code>.</p>
        <p class="noindent">However, sometimes this inference doesn’t work. Here is an example:</p>
        <p class="codelink"><a id="rch13pr28" href="ch13_images.xhtml#ch13pr28">Click here to view code image</a></p>
        <pre class="pre">const more = (values: number[] | string[]) =&gt; {
          if (array.length &gt; 0 &amp;&amp; typeof x[0] === 'number') // <span class="cite">Error—not a valid type guard</span>
            return values.map(x =&gt; x + 1)
          else
            return values.map(x =&gt; x + x)
        }</pre>
        <p class="noindent">TypeScript can’t analyze the condition. It is simply too complex.</p>
        <p class="noindent">In such a situation, you can provide a custom <em>type guard function</em>. Its special role is indicated by the return type:</p>
        <p class="codelink"><a id="rch13pr29" href="ch13_images.xhtml#ch13pr29">Click here to view code image</a></p>
        <pre class="pre">const isNumberArray = (array: unknown[]): <strong>array is number[]</strong> =&gt;
          array.length &gt; 0 &amp;&amp; typeof array[0] === 'number'</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_280"></span>The return type <code>array is number[]</code> indicates that this function returns a <code>boolean</code> and can be used to test whether the <code>array</code> argument has type <code>number[]</code>. Here is how to use the function:</p>
        <p class="codelink"><a id="rch13pr30" href="ch13_images.xhtml#ch13pr30">Click here to view code image</a></p>
        <pre class="pre">const more = (values: number[] | string[]) =&gt; {
          if (isNumberArray(values))
            return values.map(x =&gt; x + 1)
          else
            return values.map(x =&gt; x + x)
        }</pre>
        <p class="noindent">Here is the same type guard with the <code>function</code> syntax:</p>
        <p class="codelink"><a id="rch13pr31" href="ch13_images.xhtml#ch13pr31">Click here to view code image</a></p>
        <pre class="pre">function isNumberArray(array: unknown[]): <strong>array is number[]</strong> {
          return array.length &gt; 0 &amp;&amp; typeof array[0] === 'number'
        }</pre>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec7">13.7 Subtypes</h3>
        <p class="noindent">Some types, for example <code>number</code> and <code>string</code>, have no relationship with each other. A <code>number</code> variable cannot hold a <code>string</code> variable, nor can a <code>string</code> variable hold a <code>number</code> value. But other types are related. For example, a variable with type <code>number | string</code> <em>can</em> hold a <code>number</code> value.</p>
        <p class="noindent">We say that <code>number</code> is a <em>subtype</em> of <code>number | string</code>, and <code>number | string</code> is a <em>supertype</em> of <code>number</code> and <code>string</code>. A subtype has more constraints than its supertypes. A variable of the supertype can hold values of the subtype, but not the other way around.</p>
        <p class="noindent">In the following sections, we will examine the subtype relationship in more detail.</p>
        <section>
        <h4 class="h4" id="ch13lev2sec1">13.7.1 The Substitution Rule</h4>
        <p class="noindent">Consider again the object type</p>
        <p class="codelink"><a id="rch13pr32" href="ch13_images.xhtml#ch13pr32">Click here to view code image</a></p>
        <pre class="pre">type Point = { x: number, y: number }</pre>
        <p class="noindent">The object <code>{ x: 3, y: 4 }</code> is clearly an instance of <code>Point</code>. What about</p>
        <p class="codelink"><a id="rch13pr33" href="ch13_images.xhtml#ch13pr33">Click here to view code image</a></p>
        <pre class="pre">const bluePoint = { x: 3, y: 4, color: 'blue' }</pre>
        <p class="noindent">Is it also an instance of <code>Point</code>? After all, it has <code>x</code> and <code>y</code> properties whose values are numbers.</p>
        <p class="noindent">In TypeScript, the answer is “no.” The <code>bluePoint</code> object is an instance of the type</p>
        <p class="codelink"><a id="rch13pr34" href="ch13_images.xhtml#ch13pr34">Click here to view code image</a></p>
        <pre class="pre">{ x: number, y: number, color: string }</pre>
        <p class="noindent">For convenience, let us give a name to that type:<span epub:type="pagebreak" id="page_281"></span></p>
        <p class="codelink"><a id="rch13pr35" href="ch13_images.xhtml#ch13pr35">Click here to view code image</a></p>
        <pre class="pre">type ColoredPoint = { x: number, y: number, color: string }</pre>
        <p class="noindent">The <code>ColoredPoint</code> type is a subtype of <code>Point</code>, and <code>Point</code> is a supertype of <code>ColoredPoint</code>. A subtype imposes all the requirements of the supertype, and then some.</p>
        <p class="noindent">Whenever a value of a given type is expected, you can supply a subtype instance. This is sometimes called the <em>substitution rule</em>.</p>
        <p class="noindent">For example, here we pass a <code>ColoredPoint</code> object to a function with a <code>Point</code> parameter:</p>
        <p class="codelink"><a id="rch13pr36" href="ch13_images.xhtml#ch13pr36">Click here to view code image</a></p>
        <pre class="pre">const distanceFromOrigin = (p<strong>: Point</strong>) =&gt; Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2))
        const result = distanceFromOrigin(<strong>bluePoint</strong>) // <span class="cite">OK</span></pre>
        <p class="noindent">The <code>distanceFromOrigin</code> function expects a <code>Point</code>, and it is happy to accept a <code>ColoredPoint</code>. And why shouldn’t it be? The function needs to access numeric <code>x</code> and <code>y</code> properties, and those are certainly present.</p>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">As you just saw, the type of a variable need not be exactly the same as the type of the value to which it refers. In this example, the parameter <code>p</code> has type <code>Point</code>, but the value to which it refers has type <code>ColoredPoint</code>. When you have a variable of a given type, you can be assured that the referenced value belongs to that type <em>or a subtype</em>.</p>
        </div>
        <p class="noindent">The substitution rule has one exception in TypeScript. You cannot substitute an <em>object literal</em> of a subtype. The call</p>
        <p class="codelink"><a id="rch13pr37" href="ch13_images.xhtml#ch13pr37">Click here to view code image</a></p>
        <pre class="pre">const result = distanceFromOrigin({ x: 3, y: 4, color: 'blue' }) // <span class="cite">Error</span></pre>
        <p class="noindent">fails at compile time. This is called an <em>excess property check</em>.</p>
        <p class="noindent">The same check is carried out when you assign an object literal to a typed variable:</p>
        <p class="codelink"><a id="rch13pr38" href="ch13_images.xhtml#ch13pr38">Click here to view code image</a></p>
        <pre class="pre">let p: Point = { x: 3, y: 4 }
        p = { x: 0, y: 0, color: 'red' } // <span class="cite">Error—excess property</span> <code>blue</code></pre>
        <p class="noindent">You will see the rationale for this check in the following section.</p>
        <p class="noindent">It is easy enough to bypass an excess property check. Just introduce another variable:</p>
        <p class="codelink"><a id="rch13pr39" href="ch13_images.xhtml#ch13pr39">Click here to view code image</a></p>
        <pre class="pre">const redOrigin = { x: 0, y: 0, color: 'red' }
        p = redOrigin // <span class="cite">OK—</span><code>p</code> <span class="cite">can hold a subtype value</span></pre>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec2">13.7.2 Optional and Excess Properties</h4>
        <p class="noindent">When you have an object of type <code>Point</code>, you can’t read any properties other than <code>x</code> and <code>y</code>. After all, there is no guarantee that such properties exist.<span epub:type="pagebreak" id="page_282"></span></p>
        <p class="codelink"><a id="rch13pr40" href="ch13_images.xhtml#ch13pr40">Click here to view code image</a></p>
        <pre class="pre">let p: Point = . . .
        console.log(p.color) // <span class="cite">Error—no such property</span></pre>
        <p class="noindent">That makes sense. It is exactly the kind of check that a type system should provide.</p>
        <p class="noindent">What about writing to such a property?</p>
        <pre class="pre">p.color = 'blue' // <span class="cite">Error—no such property</span></pre>
        <p class="noindent">From a type-theoretical point of view, this would be safe. The variable <code>p</code> would still refer to a value that belongs to a subtype of <code>Point</code>. But TypeScript prohibits setting “excess properties.”</p>
        <p class="noindent">If you want properties that are present with some but not all objects of a type, use <em>optional properties</em>. A property marked with <code>?</code> is permitted but not required. Here is an example:</p>
        <p class="codelink"><a id="rch13pr41" href="ch13_images.xhtml#ch13pr41">Click here to view code image</a></p>
        <pre class="pre">type MaybeColoredPoint = {
          x: number,
          y: number,
          <strong>color?</strong>: string
        }</pre>
        <p class="noindent">Now the following statements are OK:</p>
        <p class="codelink"><a id="rch13pr42" href="ch13_images.xhtml#ch13pr42">Click here to view code image</a></p>
        <pre class="pre">let p: MaybeColoredPoint = { x: 0, y: 0 } // <span class="cite">OK—</span><code>color</code> <span class="cite">optional</span>
        p.color = 'red' // <span class="cite">OK—can set optional property</span>
        p = { x: 3, y: 4, color: 'blue' } // <span class="cite">OK—can use literal with optional property</span></pre>
        <p class="noindent">Excess property checks are meant to catch typos with optional properties. Consider a function for plotting a point:</p>
        <p class="codelink"><a id="rch13pr43" href="ch13_images.xhtml#ch13pr43">Click here to view code image</a></p>
        <pre class="pre">const plot = (p: MaybeColoredPoint) =&gt; . . .</pre>
        <p class="noindent">The following call fails:</p>
        <p class="codelink"><a id="rch13pr44" href="ch13_images.xhtml#ch13pr44">Click here to view code image</a></p>
        <pre class="pre">const result = plot({ x: 3, y: 4, <strong>colour</strong>: 'blue' })
          // <span class="cite">Error—excess property</span> <code>colour</code></pre>
        <p class="noindent">Note the British spelling of <code>colour</code>. The <code>MaybeColoredPoint</code> class has no <code>colour</code> property, and TypeScript catches the error. If the compiler had followed the substitution rule without the excess property check, the function would have plotted a point with no <code>color</code>.</p>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec3">13.7.3 Array and Object Type Variance</h4>
        <p class="noindent">Is an array of colored points more specialized than an array of points? It certainly seems to. Indeed, in TypeScript, the <code>ColoredPoint[]</code> type is a subtype of <code>Point[]</code>. In general, if <em>S</em> is a subtype of <em>T</em>, then the array type <em>S</em><code>[]</code> is a <span epub:type="pagebreak" id="page_283"></span>subtype of <em>T</em><code>[]</code>. We say that arrays are <em>covariant</em> in TypeScript since the array types vary in the same direction as the element types.</p>
        <p class="noindent">However, this relationship is actually <em>unsound</em>. It is possible to write TypeScript programs that compile without errors but create errors at runtime. Consider this example:</p>
        <p class="codelink"><a id="rch13pr45" href="ch13_images.xhtml#ch13pr45">Click here to view code image</a></p>
        <pre class="pre">const coloredPoints: ColoredPoint[] = [{ x: 3, y: 4, color: 'blue' },
                                               { x: 0, y: 0, color: 'red' }]
        const points: Point[] = coloredPoints // <span class="cite">OK for</span> <code>points</code> <span class="cite">to hold a subtype value</span></pre>
        <p class="noindent">We can add a plain <code>Point</code> via the <code>points</code> variable:</p>
        <p class="codelink"><a id="rch13pr46" href="ch13_images.xhtml#ch13pr46">Click here to view code image</a></p>
        <pre class="pre">points.push({ x: 4, y: 3 }) // <span class="cite">OK to add a</span> <code>Point</code> <span class="cite">to a</span> <code>Point[]</code></pre>
        <p class="noindent">But <code>coloredPoints</code> and <code>points</code> <em>refer to the same array</em>. Reading the added point with the <code>coloredPoints</code> variable causes a runtime error:</p>
        <p class="codelink"><a id="rch13pr47" href="ch13_images.xhtml#ch13pr47">Click here to view code image</a></p>
        <pre class="pre">console.log(coloredPoints[2].color.length)
          // <span class="cite">Error—cannot read property</span> <code>'length'</code> <span class="cite">of</span> <code>undefined</code></pre>
        <p class="noindent">The value <code>coloredPoints[2].color</code> is <code>undefined</code>, which should not be possible for a <code>ColoredPoint</code>. The type system has a blind spot.</p>
        <p class="noindent">This was a conscious choice by the language designers. Theoretically, only immutable arrays should be covariant, and mutable arrays should be <em>invariant</em>. That is, there should be no subtype relationship between mutable arrays of different types. However, invariant arrays would be inconvenient. In this case, TypeScript, as well as Java and C#, made the decision to give up on complete type safety for the sake of convenience.</p>
        <p class="noindent">Covariance is also used for object types. To determine whether one object type is a subtype of another, we look at the subtype relationships of the matching properties. Let us look at two types that share a single property:</p>
        <p class="codelink"><a id="rch13pr48" href="ch13_images.xhtml#ch13pr48">Click here to view code image</a></p>
        <pre class="pre">type Colored = { color: string }
        type MaybeColored = { color: string | undefined }</pre>
        <p class="noindent">In this case, <code>string</code> is a subtype of <code>string | undefined</code>, and therefore <code>Colored</code> is a subtype of <code>MaybeColored</code>.</p>
        <p class="noindent">In general, if <em>S</em> is a subtype of <em>T</em>, then the object type { <em>p</em>: <em>S</em> } is a subtype of { <em>p</em>: <em>T</em> }. If there are multiple properties, all of them must vary in the same direction.</p>
        <p class="noindent">As with arrays, covariance for objects is unsound—see <a href="#ch13ex11">Exercise 11</a>.</p>
        <p class="noindent">In this section, you have seen how array and object types vary with their component types. For variance of function types, see <a href="ch13.xhtml#ch13lev2sec9">Section 13.12.3</a>, “<a href="ch13.xhtml#ch13lev2sec9">Function Type Variance</a>” (<a href="ch13.xhtml#page_293">page 293</a>), and for generic variance, <a href="ch13.xhtml#ch13lev2sec15">Section 13.13.5</a>, “<a href="ch13.xhtml#ch13lev2sec15">Generic Type Variance</a>” (<a href="ch13.xhtml#page_302">page 302</a>).</p>
        </section>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec8"><span epub:type="pagebreak" id="page_284"></span>13.8 Classes</h3>
        <p class="noindent">The following sections cover how classes work in TypeScript. First, we go over the syntactical differences between classes in JavaScript and TypeScript. Then you will see how classes are related to types.</p>
        <section>
        <h4 class="h4" id="ch13lev2sec4">13.8.1 Declaring Classes</h4>
        <p class="noindent">The TypeScript syntax for classes is similar to that of JavaScript. Of course, you provide type annotations for constructor and method parameters. You also need to specify the types of the instance fields. One way is to list the fields with type annotations, like this:</p>
        <p class="codelink"><a id="rch13pr49" href="ch13_images.xhtml#ch13pr49">Click here to view code image</a></p>
        <pre class="pre">class Point {
          <strong>x: number</strong>
          <strong>y: number</strong>
        
          constructor(x: number, y: number) {
            this.x = x
            this.y = y
          }
        
          distance(other: Point) {
            return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2))
          }
        
          toString() { return `(${this.x}, ${this.y})` }
        
          static origin = new Point(0, 0)
        }</pre>
        <p class="noindent">Alternatively, you can provide initial values from which TypeScript can infer the type:</p>
        <pre class="pre">class Point {
          <strong>x = 0</strong>
          <strong>y = 0</strong>
          . . .
        }</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">This syntax corresponds to the field syntax that is a stage 3 proposal in JavaScript.</p>
        </div>
        <p class="noindent">You can make the instance fields private. TypeScript supports the syntax for private features that is currently at stage 3 in JavaScript.<span epub:type="pagebreak" id="page_285"></span></p>
        <p class="codelink"><a id="rch13pr50" href="ch13_images.xhtml#ch13pr50">Click here to view code image</a></p>
        <pre class="pre">class Point {
          #x: number
          #y: number
        
          constructor(x: number, y: number) {
            this.#x = x
            this.#y = y
          }
        
          distance(other: Point) {
            return Math.sqrt(Math.pow(this.#x - other.#x, 2) + Math.pow(this.#y - other.#y, 2))
          }
        
          toString() { return `(${this.#x}, ${this.#y})` }
        
          static origin = new Point(0, 0)
        }</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">TypeScript also supports <code>private</code> and <code>protected</code> modifiers for instance fields and methods. These modifiers work just like in Java or C++. They come from a time where JavaScript did not have a syntax for private variables and methods. I do not discuss those modifiers in this chapter.</p>
        </div>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">You can declare instance fields as <code>readonly</code>:</p>
        <pre class="pre">class Point {
          <strong>readonly</strong> x: number
          <strong>readonly</strong> y: number
          . . .
        }</pre>
        <p class="noindent">A <code>readonly</code> property cannot be changed after its initial assignment.</p>
        <p class="codelink"><a id="rch13pr51" href="ch13_images.xhtml#ch13pr51">Click here to view code image</a></p>
        <pre class="pre">const p = new Point(3, 4)
        p.x = 0 // <span class="cite">Error—cannot change</span> <code>readonly</code> <span class="cite">property</span></pre>
        <p class="noindent">Note that <code>readonly</code> is applied to <em>properties</em>, whereas <code>const</code> applies to <em>variables</em>.</p>
        </div>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec5">13.8.2 The Instance Type of a Class</h4>
        <p class="noindent">The instances of a class have a TypeScript type that contains every public property and method. For example, consider the <code>Point</code> class with public fields from the preceding sections. Its instances have the type<span epub:type="pagebreak" id="page_286"></span></p>
        <p class="codelink"><a id="rch13pr52" href="ch13_images.xhtml#ch13pr52">Click here to view code image</a></p>
        <pre class="pre">{
          x: number,
          y: number,
          distance: (this: Point, arg1: Point) =&gt; number
          toString: (this: Point) =&gt; string
        }</pre>
        <p class="noindent">Note that the constructor and static members are not a part of the instance type.</p>
        <p class="noindent">You can indicate a method by naming the first parameter <code>this</code>, as in the preceding example. Alternatively, you can use the following compact notation:</p>
        <p class="codelink"><a id="rch13pr53" href="ch13_images.xhtml#ch13pr53">Click here to view code image</a></p>
        <pre class="pre">{
          x: number,
          y: number,
          <strong>distance(arg1: Point): number</strong>
          <strong>toString(): string</strong>
        }</pre>
        <p class="noindent">Getter and setter methods in classes give rise to properties in TypeScript types. For example, if you define</p>
        <p class="codelink"><a id="rch13pr54" href="ch13_images.xhtml#ch13pr54">Click here to view code image</a></p>
        <pre class="pre">get x() { return this.#x }
        set x(x: number) { this.#x = x }
        get y() { return this.#y }
        set y(y: number) { this.#y = y }</pre>
        <p class="noindent">for the <code>Point</code> class with private instance fields in the preceding section, then the TypeScript type has properties <code>x</code> and <code>y</code> of type <code>number</code>.</p>
        <p class="noindent">If you only provide a getter, the property is <code>readonly</code>.</p>
        <div class="caution">
        <p class="caution-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">If you only provide a setter and no getter, reading from the property is permitted and returns <code>undefined</code>.</p>
        </div>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec6">13.8.3 The Static Type of a Class</h4>
        <p class="noindent">As noted in the preceding section, the constructor and static members are not part of the instance type of a class. Instead, they belong to the static type.</p>
        <p class="noindent">The static type of our sample <code>Point</code> class is</p>
        <pre class="pre">{
          new (x: number, y: number): Point
          origin: Point
        }</pre>
        <p class="noindent">The syntax for specifying a constructor is similar to that for a method, but you use <code>new</code> in place of the method name.</p>
        <p class="noindent"><span epub:type="pagebreak" id="page_287"></span>You don’t usually have to worry about the static type (but see <a href="ch13.xhtml#ch13lev2sec14">Section 13.13.4</a>, “<a href="ch13.xhtml#ch13lev2sec14">Erasure</a>,” <a href="ch13.xhtml#page_300">page 300</a>). Nevertheless, it is a common cause of confusion. Consider this code snippet:</p>
        <p class="codelink"><a id="rch13pr55" href="ch13_images.xhtml#ch13pr55">Click here to view code image</a></p>
        <pre class="pre">const a = new Point(3, 4)
        const b: typeof a = new Point(0, 0) // <span class="cite">OK</span>
        const ctor: typeof Point = new Point(0, 0) // <span class="cite">Error</span></pre>
        <p class="noindent">Since <code>a</code> is an instance of <code>Point</code>, <code>typeof a</code> is the instance type of the <code>Point</code> class. But what is <code>typeof Point</code>? Here, <code>Point</code> is the constructor function. After all, that’s all a class is in JavaScript—a constructor function. Its type is the static type of the class. You can initialize <code>ctor</code> as</p>
        <pre class="pre">const ctor: typeof Point = Point</pre>
        <p class="noindent">Then you can call <code>new ctor(3, 4)</code> or access <code>ctor.origin</code>.</p>
        </section>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec9">13.9 Structural Typing</h3>
        <p class="noindent">The TypeScript type system uses <em>structural typing</em>. Two types are the same if they have the same structure. For example,</p>
        <pre class="pre">type ErrorCode = [number, string]</pre>
        <p class="noindent">and</p>
        <pre class="pre">type LineItem = [number, string]</pre>
        <p class="noindent">are the same type. The names of the types are irrelevant. You can freely copy values between the two types:</p>
        <p class="codelink"><a id="rch13pr56" href="ch13_images.xhtml#ch13pr56">Click here to view code image</a></p>
        <pre class="pre">let code: ErrorCode = [404, 'Not found']
        let items: LineItem[] = [[2, 'Blackwell Toaster']]
        items[1] = code</pre>
        <p class="noindent">This sounds potentially dangerous, but it is certainly no worse than what programmers do every day with plain JavaScript. And in practice, with object types, it is quite unlikely that two types have exactly the same structure. If we use object types in our example, we might arrive at these types:</p>
        <p class="codelink"><a id="rch13pr57" href="ch13_images.xhtml#ch13pr57">Click here to view code image</a></p>
        <pre class="pre">type ErrorCode = { code: number, description: string }
        type LineItem = { quantity: number, description: string }</pre>
        <p class="noindent">They are different since the property names don’t match.</p>
        <p class="noindent">Structural typing is very different from the “nominal” type systems in Java, C#, or C++, where the names of the type matter. But in JavaScript, what matters are the capabilities of an object, not the name of its type.</p>
        <p class="noindent">To illustrate the difference, consider this JavaScript function:</p>
        <p class="codelink"><a id="rch13pr58" href="ch13_images.xhtml#ch13pr58">Click here to view code image</a></p>
        <pre class="pre">const act = x =&gt; { x.walk(); x.quack(); }</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_288"></span>Obviously, in JavaScript, the function works with any <code>x</code> that has methods <code>walk</code> and <code>quack</code>.</p>
        <p class="noindent">In TypeScript, you can accurately reflect this behavior with a type:</p>
        <p class="codelink"><a id="rch13pr59" href="ch13_images.xhtml#ch13pr59">Click here to view code image</a></p>
        <pre class="pre">const act = (x: <strong>{ walk(): void, quack(): void }</strong>) =&gt; { x.walk(); x.quack(); }</pre>
        <p class="noindent">You may have a class <code>Duck</code> that provides these methods:</p>
        <p class="codelink"><a id="rch13pr60" href="ch13_images.xhtml#ch13pr60">Click here to view code image</a></p>
        <pre class="pre">class Duck {
          constructor(. . .) { . . . }
          walk(): void { . . . }
          quack(): void { . . . }
        }</pre>
        <p class="noindent">That’s swell. You can pass a <code>Duck</code> instance to the <code>act</code> function:</p>
        <p class="codelink"><a id="rch13pr61" href="ch13_images.xhtml#ch13pr61">Click here to view code image</a></p>
        <pre class="pre">const donald = new Duck(. . .)
        act(donald)</pre>
        <p class="noindent">But now suppose you have another object—not an instance of this class, but still with <code>walk</code> and <code>quack</code> methods:</p>
        <p class="codelink"><a id="rch13pr62" href="ch13_images.xhtml#ch13pr62">Click here to view code image</a></p>
        <pre class="pre">const daffy = { walk: function () { . . . }, quack: function () { . . . } };</pre>
        <p class="noindent">You can equally well pass this object to the <code>act</code> function. This phenomenon is called “duck typing,” after the proverbial saying: “If it walks like a duck and quacks like a duck, it must be a duck.”</p>
        <p class="noindent">The structural typing in TypeScript formalizes this approach. Using the structure of the type, TypeScript can check at compile time that each value has the needed capabilities. The type names don’t matter at all.</p>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec10">13.10 Interfaces</h3>
        <p class="noindent">Consider an object type to describe objects that have an ID method:</p>
        <pre class="pre">type Identifiable = {
          id(): string
        }</pre>
        <p class="noindent">Using this type, you can define a function that finds an element by ID:</p>
        <p class="codelink"><a id="rch13pr63" href="ch13_images.xhtml#ch13pr63">Click here to view code image</a></p>
        <pre class="pre">const findById = (elements: Identifiable[], id: string) =&gt; {
          for (const e of elements) if (e.id() === id) return e;
          return undefined;
        }</pre>
        <p class="noindent">To make sure that a class is a subtype of this type, you can define the class with an <code>implements</code> clause:<span epub:type="pagebreak" id="page_289"></span></p>
        <p class="codelink"><a id="rch13pr64" href="ch13_images.xhtml#ch13pr64">Click here to view code image</a></p>
        <pre class="pre">class Person implements Identifiable {
          #name: string
          #id: string
          constructor(name: string, id: string) { this.#name = name; this.#id = id; }
          id() { return this.#id }
        }</pre>
        <p class="noindent">Now TypeScript checks that your class really provides an <code>id</code> method with the correct types.</p>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">That is all that the <code>implements</code> clause does. If you omit the clause, <code>Person</code> is still a subtype of <code>Identifiable</code>, because of structural typing.</p>
        </div>
        <p class="noindent">There is an alternate syntax for object types that looks more familiar to Java and C# programmers:</p>
        <p class="codelink"><a id="rch13pr65" href="ch13_images.xhtml#ch13pr65">Click here to view code image</a></p>
        <pre class="pre">interface Identifiable {
          id(): string
        }</pre>
        <p class="noindent">In older versions of TypeScript, object types were more limited than interfaces. Nowadays, you can use either.</p>
        <p class="noindent">There are a couple of minor differences. One interface can extend another:</p>
        <p class="codelink"><a id="rch13pr66" href="ch13_images.xhtml#ch13pr66">Click here to view code image</a></p>
        <pre class="pre">interface Employable extends Identifiable {
          salary(): number
        }</pre>
        <p class="noindent">With type declarations, you use an intersection type instead:</p>
        <p class="codelink"><a id="rch13pr67" href="ch13_images.xhtml#ch13pr67">Click here to view code image</a></p>
        <pre class="pre">type Employable = Identifiable &amp; {
          salary(): number
        }</pre>
        <p class="noindent">Interfaces, unlike object types, can be defined in fragments. You can have</p>
        <p class="codelink"><a id="rch13pr68" href="ch13_images.xhtml#ch13pr68">Click here to view code image</a></p>
        <pre class="pre">interface Employable {
          id(): string
        }</pre>
        <p class="noindent">followed elsewhere by</p>
        <p class="codelink"><a id="rch13pr69" href="ch13_images.xhtml#ch13pr69">Click here to view code image</a></p>
        <pre class="pre">interface Employable {
          salary(): number
        }</pre>
        <p class="noindent">The fragments are merged together. This merging is not done for <code>type</code> declarations. It is debatable whether this is a useful feature.</p>
        <div class="note">
        <p class="note-caption"><span epub:type="pagebreak" id="page_290"></span><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">In TypeScript, an interface can extend a class. It then picks up all properties of the instance type of the class. For example,</p>
        <p class="codelink"><a id="rch13pr70" href="ch13_images.xhtml#ch13pr70">Click here to view code image</a></p>
        <pre class="pre">interface Point3D extends Point { z: number }</pre>
        <p class="noindent">has the fields and methods of <code>Point</code>, as well as the <code>z</code> property.</p>
        <p class="noindent">Instead of such an interface, you can use an intersection type</p>
        <p class="codelink"><a id="rch13pr71" href="ch13_images.xhtml#ch13pr71">Click here to view code image</a></p>
        <pre class="pre">type Point3D = Point &amp; { z: number }</pre>
        </div>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec11">13.11 Indexed Properties</h3>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/cat.jpg" alt="Images" width="85" height="85">
        </figure>
        <p class="noindent">Sometimes, you want to use objects with arbitrary properties. In TypeScript, you need to use an <em>index signature</em> to let the type checker know that arbitrary properties are OK. Here is the syntax:</p>
        <p class="codelink"><a id="rch13pr72" href="ch13_images.xhtml#ch13pr72">Click here to view code image</a></p>
        <pre class="pre">type Dictionary = {
          creator: string,
          <strong>[arg: string]: string | string[]</strong>
        }</pre>
        <p class="noindent">The variable name of the index argument (here, <code>arg</code>) is immaterial, but you must supply a name.</p>
        <p class="noindent">Each <code>Dictionary</code> instance has a <code>creator</code> property and any number of other properties whose values are strings or string arrays.</p>
        <p class="codelink"><a id="rch13pr73" href="ch13_images.xhtml#ch13pr73">Click here to view code image</a></p>
        <pre class="pre">const dict: Dictionary = { creator: 'Pierre' }
        dict.hello = ['bonjour', 'salut', 'allô']
        let str = 'world'
        dict[str] = 'monde'</pre>
        <div class="caution">
        <p class="caution-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">The types of explicitly provided properties must be subtypes of the index type. The following would be an error:</p>
        <p class="codelink"><a id="rch13pr74" href="ch13_images.xhtml#ch13pr74">Click here to view code image</a></p>
        <pre class="pre">type Dictionary = {
          created: Date, // <span class="cite">Error—not a</span> <code>string</code> <span class="cite">or</span> <code>string[]</code>
          [arg: string]: string | string[]
        }</pre>
        <p class="noindent">There would be no way to check that an assignment to <code>dict[str]</code> is correct with an arbitrary value for <code>str</code>.</p>
        </div>
        <p class="noindent"><span epub:type="pagebreak" id="page_291"></span>You can also describe array-like types with integer index values:</p>
        <p class="codelink"><a id="rch13pr75" href="ch13_images.xhtml#ch13pr75">Click here to view code image</a></p>
        <pre class="pre">type ShoppingList = {
          created: Date,
          [arg: number] : string
        }
        
        const list: ShoppingList = {
          created: new Date()
        }
        list[0] = 'eggs'
        list[1] = 'ham'</pre>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec12">13.12 Complex Function Parameters</h3>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/cat.jpg" alt="Images" width="85" height="85">
        </figure>
        <p class="noindent">In the following sections, you will see how to provide annotations for more optional, default, rest, and destructured parameters. Then we turn to “overloading”—specifying multiple parameter and return types for a single function.</p>
        <section>
        <h4 class="h4" id="ch13lev2sec7">13.12.1 Optional, Default, and Rest Parameters</h4>
        <p class="noindent">Consider the JavaScript function</p>
        <p class="codelink"><a id="rch13pr76" href="ch13_images.xhtml#ch13pr76">Click here to view code image</a></p>
        <pre class="pre">const average = (x, y) =&gt; (x + y) / 2 // <span class="cite">JavaScript</span></pre>
        <p class="noindent">In JavaScript, you have to worry about the fact that someone might call <code>average(3)</code>, which would evaluate to <code>(3 + undefined) / 2</code>, or <code>NaN</code>. In TypeScript, that’s not an issue. You cannot call a function without supplying all of the required arguments.</p>
        <p class="noindent">However, JavaScript programmers often provide optional parameters. In our <code>average</code> function, the second parameter can be optional:</p>
        <p class="codelink"><a id="rch13pr77" href="ch13_images.xhtml#ch13pr77">Click here to view code image</a></p>
        <pre class="pre">const average = (x, y) =&gt; y === undefined ? x : (x + y) / 2 // <span class="cite">JavaScript</span></pre>
        <p class="noindent">In TypeScript, you tag optional parameters with a <code>?</code>, like this:</p>
        <p class="codelink"><a id="rch13pr78" href="ch13_images.xhtml#ch13pr78">Click here to view code image</a></p>
        <pre class="pre">const average = (x: number, y<strong>?</strong>: number) =&gt; y === undefined ? x : (x + y) / 2
          // <span class="cite">TypeScript</span></pre>
        <p class="noindent">Optional parameters must come after the required parameters.</p>
        <p class="noindent">As in JavaScript, you can provide default parameters in TypeScript:</p>
        <p class="codelink"><a id="rch13pr79" href="ch13_images.xhtml#ch13pr79">Click here to view code image</a></p>
        <pre class="pre">const average = (x = 0, y = x) =&gt; (x + y) / 2  // <span class="cite">TypeScript</span></pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_292"></span>Here, the parameter types are inferred from the types of the defaults.</p>
        <p class="noindent">Rest parameters work exactly like in JavaScript. You annotate a rest parameter as an array:</p>
        <p class="codelink"><a id="rch13pr80" href="ch13_images.xhtml#ch13pr80">Click here to view code image</a></p>
        <pre class="pre">const average = (first = 0, ...following<strong>: number[]</strong>) =&gt; {
          let sum = first
          for (const value of following) { sum += value }
          return sum / (1 + following.length)
        }</pre>
        <p class="noindent">The type of this function is</p>
        <p class="codelink"><a id="rch13pr81" href="ch13_images.xhtml#ch13pr81">Click here to view code image</a></p>
        <pre class="pre">(arg1: number, ...arg2: number[]) =&gt; number</pre>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec8">13.12.2 Destructuring Parameters</h4>
        <p class="noindent">In <a href="ch03.xhtml#ch03">Chapter 3</a>, we looked at functions that are called with a “configuration object,” like this:</p>
        <p class="codelink"><a id="rch13pr82" href="ch13_images.xhtml#ch13pr82">Click here to view code image</a></p>
        <pre class="pre">const result = mkString(elements,
          <strong>{ separator: ', ', leftDelimiter: '(', rightDelimiter: ')' }</strong>)</pre>
        <p class="noindent">When implementing the function, you can, of course, have a parameter for the configuration object:</p>
        <p class="codelink"><a id="rch13pr83" href="ch13_images.xhtml#ch13pr83">Click here to view code image</a></p>
        <pre class="pre">const mkString = (values, config) =&gt;
          config.leftDelimiter + values.join(config.separator) + config.rightDelimiter</pre>
        <p class="noindent">Or you can use destructuring to declare three parameter variables:</p>
        <p class="codelink"><a id="rch13pr84" href="ch13_images.xhtml#ch13pr84">Click here to view code image</a></p>
        <pre class="pre">const mkString = (values, { separator, leftDelimiter, rightDelimiter }) =&gt;
          leftDelimiter + values.join(separator) + rightDelimiter</pre>
        <p class="noindent">In TypeScript, you need to add types. However, the obvious way does not work:</p>
        <p class="codelink"><a id="rch13pr85" href="ch13_images.xhtml#ch13pr85">Click here to view code image</a></p>
        <pre class="pre">const mkString = (values: unknown[], { // <span class="cite">TypeScript</span>
            separator: string,
            leftDelimiter: string, // <span class="cite">Error—duplicate identifier</span>
            rightDelimiter: string // <span class="cite">Error—duplicate identifier</span>
          }) =&gt; leftDelimiter + values.join(separator) + rightDelimiter</pre>
        <p class="noindent">The syntax for TypeScript type annotations is in conflict with the destructuring syntax. In JavaScript (and therefore, in TypeScript), you can add variable names after the property names:<span epub:type="pagebreak" id="page_293"></span></p>
        <p class="codelink"><a id="rch13pr86" href="ch13_images.xhtml#ch13pr86">Click here to view code image</a></p>
        <pre class="pre">const mkString = (values, { // <span class="cite">JavaScript</span>
            separator<strong>: sep</strong>,
            leftDelimiter<strong>: left</strong>,
            rightDelimiter<strong>: right</strong>
          }) =&gt; left + values.join(sep) + right</pre>
        <p class="noindent">To correctly specify the types, add a type annotation to the entire configuration object:</p>
        <p class="codelink"><a id="rch13pr87" href="ch13_images.xhtml#ch13pr87">Click here to view code image</a></p>
        <pre class="pre">const mkString = (values: unknown[], // <span class="cite">TypeScript</span>
            { separator, leftDelimiter, rightDelimiter }
              <strong>: { separator: string, leftDelimiter: string, rightDelimiter: string }</strong>)
          =&gt; leftDelimiter + values.join(separator) + rightDelimiter</pre>
        <p class="noindent">In <a href="ch03.xhtml#ch03">Chapter 3</a>, we also provided default arguments for each option. Here is the function with the defaults:</p>
        <p class="codelink"><a id="rch13pr88" href="ch13_images.xhtml#ch13pr88">Click here to view code image</a></p>
        <pre class="pre">const mkString = (values: unknown[], // <span class="cite">TypeScript</span>
            { separator <strong>= ','</strong>, leftDelimiter <strong>= '['</strong>, rightDelimiter <strong>= ']'</strong> }
              : { separator<strong>?</strong>: string, leftDelimiter<strong>?</strong>: string, rightDelimiter<strong>?</strong>: string })
          =&gt; leftDelimiter + values.join(separator) + rightDelimiter</pre>
        <p class="noindent">Note that with the defaults, the type changes slightly—each property is now optional.</p>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec9">13.12.3 Function Type Variance</h4>
        <p class="noindent">In <a href="ch13.xhtml#ch13lev2sec3">Section 13.7.3</a>, “<a href="ch13.xhtml#ch13lev2sec3">Array and Object Type Variance</a>” (<a href="ch13.xhtml#page_282">page 282</a>), you saw that arrays are covariant. Replacing the element type with a subtype yields an array subtype. For example, if <code>Employee</code> is a subtype of <code>Person</code>, then <code>Employee[]</code> is a subtype of <code>Person[]</code>.</p>
        <p class="noindent">Similarly, object types are covariant in the property types. The type <code>{ partner: Employee }</code> is a subtype of <code>{ partner: Person }</code>.</p>
        <p class="noindent">In this section, we examine subtype relationships between function types.</p>
        <p class="noindent">Function types are <em>contravariant</em> in their parameter types. If you replace a parameter type with a <em>supertype</em>, you get a subtype. For example, the type</p>
        <p class="codelink"><a id="rch13pr89" href="ch13_images.xhtml#ch13pr89">Click here to view code image</a></p>
        <pre class="pre">type PersonConsumer = (arg1: <strong>Person</strong>) =&gt; void</pre>
        <p class="noindent">is a subtype of</p>
        <p class="codelink"><a id="rch13pr90" href="ch13_images.xhtml#ch13pr90">Click here to view code image</a></p>
        <pre class="pre">type EmployeeConsumer = (arg1: <strong>Employee</strong>) =&gt; void</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_294"></span>That means, an <code>EmployeeConsumer</code> variable can hold a <code>PersonConsumer</code> value:</p>
        <p class="codelink"><a id="rch13pr91" href="ch13_images.xhtml#ch13pr91">Click here to view code image</a></p>
        <pre class="pre">const pc: PersonConsumer = (p: Person) =&gt; { console.log(`a person named ${p.name}`) }
        const ec: EmployeeConsumer = pc
          // <span class="cite">OK for</span> <code>ec</code> <span class="cite">to hold subtype value</span></pre>
        <p class="noindent">This assignment is sound because <code>pf</code> can surely accept <code>Employee</code> instances. After all, it is prepared to handle more general <code>Person</code> instances.</p>
        <p class="noindent">With the return type, we have covariance. For example,</p>
        <p class="codelink"><a id="rch13pr92" href="ch13_images.xhtml#ch13pr92">Click here to view code image</a></p>
        <pre class="pre">type EmployeeProducer = (arg1: string) =&gt; <strong>Employee</strong></pre>
        <p class="noindent">is a subtype of</p>
        <p class="codelink"><a id="rch13pr93" href="ch13_images.xhtml#ch13pr93">Click here to view code image</a></p>
        <pre class="pre">type PersonProducer = (arg1: string) =&gt; <strong>Person</strong></pre>
        <p class="noindent">The following assignment is sound:</p>
        <p class="codelink"><a id="rch13pr94" href="ch13_images.xhtml#ch13pr94">Click here to view code image</a></p>
        <pre class="pre">const ep: EmployeeProducer = (name: string) =&gt; ({ name, salary: 0 })
        const pp: PersonProducer = ep
          // <span class="cite">OK for</span> <code>pp</code> <span class="cite">to hold subtype value</span></pre>
        <p class="noindent">Calling <code>pp('Fred')</code> surely produces a <code>Person</code> instance.</p>
        <p class="noindent">If you drop the last parameter type from a function type, you obtain a subtype. For example,</p>
        <pre class="pre">(arg1: number) =&gt; number</pre>
        <p class="noindent">is a subtype of</p>
        <pre class="pre">(arg1: number, arg2: number) =&gt; number</pre>
        <p class="noindent">To see why, consider the assignment</p>
        <p class="codelink"><a id="rch13pr95" href="ch13_images.xhtml#ch13pr95">Click here to view code image</a></p>
        <pre class="pre">const g = (x: number) =&gt; 2 * x
          // <span class="cite">Type</span> <code>(arg1: number) =&gt; number</code>
        const f: (arg1: number, arg2: number) =&gt; number = g
          // <span class="cite">OK for</span> <code>f</code> <span class="cite">to hold subtype value</span></pre>
        <p class="noindent">It is safe to call <code>f</code> with two arguments. The second argument is simply ignored.</p>
        <p class="noindent">Similarly, if you make a parameter optional, you obtain a subtype:</p>
        <p class="codelink"><a id="rch13pr96" href="ch13_images.xhtml#ch13pr96">Click here to view code image</a></p>
        <pre class="pre">const g = (x: number, y?: number) =&gt; y === undefined ? x : (x + y) / 2
          // <span class="cite">Type</span> <code>(arg1: number, arg2?: number) =&gt; number</code>
        const f: (arg1: number, arg2: number) =&gt; number = g
          // <span class="cite">OK for</span> <code>f</code> <span class="cite">to hold subtype value</span></pre>
        <p class="noindent">Again, it is safe to call <code>f</code> with two arguments.</p>
        <p class="noindent">Finally, if you add a rest parameter, you get a subtype.</p>
        <p class="codelink"><a id="rch13pr97" href="ch13_images.xhtml#ch13pr97">Click here to view code image</a></p>
        <pre class="pre">let g = (x: number, y: number, ...following: number[]) =&gt; Math.max(x, y, ...following)
          // <span class="cite">Type:</span> <code>(arg1: number, arg2: number, ...rest: number[]) =&gt; number</code>
        let f: (arg1: number, arg2: number) =&gt; number = g
          // <span class="cite">OK for</span> <code>f</code> <span class="cite">to hold subtype value</span></pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_295"></span>Once again, calling <code>f</code> with two parameters is fine.</p>
        <p class="noindent"><a href="ch13.xhtml#ch13tab01">Table 13-1</a> gives a summary of all subtype rules that were covered so far.</p>
        <figure class="table" id="ch13tab01">
        <figcaption><p class="table-title"><strong>Table 13-1</strong>&nbsp;&nbsp;&nbsp;&nbsp;Forming Subtypes</p></figcaption>
        <table class="tabletb">
        <thead>
        <tr>
        <th style="width: 33%;"><p class="tableth">Action</p></th>
        <th style="width: 34%;"><p class="tableth">Supertype<br>A variable of this type...</p></th>
        <th style="width: 33%;"><p class="tableth">Subtype<br>...can hold a value of this type</p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p class="tabletd">Replace array element type with subtype</p></td>
        <td><p class="tabletd"><code>Person[]</code></p></td>
        <td><p class="tabletd"><code>Employee[]</code></p></td>
        </tr>
        <tr>
        <td><p class="tabletd">Replace object property type with subtype</p></td>
        <td><p class="tabletd"><code>{ partner: Person }</code></p></td>
        <td><p class="tabletd"><code>{ partner: Employee }</code></p></td>
        </tr>
        <tr>
        <td><p class="tabletd">Add object property</p></td>
        <td><p class="tabletd"><code>{ x: number, y: number }</code></p></td>
        <td><p class="tabletd"><code>{ x: number, y: number, color: string }</code></p></td>
        </tr>
        <tr>
        <td><p class="tabletd">Replace function parameter type with <em>supertype</em></p></td>
        <td><p class="tabletd"><code>(arg1: Employee) =&gt; void</code></p></td>
        <td><p class="tabletd"><code>(arg1: Person) =&gt; void</code></p></td>
        </tr>
        <tr>
        <td><p class="tabletd">Replace function return type with subtype</p></td>
        <td><p class="tabletd"><code>(arg1: string) =&gt; Person</code></p></td>
        <td><p class="tabletd"><code>(arg1: string) =&gt; Employee</code></p></td>
        </tr>
        <tr>
        <td><p class="tabletd">Drop the last parameter</p></td>
        <td><p class="tabletd"><code>(arg1: number, arg2: number) =&gt; number</code></p></td>
        <td><p class="tabletd"><code>(arg1: number) =&gt; number</code></p></td>
        </tr>
        <tr>
        <td><p class="tabletd">Make the last parameter optional</p></td>
        <td><p class="tabletd"><code>(arg1: number, arg2: number) =&gt; number</code></p></td>
        <td><p class="tabletd"><code>(arg1: number, arg2?: number) =&gt; number</code></p></td>
        </tr>
        <tr>
        <td><p class="tabletd">Add a rest parameter</p></td>
        <td><p class="tabletd"><code>(arg1: number) =&gt; number</code></p></td>
        <td><p class="tabletd"><code>(arg1: number, ...rest: number[]) =&gt; number</code></p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec10">13.12.4 Overloads</h4>
        <p class="noindent">In JavaScript, it is common to write functions that can be called flexibly. For example, this JavaScript function counts how many times a letter occurs in a string:</p>
        <p class="codelink"><a id="rch13pr98" href="ch13_images.xhtml#ch13pr98">Click here to view code image</a></p>
        <pre class="pre">function count(str, c) { return str.length - str.replace(c, '').length }</pre>
        <p class="noindent">What if we have an array of strings? In JavaScript, it is easy to extend the behavior:</p>
        <p class="codelink"><a id="rch13pr99" href="ch13_images.xhtml#ch13pr99">Click here to view code image</a></p>
        <pre class="pre">function count(str, c) {
          if (Array.isArray(str)) {
            let sum = 0
            for (const s of str) {
              sum += s.length - s.replace(c, '').length
            }
            <span epub:type="pagebreak" id="page_296"></span>return sum
          } else {
            return str.length - str.replace(c, '').length
          }
        }</pre>
        <p class="noindent">In TypeScript, we need to provide a type for this function. That is not too hard: <code>str</code> is either a string or an array of strings:</p>
        <p class="codelink"><a id="rch13pr100" href="ch13_images.xhtml#ch13pr100">Click here to view code image</a></p>
        <pre class="pre">function count(str: <strong>string | string[]</strong>, c: string) { . . . }</pre>
        <p class="noindent">This works because in either case, the return type is <code>number</code>. That is, the function has type</p>
        <p class="codelink"><a id="rch13pr101" href="ch13_images.xhtml#ch13pr101">Click here to view code image</a></p>
        <pre class="pre">(str: string | string[], c: string) =&gt; number</pre>
        <p class="noindent">But what if the return type differs depending on the argument types? Let’s say we remove the characters instead of counting them:</p>
        <p class="codelink"><a id="rch13pr102" href="ch13_images.xhtml#ch13pr102">Click here to view code image</a></p>
        <pre class="pre">function remove(str, c) { // <span class="cite">JavaScript</span>
          if (Array.isArray(str))
            return str.map(s =&gt; s.replace(c, ''))
          else
            return str.replace(c, '')
        }</pre>
        <p class="noindent">Now the return type is either <code>string</code> or <code>string[]</code>.</p>
        <p class="noindent">But it is not optimal to use the union type <code>string | string[]</code> as the return type. In an expression</p>
        <p class="codelink"><a id="rch13pr103" href="ch13_images.xhtml#ch13pr103">Click here to view code image</a></p>
        <pre class="pre">const result = remove(['Fred', 'Barney'], 'e')</pre>
        <p class="noindent">we would like <code>result</code> to be typed as <code>string[]</code>, not the union type.</p>
        <p class="noindent">You can achieve this by <em>overloading</em> the function. JavaScript doesn’t actually allow you to overload functions in the traditional sense—that is, implement separate functions with the same name but different parameter types. Instead, you list the declarations that you wish you could implement separately, followed by the one implementation:</p>
        <p class="codelink"><a id="rch13pr104" href="ch13_images.xhtml#ch13pr104">Click here to view code image</a></p>
        <pre class="pre">function remove(str: string, c: string): string
        function remove(str: string[], c: string): string[]
        function remove(str: string | string[], c: string) {
          if (Array.isArray(str))
            return str.map(s =&gt; s.replace(c, ''))
          else
            return str.replace(c, '')
        }</pre>
        <p class="noindent">With arrow functions, the syntax is a little different. Annotate the type of the variable that will hold the function, like this:<span epub:type="pagebreak" id="page_297"></span></p>
        <p class="codelink"><a id="rch13pr105" href="ch13_images.xhtml#ch13pr105">Click here to view code image</a></p>
        <pre class="pre">const remove<strong>: {
          (arg1: string, arg2: string): string
          (arg1: string[], arg2: string): string[]
        }</strong> = (str: any, c: string) =&gt; {
          if (Array.isArray(str))
            return str.map(s =&gt; s.replace(c, ''))
          else
            return str.replace(c, '')
        }</pre>
        <div class="caution">
        <p class="caution-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">Perhaps for historical reasons, the syntax of this overload annotation does not use the arrow syntax for function types. Instead, the syntax is reminiscent of an <code>interface</code> declaration.</p>
        <p class="noindent">Also, the type checking is not as good with arrow functions. The parameter <code>str</code> must be declared with type <code>any</code>, not <code>string | string[]</code>. With <code>function</code> declarations, TypeScript works harder and checks the execution paths of the function, guaranteeing that <code>string</code> arguments yield <code>string</code> results, but <code>string[]</code> arguments return <code>string[]</code> values.</p>
        </div>
        <p class="noindent">Overloaded methods use a syntax that is similar to functions:</p>
        <p class="codelink"><a id="rch13pr106" href="ch13_images.xhtml#ch13pr106">Click here to view code image</a></p>
        <pre class="pre">class Remover {
          c: string
          constructor(c: string) { this.c = c }
        
          removeFrom(str: string): string
          removeFrom(str: string[]): string[]
          removeFrom(str: string | string[]) {
            if (Array.isArray(str))
              return str.map(s =&gt; s.replace(this.c, ''))
            else
              return str.replace(this.c, '')
          }
        }</pre>
        </section>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec13">13.13 Generic Programming</h3>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/cat.jpg" alt="Images" width="85" height="85">
        </figure>
        <p class="noindent">A declaration of a class, type, or function is <em>generic</em> when it uses <em>type parameters</em> for types that are not yet specified and can be filled in later. For example, in TypeScript, the standard <code>Set&lt;T&gt;</code> type has a type parameter <code>T</code>, allowing you to form sets of any type, such as <code>Set&lt;string&gt;</code> or <code>Set&lt;Point&gt;</code>. The following sections show you how to work with generics in TypeScript.</p>
        <section>
        <h4 class="h4" id="ch13lev2sec11"><span epub:type="pagebreak" id="page_298"></span>13.13.1 Generic Classes and Types</h4>
        <p class="noindent">Here is a simple example of a generic class. Its instances hold key/value pairs:</p>
        <p class="codelink"><a id="rch13pr107" href="ch13_images.xhtml#ch13pr107">Click here to view code image</a></p>
        <pre class="pre">class Entry&lt;K, V&gt; {
          key: K
          value: V
          constructor(key: K, second: V) {
            this.key = key
            this.value = value
          }
        }</pre>
        <p class="noindent">As you can see, the type parameters <code>K</code> and <code>V</code> are specified inside angle brackets after the name of the class. In the definitions of fields and the constructor, the type parameters are used as types.</p>
        <p class="noindent">You <em>instantiate</em> the generic class by substituting types for the type variables. For example, <code>Entry&lt;string, number&gt;</code> is an ordinary class with fields of type <code>string</code> and <code>number</code>.</p>
        <p class="noindent">A <em>generic type</em> is a type with one or more type parameters, such as</p>
        <p class="codelink"><a id="rch13pr108" href="ch13_images.xhtml#ch13pr108">Click here to view code image</a></p>
        <pre class="pre">type Pair&lt;T&gt; = { first: T, second: T }</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">You can specify a default for a type parameter, such as</p>
        <p class="codelink"><a id="rch13pr109" href="ch13_images.xhtml#ch13pr109">Click here to view code image</a></p>
        <pre class="pre">type Pair&lt;T = any&gt; = { first: T, second: T }</pre>
        <p class="noindent">Then the type <code>Pair</code> is the same as <code>Pair&lt;any&gt;</code>.</p>
        </div>
        <p class="noindent">TypeScript provides generic forms of the <code>Set</code>, <code>Map</code>, and <code>WeakMap</code> classes that you saw in <a href="ch07.xhtml#ch07">Chapter 7</a>. You simply provide the types of the elements:</p>
        <p class="codelink"><a id="rch13pr110" href="ch13_images.xhtml#ch13pr110">Click here to view code image</a></p>
        <pre class="pre">const salaries = new Map&lt;Person, number&gt;()</pre>
        <p class="noindent">Types can also be inferred from the constructor arguments. For example, this map is typed as a <code>Map&lt;string, number&gt;</code>:</p>
        <p class="codelink"><a id="rch13pr111" href="ch13_images.xhtml#ch13pr111">Click here to view code image</a></p>
        <pre class="pre">const weekdays = new Map(
          [['Mon', 0], ['Tue', 1], ['Wed', 2], ['Thu', 3], ['Fri', 4], ['Sat', 5], ['Sun', 6]])</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">The generic <code>Array&lt;T&gt;</code> class is exactly the same as the type <code>T[]</code>.</p>
        </div>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec12">13.13.2 Generic Functions</h4>
        <p class="noindent">Just like a generic class is a class with type parameters, a <em>generic function</em> is a function with type parameters. Here is an example of a function with one <span epub:type="pagebreak" id="page_299"></span>type parameter. The function counts how many times a target value is present in an array.</p>
        <p class="codelink"><a id="rch13pr112" href="ch13_images.xhtml#ch13pr112">Click here to view code image</a></p>
        <pre class="pre">function count<strong>&lt;T&gt;</strong>(arr: T[], target: T) {
          let count = 0
          for (let e of arr) if (e === target) count++
          return count
        }</pre>
        <p class="noindent">Using a type parameter ensures that the array type is the same as the target type.</p>
        <p class="codelink"><a id="rch13pr113" href="ch13_images.xhtml#ch13pr113">Click here to view code image</a></p>
        <pre class="pre">let digits = [3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]
        let result = count(digits, 5) // <span class="cite">OK</span>
        result = count(digits, 'Fred') // <span class="cite">Type error</span></pre>
        <p class="noindent">The type parameters of a generic function are always placed before the opening parenthesis that starts the list of function parameters. A generic arrow function looks like this:</p>
        <p class="codelink"><a id="rch13pr114" href="ch13_images.xhtml#ch13pr114">Click here to view code image</a></p>
        <pre class="pre">const count = <strong>&lt;T&gt;</strong>(arr: T[], target: T) =&gt; {
          let count = 0
          for (let e of arr) if (e === target) count++
          return count
        }</pre>
        <p class="noindent">The type of this function is</p>
        <p class="codelink"><a id="rch13pr115" href="ch13_images.xhtml#ch13pr115">Click here to view code image</a></p>
        <pre class="pre">&lt;T&gt; (arg1: T[], arg2: T) =&gt; number</pre>
        <p class="noindent">When calling a generic function, you do not need to specify the type parameters. They are inferred from the argument types. For example, in the call <code>count(digits, 5)</code>, the type of <code>digits</code> is <code>number[]</code>, and TypeScript can infer that <code>T</code> should be <code>number</code>.</p>
        <p class="noindent">You can, if you like, supply the type explicitly, before the arguments, like this:</p>
        <pre class="pre">count&lt;number&gt;(digits, 4)</pre>
        <p class="noindent">You occasionally need to do this if TypeScript doesn’t infer the types that you intended. You will see an example in the following section.</p>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec13">13.13.3 Type Bounds</h4>
        <p class="noindent">Sometimes, the type parameters of a generic class or function need to fulfill certain requirements. You express these requirements with a <em>type bound</em>.</p>
        <p class="noindent">Consider this function that yields the tail—all but the first element—of its argument:</p>
        <p class="codelink"><a id="rch13pr116" href="ch13_images.xhtml#ch13pr116">Click here to view code image</a></p>
        <pre class="pre">const tail = &lt;T&gt;(values: T) =&gt; values.slice(1) // <span class="cite">Error</span></pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_300"></span>This approach cannot work since TypeScript doesn’t know whether <code>values</code> has a <code>slice</code> method. Let’s use a type bound:</p>
        <p class="codelink"><a id="rch13pr117" href="ch13_images.xhtml#ch13pr117">Click here to view code image</a></p>
        <pre class="pre">const tail = &lt;T <strong>extends { slice(from: number, to?: number): T }</strong>&gt;(values: T) =&gt;
          values.slice(1) // <span class="cite">OK</span></pre>
        <p class="noindent">The type bound ensures that the call <code>values.slice(1)</code> is valid. Note that the <code>extends</code> keyword in a type bound actually means “subtype”—the TypeScript designers just used the existing <code>extends</code> keyword instead of coming up with another keyword or symbol.</p>
        <p class="noindent">Now we can call</p>
        <p class="codelink"><a id="rch13pr118" href="ch13_images.xhtml#ch13pr118">Click here to view code image</a></p>
        <pre class="pre">let result = tail([1, 7, 2, 9]) // <span class="cite">Sets result to [7, 2, 9]</span></pre>
        <p class="noindent">or</p>
        <p class="codelink"><a id="rch13pr119" href="ch13_images.xhtml#ch13pr119">Click here to view code image</a></p>
        <pre class="pre">let greeting = 'Hello'
        console.log(tail(greeting)) // <span class="cite">Displays</span> <code>ello</code></pre>
        <p class="noindent">Of course, we can give a name to the type that is used as a bound:</p>
        <p class="codelink"><a id="rch13pr120" href="ch13_images.xhtml#ch13pr120">Click here to view code image</a></p>
        <pre class="pre">type Sliceable&lt;T&gt; = { slice(from: number, to?: number): T }
        const tail = &lt;T <strong>extends Sliceable&lt;T&gt;</strong>&gt;(values: T) =&gt; values.slice(1)</pre>
        <p class="noindent">For example, the type <code>number[]</code> is a subtype of <code>Sliceable&lt;number[]&gt;</code> since the <code>slice</code> method returns a <code>number[]</code> instance. Similarly, <code>string</code> is a subtype of <code>Sliceable&lt;string&gt;</code>.</p>
        <div class="caution">
        <p class="caution-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">If you try out the call</p>
        <p class="codelink"><a id="rch13pr121" href="ch13_images.xhtml#ch13pr121">Click here to view code image</a></p>
        <pre class="pre">console.log(tail('Hello')) // <span class="cite">Error</span></pre>
        <p class="noindent">compilation fails with an error—the type <code>'Hello'</code> is not a subtype of <code>Sliceable&lt;'Hello'&gt;</code>. The problem is that <code>'Hello'</code> is both an instance of the literal type <code>'Hello'</code> and the type <code>string</code>. TypeScript chooses the literal type as the most specific one, and typechecking fails. To overcome this problem, explicitly instantiate the template function:</p>
        <p class="codelink"><a id="rch13pr122" href="ch13_images.xhtml#ch13pr122">Click here to view code image</a></p>
        <pre class="pre">console.log(tail<strong>&lt;string&gt;</strong>('Hello')) // <span class="cite">OK</span></pre>
        <p class="noindent">or use a type assertion:</p>
        <p class="codelink"><a id="rch13pr123" href="ch13_images.xhtml#ch13pr123">Click here to view code image</a></p>
        <pre class="pre">console.log(tail('Hello' as string))</pre>
        </div>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec14">13.13.4 Erasure</h4>
        <p class="noindent">When TypeScript code is translated to plain JavaScript, all types are erased. As a consequence, the call</p>
        <pre class="pre">let newlyCreated = new T()</pre>
        <p class="noindent">is illegal. At runtime, there is no <code>T</code>.</p>
        <p class="noindent"><span epub:type="pagebreak" id="page_301"></span>To construct objects of arbitrary types, you need to use the constructor function. Here is an example:</p>
        <p class="codelink"><a id="rch13pr124" href="ch13_images.xhtml#ch13pr124">Click here to view code image</a></p>
        <pre class="pre">const fill = &lt;T&gt;(ctor: { new() : T }, n: number) =&gt; {
          let result: T[] = []
          for (let i = 0; i &lt; n; i++)
            result.push(new ctor())
          return result
        }</pre>
        <p class="noindent">Note the type of <code>ctor</code>—a function that can be called with <code>new</code> and yields a value of type <code>T</code>. That is a constructor. This particular constructor has no arguments.</p>
        <p class="noindent">When calling the <code>fill</code> function, you provide the name of a class:</p>
        <p class="codelink"><a id="rch13pr125" href="ch13_images.xhtml#ch13pr125">Click here to view code image</a></p>
        <pre class="pre">const dates = fill(Date, 10)</pre>
        <p class="noindent">The expression <code>Date</code> is the constructor function. In JavaScript, a class is just “syntactic sugar” for a constructor function with a prototype.</p>
        <p class="noindent">Similarly, you cannot make a generic <code>instanceof</code> check. The following will not work:</p>
        <p class="codelink"><a id="rch13pr126" href="ch13_images.xhtml#ch13pr126">Click here to view code image</a></p>
        <pre class="pre">const filter = &lt;T&gt;(values: unknown[]) =&gt; {
          let result: T[] = []
          for (const v of values)
            if (v instanceof T) // <span class="cite">Error</span>
              result.push(v)
          return result
        }</pre>
        <p class="noindent">The remedy is, again, to pass the constructor:</p>
        <p class="codelink"><a id="rch13pr127" href="ch13_images.xhtml#ch13pr127">Click here to view code image</a></p>
        <pre class="pre">const filter = &lt;T&gt;(values: unknown[], ctor: new (...args: any[]) =&gt; T) =&gt; {
          let result: T[] = []
          for (const v of values)
            if (v instanceof ctor) // <span class="cite">OK—right-hand side of</span> <code>instanceof</code> <span class="cite">is a constructor</span>
              result.push(v)
          return result
        }</pre>
        <p class="noindent">Here is a sample call:</p>
        <p class="codelink"><a id="rch13pr128" href="ch13_images.xhtml#ch13pr128">Click here to view code image</a></p>
        <pre class="pre">const pointsOnly = filter([3, 4, new Point(3, 4), Point.origin], Point)</pre>
        <p class="noindent">Note that in this case, the constructor accepts arbitrary arguments.</p>
        <div class="caution">
        <p class="caution-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">The <code>instanceof</code> test only works with a <em>class</em>. There is no way of testing at runtime whether a value is an instance of a type or interface.</p>
        </div>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec15"><span epub:type="pagebreak" id="page_302"></span>13.13.5 Generic Type Variance</h4>
        <p class="noindent">Consider a generic type such as</p>
        <p class="codelink"><a id="rch13pr129" href="ch13_images.xhtml#ch13pr129">Click here to view code image</a></p>
        <pre class="pre">type Pair&lt;T&gt; = { first: T, second: T }</pre>
        <p class="noindent">Now suppose you have a type <code>Person</code> and a subtype <code>Employee</code>. What is the appropriate relationship between <code>Pair&lt;Person&gt;</code> and <code>Pair&lt;Employee&gt;</code>?</p>
        <p class="noindent">Type theory provides three possibilities for a type variable. It can be covariant (that is, the generic type varies in the same direction), contravariant (with subtype relationships flipped), and invariant (with no subtype relationships between the generic types).</p>
        <p class="noindent">In Java, type variables are always invariant, but you can express relationships with wildcards such as <code>Pair&lt;? extends Person&gt;</code>. In C#, you can choose the variance of type parameters: <code>Entry&lt;out K, in V&gt;</code>. TypeScript does not have any comparable mechanism.</p>
        <p class="noindent">Instead, when deciding whether a generic type instance is a subtype of another, TypeScript simply substitutes the actual types and then compares the resulting nongeneric types.</p>
        <p class="noindent">For example, when comparing <code>Pair&lt;Person&gt;</code> and <code>Pair&lt;Employee&gt;</code>, substituting the types <code>Person</code> and <code>Employee</code> yields</p>
        <pre class="pre">{ first: Person, second: Person }</pre>
        <p class="noindent">and the subtype</p>
        <pre class="pre">{ first: Employee, second: Employee }</pre>
        <p class="noindent">As a result, the <code>Pair&lt;T&gt;</code> type is covariant in <code>T</code>. This is unsound (see <a href="#ch13ex15">Exercise 15</a>). However, as discussed in <a href="ch13.xhtml#ch13lev2sec3">Section 13.7.3</a>, “<a href="ch13.xhtml#ch13lev2sec3">Array and Object Type Variance</a>” (<a href="ch13.xhtml#page_282">page 282</a>), this unsoundness is a conscious design decision.</p>
        <p class="noindent">Let us look at another example that illustrates contravariance:</p>
        <p class="codelink"><a id="rch13pr130" href="ch13_images.xhtml#ch13pr130">Click here to view code image</a></p>
        <pre class="pre">type Formatter&lt;T&gt; = (arg1: T) =&gt; string</pre>
        <p class="noindent">To compare <code>Formatter&lt;Person&gt;</code> and <code>Formatter&lt;Employee&gt;</code>, plug in the types, then compare</p>
        <pre class="pre">(arg1: Person) =&gt; string</pre>
        <p class="noindent">and</p>
        <pre class="pre">(arg1: Employee) =&gt; string</pre>
        <p class="noindent">Since function parameter types are contravariant, so is the type variable <code>T</code> of <code>Formatter&lt;T&gt;</code>. This behavior is sound.</p>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec16"><span epub:type="pagebreak" id="page_303"></span>13.13.6 Conditional Types</h4>
        <p class="noindent">A conditional type has the form <em>T</em> <code>extends</code> <em>U</em> <code>?</code> <em>V</em> <code>:</code> <em>W</em>, where <em>T</em>, <em>U</em>, <em>V</em>, and <em>W</em> are types or type variables. Here is an example:</p>
        <p class="codelink"><a id="rch13pr131" href="ch13_images.xhtml#ch13pr131">Click here to view code image</a></p>
        <pre class="pre">type ExtractArray&lt;T&gt; = T extends any[] ? T : never</pre>
        <p class="noindent">If <code>T</code> is an array, then <code>ExtractArray&lt;T&gt;</code> is <code>T</code> itself. Otherwise, it is <code>never</code>, the type that has no instances.</p>
        <p class="noindent">By itself, this type isn’t very useful. But it can be used to filter out types from unions:</p>
        <p class="codelink"><a id="rch13pr132" href="ch13_images.xhtml#ch13pr132">Click here to view code image</a></p>
        <pre class="pre">type Data =  string | string[] | number | number[]
        type ArrayData = ExtractArray&lt;Data&gt; // <span class="cite">The type</span> <code>string[] | number[]</code></pre>
        <p class="noindent">For the <code>string</code> and <code>number</code> alternatives, <code>ExtractArray</code> yields <code>never</code>, which is simply dropped.</p>
        <p class="noindent">Now suppose you want to have just the element type. The following doesn’t quite work:</p>
        <p class="codelink"><a id="rch13pr133" href="ch13_images.xhtml#ch13pr133">Click here to view code image</a></p>
        <pre class="pre">type ArrayOf&lt;T&gt; = T extends U[] ? U : never // <span class="cite">Error—</span><code>U</code> <span class="cite">not defined</span></pre>
        <p class="noindent">Instead, use the <code>infer</code> keyword:</p>
        <p class="codelink"><a id="rch13pr134" href="ch13_images.xhtml#ch13pr134">Click here to view code image</a></p>
        <pre class="pre">type ArrayOf&lt;T&gt; = T extends (<strong>infer</strong> U)[] ? U : never</pre>
        <p class="noindent">Here, we check whether <code>T</code> extends <code>X[]</code> for some <code>X</code>, and if so, bind <code>U</code> to <code>X</code>. When applied to a union type, the non-arrays are dropped and the arrays replaced by their element type. For example, <code>ArrayOf&lt;Data&gt;</code> is <code>number | string</code>.</p>
        </section>
        <section>
        <h4 class="h4" id="ch13lev2sec17">13.13.7 Mapped Types</h4>
        <p class="noindent">Another way to specify indexes is with <em>mapped types</em>. Given a union type of string, integer, or symbol literals, you can define indexes like this:</p>
        <p class="codelink"><a id="rch13pr135" href="ch13_images.xhtml#ch13pr135">Click here to view code image</a></p>
        <pre class="pre">type Point = {
          [propname in 'x'|'y']: number
        }</pre>
        <p class="noindent">This <code>Point</code> type has two properties <code>x</code> and <code>y</code>, both of type <code>number</code>.</p>
        <div class="caution">
        <p class="caution-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">This notation is similar to the syntax for indexed properties (see <a href="ch13.xhtml#ch13lev1sec11">Section 13.11</a>, “<a href="ch13.xhtml#ch13lev1sec11">Indexed Properties</a>,” <a href="ch13.xhtml#page_290">page 290</a>). However, a mapped type has only one mapping, and it cannot have additional properties.</p>
        </div>
        <p class="noindent">This example is not very useful. Mapped types are intended for transforming existing types. Given an <code>Employee</code> type, you can make all properties readonly:<span epub:type="pagebreak" id="page_304"></span></p>
        <p class="codelink"><a id="rch13pr136" href="ch13_images.xhtml#ch13pr136">Click here to view code image</a></p>
        <pre class="pre">type ReadonlyEmployee = {
          readonly [propname in keyof Employee]: <strong>Employee[propname]</strong>
        }</pre>
        <p class="noindent">There are two pieces of new syntax here:</p>
        <ul class="bullet">
        <li><p class="list-item">The type <code>keyof</code> <em>T</em> is the union type of all property names in <em>T</em>. That is <code>'name' | 'salary' | . . .</code> in this example.</p></li>
        <li><p class="list-item">The type <em>T</em>[<em>p</em>] is the type of the property with name <em>p</em>. For example, <code>Employee['name']</code> is the type <code>string</code>.</p></li>
        </ul>
        <p class="noindent">Mapped types really shine with generics. The TypeScript library defines the following utility type:</p>
        <p class="codelink"><a id="rch13pr137" href="ch13_images.xhtml#ch13pr137">Click here to view code image</a></p>
        <pre class="pre">type Readonly&lt;T&gt; = {
          readonly [propname in keyof T]: T[propname]
        }</pre>
        <p class="noindent">This type marks all properties of <code>T</code> as <code>readonly</code>.</p>
        <div class="tip">
        <p class="tip-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/tip.jpg" alt="Images" width="36" height="33"></span> Tip</p>
        <p class="noindent">By using <code>Readonly</code> with a parameter type, you can assure callers that the parameter is not mutated.</p>
        <p class="codelink"><a id="rch13pr138" href="ch13_images.xhtml#ch13pr138">Click here to view code image</a></p>
        <pre class="pre">const distanceFromOrigin = (p<strong>: Readonly&lt;Point&gt;</strong>) =&gt;
          Math.sqrt(Math.pow(p.x, 2) + Math.pow(p.y, 2))</pre>
        </div>
        <p class="noindent">Another example is the <code>Pick</code> utility type that lets you pick a subset of properties, like this:</p>
        <p class="codelink"><a id="rch13pr139" href="ch13_images.xhtml#ch13pr139">Click here to view code image</a></p>
        <pre class="pre">let str: Pick&lt;string, 'length' | 'substring'&gt; = 'Fred'
          // <span class="cite">Can only apply</span> <code>length</code> <span class="cite">and</span> <code>substring</code> <span class="cite">to</span> <code>str</code></pre>
        <p class="noindent">The type is defined as follows:</p>
        <p class="codelink"><a id="rch13pr140" href="ch13_images.xhtml#ch13pr140">Click here to view code image</a></p>
        <pre class="pre">type Pick&lt;T, K extends keyof T&gt; = {
          [propname in K]: T[propname]
        };</pre>
        <p class="noindent">Note that <code>extends</code> means “subtype.” The type <code>keyof string</code> is the union of all string property names. A subtype is a subset of those names.</p>
        <p class="noindent">You can also remove a modifier:</p>
        <p class="codelink"><a id="rch13pr141" href="ch13_images.xhtml#ch13pr141">Click here to view code image</a></p>
        <pre class="pre">type Writable&lt;T&gt; = {
          <strong>-readonly</strong> [propname in keyof T]: T[propname]
        }</pre>
        <p class="noindent">To add or remove the <code>?</code> modifier, use <code>?</code> or <code>-?</code>:</p>
        <p class="codelink"><a id="rch13pr142" href="ch13_images.xhtml#ch13pr142">Click here to view code image</a></p>
        <pre class="pre">type AllRequired&lt;T&gt; = {
          [propname in keyof T]<strong>-?</strong>: T[propname]
        }</pre>
        </section>
        </section>
        <section>
        <h3 class="h3" id="ch13lev1sec14"><span epub:type="pagebreak" id="page_305"></span>Exercises</h3>
        <ol class="ol-exe">
        <li><p class="list" id="ch13ex01">What do the following types describe?</p>
        <p class="codelink"><a id="rch13pr143" href="ch13_images.xhtml#ch13pr143">Click here to view code image</a></p>
        <pre class="pre">(number | string)[]
        number[] | string[]
        [[number, string]]
        [number, string, ...:number[]]
        [number, string, ...:(number | string)[]]
        [number, ...: string[]] | [string, ...: number[]]</pre></li>
        <li><p class="list" id="ch13ex02">Investigate the difference between functions with return type <code>void</code> and return type <code>undefined</code>. Can a function returning <code>void</code> have any <code>return</code> statements? How about returning <code>undefined</code> or <code>null</code>? Must a function with return type <code>undefined</code> have a <code>return</code> statement, or can it implicitly return <code>undefined</code>?</p></li>
        <li><p class="list" id="ch13ex03">List all types of the functions of the <code>Math</code> class.</p></li>
        <li><p class="list" id="ch13ex04">What is the difference between the types <code>object</code>, <code>Object</code>, and <code>{}</code>?</p></li>
        <li><p class="list" id="ch13ex05">Describe the difference between the types</p>
        <p class="codelink"><a id="rch13pr144" href="ch13_images.xhtml#ch13pr144">Click here to view code image</a></p>
        <pre class="pre">type MaybeColoredPoint = {
          x: number,
          y: number,
          color?: string
        }</pre>
        <p class="noindent">and</p>
        <p class="codelink"><a id="rch13pr145" href="ch13_images.xhtml#ch13pr145">Click here to view code image</a></p>
        <pre class="pre">type PerhapsColoredPoint = {
          x: number,
          y: number,
          color: string | undefined
        }</pre></li>
        <li><p class="list" id="ch13ex06">Given the type</p>
        <p class="codelink"><a id="rch13pr146" href="ch13_images.xhtml#ch13pr146">Click here to view code image</a></p>
        <pre class="pre">type Weekday = 'Mon' | 'Tue' | 'Wed' | 'Thu' | 'Fri' | 'Sat' | 'Sun'</pre>
        <p class="noindent">is <code>Weekday</code> a subtype of <code>string</code> or the other way around?</p></li>
        <li><p class="list" id="ch13ex07">What is the subtype relationship between <code>number[]</code> and <code>unknown[]</code>? Between <code>{ x: number, y: number }</code> and <code>{ x: number | undefined, y: number | undefined }</code>? Between <code>{ x: number, y: number }</code> and <code>{ x: number, y: number, z: number }</code>?</p></li>
        <li><p class="list" id="ch13ex08">What is the subtype relationship between <code>(arg: number) =&gt; void</code> and <code>(arg: number | undefined) =&gt; void</code>? Between <code>() =&gt; unknown</code> and <code>() =&gt; number</code>? Between <code>() =&gt; number</code> and <code>(number) =&gt; void</code>?</p></li>
        <li><p class="list" id="ch13ex09">What is the subtype relationship between <code>(arg1: number) =&gt; number</code> and <code>(arg1: number, arg2?: number) =&gt; number</code>?<span epub:type="pagebreak" id="page_306"></span></p></li>
        <li><p class="list" id="ch13ex10">Implement the function</p>
        <p class="codelink"><a id="rch13pr147" href="ch13_images.xhtml#ch13pr147">Click here to view code image</a></p>
        <pre class="pre">const act = (x: { bark(): void } | { meow(): void }) =&gt; . . .</pre>
        <p class="noindent">that invokes either <code>bark</code> or <code>meow</code> on <code>x</code>. Use the <code>in</code> operator to distinguish between the alternatives.</p></li>
        <li><p class="list" id="ch13ex11">Show that object covariance is unsound. Use the types</p>
        <p class="codelink"><a id="rch13pr148" href="ch13_images.xhtml#ch13pr148">Click here to view code image</a></p>
        <pre class="pre">type Colored = { color: string }
        type MaybeColored = { color: string | undefined }</pre>
        <p class="noindent">As with arrays in <a href="ch13.xhtml#ch13lev2sec3">Section 13.7.3</a>, “<a href="ch13.xhtml#ch13lev2sec3">Array and Object Type Variance</a>” (<a href="ch13.xhtml#page_282">page 282</a>), define two variables, one of each type, both referring to the same value. Create a situation that shows a hole in the type checker by modifying the <code>color</code> property of one of the variables and reading the property with the other variable.</p></li>
        <li><p class="list" id="ch13ex12">In <a href="ch13.xhtml#ch13lev1sec11">Section 13.11</a>, “<a href="ch13.xhtml#ch13lev1sec11">Indexed Properties</a>” (<a href="ch13.xhtml#page_290">page 290</a>), you saw that it is impossible to declare</p>
        <p class="codelink"><a id="rch13pr149" href="ch13_images.xhtml#ch13pr149">Click here to view code image</a></p>
        <pre class="pre">type Dictionary = {
          created: Date, // <span class="cite">Error—not a</span> <code>string</code> <span class="cite">or</span> <code>string[]</code>
          [arg: string]: string | string[]
        }</pre>
        <p class="noindent">Can you overcome this problem with an intersection type?</p></li>
        <li><p class="list" id="ch13ex13">Consider this type from <a href="ch13.xhtml#ch13lev1sec11">Section 13.11</a>, “<a href="ch13.xhtml#ch13lev1sec11">Indexed Properties</a>” (<a href="ch13.xhtml#page_290">page 290</a>):</p>
        <p class="codelink"><a id="rch13pr150" href="ch13_images.xhtml#ch13pr150">Click here to view code image</a></p>
        <pre class="pre">type ShoppingList = {
          created: Date,
          [arg: number] : string
        }</pre>
        <p class="noindent">Why does the following code fail?</p>
        <p class="codelink"><a id="rch13pr151" href="ch13_images.xhtml#ch13pr151">Click here to view code image</a></p>
        <pre class="pre">const list: ShoppingList = {
          created: new Date()
        }
        list[0] = 'eggs'
        const more = ['ham', 'hash browns']
        for (let i in arr)
          list[i + 1] = arr[i]</pre>
        <p class="noindent">Why does this code not fail?</p>
        <pre class="pre">for (let i in arr)
          list[i] = arr[i]</pre></li>
        <li><p class="list" id="ch13ex14">Give an example of supertype/subtype pairs for each of the rows of <a href="ch13.xhtml#ch13tab01">Table 13-1</a> that is different from those given in the table. For each pair, demonstrate that a supertype variable can hold a subtype instance.<span epub:type="pagebreak" id="page_307"></span></p></li>
        <li><p class="list" id="ch13ex15">The generic <code>Pair&lt;T&gt;</code> class from <a href="ch13.xhtml#ch13lev2sec15">Section 13.13.5</a>, “<a href="ch13.xhtml#ch13lev2sec15">Generic Type Variance</a>” (<a href="ch13.xhtml#page_302">page 302</a>), is covariant in <code>T</code>. Show that this is unsound. As with arrays in <a href="ch13.xhtml#ch13lev2sec3">Section 13.7.3</a>, “<a href="ch13.xhtml#ch13lev2sec3">Array and Object Type Variance</a>” (<a href="ch13.xhtml#page_282">page 282</a>), define two variables, one of type <code>Pair&lt;Person&gt;</code> and of type <code>Pair&lt;Employee&gt;</code>, both referring to the same value. Mutate the value through one of the variables so that you can produce a runtime error by reading from the other variable.</p></li>
        <li><p class="list" id="ch13ex16">Complete the generic function</p>
        <p class="codelink"><a id="rch13pr152" href="ch13_images.xhtml#ch13pr152">Click here to view code image</a></p>
        <pre class="pre">const last = &lt;. . .&gt; (values: T)  =&gt; values[values.length - 1]</pre>
        <p class="noindent">so that you can call:</p>
        <p class="codelink"><a id="rch13pr153" href="ch13_images.xhtml#ch13pr153">Click here to view code image</a></p>
        <pre class="pre">const str = 'Hello'
        console.log(last(str))
        console.log(last([1, 2, 3]))
        console.log(last(new Int32Array(1024)))</pre>
        <p class="noindent">Hint: Require that <code>T</code> has a <code>length</code> property and an indexed property. What is the return type of the indexed property?<span epub:type="pagebreak" id="page_308"></span></p></li>
        </ol>
        </section>
        </section>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780136502166/files/9780136502142.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com