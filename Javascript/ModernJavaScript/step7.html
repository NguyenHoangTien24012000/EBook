<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section epub:type="chapter">
        <h2 class="ch2" id="ch07"><span epub:type="pagebreak" id="page_140"></span>Chapter 7. Arrays and Collections</h2>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/queen.jpg" alt="Images" width="85" height="85">
        </figure>
        <div class="outline">
        <p class="outh">Topics in This Chapter</p>
        <p class="chap-lev1"><a href="#ch07lev1sec1">7.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructing Arrays</a></p>
        <p class="chap-lev1"><a href="#ch07lev1sec2">7.2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The <code>length</code> Property and Index Properties</a></p>
        <p class="chap-lev1"><a href="#ch07lev1sec3">7.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Deleting and Adding Elements</a></p>
        <p class="chap-lev1"><a href="#ch07lev1sec4">7.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Other Array Mutators</a></p>
        <p class="chap-lev1"><a href="#ch07lev1sec5">7.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Producing Elements</a></p>
        <p class="chap-lev1"><a href="#ch07lev1sec6">7.6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Finding Elements</a></p>
        <p class="chap-lev1"><a href="#ch07lev1sec7">7.7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Visiting All Elements</a></p>
        <p class="chap-lev1i"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/catc.jpg" alt="Images" width="23" height="23"></span>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ch07lev1sec8">7.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sparse Arrays</a></p>
        <p class="chap-lev1i"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/catc.jpg" alt="Images" width="23" height="23"></span>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ch07lev1sec9">7.9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reduction</a></p>
        <p class="chap-lev1a"><a href="#ch07lev1sec10">7.10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Maps</a></p>
        <p class="chap-lev1a"><a href="#ch07lev1sec11">7.11&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets</a></p>
        <p class="chap-lev1i"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/catc.jpg" alt="Images" width="23" height="23"></span>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ch07lev1sec12">7.12&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Weak Maps and Sets</a></p>
        <p class="chap-lev1i"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/catc.jpg" alt="Images" width="23" height="23"></span>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ch07lev1sec13">7.13&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Typed Arrays</a></p>
        <p class="chap-lev1i"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/catc.jpg" alt="Images" width="23" height="23"></span>&nbsp;&nbsp;&nbsp;&nbsp;<a href="#ch07lev1sec14">7.14&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Array Buffers</a></p>
        <p class="chap-lev1a"><a href="#ch07lev1sec15">Exercises</a></p>
        </div>
        <p class="noindent"><span epub:type="pagebreak" id="page_141"></span>Whenever you learn a new programming language, you want to know how to store your data. The traditional data structure of choice for sequential data is the humble array. In this chapter, you will learn the various array methods that the JavaScript API provides. We then turn to typed arrays and array buffers—advanced constructs for efficient handling of binary data blocks. Unlike Java or C++, JavaScript does not provide a rich set of data structures, but there are simple map and set classes that we discuss at the end of the chapter.</p>
        <section>
        <h3 class="h3" id="ch07lev1sec1">7.1 Constructing Arrays</h3>
        <p class="noindent">You already know how to construct an array with a given sequence of elements—simply write a literal:</p>
        <p class="codelink"><a id="rch07pr01" href="ch07_images.xhtml#ch07pr01">Click here to view code image</a></p>
        <pre class="pre">const names = ['Peter', 'Paul', 'Mary']</pre>
        <p class="noindent">Here is how to construct an empty array with ten thousand elements, all initially <code>undefined</code>:</p>
        <pre class="pre">const bigEmptyArray = []
        bigEmptyArray.length = 10000</pre>
        <p class="noindent">In an array literal, you can place spreads of any <em>iterable</em>. Arrays and strings, the sets and maps that you will see later in this chapter, as well as <code>NodeList</code> and <code>HTMLCollection</code> from the DOM API, are iterable. For example, here is how to form an array containing the elements of two iterables <code>a</code> and <code>b</code>:<span epub:type="pagebreak" id="page_142"></span></p>
        <pre class="pre">const elements = [...a, ...b]</pre>
        <p class="noindent">As you will see in <a href="ch09.xhtml#ch09">Chapter 9</a>, an iterable object has a somewhat complex structure. The <code>Array.from</code> method collects elements from a simpler <em>array-like</em> object. An array-like object is an object with an integer-valued property with name <code>'length'</code> and properties with names <code>'0'</code>, <code>'1'</code>, <code>'2'</code>, and so on. Of course, arrays are array-like, but some methods of the DOM API yield array-like objects that aren’t arrays or iterables. Then you can call <code>Array.from(arrayLike)</code> to place the elements into an array.</p>
        <p class="codelink"><a id="rch07pr02" href="ch07_images.xhtml#ch07pr02">Click here to view code image</a></p>
        <pre class="pre">const arrayLike = { length: 3 , '0': 'Peter', '1': 'Paul', '2': 'Mary'}
        const elements = Array.from(arrayLike)
          // <span class="cite"><code>elements</code> is the array <code>['Peter', 'Paul', 'Mary']</code></span>
          // <span class="cite"><code>Array.isArray(arrayLike)</code> is <code>false</code>, <code>Array.isArray(elements)</code> is <code>true</code></span></pre>
        <p class="noindent">The <code>Array.from</code> method accepts an optional second argument, a function that is called for all index values from 0 up to <code>length</code> − 1, passing the element (or <code>undefined</code> for missing elements) and the index. The results of the function are collected into an array. For example,</p>
        <p class="codelink"><a id="rch07pr03" href="ch07_images.xhtml#ch07pr03">Click here to view code image</a></p>
        <pre class="pre">const squares = Array.from({ length: 5 }, (element, index) =&gt; index * index)
          // [0, 1, 4, 9, 16]</pre>
        <div class="caution">
        <p class="caution-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">There is a constructor for constructing an array with given elements that you can invoke with or without <code>new</code>:</p>
        <p class="codelink"><a id="rch07pr04" href="ch07_images.xhtml#ch07pr04">Click here to view code image</a></p>
        <pre class="pre">names = new Array('Peter', 'Paul', 'Mary')
        names = Array('Peter', 'Paul', 'Mary')</pre>
        <p class="noindent">But it has a pitfall. Calling <code>new Array</code> or <code>Array</code> with a single numeric argument has an entirely different effect. The single argument denotes the length of the array:</p>
        <p class="codelink"><a id="rch07pr05" href="ch07_images.xhtml#ch07pr05">Click here to view code image</a></p>
        <pre class="pre">numbers = new Array(10000)</pre>
        <p class="noindent">The result is an array of length 10000 and no elements!</p>
        <p class="noindent">I suggest to stay away from the <code>Array</code> constructor and use array literals:</p>
        <p class="codelink"><a id="rch07pr06" href="ch07_images.xhtml#ch07pr06">Click here to view code image</a></p>
        <pre class="pre">names = ['Peter', 'Paul', 'Mary']
        numbers = [10000]</pre>
        </div>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">The factory function <code>Array.of</code> doesn’t suffer from the problem of the <code>Array</code> constructor:</p>
        <p class="codelink"><a id="rch07pr07" href="ch07_images.xhtml#ch07pr07">Click here to view code image</a></p>
        <pre class="pre">names = Array.of('Peter', 'Paul', 'Mary')
        littleArray = Array.of(10000) // <span class="cite">An array of length 1, same as</span> [10000]</pre>
        <p class="noindent">But it offers no advantage over array literals either. (<a href="#ch07ex02">Exercise 2</a> shows a subtle and uncommon use case for the <code>of</code> method.)</p>
        </div>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec2"><span epub:type="pagebreak" id="page_143"></span>7.2 The <code>length</code> Property and Index Properties</h3>
        <p class="noindent">Every array has a <code>'length'</code> property whose value is an integer between 0 and 2<sup>32</sup> − 1. The properties whose numeric values are non-negative integers are called <em>index properties</em>. For example, the array</p>
        <p class="codelink"><a id="rch07pr08" href="ch07_images.xhtml#ch07pr08">Click here to view code image</a></p>
        <pre class="pre">const names = ['Peter', 'Paul', 'Mary']</pre>
        <p class="noindent">is an object with a <code>'length'</code> property (whose value is <code>3</code>) and index properties <code>'0'</code>, <code>'1'</code>, <code>'2'</code>. Recall that property keys are always strings.</p>
        <p class="noindent">The length is always one more than the highest index:</p>
        <p class="codelink"><a id="rch07pr09" href="ch07_images.xhtml#ch07pr09">Click here to view code image</a></p>
        <pre class="pre">const someNames = [ , 'Smith', , 'Jones'] // <span class="cite"><code>someNumbers.length</code> is 4</span></pre>
        <p class="noindent">The length is adjusted when a value is assigned to an index property:</p>
        <p class="codelink"><a id="rch07pr10" href="ch07_images.xhtml#ch07pr10">Click here to view code image</a></p>
        <pre class="pre">someNames[5] = 'Miller' // <span class="cite">Now <code>someNames</code> has length 6</span></pre>
        <p class="noindent">You can adjust the length manually:</p>
        <p class="codelink"><a id="rch07pr11" href="ch07_images.xhtml#ch07pr11">Click here to view code image</a></p>
        <pre class="pre">someNames.length = 100</pre>
        <p class="noindent">If you decrease the length, any element whose index is at least the new length gets deleted.</p>
        <p class="codelink"><a id="rch07pr12" href="ch07_images.xhtml#ch07pr12">Click here to view code image</a></p>
        <pre class="pre">someNames.length = 4 // <span class="cite"><code>someNames[4]</code> and beyond are deleted</span></pre>
        <p class="noindent">There is no requirement that an array has an index property for every index between 0 and <code>length</code> − 1. The ECMAScript standard uses the term <em>missing elements</em> for gaps in the index sequence.</p>
        <p class="noindent">To find out whether an element is missing, you can use the <code>in</code> operator:</p>
        <p class="codelink"><a id="rch07pr13" href="ch07_images.xhtml#ch07pr13">Click here to view code image</a></p>
        <pre class="pre">'2' in someNames // <span class="cite"><code>false</code>—no property <code>'2'</code></span>
        3 in someNames // <span class="cite"><code>true</code>; there is a property <code>'3'</code></span>
          // <span class="cite">Note that the left operand is converted to a string</span></pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">An array can have properties that are not index properties. This is occasionally used to attach other information to an array. For example, the <code>exec</code> method of the <code>RegExp</code> class yields an array of matches, with additional properties <code>index</code> and <code>input</code>.</p>
        <p class="codelink"><a id="rch07pr14" href="ch07_images.xhtml#ch07pr14">Click here to view code image</a></p>
        <pre class="pre">/([1-9]|1[0-2]):([0-5][0-9])([ap]m)/.exec('12:15pm')
          // ['12:15pm', '12', '15', 'pm', <strong>index: 0</strong>, <strong>input: '12:15pm'</strong>]</pre>
        </div>
        <div class="caution">
        <p class="caution-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">A string containing a negative number, such as <code>'-1'</code>, is a valid property, but it is not an index property.</p>
        <p class="codelink"><a id="rch07pr15" href="ch07_images.xhtml#ch07pr15">Click here to view code image</a></p>
        <pre class="pre">const squares = [0, 1, 4, 9]
        squares[-1] = 1 // [ 0, 1, 4, 9, <strong>'-1': 1</strong> ]</pre>
        </div>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec3"><span epub:type="pagebreak" id="page_144"></span>7.3 Deleting and Adding Elements</h3>
        <p class="noindent">The calls</p>
        <p class="codelink"><a id="rch07pr16" href="ch07_images.xhtml#ch07pr16">Click here to view code image</a></p>
        <pre class="pre">let arr = [0, 1, 4, 9, 16, 25]
        const deletedElement = arr.pop() // <span class="cite"><code>arr</code> is now <code>[0, 1, 4, 9, 16]</code></span>
        const newLength = arr.push(x) // <span class="cite"><code>arr</code> is now <code>[0, 1, 4, 9, 16, x]</code></span></pre>
        <p class="noindent">delete or add an element at the end of an array, adjusting the length.</p>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">Instead of calling <code>pop</code> and <code>push</code>, you could write</p>
        <p class="codelink"><a id="rch07pr17" href="ch07_images.xhtml#ch07pr17">Click here to view code image</a></p>
        <pre class="pre">arr.length--
        arr[arr.length] = x</pre>
        <p class="noindent">I prefer <code>pop</code> and <code>push</code> since they indicate the intent better.</p>
        </div>
        <p class="noindent">To delete or add the initial element, call</p>
        <p class="codelink"><a id="rch07pr18" href="ch07_images.xhtml#ch07pr18">Click here to view code image</a></p>
        <pre class="pre">arr = [0, 1, 4, 9, 16, 25]
        const deletedElement = arr.shift() // <span class="cite"><code>arr</code> is now <code>[1, 4, 9, 16, 25]</code></span>
        const newLength = arr.unshift(x) // <span class="cite"><code>arr</code> is now <code>[<strong>x</strong>, 1, 4, 9, 16, 25]</code></span></pre>
        <p class="noindent">The <code>push</code> and <code>unshift</code> methods can add any number of elements at once:</p>
        <p class="codelink"><a id="rch07pr19" href="ch07_images.xhtml#ch07pr19">Click here to view code image</a></p>
        <pre class="pre">arr = [9]
        arr.push(16, 25) // <span class="cite"><code>16</code>, <code>25</code> are appended; <code>arr</code> is now <code>[9, 16, 25]</code></span>
        arr.unshift(0, 1, 4) // <span class="cite"><code>0</code>, <code>1</code>, <code>4</code> are prepended; <code>arr</code> is now <code>[0, 1, 4, 9, 16, 25]</code></span></pre>
        <p class="noindent">Use the <code>splice</code> method to delete or add elements in the middle:</p>
        <p class="codelink"><a id="rch07pr20" href="ch07_images.xhtml#ch07pr20">Click here to view code image</a></p>
        <pre class="pre">const deletedElements = arr.splice(start, deleteCount, x1, x2, . . .)</pre>
        <p class="noindent">First, <code>deleteCount</code> elements are removed, starting at offset <code>start</code>. Then the provided elements are inserted at <code>start</code>.</p>
        <p class="codelink"><a id="rch07pr21" href="ch07_images.xhtml#ch07pr21">Click here to view code image</a></p>
        <pre class="pre">arr = [0, 1, 12, 24, 36]
        const start = 2
        // <span class="cite">Replace <code>arr[start]</code> and <code>arr[start + 1]</code></span>
        arr.splice(start, 2, 16, 25) // <span class="cite"><code>arr</code> is now <code>[0, 1, <strong>16, 25</strong>, 36]</code></span>
        // <span class="cite">Add elements at index <code>start</code></span>
        arr.splice(start, 0, 4, 9) // <span class="cite"><code>arr</code> is now <code>[0, 1, 4, 9, 16, 25, 36]</code></span>
        // <span class="cite">Delete the elements at index <code>start</code> and <code>start + 1</code></span>
        arr.splice(start, 2) // <span class="cite"><code>arr</code> is now <code>[0, 1, 16, 25, 36]</code></span>
        // <span class="cite">Delete all elements at index <code>start</code> and beyond</span>
        arr.splice(start) // <span class="cite"><code>arr</code> is now <code>[0, 1]</code></span></pre>
        <p class="noindent">If <code>start</code> is negative, it is counted from the <em>end</em> of the array (that is, it is adjusted by adding <code>arr.length</code>).</p>
        <p class="codelink"><a id="rch07pr22" href="ch07_images.xhtml#ch07pr22">Click here to view code image</a></p>
        <pre class="pre">arr = [0, 1, 4, 16]
        arr.splice(-1, 1, 9) // <span class="cite"><code>arr</code> is now <code>[0, 1, 4, 9]</code></span></pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_145"></span>The <code>splice</code> method returns an array of the removed elements.</p>
        <p class="codelink"><a id="rch07pr23" href="ch07_images.xhtml#ch07pr23">Click here to view code image</a></p>
        <pre class="pre">arr = [1, 4, 9, 16]
        const spliced = arr.splice(1, 2) // <span class="cite"><code>spliced</code> is <code>[4, 9]</code>, <code>arr</code> is <code>[1, 16]</code></span></pre>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec4">7.4 Other Array Mutators</h3>
        <p class="noindent">In this section, you will see the mutator methods of the <code>Array</code> class other than those for deleting and adding elements.</p>
        <p class="noindent">The <code>fill</code> method overwrites existing elements with a new value:</p>
        <pre class="pre">arr.fill(value, start, end)</pre>
        <p class="noindent">The <code>copyWithin</code> method overwrites existing elements with other elements from the same array:</p>
        <p class="codelink"><a id="rch07pr24" href="ch07_images.xhtml#ch07pr24">Click here to view code image</a></p>
        <pre class="pre">arr.copyWithin(targetIndex, start, end)</pre>
        <p class="noindent">With both methods, <code>start</code> defaults to <code>0</code> and <code>end</code> to <code>arr.length</code>.</p>
        <p class="noindent">If <code>start</code>, <code>end</code>, or <code>targetIndex</code> are negative, they count from the end of the array.</p>
        <p class="noindent">Here are some examples:</p>
        <p class="codelink"><a id="rch07pr25" href="ch07_images.xhtml#ch07pr25">Click here to view code image</a></p>
        <pre class="pre">let arr = [0, 1, 4, 9, 16, 25]
        arr.copyWithin(0, 1) // <span class="cite"><code>arr</code> is now <code>[1, 4, 9, 16, 25, 25]</code></span>
        arr.copyWithin(1) // <span class="cite"><code>arr</code> is now <code>[1, 1, 4, 9, 16, 25]</code></span>
        arr.fill(7, 3, -1)  // <span class="cite"><code>arr</code> is now <code>[1, 1, 4, 7, 7, 25]</code></span></pre>
        <p class="noindent"><code>arr.reverse()</code> reverses <code>arr</code> in place:</p>
        <p class="codelink"><a id="rch07pr26" href="ch07_images.xhtml#ch07pr26">Click here to view code image</a></p>
        <pre class="pre">arr = [0, 1, 4, 9, 16, 25]
        arr.reverse() // <span class="cite"><code>arr</code> is now <code>[25, 16, 9, 4, 1, 0]</code></span></pre>
        <p class="noindent">The call</p>
        <pre class="pre">arr.sort(comparisonFunction)</pre>
        <p class="noindent">sorts <code>arr</code> in place. The comparison function compares two elements <code>x</code>, <code>y</code> and returns</p>
        <ul class="bullet">
        <li><p class="list-item">A negative number if <code>x</code> should come before <code>y</code></p></li>
        <li><p class="list-item">A positive number if <code>x</code> should come after <code>y</code></p></li>
        <li><p class="list-item"><code>0</code> if they are indistinguishable</p></li>
        </ul>
        <p class="noindent">For example, here is how you can sort an array of numbers:</p>
        <p class="codelink"><a id="rch07pr27" href="ch07_images.xhtml#ch07pr27">Click here to view code image</a></p>
        <pre class="pre">arr = [0, 1, 16, 25, 4, 9]
        arr.sort((x, y) =&gt; x - y) // <span class="cite"><code>arr</code> is now <code>[0, 1, 4, 9, 16, 25]</code></span></pre>
        <div class="caution">
        <p class="caution-caption"><span epub:type="pagebreak" id="page_146"></span><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/caution.jpg" alt="Images" width="36" height="36"></span> Caution</p>
        <p class="noindent">If the comparison function is not provided, the <code>sort</code> method turns elements to strings and compares them—see <a href="#ch07ex05">Exercise 5</a>. For numbers, this might be the world’s worst comparison function:</p>
        <p class="codelink"><a id="rch07pr28" href="ch07_images.xhtml#ch07pr28">Click here to view code image</a></p>
        <pre class="pre">arr = [0, 1, 4, 9, 16, 25]
        arr.sort() // <span class="cite"><code>arr</code> is now <code>[0, 1, 16, 25, 4, 9]</code></span></pre>
        </div>
        <p class="noindent">The most useful methods of the <code>Array</code> class are summarized in <a href="#ch07tbl01">Table 7-1</a>.</p>
        <figure class="table" id="ch07tbl01">
        <figcaption><p class="table-title"><strong>Table 7-1</strong>&nbsp;&nbsp;&nbsp;&nbsp;Useful Functions and Methods of the <code>Array</code> Class</p></figcaption>
        <table class="tabletb">
        <thead>
        <tr>
        <th><p class="tableth">Name</p></th>
        <th><p class="tableth">Description</p></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td colspan="2"><p class="tabletd"><strong>Functions</strong></p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>from(arraylike, f)</code></p></td>
        <td><p class="tabletd">Produces an array from any object with properties named <code>'length'</code>, <code>'0'</code>, <code>'1'</code>, and so on. If present, the function <code>f</code> is applied to each element.</p></td>
        </tr>
        <tr>
        <td colspan="2"><p class="tabletd"><strong>Mutating Methods</strong></p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>pop()</code>, <code>shift()</code></p></td>
        <td><p class="tabletd">Removes and returns the last element</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>push(value)</code>, <code>unshift(value)</code></p></td>
        <td><p class="tabletd">Appends or prepends <code>value</code> to this array and returns the new length</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>fill(value, start, end)</code></p></td>
        <td><p class="tabletd">Overwrites the given range with <code>value</code>. For this and the following methods, the following apply unless otherwise mentioned: If <code>start</code> or <code>end</code> are negative, they are counted from the end of the array. The range includes <code>start</code> and excludes <code>end</code>. The default for <code>start</code> and <code>end</code> are <code>0</code> and the array length. The method returns this array.</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>copyWithin(targetIndex, start, end)</code></p></td>
        <td><p class="tabletd">Copies the given range to the target index</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>reverse()</code></p></td>
        <td><p class="tabletd">Reverses the elements of this array</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>sort(comparisonFunction)</code></p></td>
        <td><p class="tabletd">Sorts this array</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>splice(start, deleteCount, values...)</code></p></td>
        <td><p class="tabletd">Removes and returns <code>deleteCount</code> elements at index <code>start</code>, then inserts the given values at <code>start</code><span epub:type="pagebreak" id="page_147"></span></p></td>
        </tr>
        <tr>
        <td colspan="2"><p class="tabletd"><strong>Nonmutating Methods</strong></p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>slice(start, end)</code></p></td>
        <td><p class="tabletd">Returns the elements in the given range</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>includes(target, start)</code>, <code>firstIndex(target, start)</code>, <code>lastIndex(target, start)</code></p></td>
        <td><p class="tabletd">If the array includes <code>target</code> at or after index <code>start</code>, these methods return <code>true</code> or the index; otherwise, <code>false</code> or <code>-1</code></p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>flat(k)</code></p></td>
        <td><p class="tabletd">Returns the elements of this array, replacing any arrays of dimension ≤<code>k</code> with their elements. The default for <code>k</code> is <code>1</code>.</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>map(f)</code>, <code>flatMap(f)</code>, <code>forEach(f)</code></p></td>
        <td><p class="tabletd">Calls the given function on each element and returns an array of the results, or the flattened results, or <code>undefined</code></p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>filter(f)</code></p></td>
        <td><p class="tabletd">Returns all elements for which <code>f</code> returns a truish result</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>findIndex(f)</code>, <code>find(f)</code></p></td>
        <td><p class="tabletd">Return the index or value of the first element for which <code>f</code> returns a truish value. The function <code>f</code> is called with three arguments: the element, index, and array.</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>every(f)</code>, <code>some(f)</code></p></td>
        <td><p class="tabletd">Return <code>true</code> if <code>f</code> returns a truish value for every, or at least one, element</p></td>
        </tr>
        <tr>
        <td><p class="tabletd"><code>join(separator)</code></p></td>
        <td><p class="tabletd">Returns a string consisting of all elements turned to strings and separated by the given separator (which defaults to <code>','</code>)</p></td>
        </tr>
        </tbody>
        </table>
        </figure>
        <p class="noindent">For sorting strings in a human language, the <code>localeCompare</code> method can be a good choice:</p>
        <p class="codelink"><a id="rch07pr29" href="ch07_images.xhtml#ch07pr29">Click here to view code image</a></p>
        <pre class="pre">const titles = . . .
        titles.sort((s, t) =&gt; s.localeCompare(t))</pre>
        <p class="noindent"><a href="ch08.xhtml#ch08">Chapter 8</a> has more information about locale-based comparisons.</p>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">Since 2019, the <code>sort</code> method is guaranteed to be <em>stable</em>. That is, the order of indistinguishable elements is not disturbed. For example, suppose you have a sequence of messages that was previously sorted by date. If you now sort it by the sender, then messages with the same sender will continue to be sorted by date.</p>
        </div>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec5"><span epub:type="pagebreak" id="page_148"></span>7.5 Producing Elements</h3>
        <p class="noindent">All methods that are introduced from this point on do not mutate the array on which they operate.</p>
        <p class="noindent">The following methods produce arrays containing elements from an existing array.</p>
        <p class="noindent">The call</p>
        <pre class="pre">arr.slice(start, end)</pre>
        <p class="noindent">yields an array containing the elements in the given range. The <code>start</code> index defaults to <code>0</code>, <code>end</code> to <code>arr.length</code>.</p>
        <p class="noindent"><code>arr.slice()</code> is the same as <code>[...arr]</code>.</p>
        <p class="noindent">The <code>flat</code> method flattens multidimensional arrays. The default is to flatten one level.</p>
        <pre class="pre">[[1, 2], [3, 4]].flat()</pre>
        <p class="noindent">is the array</p>
        <pre class="pre">[1, 2, 3, 4]</pre>
        <p class="noindent">In the unlikely case that you have an array of more than two dimensions, you can specify how many levels you want to flatten. Here is a flattening from three dimensions to one:</p>
        <p class="codelink"><a id="rch07pr30" href="ch07_images.xhtml#ch07pr30">Click here to view code image</a></p>
        <pre class="pre">[[[1, 2], [3, 4]], [[5, 6], [7, 8]]].flat(2) // [1, 2, 3, 4, 5, 6, 7, 8]</pre>
        <p class="noindent">The call</p>
        <pre class="pre">arr.concat(arg1, arg2, . . .)</pre>
        <p class="noindent">yields an array starting with <code>arr</code>, to which the arguments are appended. However, there is a twist: Array arguments are flattened.</p>
        <p class="codelink"><a id="rch07pr31" href="ch07_images.xhtml#ch07pr31">Click here to view code image</a></p>
        <pre class="pre">const arr = [1, 2]
        const arr2 = [5, 6]
        const result = arr.concat(3, 4, arr2) // <span class="cite"><code>result</code> is <code>[1, 2, 3, 4, 5, 6]</code></span></pre>
        <p class="noindent">Since you can nowadays use spreads in array literals, the <code>concat</code> method is no longer very useful. A simpler way of achieving the same result is:</p>
        <p class="codelink"><a id="rch07pr32" href="ch07_images.xhtml#ch07pr32">Click here to view code image</a></p>
        <pre class="pre">const result = [...arr, 3, 4, ...arr2]</pre>
        <p class="noindent">There is one remaining use case for the <code>concat</code> method: to concatenate a sequence of items of unknown type and flatten just those that are arrays.</p>
        <div class="note">
        <p class="note-caption"><span epub:type="pagebreak" id="page_149"></span><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">You can control the flattening with the <code>isConcatSpreadable</code> symbol. (Symbols are covered in <a href="ch08.xhtml#ch08">Chapter 8</a>.)</p>
        <p class="noindent">If the symbol is <code>false</code>, arrays are not flattened:</p>
        <p class="codelink"><a id="rch07pr33" href="ch07_images.xhtml#ch07pr33">Click here to view code image</a></p>
        <pre class="pre">arr = [17, 29]
        arr[Symbol.isConcatSpreadable] = false
        [].concat(arr) // <span class="cite">An array with a single element <code>[17, 29]</code></span></pre>
        <p class="noindent">If the symbol is <code>true</code>, then array-like objects are flattened:</p>
        <p class="codelink"><a id="rch07pr34" href="ch07_images.xhtml#ch07pr34">Click here to view code image</a></p>
        <pre class="pre">[].concat({ length: 2, [Symbol.isConcatSpreadable]: true,
          '0': 17, '1': 29 }) // <span class="cite">An array with two elements <code>17</code>, <code>29</code></span></pre>
        </div>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec6">7.6 Finding Elements</h3>
        <p class="noindent">The following calls check whether a specific value is contained in an array.</p>
        <p class="codelink"><a id="rch07pr35" href="ch07_images.xhtml#ch07pr35">Click here to view code image</a></p>
        <pre class="pre">const found = arr.includes(target, start) // <span class="cite"><code>true</code> or <code>false</code></span>
        const firstIndex = arr.indexOf(target, start) // <span class="cite">first index or <code>-1</code></span>
        const lastIndex = arr.lastIndexOf(target, start) // <span class="cite">last index or <code>-1</code></span></pre>
        <p class="noindent">The target must match the element strictly, using the <code>===</code> comparison.</p>
        <p class="noindent">The search starts at <code>start</code>. If <code>start</code> is less than <code>0</code>, it counts from the end of the array. If <code>start</code> is omitted, it defaults to <code>0</code>.</p>
        <p class="noindent">If you want to find a value that fulfills a condition, then call one of the following:</p>
        <p class="codelink"><a id="rch07pr36" href="ch07_images.xhtml#ch07pr36">Click here to view code image</a></p>
        <pre class="pre">const firstIndex = arr.findIndex(conditionFunction)
        const firstElement = arr.find(conditionFunction)</pre>
        <p class="noindent">For example, here is how you can find the first negative number in an array:</p>
        <p class="codelink"><a id="rch07pr37" href="ch07_images.xhtml#ch07pr37">Click here to view code image</a></p>
        <pre class="pre">const firstNegative = arr.find(x =&gt; x &lt; 0)</pre>
        <p class="noindent">For this and the subsequent methods of this section, the condition function receives three arguments:</p>
        <ul class="bullet">
        <li><p class="list-item">The array element</p></li>
        <li><p class="list-item">The index</p></li>
        <li><p class="list-item">The entire array</p></li>
        </ul>
        <p class="noindent">The calls</p>
        <p class="codelink"><a id="rch07pr38" href="ch07_images.xhtml#ch07pr38">Click here to view code image</a></p>
        <pre class="pre">arr.every(conditionFunction)
        arr.some(conditionFunction)</pre>
        <p class="noindent">yield <code>true</code> if <code>conditionFunction(element, index, arr)</code> is <code>true</code> for every element or at least one element.</p>
        <p class="noindent"><span epub:type="pagebreak" id="page_150"></span>For example,</p>
        <p class="codelink"><a id="rch07pr39" href="ch07_images.xhtml#ch07pr39">Click here to view code image</a></p>
        <pre class="pre">const atLeastOneNegative = arr.some(x =&gt; x &lt; 0)</pre>
        <p class="noindent">The <code>filter</code> method yields all values that fulfill a condition:</p>
        <p class="codelink"><a id="rch07pr40" href="ch07_images.xhtml#ch07pr40">Click here to view code image</a></p>
        <pre class="pre">const negatives = [-1, 7, 2, -9].filter(x =&gt; x &lt; 0) // [-1, -9]</pre>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec7">7.7 Visiting All Elements</h3>
        <p class="noindent">To visit all elements of an array, you can use a <code>for of</code> loop to visit all elements in order, or the <code>for in</code> loop to visit all index values.</p>
        <p class="codelink"><a id="rch07pr41" href="ch07_images.xhtml#ch07pr41">Click here to view code image</a></p>
        <pre class="pre">for (const e of arr) {
          // <span class="cite">Do something with the element <code>e</code></span>
        }
        for (const i in arr) {
          // <span class="cite">Do something with the index <code>i</code> and the element <code>arr[i]</code></span>
        }</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">The <code>for of</code> loop looks up elements for all index values between 0 and <code>length</code> − 1, yielding <code>undefined</code> for missing elements. In contrast, the <code>for in</code> loop only visits keys that are present.</p>
        <p class="noindent">In other words, the <code>for in</code> loop views an array as an object, whereas the <code>for of</code> loop views an array as an iterable. (As you will see in <a href="ch12.xhtml#ch12">Chapter 12</a>, iterables are sequences of values without gaps.)</p>
        </div>
        <p class="noindent">If you want to visit both the index values and elements, use the iterator that the <code>entries</code> method returns. It produces arrays of length 2 holding each index and element. This loop uses the <code>entries</code> method, a <code>for of</code> loop, and destructuring:</p>
        <p class="codelink"><a id="rch07pr42" href="ch07_images.xhtml#ch07pr42">Click here to view code image</a></p>
        <pre class="pre">for (const [index, element] of arr.entries())
           console.log(index, element)</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">The <code>entries</code> method is defined for all JavaScript data structures, including arrays. There are corresponding methods <code>keys</code> and <code>values</code> that yield iterators over the keys and values of the collection. These are useful for working with generic collections. If you know that you are working with an array, you won’t need them.</p>
        </div>
        <p class="noindent">The call <code>arr.forEach(f)</code> invokes <code>f(element, index, arr)</code> for each element, skipping missing elements. The call</p>
        <p class="codelink"><a id="rch07pr43" href="ch07_images.xhtml#ch07pr43">Click here to view code image</a></p>
        <pre class="pre">arr.forEach((element, index) =&gt; console.log(index, element))</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_151"></span>is equivalent to</p>
        <p class="codelink"><a id="rch07pr44" href="ch07_images.xhtml#ch07pr44">Click here to view code image</a></p>
        <pre class="pre">for (const index in arr) console.log(index, arr[index])</pre>
        <p class="noindent">Instead of specifying an action for each element, it is often better to transform the elements and collect the results. The call <code>arr.map(f)</code> yields an array of all values returned from <code>f(arr[index], index, arr)</code>:</p>
        <p class="codelink"><a id="rch07pr45" href="ch07_images.xhtml#ch07pr45">Click here to view code image</a></p>
        <pre class="pre">[1, 7, 2, 9].map(x =&gt; x * x) // [1, 49, 4, 81]
        [1, 7, 2, 9].map((x, i) =&gt; x * 10 ** i) // [1, 70, 200, 9000]</pre>
        <p class="noindent">Consider a function that returns an array of values:</p>
        <p class="codelink"><a id="rch07pr46" href="ch07_images.xhtml#ch07pr46">Click here to view code image</a></p>
        <pre class="pre">function roots(x) {
          if (x &lt; 0) {
            return [] // <span class="cite">No roots</span>
          } else if (x === 0) {
            return [0] // <span class="cite">Single root</span>
          } else {
            return [Math.sqrt(x), -Math.sqrt(x)] // <span class="cite">Two roots</span>
          }
        }</pre>
        <p class="noindent">When you map this function to an array of inputs, you get an array of the array-valued answers:</p>
        <p class="codelink"><a id="rch07pr47" href="ch07_images.xhtml#ch07pr47">Click here to view code image</a></p>
        <pre class="pre">[-1, 0, 1, 4].map(roots) // [[], [0], [1, -1], [2, -2]]</pre>
        <p class="noindent">If you want to flatten out the results, you can call <code>map</code> followed by <code>flat</code>, or you can call <code>flatMap</code> which is slightly more efficient:</p>
        <p class="codelink"><a id="rch07pr48" href="ch07_images.xhtml#ch07pr48">Click here to view code image</a></p>
        <pre class="pre">[-1, 0, 1, 4].flatMap(roots) // [0, 1, -1, 2, -2]</pre>
        <p class="noindent">Finally, the call <code>arr.join(separator)</code> converts all elements to strings and joins them with the given separator. The default separator is <code>','</code>.</p>
        <p class="codelink"><a id="rch07pr49" href="ch07_images.xhtml#ch07pr49">Click here to view code image</a></p>
        <pre class="pre">[1,2,3,[4,5]].join(' and ') // '1 and 2 and 3 and 4,5'</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">The <code>forEach</code>, <code>map</code>, <code>filter</code>, <code>find</code>, <code>findIndex</code>, <code>some</code>, and <code>every</code> methods (but not <code>sort</code> or <code>reduce</code>), as well as the <code>from</code> function, take an optional argument after the function argument:</p>
        <p class="codelink"><a id="rch07pr50" href="ch07_images.xhtml#ch07pr50">Click here to view code image</a></p>
        <pre class="pre">arr.forEach(f, thisArg)</pre>
        <p class="noindent">The <code>thisArg</code> argument becomes the <code>this</code> parameter of <code>f</code>. That is,</p>
        <p class="codelink"><a id="rch07pr51" href="ch07_images.xhtml#ch07pr51">Click here to view code image</a></p>
        <pre class="pre">thisArg.f(arr[index], index, arr)</pre>
        <p class="noindent">is called for each index.</p>
        <p class="noindent">You only need the <code>thisArg</code> argument if you pass a method instead of a function. <a href="#ch07ex04">Exercise 4</a> shows how you can avoid this situation.</p>
        </div>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec8"><span epub:type="pagebreak" id="page_152"></span>7.8 Sparse Arrays</h3>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/cat.jpg" alt="Images" width="85" height="85">
        </figure>
        <p class="noindent">An array with one or more missing elements is called <em>sparse</em>. Sparse arrays can arise in four situations:</p>
        <ol class="order">
        <li><p class="list">Missing elements in an array literal:</p>
        <p class="codelink"><a id="rch07pr52" href="ch07_images.xhtml#ch07pr52">Click here to view code image</a></p>
        <pre class="pre">const someNumbers = [ , 2, , 9] // <span class="cite">No index properties <code>0</code>, <code>2</code></span></pre></li>
        <li><p class="list">Adding an element beyond the length:</p>
        <p class="codelink"><a id="rch07pr53" href="ch07_images.xhtml#ch07pr53">Click here to view code image</a></p>
        <pre class="pre">someNumbers[100] = 0 // <span class="cite">No index properties <code>4</code> to <code>99</code></span></pre></li>
        <li><p class="list">Increasing the length:</p>
        <p class="codelink"><a id="rch07pr54" href="ch07_images.xhtml#ch07pr54">Click here to view code image</a></p>
        <pre class="pre">const bigEmptyArray = []
        bigEmptyArray.length = 10000 // <span class="cite">No index properties</span></pre></li>
        <li><p class="list">Deleting an element:</p>
        <p class="codelink"><a id="rch07pr55" href="ch07_images.xhtml#ch07pr55">Click here to view code image</a></p>
        <pre class="pre">delete someNumbers[1] // <span class="cite">No longer an index property <code>1</code></span></pre></li>
        </ol>
        <p class="noindent">Most methods in the array API skip over the missing elements in sparse arrays. For example, <code>[ , 2, , 9].forEach(f)</code> only invokes <code>f</code> twice. No call is made for the missing elements at indices <code>0</code> and <code>2</code>.</p>
        <p class="noindent">As you have seen in <a href="ch07.xhtml#ch07lev1sec1">Section 7.1</a>, “<a href="ch07.xhtml#ch07lev1sec1">Constructing Arrays</a>” (<a href="ch07.xhtml#page_141">page 141</a>), <code>Array.from(arrayLike, f)</code> is an exception, invoking <code>f</code> for every index.</p>
        <p class="noindent">You can use <code>Array.from</code> to replace missing elements with <code>undefined</code>:</p>
        <p class="codelink"><a id="rch07pr56" href="ch07_images.xhtml#ch07pr56">Click here to view code image</a></p>
        <pre class="pre">Array.from([ , 2, , 9]) // [undefined, 2, undefined, 9]</pre>
        <p class="noindent">The <code>join</code> method turns missing and <code>undefined</code> elements into empty strings:</p>
        <p class="codelink"><a id="rch07pr57" href="ch07_images.xhtml#ch07pr57">Click here to view code image</a></p>
        <pre class="pre">[ , 2, undefined, 9].join(' and ') // ' and 2 and  and 9'</pre>
        <p class="noindent">Most methods that produce arrays from given arrays keep the missing elements in place. For example, <code>[ , 2, , 9].map(x =&gt; x * x)</code> yields <code>[ , 4, , 81]</code>.</p>
        <p class="noindent">However, the <code>sort</code> method places missing elements at the end:</p>
        <p class="codelink"><a id="rch07pr58" href="ch07_images.xhtml#ch07pr58">Click here to view code image</a></p>
        <pre class="pre">let someNumbers = [ , 2, , 9]
        someNumbers.sort((x, y) =&gt; y - x) // <span class="cite"><code>someNumbers</code> is now <code>[9, 2, , , ]</code></span></pre>
        <p class="noindent">(Eagle-eyed readers may have noted that there are four commas. The last comma is a trailing comma. If it had not been present, then the preceding comma would have been a trailing comma and the array would only have had one <code>undefined</code> element.)</p>
        <p class="noindent">The <code>filter</code>, <code>flat</code>, and <code>flatMap</code> skip missing elements entirely.</p>
        <p class="noindent"><span epub:type="pagebreak" id="page_153"></span>A simple way of eliminating missing elements from an array is to filter with a function that accepts all elements:</p>
        <p class="codelink"><a id="rch07pr59" href="ch07_images.xhtml#ch07pr59">Click here to view code image</a></p>
        <pre class="pre">[ , 2, , 9].filter(x =&gt; true) // [2, 9]</pre>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec9">7.9 Reduction</h3>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/cat.jpg" alt="Images" width="85" height="85">
        </figure>
        <p class="noindent">This section discusses a general mechanism for computing a value from the elements of an array. The mechanism is elegant, but frankly, it is never necessary—you can achieve the same effect with a simple loop. Feel free to skip this section if you don’t find it interesting.</p>
        <p class="noindent">The <code>map</code> method applies a unary function to all elements of a collection. The <code>reduce</code> and <code>reduceRight</code> methods that we discuss in this section combine elements with a <em>binary</em> operation. The call <code>arr.reduce(op)</code> applies <code>op</code> to successive elements like this:</p>
        <p class="codelink"><a id="rch07pr60" href="ch07_images.xhtml#ch07pr60">Click here to view code image</a></p>
        <pre class="pre">             .
                    .
                   .
                  op
                 /  \
                op   arr[3]
               /  \
              op   arr[2]
             /  \
        arr[0]  arr[1]</pre>
        <p class="noindent">For example, here is how to compute the sum of array elements:</p>
        <p class="codelink"><a id="rch07pr61" href="ch07_images.xhtml#ch07pr61">Click here to view code image</a></p>
        <pre class="pre">const arr = [1, 7, 2, 9]
        const result = arr.reduce((x, y) =&gt; x + y) // ((1 + 7) + 2) + 9</pre>
        <p class="noindent">Here is a more interesting reduction that computes the value of a decimal number from an array of digits:</p>
        <p class="codelink"><a id="rch07pr62" href="ch07_images.xhtml#ch07pr62">Click here to view code image</a></p>
        <pre class="pre">[1, 7, 2, 9].reduce((x, y) =&gt; 10 * x + y) // 1729</pre>
        <p class="noindent">This tree diagram shows the intermediate results:</p>
        <p class="codelink"><a id="rch07pr63" href="ch07_images.xhtml#ch07pr63">Click here to view code image</a></p>
        <pre class="pre">            1729
                   /   \
                 172    9
                /   \
              17     2
             /  \
            1    7</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_154"></span>In most cases, it is useful to start the computation with an initial value other than the initial array element. The call <code>arr.reduce(op, init)</code> computes</p>
        <p class="codelink"><a id="rch07pr64" href="ch07_images.xhtml#ch07pr64">Click here to view code image</a></p>
        <pre class="pre">           .
                  .
                 .
                op
               /  \
              op   arr[2]
             /  \
            op   arr[1]
           /  \
        init   arr[0]</pre>
        <p class="noindent">Compared with the tree diagram of <code>reduce</code> without an initial value, this diagram is more regular. All array elements are on the right of the tree. Each operation combines an accumulated value (starting with the initial value) and an array element.</p>
        <p class="noindent">For example,</p>
        <p class="codelink"><a id="rch07pr65" href="ch07_images.xhtml#ch07pr65">Click here to view code image</a></p>
        <pre class="pre">[1, 7, 2, 9].reduce((accum, current) =&gt; accum - current, 0)</pre>
        <p class="noindent">is</p>
        <pre class="pre"><span class="cite">0 − 1 − 7 − 2 − 9 = −19</span></pre>
        <p class="noindent">Without the initial value, the result would have been 1 − 7 − 2 − 9, which is not the difference of all elements.</p>
        <p class="noindent">The initial value is returned when the array is empty. For example, if you define</p>
        <p class="codelink"><a id="rch07pr66" href="ch07_images.xhtml#ch07pr66">Click here to view code image</a></p>
        <pre class="pre">const sum = arr =&gt; arr.reduce((accum, current) =&gt; accum + current, 0)</pre>
        <p class="noindent">then the sum of the empty array is <code>0</code>. Reducing an empty array without an initial value throws an exception.</p>
        <p class="noindent">The callback function actually takes four arguments:</p>
        <ul class="bullet">
        <li><p class="list-item">The accumulated value</p></li>
        <li><p class="list-item">The current array element</p></li>
        <li><p class="list-item">The index of the current element</p></li>
        <li><p class="list-item">The entire array</p></li>
        </ul>
        <p class="noindent">In this example, we collect the positions of all elements fulfilling a condition:<span epub:type="pagebreak" id="page_155"></span></p>
        <p class="codelink"><a id="rch07pr67" href="ch07_images.xhtml#ch07pr67">Click here to view code image</a></p>
        <pre class="pre">function findAll(arr, condition) {
          return arr.reduce((accum, current, currentIndex) =&gt;
            condition(current) ? [...accum, currentIndex] : accum, [])
        }
        
        const odds = findAll([1, 7, 2, 9], x =&gt; x % 2 !== 0)
          // <span class="cite"><code>[0, 1, 3]</code>, the positions of all odd elements</span></pre>
        <p class="noindent">The <code>reduceRight</code> method starts at the end of the array, visiting the elements in reverse order.</p>
        <p class="codelink"><a id="rch07pr68" href="ch07_images.xhtml#ch07pr68">Click here to view code image</a></p>
        <pre class="pre">                    op
                           /  \
                          .    arr[0]
                         .
                        .
                       /
                      op
                     /  \
                    op   arr[n-2]
                   /  \
                init   arr[n-1]</pre>
        <p class="noindent">For example,</p>
        <p class="codelink"><a id="rch07pr69" href="ch07_images.xhtml#ch07pr69">Click here to view code image</a></p>
        <pre class="pre">[1, 2, 3, 4].reduceRight((x, y) =&gt; [x, y], [])</pre>
        <p class="noindent">is</p>
        <pre class="pre">[[[[[], 4], 3], 2], 1]</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">Right reduction in JavaScript is similar to a right fold in Lisp-like languages, but the order of the operands is reversed.</p>
        </div>
        <p class="noindent">Reducing can be used instead of a loop. Suppose, for example, that we want to count the frequencies of the letters in a string. One way is to visit each letter and update an object.</p>
        <p class="codelink"><a id="rch07pr70" href="ch07_images.xhtml#ch07pr70">Click here to view code image</a></p>
        <pre class="pre">const freq = {}
        for (const c of 'Mississippi') {
          if (c in freq) {
            freq[c]++
          } else {
            freq[c] = 1
          }
        }</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_156"></span>Here is another way of thinking about this. At each step, combine the frequency map and the newly encountered letter, yielding a new frequency map. That’s a reduction:</p>
        <p class="codelink"><a id="rch07pr71" href="ch07_images.xhtml#ch07pr71">Click here to view code image</a></p>
        <pre class="pre">                .
                       .
                      .
                     op
                    /  \
                   op   's'
                  /  \
                 op   'i'
                /  \
        empty map  'M'</pre>
        <p class="noindent">What is <code>op</code>? The left operand is the partially filled frequency map, and the right operand is the new letter. The result is the augmented map. It becomes the input to the next call to <code>op</code>, and at the end, the result is a map with all counts. The code is</p>
        <p class="codelink"><a id="rch07pr72" href="ch07_images.xhtml#ch07pr72">Click here to view code image</a></p>
        <pre class="pre">[...'Mississippi'].reduce(
          (freq, c) =&gt; ({ ...freq, [c]: (c in freq ? freq[c] + 1 : 1) }),
          {})</pre>
        <p class="noindent">In the reduction function, a new object is created, starting with a copy of the <code>freq</code> object. Then the value associated with the <code>c</code> key is set either to an increment of the preceding value if there was one, or to <code>1</code>.</p>
        <p class="noindent">Note that in this approach, no state is mutated. In each step, a new object is computed.</p>
        <p class="noindent">It is possible to replace any loop with a call to <code>reduce</code>. Put all variables updated in the loop into an object, and define an operation that implements one step through the loop, producing a new object with the updated variables. I am not saying this is always a good idea, but you may find it interesting that loops can be eliminated in this way.</p>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec10">7.10 Maps</h3>
        <p class="noindent">The JavaScript API provides a <code>Map</code> class that implements the classic map data structure: a collection of key/value pairs.</p>
        <p class="noindent">Of course, every JavaScript object is a map, but there are advantages of using the <code>Map</code> class instead:</p>
        <ul class="bullet">
        <li><p class="list-item">Object keys must be strings or symbols, but <code>Map</code> keys can be of any type.</p></li>
        <li><p class="list-item">A <code>Map</code> instance remembers the order in which elements were inserted.</p></li>
        <li><p class="list-item">Unlike objects, maps do not have a prototype chain.<span epub:type="pagebreak" id="page_157"></span></p></li>
        <li><p class="list-item">You can find out the number of entries with the <code>size</code> property.</p></li>
        </ul>
        <p class="noindent">To construct a map, you can provide an iterable with <code>[<span class="var">key</span>, <span class="var">value</span>]</code> pairs:</p>
        <p class="codelink"><a id="rch07pr73" href="ch07_images.xhtml#ch07pr73">Click here to view code image</a></p>
        <pre class="pre">const weekdays = new Map(
          [["Mon", 0], ["Tue", 1], ["Wed", 2], ["Thu", 3], ["Fri", 4], ["Sat", 5], ["Sun", 6], ])</pre>
        <p class="noindent">Or you can construct an empty map and add entries later:</p>
        <p class="codelink"><a id="rch07pr74" href="ch07_images.xhtml#ch07pr74">Click here to view code image</a></p>
        <pre class="pre">const emptyMap = new Map()</pre>
        <p class="noindent">You must use <code>new</code> with the constructor.</p>
        <p class="noindent">The API is very straightforward. The call</p>
        <p class="codelink"><a id="rch07pr75" href="ch07_images.xhtml#ch07pr75">Click here to view code image</a></p>
        <pre class="pre">map.set(key, value)</pre>
        <p class="noindent">adds an entry and returns the map for chaining:</p>
        <p class="codelink"><a id="rch07pr76" href="ch07_images.xhtml#ch07pr76">Click here to view code image</a></p>
        <pre class="pre">map.set(key1, value1).set(key2, value2)</pre>
        <p class="noindent">To remove an entry, call:</p>
        <p class="codelink"><a id="rch07pr77" href="ch07_images.xhtml#ch07pr77">Click here to view code image</a></p>
        <pre class="pre">map.delete(key) // <span class="cite">Returns <code>true</code> if the key was present, <code>false</code> otherwise</span></pre>
        <p class="noindent">The <code>clear</code> method removes all entries.</p>
        <p class="noindent">To test whether a key is present, call</p>
        <p class="codelink"><a id="rch07pr78" href="ch07_images.xhtml#ch07pr78">Click here to view code image</a></p>
        <pre class="pre">if (map.has(key)) . . .</pre>
        <p class="noindent">Retrieve a key’s value with</p>
        <p class="codelink"><a id="rch07pr79" href="ch07_images.xhtml#ch07pr79">Click here to view code image</a></p>
        <pre class="pre">const value = map.get(key) // <span class="cite">Returns <code>undefined</code> if the <code>key</code> is not present</span></pre>
        <p class="noindent">A map is an iterable yielding <code>[key, value]</code> pairs. Therefore, you can easily visit all entries with a <code>for of</code> loop:</p>
        <p class="codelink"><a id="rch07pr80" href="ch07_images.xhtml#ch07pr80">Click here to view code image</a></p>
        <pre class="pre">for (const [key, value] of map) {
          console.log(key, value)
        }</pre>
        <p class="noindent">Alternatively, use the <code>forEach</code> method:</p>
        <p class="codelink"><a id="rch07pr81" href="ch07_images.xhtml#ch07pr81">Click here to view code image</a></p>
        <pre class="pre">map.forEach((key, value) =&gt; {
          console.log(key, value)
        })</pre>
        <p class="noindent">Maps are traversed in insertion order. Consider this map:</p>
        <p class="codelink"><a id="rch07pr82" href="ch07_images.xhtml#ch07pr82">Click here to view code image</a></p>
        <pre class="pre">const weekdays = new Map([['Mon', 0], ['Tue', 1], . . ., ['Sun', 6]])</pre>
        <p class="noindent">Both the <code>for of</code> loop and the <code>forEach</code> method will respect the order in which you inserted the elements.</p>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">In Java, you would use a <code>LinkedHashMap</code> to visit elements in insertion order. In JavaScript, tracking insertion order is automatic.</p>
        </div>
        <div class="note">
        <p class="note-caption"><span epub:type="pagebreak" id="page_158"></span><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">Maps, like all JavaScript collections, have methods <code>keys</code>, <code>values</code>, and <code>entries</code> that yield iterators over the keys, values, and key/value pairs. If you just want to iterate over the keys, you can use a loop:</p>
        <pre class="pre">for (const key of map.keys()) . . .</pre>
        </div>
        <p class="noindent">In programming languages such as Java and C++, you get the choice between hash maps and tree maps, and you have to come up with a hash or comparison function. In JavaScript, you always get a hash map, and you have no choice of the hash function.</p>
        <p class="noindent">The hash function for a JavaScript <code>Map</code> is compatible with <em>key equality</em>: <code>===</code> except that all <code>NaN</code> are equal. Hash values are derived from primitive type values or object references.</p>
        <p class="noindent">This is fine if your keys are strings or numbers, or if you are happy to compare keys by identity. For example, you can use a map to associate values with DOM nodes. That is better than adding properties directly into the node objects.</p>
        <p class="noindent">But you have to be careful when you use other objects as keys. Distinct objects are separate keys, even if their values are the same:</p>
        <p class="codelink"><a id="rch07pr83" href="ch07_images.xhtml#ch07pr83">Click here to view code image</a></p>
        <pre class="pre">const map = new Map()
        const key1 = new Date('1970-01-01T00:00:00.000Z')
        const key2 = new Date('1970-01-01T00:00:00.000Z')
        map.set(key1, 'Hello')
        map.set(key2, 'Epoch') // <span class="cite">Now <code>map</code> has two entries</span></pre>
        <p class="noindent">If that’s not what you want, consider choosing different keys, such as the date strings in this example.</p>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec11">7.11 Sets</h3>
        <p class="noindent">A <code>Set</code> is a data structure that collects elements without duplicates.</p>
        <p class="noindent">Construct a set as</p>
        <p class="codelink"><a id="rch07pr84" href="ch07_images.xhtml#ch07pr84">Click here to view code image</a></p>
        <pre class="pre">const emptySet = new Set()
        const setWithElements = new Set(iterable)</pre>
        <p class="noindent">where <code>iterable</code> produces the elements.</p>
        <p class="noindent">As with maps, the <code>size</code> property yields the number of elements.</p>
        <p class="noindent">The API for sets is even simpler than that for maps:<span epub:type="pagebreak" id="page_159"></span></p>
        <p class="codelink"><a id="rch07pr85" href="ch07_images.xhtml#ch07pr85">Click here to view code image</a></p>
        <pre class="pre">set.add(x)
          // <span class="cite">Adds <code>x</code> if not present and returns <code>set</code> for chaining</span>
        set.delete(x)
          // <span class="cite">If <code>x</code> is present, deletes <code>x</code> and returns <code>true</code>, otherwise returns <code>false</code></span>
        set.has(x) // <span class="cite">Returns <code>true</code> if <code>x</code> is present</span>
        set.clear() // <span class="cite">Deletes all elements</span></pre>
        <p class="noindent">To visit all elements of a set, you can use a <code>for of</code> loop:</p>
        <p class="codelink"><a id="rch07pr86" href="ch07_images.xhtml#ch07pr86">Click here to view code image</a></p>
        <pre class="pre">for (const value of set) {
          console.log(value)
        }</pre>
        <p class="noindent">Alternatively, you can use the <code>forEach</code> method:</p>
        <p class="codelink"><a id="rch07pr87" href="ch07_images.xhtml#ch07pr87">Click here to view code image</a></p>
        <pre class="pre">set.forEach(value =&gt; {
          console.log(value)
        })</pre>
        <p class="noindent">Just like maps, sets remember their insertion order. For example, suppose you add weekday names in order:</p>
        <p class="codelink"><a id="rch07pr88" href="ch07_images.xhtml#ch07pr88">Click here to view code image</a></p>
        <pre class="pre">const weekdays = new Set(['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'])</pre>
        <p class="noindent">Then the <code>for of</code> loop and <code>forEach</code> method iterate over the elements in this order.</p>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">A set is considered as a map of <code>[value, value]</code> pairs. Both the <code>keys</code> and <code>values</code> methods yield an iterator over the values, and the <code>entries</code> method yield an iterator over <code>[value, value]</code> pairs. None of these methods are useful when you work with a known set. They are intended for code that deals with generic collections.</p>
        </div>
        <p class="noindent">As with maps, sets are implemented as hash tables with a predefined hash function. Set elements are considered to be the same if they are the same primitive type values or the same object references. In addition, <code>NaN</code> values equal each other.</p>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec12">7.12 Weak Maps and Sets</h3>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/cat.jpg" alt="Images" width="85" height="85">
        </figure>
        <p class="noindent">An important use case for JavaScript maps and sets is to attach properties to DOM nodes. Suppose we want to categorize certain nodes to indicate success, work in progress, or an error. We could attach the properties directly to the nodes:</p>
        <pre class="pre">node.outcome = 'success'</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_160"></span>That generally works fine, but it is a bit fragile. DOM nodes have lots of properties, and trouble lies ahead if someone else, or a future version of the DOM API, uses the same property.</p>
        <p class="noindent">It is more robust to use a map:</p>
        <p class="codelink"><a id="rch07pr89" href="ch07_images.xhtml#ch07pr89">Click here to view code image</a></p>
        <pre class="pre">const outcome = new Map()
        . . .
        outcome.set(node, 'success')</pre>
        <p class="noindent">DOM nodes come and go. If a particular node is no longer needed, it should be garbage-collected. However, if a node reference resides in the <code>outcome</code> map, that reference will keep the node object alive.</p>
        <p class="noindent">That is where <em>weak maps</em> come in. If a key in a weak map is the only reference to an object, that object is not kept alive by the garbage collector.</p>
        <p class="noindent">Simply use a weak map to collect properties:</p>
        <pre class="pre">const outcome = new WeakMap()</pre>
        <p class="noindent">Weak maps have no traversal methods, and the map objects are not iterable. The only methods are <code>set</code>, <code>delete</code>, <code>has</code>, and <code>get</code>. That is enough to set properties and to check the properties of a given object.</p>
        <p class="noindent">If the property that you want to monitor is binary, you can use a <code>WeakSet</code> instead of a <code>WeakMap</code>. Then the only methods are <code>set</code>, <code>delete</code>, and <code>has</code>.</p>
        <p class="noindent">The keys of weak maps and the elements of weak sets can only be objects, not primitive type values.</p>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec13">7.13 Typed Arrays</h3>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/cat.jpg" alt="Images" width="85" height="85">
        </figure>
        <p class="noindent">JavaScript arrays store sequences of elements of any kind, possibly with missing elements. If all you want to store is a sequence of numbers, or the raw bytes of an image, a generic array is quite inefficient.</p>
        <p class="noindent">If you need to store sequences of numbers of the same type efficiently, you can use a <em>typed array</em>. The following array types are available:</p>
        <p class="codelink"><a id="rch07pr90" href="ch07_images.xhtml#ch07pr90">Click here to view code image</a></p>
        <pre class="pre">Int8Array
        Uint8Array
        Uint8ClampedArray
        Int16Array
        Uint16Array
        Int32Array
        Uint32Array
        Float32Array
        Float64Array</pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_161"></span>All elements are of the given type. For example, an <code>Int16Array</code> stores 16-bit integers between −32768 and 32767. The <code>Uint</code> prefix denotes unsigned integers. An <code>UInt16Array</code> holds integers from 0 to 65535.</p>
        <p class="noindent">When constructing an array, specify the length. You cannot change it later.</p>
        <p class="codelink"><a id="rch07pr91" href="ch07_images.xhtml#ch07pr91">Click here to view code image</a></p>
        <pre class="pre">const iarr = new Int32Array(1024)</pre>
        <p class="noindent">Upon construction, all array elements are zero.</p>
        <p class="noindent">There are no typed array literals, but each typed array class has a function named <code>of</code> for constructing an instance with given values:</p>
        <p class="codelink"><a id="rch07pr92" href="ch07_images.xhtml#ch07pr92">Click here to view code image</a></p>
        <pre class="pre">const farr = Float32Array.of(1, 0.5, 0.25, 0.125, 0.0625, 0.03215, 0.015625)</pre>
        <p class="noindent">As with arrays, there is a <code>from</code> function that takes elements from any iterable, with an optional mapping function:</p>
        <p class="codelink"><a id="rch07pr93" href="ch07_images.xhtml#ch07pr93">Click here to view code image</a></p>
        <pre class="pre">const uarr = Uint32Array.from(farr, x =&gt; 1 / x)
          // <span class="cite">An <code>Uint32Array</code> with elements <code>[1, 2, 4, 8, 16, 32, 64]</code></span></pre>
        <p class="noindent">Assigning to a numerical array index that is not an integer between 0 and <code>length</code> − 1 has no effect. However, as with regular arrays, you can set other properties:</p>
        <p class="codelink"><a id="rch07pr94" href="ch07_images.xhtml#ch07pr94">Click here to view code image</a></p>
        <pre class="pre">farr[-1] = 2 // <span class="cite">No effect</span>
        farr[0.5] = 1.414214 // <span class="cite">No effect</span>
        farr.lucky = true // <span class="cite">Sets the <code>lucky</code> property</span></pre>
        <p class="noindent">When you assign a number to an integer array element, any fractional part is discarded. Then the number is truncated to fit into the integer range. Consider this example:</p>
        <p class="codelink"><a id="rch07pr95" href="ch07_images.xhtml#ch07pr95">Click here to view code image</a></p>
        <pre class="pre">iarr[0] = 40000.25 // <span class="cite">Sets <code>iarr[0]</code> to <code>-25536</code></span></pre>
        <p class="noindent">Only the integer part is used. Since <code>40000</code> is too large to fit in the range of 32-bit integers, the last 32 bits are taken, which happen to represent −25536.</p>
        <p class="noindent">An exception to this truncation process is the <code>Uint8ClampedArray</code> which sets an out-of-range value to 0 or 255 and rounds non-integer values to the nearest integer.</p>
        <p class="noindent">The <code>Uint8ClampedArray</code> type is intended for use with HTML canvas images. The <code>getImageData</code> method of a canvas context yields an object whose <code>data</code> property is an <code>Uint8ClampedArray</code> containing the RGBA values of a rectangle on a canvas:</p>
        <p class="codelink"><a id="rch07pr96" href="ch07_images.xhtml#ch07pr96">Click here to view code image</a></p>
        <pre class="pre">const canvas = document.getElementById('canvas')
        const ctx = canvas.getContext('2d')
        ctx.drawImage(img, 0, 0)
        let imgdata = ctx.getImageData(0, 0, canvas.width, canvas.height)
        let rgba = imgdata.data // <span class="cite">an <code><code>Uint8ClampedArray</code></code></span></pre>
        <p class="noindent"><span epub:type="pagebreak" id="page_162"></span>The companion code for this book has a sample program that turns the canvas contents into negative when you click on it—see <a href="#ch07fig01">Figure 7-1</a>.</p>
        <p class="codelink"><a id="rch07pr97" href="ch07_images.xhtml#ch07pr97">Click here to view code image</a></p>
        <pre class="pre">canvas.addEventListener('click', event =&gt; {
          for (let i = 0; i &lt; rgba.length; i++) {
            if (i % 4 != 3) rgba[i] = 255 - rgba[i]
          }
          ctx.putImageData(imgdata, 0, 0)
        })</pre>
        <figure class="figure" id="ch07fig01">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/pg162_Image_463.jpg" alt="Images" width="230" height="251">
        <figcaption><p class="fig-title"><strong>Figure 7-1</strong>&nbsp;&nbsp;&nbsp;&nbsp;The canvas content turns into negative when clicked</p></figcaption>
        </figure>
        <p class="noindent">Typed arrays have all methods of regular arrays, except for:</p>
        <ul class="bullet">
        <li><p class="list-item"><code>push</code>, <code>pop</code>, <code>shift</code>, <code>unshift</code>—you can’t change the size of a typed array</p></li>
        <li><p class="list-item"><code>flat</code>, <code>flatMap</code>—a typed array can’t hold arrays</p></li>
        <li><p class="list-item"><code>concat</code>—use <code>set</code> instead</p></li>
        </ul>
        <p class="noindent">There are two methods that regular arrays don’t have. The <code>set</code> method copies values from an array or typed array at an offset:</p>
        <p class="codelink"><a id="rch07pr98" href="ch07_images.xhtml#ch07pr98">Click here to view code image</a></p>
        <pre class="pre">targetTypedArray.set(source, offset)</pre>
        <p class="noindent">By default, the offset is zero. The source must fit entirely into the target. If the offset and source length exceed the target length, a <code>RangeError</code> is thrown. (This means you cannot use this method to shift elements of a typed array.)</p>
        <p class="noindent">The <code>subarray</code> method yields a view into a subrange of the elements:</p>
        <p class="codelink"><a id="rch07pr99" href="ch07_images.xhtml#ch07pr99">Click here to view code image</a></p>
        <pre class="pre">const sub = iarr.subarray(16, 32)</pre>
        <p class="noindent">If omitted, the end index is the length of the array, and the start index is zero.</p>
        <p class="noindent">This seems to be just the same as the <code>slice</code> method, but there is an important difference. The array and subarray share the same elements. Modifying either is visible in the other.</p>
        <p class="codelink"><a id="rch07pr100" href="ch07_images.xhtml#ch07pr100">Click here to view code image</a></p>
        <pre class="pre">sub[0] = 1024 // <span class="cite">Now <code>iarr[16]</code> is also <code>1024</code></span></pre>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec14"><span epub:type="pagebreak" id="page_163"></span>7.14 Array Buffers</h3>
        <figure class="image-1">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/cat.jpg" alt="Images" width="85" height="85">
        </figure>
        <p class="noindent">An <em>array buffer</em> is a contiguous byte sequence that can hold data from a file, a data stream, an image, and so on. The data from typed arrays are also stored in array buffers.</p>
        <p class="noindent">A number of web APIs (including the File API, <code>XMLHttpRequest</code>, and WebSockets) yield array buffers. You can also construct an array buffer with a given number of bytes:</p>
        <p class="codelink"><a id="rch07pr101" href="ch07_images.xhtml#ch07pr101">Click here to view code image</a></p>
        <pre class="pre">const buf = new ArrayBuffer(1024 * 2)</pre>
        <p class="noindent">Usually, the binary data in an array buffer has a complex structure, such as an image or sound file. Then use a <code>DataView</code> to look at the data inside:</p>
        <pre class="pre">const view = new DataView(buf)</pre>
        <p class="noindent">Read values at a given offset with the <code>DataView</code> methods <code>getInt8</code>, <code>getInt16</code>, <code>getInt32</code>, <code>getUInt8</code>, <code>getUInt16</code>, <code>getUInt32</code>, <code>getFloat32</code>, <code>getFloat64</code>:</p>
        <p class="codelink"><a id="rch07pr102" href="ch07_images.xhtml#ch07pr102">Click here to view code image</a></p>
        <pre class="pre">const littleEndian = true // <span class="cite"><code>false</code> or omitted for big-endian byte order</span>
        const value = view.getUint32(offset, littleEndian)</pre>
        <p class="noindent">Write data with the <code>set</code> method:</p>
        <p class="codelink"><a id="rch07pr103" href="ch07_images.xhtml#ch07pr103">Click here to view code image</a></p>
        <pre class="pre">view.setUint32(offset, newValue, littleEndian)</pre>
        <div class="note">
        <p class="note-caption"><span class="middle"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780136502166/files/graphics/note.jpg" alt="Images" width="42" height="42"></span> Note</p>
        <p class="noindent">There are two ways of storing binary data as a sequence of bytes, called “big-endian” and “little-endian.” Consider the 16-bit value <code>0x2122</code>. In the big-endian way, the more significant byte comes first: <code>0x21</code> followed by <code>0x22</code>. Little-endian is the other way around: <code>0x22 0x21</code>.</p>
        <p class="noindent">Most modern processors are little-endian, but a number of common file formats (such as PNG and JPEG) use big-endian numbers.</p>
        <p class="noindent">The “big-endian” and “little-endian” terms, while eminently sensible on their own, are actually borrowed from a satirical passage in <em>Gulliver’s Travels</em>.</p>
        </div>
        <p class="noindent">The buffer of a typed array always uses the endianness of the host platform. If the entire buffer data is an array, and you know that the endianness matches that of the host platform, you can construct a typed array from the buffer contents:</p>
        <p class="codelink"><a id="rch07pr104" href="ch07_images.xhtml#ch07pr104">Click here to view code image</a></p>
        <pre class="pre">const arr = new Uint16Array(buf) // <span class="cite">An array of 1024 <code>Uint16</code>, backed by <code>buf</code></span></pre>
        </section>
        <section>
        <h3 class="h3" id="ch07lev1sec15"><span epub:type="pagebreak" id="page_164"></span>Exercises</h3>
        <ol class="ol-exe">
        <li><p class="list" id="ch07ex01">Implement a function that works exactly like the <code>from</code> function of the <code>Array</code> class. Pay careful attention to missing elements. What happens with objects that have keys whose numeric values are ≥ the <code>length</code> property? With properties that are not index properties?</p></li>
        <li><p class="list" id="ch07ex02">The <code>Array.of</code> method was designed for a very specific use case: to be passed as a “collector” to a function that produces a sequence of values and sends them to some destination—perhaps printing them, summing them, or collecting them in an array. Implement such a function:</p>
        <pre class="pre">mapCollect(values, f, collector)</pre>
        <p class="noindent">The function should apply <code>f</code> to all values and then send the result to the collector, a function with a variable number of arguments. Return the result of the collector.</p>
        <p class="noindent">Explain the advantage of using <code>Array.of</code> over <code>Array</code> (i.e., <code>(...elements) =&gt; new Array(...elements)</code>) in this context.</p></li>
        <li><p class="list" id="ch07ex03">An array can have properties whose numeric values are negative integers, such as <code>'-1'</code>. Do they affect the length? How can you iterate over them in order?</p></li>
        <li><p class="list" id="ch07ex04">Google for “JavaScript forEach thisArg” to find blog articles explaining the <code>thisArg</code> parameter of the <code>forEach</code> method. Rewrite the examples without using the <code>thisArg</code> parameter. If you find a call such as</p>
        <p class="codelink"><a id="rch07pr105" href="ch07_images.xhtml#ch07pr105">Click here to view code image</a></p>
        <pre class="pre">arr.forEach(function() { . . . this.something() . . . }, thisArg)</pre>
        <p class="noindent">where <code>thisArg</code> is <code>this</code>, replace the function with an arrow function. Otherwise, replace the inner <code>this</code> with whatever <code>thisArg</code> is. If the call has the form</p>
        <pre class="pre">arr.forEach(method, thisArg)</pre>
        <p class="noindent">use an arrow function invoking <code>thisArg.method(. . .)</code>. Can you come up with any situation where <code>thisArg</code> is required?</p></li>
        <li><p class="list" id="ch07ex05">If you do not supply a comparison function in the <code>sort</code> method of the <code>Array</code> class, then elements are converted to strings and lexicographically compared by UTF-16 code units. Why is this a terrible idea? Come up with arrays of integers or objects where the sort results are useless. What about characters above <code>\u{FFFF}</code>?</p></li>
        <li><p class="list" id="ch07ex06">Suppose an object representing a message has properties for dates and for senders. Sort an array of messages first by date, then by sender. Verify that the <code>sort</code> method is stable: Messages with the same sender continue to be sorted by date after the second sort.<span epub:type="pagebreak" id="page_165"></span></p></li>
        <li><p class="list" id="ch07ex07">Suppose an object representing a person has properties for first and last names. Provide a comparison function that compares last names and then breaks the ties using first names.</p></li>
        <li><p class="list" id="ch07ex08">Implement a comparison function that compares two strings by their Unicode code points, not their UTF-16 code units.</p></li>
        <li><p class="list" id="ch07ex09">Write a function that yields all positions of a target value in an array. For example, <code>indexOf(arr, 0)</code> yields all array index values <code>i</code> where <code>arr[i]</code> is zero. Use <code>map</code> and <code>filter</code>.</p></li>
        <li><p class="list" id="ch07ex10">Write a function that yields all positions at which a given function is <code>true</code>. For example, <code>indexOf(arr, x =&gt; x &gt; 0)</code> yields all array index values <code>i</code> where <code>arr[i]</code> is positive.</p></li>
        <li><p class="list" id="ch07ex11">Compute the spread (that is, the difference between maximum and minimum) of an array using <code>reduce</code>.</p></li>
        <li><p class="list" id="ch07ex12">Given an array of functions <code>[f<sub>1</sub>, f<sub>2</sub>, . . . , f<sub>n</sub>]</code>, obtain the composition function <code>x =&gt; f<sub>1</sub>(f<sub>2</sub>( . . . (f<sub>n</sub>(x)) . . . ))</code> using <code>reduceRight</code>.</p></li>
        <li><p class="list" id="ch07ex13">Implement functions <code>map</code>, <code>filter</code>, <code>forEach</code>, <code>some</code>, <code>every</code> for sets.</p></li>
        <li><p class="list" id="ch07ex14">Implement functions <code>union(set1, set2)</code>, <code>intersection(set1, set2)</code>, <code>difference(set1, set2)</code> that yield the union, intersection, or difference of the sets, without mutating the arguments.</p></li>
        <li><p class="list" id="ch07ex15">Write a function that constructs a <code>Map</code> from an object, so that you can easily construct a map as <code>toMap({ Monday: 1, Tuesday: 2, . . . })</code>.</p></li>
        <li><p class="list" id="ch07ex16">Suppose you use a <code>Map</code> whose keys are point objects of the form <code>{ x:. . ., y:. . . }</code>. What can go wrong when you make queries such as <code>map.get({ x: 0, y: 0 })</code>? What can you do to overcome that?</p></li>
        <li><p class="list" id="ch07ex17">Show that weak sets really work as promised. Start Node.js with the flag <code>--expose-gc</code>. Call <code>process.memoryUsage()</code> to find out how much of the heap is used. Allocate an object:</p>
        <p class="codelink"><a id="rch07pr106" href="ch07_images.xhtml#ch07pr106">Click here to view code image</a></p>
        <pre class="pre">let fred = { name: 'Fred', image: new Int8Array(1024*1024) }</pre>
        <p class="noindent">Verify that the heap usage has gone up by about a megabyte. Set <code>fred</code> to <code>null</code>, run the garbage collector by calling <code>global.gc()</code>, and check that the object was collected. Now repeat, inserting the object into a weak set. Verify that the weak set allows the object to be collected. Repeat with a regular set and show that the object won’t be collected.</p></li>
        <li><p class="list" id="ch07ex18">Write a function to find the endianness of host platform. Use an array buffer and view it both as a data view and a typed array.</p></li>
        </ol>
        </section>
        </section>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780136502166/files/9780136502142.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com