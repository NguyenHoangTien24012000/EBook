<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div class="section" title="The Zakas/Osmani architecture"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec78"></a>The Zakas/Osmani architecture</h1></div></div></div><p>Although the Single Page Application architecture defines the key elements on which a web application that is responsive and efficient should rely, it does not say exactly how to organize our code or how to interact with the components that make up a complex application. We can say that the architecture of an SPA mainly proposes a model of interaction between client and server and suggests how to update the user interface, without saying how to organize the application's code.</p><p>An interesting architecture for large JavaScript applications is the one proposed by Nicholas C. Zakas and Addy Osmani. In contrast to the SPA, the main architectural goal of Zakas and Osmani is to organize the code so that the resulting application is easily maintainable and scalable. The architectural focus is mainly on the basis of SOLID principles we examined in <span><a class="link" href="ch11.html" title="Chapter&nbsp;11.&nbsp;SOLID Principles">Chapter 11</a></span>, <span class="emphasis"><em>SOLID Principles</em></span>. However, it is not in opposition to Single Page Applications, but it is neutral with respect to the navigation model and interaction with the server. Therefore, the Zakas/Osmani architecture can be adopted both for SPA and for traditional multipage applications. Indeed, we can say that this architecture can be considered valid also for languages other than JavaScript, and for contexts different from the web.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"></a>Note</h3><p>The architecture we are describing was defined by Zakas and then revisited by Osmani. Their work can be found at the following URLs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span><a class="ulink" href="http://www.slideshare.net/nzakas/scalable-javascript-application-architecture">http://www.slideshare.net/nzakas/scalable-javascript-application-architecture</a></span></li><li class="listitem" style="list-style-type: disc"><span><a class="ulink" href="https://addyosmani.com/largescalejavascript/">https://addyosmani.com/largescalejavascript/</a></span></li></ul></div></div></div><p>Let's see in detail what's on this architecture.</p><div class="section" title="The overall architecture"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec102"></a>The overall architecture</h2></div></div></div><p>The Zakas/Osmani architecture relies on a set of loosely coupled components organized as shown in the following diagram:</p><div class="mediaobject"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781785889103/files/graphics/image_12_005.jpg" alt="The overall architecture" width="558" height="397"></div><p>The proposed architecture contains a number of components each with a specific role and with a well-defined relationship between them. Each member knows little or nothing about the other components. The entire application is like a puzzle in which each piece has its own role but no one has an overall view of the final result. This is in line with the Single Responsibility Principle, according to which a component must have one goal and one reason to change.</p><p>Let's look at the role of each component of the architecture.</p></div><div class="section" title="The modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec103"></a>The modules</h2></div></div></div><p>A <span class="strong"><strong>module</strong></span> is an autonomous functional component and fully independent from the rest of the application. It contains both functional logic and portions of user interface and is focused on a single goal, according to the Single Responsibility Principle. We can think of it as a combination of JavaScript, HTML, and CSS that can be displayed on a portion of the web page, roughly corresponding to a view in the SPA model. In contexts different from the web, we can imagine a module as a logical unit that provides functionality on a specific aspect of the business logic.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"></a>Note</h3><p>Do not confuse the concept of module in the architecture proposed by Zakas and Osmani with module intended as a mechanism to isolate and combine application code. Zakas used the term module to create an analogy with the modules that make up the international space station: independent elements created by different people in different places and assembled together to build an organic unit.</p></div></div><p>The modules are components that know how to do their own jobs well and do not know anything about the rest of the application. A series of rules define the context in which they can operate:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">They cannot directly interact with other modules</li><li class="listitem" style="list-style-type: disc">They can only interact with the sandbox</li><li class="listitem" style="list-style-type: disc">They can only access the DOM portion under its control</li><li class="listitem" style="list-style-type: disc">They cannot create global objects</li></ul></div><p>A module has its own life cycle determined by the application core that decides when to create and destroy it. A module should be self-contained and independent from other modules in the application. It can fail and be removed without breaking the application. It can be changed with another module that implements the same interface without breaking the application.</p><p>It is possible to create a base module from which other modules can inherit, but in this case, it is recommended to keep the inheritance chain very short. A module should be very light and have as little dependency as possible. The lower the dependency between modules, the greater the flexibility and maintainability.</p></div><div class="section" title="The Sandbox"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec104"></a>The Sandbox</h2></div></div></div><p>We discussed the fact that a module is a self-contained unit and cannot directly communicate with other modules. The only way to communicate with the rest of the application is to use the Sandbox. The <span class="strong"><strong>Sandbox </strong></span>is a layer that exposes a common API to interact with the other components of the application. It has the role of keeping the modules loosely coupled. In fact, by limiting the dependency of each module to a single component, it is easier to remove or replace a module in the application architecture. In addition, the Sandbox can carry out safety checks on the interaction requests toward the rest of the application, preventing unauthorized activities.</p><p>It is possible to create a specific Sandbox for each module or one Sandbox shared among all modules. This is an architectural choice that may depend on the degree of complexity of the internal API of the application. What all the Sandboxes must provide is a standard API for common tasks that a module can perform, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The communication with other modules</li><li class="listitem" style="list-style-type: disc">The execution of Ajax requests</li><li class="listitem" style="list-style-type: disc">Access to the DOM</li><li class="listitem" style="list-style-type: disc">The association and disassociation of event handlers</li></ul></div><p>The key thing to keep in mind is that a Sandbox does not implement any of the preceding features. It is simply an interface to the features implemented by the application core. The existence of this level in the architecture proposed by Zakas and Osmani ensures a decoupling between the implementation of internal services and the interface exposed to the modules, thus promoting an evolution of the application without upheavals. A typical Design Pattern to implement the Sandbox is the facade pattern.</p><div class="section" title="The facade pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec11"></a>The facade pattern</h3></div></div></div><p>The purpose of the <span class="strong"><strong>facade pattern</strong></span> is to provide an interface to filter interactions with one or more components in a system. Its use is quite common and the reasons to prevent direct access to the components can be various:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Providing a simplified interface for access to a complex subsystem</li><li class="listitem" style="list-style-type: disc">Providing a consistent interface with the rest of the application</li><li class="listitem" style="list-style-type: disc">Reducing the coupling between the components</li></ul></div><p>In the definition of a Sandbox, the main reason to use the facade pattern is essentially the last one, that is, reducing the coupling between the various application modules and between the modules and basic functionality.</p><p>The actors involved in the facade pattern are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>One or more clients</strong></span>: These are the components that need to access one or more application subsystems</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>The facade</strong></span>: It is the component providing access to the subsystems</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>One or more subsystems</strong></span>: These are the application components the client wants to access to</li></ul></div><p>The following diagram graphically shows the interactions between the components involved in the pattern:</p><div class="mediaobject"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781785889103/files/graphics/image_12_006.jpg" alt="The facade pattern" width="571" height="440"></div><p>Let's look at an example of facade pattern implementation that aims to reduce coupling between components. Consider the following code:</p><pre class="programlisting">function Facade() {} 
 
Facade.prototype.getElement = function(selector) { 
  return document.querySelector(selector); 
}; 
</pre><p>We defined a constructor function for objects with the <code class="literal">getElement()</code> method. This method uses the <code class="literal">querySelector()</code> method to retrieve a DOM element. In this case, the wrapped subsystem is just the DOM. A client may use this method in the following way:</p><pre class="programlisting">var facade = new Facade(); 
var myElement = facade.getElement(".class"); 
</pre><p>At first glance, the facade might look unnecessarily redundant. Why do we need an intermediate component when we can directly use the <code class="literal">querySelector()</code> method? However, the usefulness of the facade becomes evident if we think that we may change the access mode to DOM elements without affecting the clients. For example, suppose that for some reason we no longer use <code class="literal">querySelector()</code> to access DOM elements, but we want to use jQuery. This change only involves the facade and has no impact on clients.</p><p>In addition, in the architecture we are examining, accessing the DOM through the facade allows us to carry out special checks, such as checking if the client is authorized to access that portion of the DOM.</p></div></div><div class="section" title="The application core"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec105"></a>The application core</h2></div></div></div><p>The <span class="strong"><strong>application core</strong></span> is the central part of the application. It is the only global object in the entire application and includes in its basic tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Allowing registration of the modules</li><li class="listitem" style="list-style-type: disc">Managing the life cycle of the modules</li><li class="listitem" style="list-style-type: disc">Managing the communication between the modules</li><li class="listitem" style="list-style-type: disc">Managing the interaction with the base library</li><li class="listitem" style="list-style-type: disc">Handling errors</li></ul></div><p>The application core should not be contacted directly by the modules, but only through the Sandbox. The Sandbox must be the only component able to contact the application core, and it must be the only component able to interact with the base library. Keeping these components separate enables us to easily swap out just one component with minimal impact on the others.</p><p>The application core has to be designed for extensibility so that it should be easy to add new features and extend existing ones with little effort. This ensures the evolution of the application and its maintainability.</p><div class="section" title="The mediator pattern"><div class="titlepage"><div><div><h3 class="title"><a id="ch12lvl3sec12"></a>The mediator pattern</h3></div></div></div><p>The application core plays a crucial role in managing the communication between modules. To ensure independence between the modules, the application core allows them to communicate by implementing the <span class="strong"><strong>mediator pattern</strong></span>. In this pattern, we have the following actors:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Colleagues</strong></span>: These are two or more components that want to communicate</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Mediator</strong></span>: This is the component that enables communication among the colleagues</li></ul></div><p>A graphic representation of the pattern is shown here:</p><div class="mediaobject"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781785889103/files/graphics/image_12_007.jpg" alt="The mediator pattern" width="540" height="315"></div><p>The colleagues who wish to communicate through the Mediator, register themselves and implement a common interface to send and receive messages. The Mediator keeps track of participants in the communication and deals with the exchange of messages. Let's see how to implement a sample Mediator by analyzing the following code:</p><pre class="programlisting">var Mediator = function() { 
 
  var colleagues = {}; 
 
  return { 
    register: function(colleague) { 
     colleagues[colleague.name] =  colleague; 
     colleague.mediator = this; 
    }, 
 
    send: function(message, sender, receiver) { 
      if (receiver) { 
        receiver.receive(message, sender); 
      } else { 
        for (key in colleagues) { 
          if (colleagues[key] != sender) { 
            colleagues[key].receive(message, sender); 
          } 
        } 
      } 
    } 
  }; 
}; 
</pre><p>We can see that the private object <code class="literal">colleagues</code> keeps track of the participants, which can register via the <code class="literal">register()</code> method. The <code class="literal">send()</code> method allows us to send messages to a specific colleague or to all colleagues.</p><p>An example of a colleague will have the following definition:</p><pre class="programlisting">var Colleague = function(name) { 
  this.name = name; 
  this.mediator = null; 
}; 
 
Colleague.prototype.send = function(message, receiver) { 
  this.mediator.send(message, this, receiver); 
}; 
 
Colleague.prototype.receive = function(message, sender) { 
  //process the message 
}; 
</pre><p>With this infrastructure, if a colleague wants to participate in the communication, he can register as shown here:</p><pre class="programlisting">var mediator = new Mediator(); 
var johnSmith = new Colleague("John"); 
 
mediator.register(johnSmith); 
</pre><p>It can communicate with a specific colleague in the following way:</p><pre class="programlisting">johnSmith.send("Hello!", marioRossi); 
</pre><p>It can communicate with all colleagues using the following statement:</p><pre class="programlisting">johnSmith.send("Hello!"); 
</pre><p>So, the Mediator deals with the indirect interaction of colleagues. The pattern is pretty generic and does not impose restrictions on the interaction modes between the components of a system. Its complexity can grow following the interaction policy between the components and communication approaches should be carefully analyzed. In the example we presented, the communication between the components is synchronous, but we might need asynchronous communication or a message queue or other approaches.</p><p>This generic nature of the mediator pattern leads us to consider, for example, the publisher/subscriber pattern that we saw in <span><a class="link" href="ch08.html" title="Chapter&nbsp;8.&nbsp;Data Binding">Chapter 8</a></span>, <span class="emphasis"><em>Data Binding</em></span>, as a special case of mediator where the communication is one way. Indeed, we can assimilate the role of observable with the mediator, while the role of the colleagues matches the subject and observer. In this case, only the subject generates messages, while only the observers receive them.</p></div></div><div class="section" title="The base library"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec106"></a>The base library</h2></div></div></div><p>The bottom layer of the Zakas/Osmani architecture is the base library. This is the layer on which the entire application is built and provides general functionalities, independent from the specific application, such as:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">DOM manipulation</li><li class="listitem" style="list-style-type: disc">Data serialization and deserialization</li><li class="listitem" style="list-style-type: disc">Ajax communication</li><li class="listitem" style="list-style-type: disc">Browser normalization and abstraction</li></ul></div><p>These features can be provided by a custom or a standard library. The important point is that only the application core knows which libraries are being used and their replacement has an impact only on it and not on the rest of the application.</p></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781785889103/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com