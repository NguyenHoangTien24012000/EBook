<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div class="section" title="A MV* pattern comparison"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"></a>A MV* pattern comparison</h1></div></div></div><p>The three presentation patterns we have seen have many similarities. All them are based on three components, and the interactions between them are quite similar. However, each pattern has its own features that make it more suitable for certain situations and not for others. Let's recap the characteristics of each pattern highlighting those that stand out from each other.</p><p>The MVC pattern proposes cooperation among the three components Model, View, and Controller. Each component has its own role, but each one has some interactions with the other. The View uses the Model for initial binding, while the Controller manages the requests of changing the Model and gives feedbacks to the View. It is a first attempt to make separation of concerns, but some changes in one component may require arrangements in the others. After all, the MVC pattern is historically the oldest presentation pattern. Its origins date back to the 70s, when the first graphical user interfaces were very rudimentary.</p><p>The MVP pattern breaks the dependency between the View and the Model, entrusting to the Presenter to act as an intermediary. The View remains the only component responsible for managing the interaction with the user, while the Presenter is the only component authorized to manage the Model and to respond to the View. This architecture grants more independency among the components by introducing a layered structure.</p><p>The MVVM pattern goes further by assigning it to the intermediary component, the ViewModel, the role of a specialized model for the View. It interacts with the user and directly maps data to what it thinks to be the Model. In reality, this model is a wrapper around the underlying Model and its name, ViewModel, indicates that it represents the model for the View. As for the MVP pattern, this architecture is also&nbsp;layered, but each component depends only on the component that stays right below it. So, the View depends on the ViewModel, but not vice versa. The application of the MVVM pattern requires that the View has some capabilities to bind data and to implement some logic. This is the reason it is best suited to platforms which support bi-directional binding and have graphic elements with advanced built-in capabilities.</p><p>In conclusion, the MVC pattern assigns specific roles to each component, but does not care about coupling. The View and the Controller can interact with each other and the Model. This approach can be efficient from a performance point of view but may incur in security issues, since the entire Model is exposed to the View.</p><p>The MVP pattern makes the Model less vulnerable since it can be accessed just through the Presenter, but the Presenter layer itself may raise performance issues in complex applications.</p><p>The same considerations about the performance issues are valid for MVVM pattern, where a bit of logic is moved from the intermediary layer to the View layer.</p></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781785889103/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com