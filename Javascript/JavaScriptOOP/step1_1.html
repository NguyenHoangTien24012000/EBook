<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div class="chapter" title="Chapter&nbsp;1.&nbsp;A Refresher of Objects"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"></a>Chapter&nbsp;1.&nbsp;A Refresher of Objects</h1></div></div></div><p>Any JavaScript programmer knows that almost everything in this scripting language is an objectâ€”from arrays to functions, from regular expressions to dates. We can say that what is not a primitive data type is an object. But, even the primitive data types such as numbers or strings have object wrappers, that is, they are accessible via objects. So, we can argue that objects are vital in JavaScript, and we need to learn the use of objects as best as we can in order to create better applications. One way, for example, to better use objects is applying the <span class="strong"><strong>Object-Oriented Programming</strong></span> (<span class="strong"><strong>OOP</strong></span>)&nbsp;paradigm.</p><p>However, before diving into principles and pattern of this programming approach, let's start this first chapter with a quick recap about objects fundamentals. In particular, the chapter will discuss:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to create and manage literal objects</li><li class="listitem" style="list-style-type: disc">How to define object constructors</li><li class="listitem" style="list-style-type: disc">What a prototype is and how to use it</li><li class="listitem" style="list-style-type: disc">The new ECMAScript 2015 class construct and its relation to&nbsp;objects, constructors, and prototypes</li></ul></div><div class="section" title="Object literals"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec8"></a>Object literals</h1></div></div></div><p>An object is a container of values combined to form a single data structure that has a particular identity. Normally, in fact, an object is used to represent a specific entity such as a person, an order, an invoice, a reservation, and so on, through an aggregation of data and functionalities.</p><p>The data is&nbsp;called <span class="strong"><strong>properties</strong></span> and are represented by pairs of names and values. The functionalities are usually called <span class="strong"><strong>methods</strong></span> and are represented by functions, even if they are nothing more than the same pairs of names and values as for properties, where values happen to be functions.</p><p>The simplest way to create an object in JavaScript is the literal representation, as shown in the following example:</p><pre class="programlisting">var emptyObject = {}; 
var person = {"name": "John", "surname": "Smith"}; 
</pre><p>Through the literal notation, we represent an object by enclosing its properties and methods in braces. In the first statement, we created an empty object, an object without properties nor methods; all in all, not very useful but important to understand that an object is basically a list of pairs of values and, as with every list, it can be empty.</p><p>In the second declaration, in order to define the object person, we listed two pairs of strings separated by commas. Each pair consists of two strings separated by a colon. The first string is the name of the property while the second one represents its value.</p><div class="section" title="Properties"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec5"></a>Properties</h2></div></div></div><p>To assign a name to the properties of an object, we don't have the same restrictions as for the JavaScript variable names. We can use any string, even if there is some constraint when accessing properties with particular names, as we are going to see.</p><p>The double or single quotes around the property name are generally optional, but they are required when the name does not follow the rules for variable names. So, we could write our definition of person as follows:</p><pre class="programlisting">var person = {name: "John", surname: "Smith"}; 
</pre><p>But if we want a definition like the following, we are forced to use double or single quotes:</p><pre class="programlisting">var person = {"first-name": "John", "second-name": "Smith"}; 
</pre><p>We can assign any value to an object property and any JavaScript expression, including another object. So, we can create nested objects as shown here:</p><pre class="programlisting">var person = {name: "John", 
               surname: "Smith", 
               address: { 
                 street: "13 Duncannon Street", 
                 city: "London", 
                 country: "United Kingdom" 
               }}; 
</pre><p>As we can see, an object with its specific properties is assigned to the <code class="literal">address</code> property.</p><p>To access the values stored in an object property, we have two approaches. The first approach is the so-called <span class="strong"><strong>dot-notation,</strong></span> by which we indicate an object and the property we're interested in, separated by a point:</p><pre class="programlisting">var name = person.name; 
</pre><p>This is usually the most used approach because it is more compact and quite familiar to developers who have worked with other programming languages.</p><p>Using the second approach, we specify the properties of an object by indicating its name as a string in square brackets:</p><pre class="programlisting">var name = person["name"]; 
</pre><p>This approach is mandatory when the property name does not follow the rules for JavaScript's variable names. For example, we cannot use the <span class="strong"><strong>dot-notation</strong></span> to access a property named <code class="literal">first-name</code>.</p><p>If we try to access a non-existing property of an object, an error is not generated but returns the undefined value. In the following example, therefore, the <code class="literal">age</code> variable will get the <span class="emphasis"><em>undefined</em></span> value:</p><pre class="programlisting">var age = person.age; 
</pre><p>If we try to assign a value to a not yet defined property, we actually create this property initializing it with the assigned value:</p><pre class="programlisting">person.age = 28; 
</pre><p>This example shows us the dynamic nature of JavaScript objects. The object's structure is very flexible and can be changed dynamically during the execution of a script. This feature gives us an alternative way for the creation of an object based on a kind of incremental definition. In practice, instead of completely defining a literal representation of our object, we can start from a basic representation and gradually enrich it with the properties we want. Following this approach, we can define our object person as follows:</p><pre class="programlisting">var person = {}; 
person.name = "John"; 
person.surname = "Smith"; 
person.address = { 
                   street: "123 Duncannon Street", 
                   city: "London", 
                   country: "United Kingdom" 
                 }; 
person.age = 28; 
</pre><p>Besides being able to dynamically create the properties of an object, we can also destroy them at runtime using the <code class="literal">delete</code> statement. The following example shows how to remove the <code class="literal">address</code> property from our person object:</p><pre class="programlisting">delete person.address; 
</pre><p>After the removal of the <code class="literal">address</code> property, any attempt to access it will return the value <span class="emphasis"><em>undefined</em></span>.</p></div><div class="section" title="Methods"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec6"></a>Methods</h2></div></div></div><p>While object properties represent data, methods represent actions that an object can perform. From a syntactical point of view, the definition of an object's method is quite similar to the definition of a property. Here's an example:</p><pre class="programlisting">function showFullName() { 
  return "John Smith"; 
} 
 
person.fullName = showFullName; 
</pre><p>We can also assign a method to an object inside its literal representation as shown here:</p><pre class="programlisting">var person = {name: "John", 
        surname: "Smith", 
        showFullName: function() { 
          return "John Smith"; 
        } 
}; 
</pre><p>ECMAScript 2015 allows us to define methods in literal notation in a more direct form, as in the following example:</p><pre class="programlisting">var person = {name: "John", 
        surname: "Smith", 
        showFullName() { 
          return "John Smith"; 
        } 
}; 
</pre><p>Actually, the distinction between properties and methods is somewhat artificial in JavaScript. In fact, since the functions are also objects, a method is nothing more than a property that has been assigned a function.</p><p>Incidentally, since the value assigned to a property can change at runtime, it is possible that a property, which was initially assigned a function, can then be assigned a different value, such as a string or a number. Unlike other programming languages, a method is not a stable condition for a member of an object, it is not a characteristic of a specific property. We can simply affirm that a property is a method when it has a function assigned, but it is a dynamic condition.</p><p>In the previous example, we defined a function that simply returns a string and we assigned that function name to a new property of the person object. Note that we are not assigning the result of the function call to the property, but the function itself by means of its name.</p><p>The <code class="literal">fullName</code> property, since it has been assigned a function, is actually a method. To run it, we must refer to it by specifying parentheses as in a usual function call:</p><pre class="programlisting">var nameAndSurname = person.fullName(); 
</pre><p>Of course, we can assign an anonymous function to a property directly as in the following example:</p><pre class="programlisting">person.fullname = function () { 
  return "John Smith"; 
} 
</pre><p>The method that we just defined in the example is not so useful. It always displays the same string even if we assign a different value to name and surname of the person object. It would be useful to have a way to display the current value of the corresponding properties.</p><p>JavaScript allows us to reach this goal through the <span class="emphasis"><em>this</em></span> keyword. The keyword represents the object when the method is invoked. So, we can rewrite our method in the following way:</p><pre class="programlisting">person.fullName = function () { 
  return this.name + " " + this.surname; 
}; 
</pre><p>This guarantees the correct display of the current data at the time of the call.</p></div></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781785889103/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com