<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div class="chapter" title="Chapter&nbsp;9.&nbsp;Asynchronous Programming and Promises"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"></a>Chapter&nbsp;9.&nbsp;Asynchronous Programming and Promises</h1></div></div></div><p>Asynchronous programming is a part of the nature of JavaScript since its birth. Regardless of the runtime environment of JavaScript, you cannot ignore the execution of asynchronous code, whether it is the management of user's interaction with a graphical interface or the interaction with a server or a hardware component of the system.</p><p>This chapter will discuss how to manage asynchronous code in JavaScript by analyzing the classical approach based on callback functions, pointing out its intrinsic drawbacks and exploring new approaches such as the ones based on Promises and Generators.</p><p>The following topics will be discussed in the chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Events and asynchronous calls</li><li class="listitem" style="list-style-type: disc">Callback functions</li><li class="listitem" style="list-style-type: disc">Troubles with callbacks</li><li class="listitem" style="list-style-type: disc">ES6 Promises</li><li class="listitem" style="list-style-type: disc">A Generator-based approach</li></ul></div><div class="section" title="Is JavaScript asynchronous?"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec58"></a>Is JavaScript asynchronous?</h1></div></div></div><p>In JavaScript programming, we often deal with activities virtually executed concurrently. For instance, events can occur independently from the main execution flow of an application and many events can occur at the same time. If we attached handlers for many events, we expect these to run immediately upon the occurrence of the associated event.</p><p>Actually, things are not exactly like that. JavaScript concurrency model is not really parallel or multithread. Even if events can occur in parallel, their handling is sequential and the interactions between the involved codes is asynchronous. This means that an event can occur at a given time, but the execution of its handler can occur after some time.</p><div class="section" title="Event loop and asynchronous code"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec64"></a>Event loop and asynchronous code</h2></div></div></div><p>In languages that support concurrency, the code of a thread can be interrupted to take the code of another thread forward. In JavaScript, everything happens in one single thread. The concurrency model that gives the impression that many threads are executing is the <span class="strong"><strong>event loop</strong></span>-each event inserts a message into a queue that will be sequentially processed by the JavaScript runtime in an endless loop.</p><p>Basically, the main task of a JavaScript engine is to check for messages in the queue and to run the code of event handlers before moving to the next message. It is important to understand that the code executed between a message and the next one is executed without any interruption. Any event that occurs during the execution of a cycle of the event loop can't stop it.</p><p>We can realize this behavior by doing some experiments with the timers. Consider, for example, the following code:</p><pre class="programlisting">console.log("First"); 
setTimeout(function() { console.log("Second"); }, 300); 
console.log("Third"); 
</pre><p>As we expect, the output of its execution is as follows:</p><pre class="programlisting">First 
Third 
Second 
</pre><p>What happens if we set the timeout interval to zero?</p><pre class="programlisting">console.log("First"); 
setTimeout(function() { console.log("Second"); }, 0); 
console.log("Third"); 
</pre><p>Maybe we would expect that the second statement is executed immediately. Instead, the output will be the same as before. Even if we set an empty timeout, the execution of <code class="literal">setTimeout()</code> puts a message in the message queue and cannot stop the execution of current code. So, the <code class="literal">Second</code>&nbsp;string will be sent to the console after the completion of current execution.</p></div><div class="section" title="Events, Ajax, and other asynchronous stuff"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec65"></a>Events, Ajax, and other asynchronous stuff</h2></div></div></div><p>Writing JavaScript applications we have many chances to write asynchronous code. In addition to timers, we usually write asynchronous code when we need to manage events, such as DOM events in a browser or when we need to interact with a server through Ajax. But, we deal with asynchronous programming also when handling server-sent event, when managing communication with web workers, when accessing a file system, and so on. Since JavaScript is increasingly spreading even outside the Web, the role of asynchronous programming is gaining growing importance. So, we need to understand how it works and what kind of problems the asynchronous code may raise.</p></div></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781785889103/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com