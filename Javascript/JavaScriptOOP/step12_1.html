<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><div class="chapter" title="Chapter&nbsp;12.&nbsp;Modern Application Architectures"><div class="titlepage"><div><div><h1 class="title"><a id="ch12"></a>Chapter&nbsp;12.&nbsp;Modern Application Architectures</h1></div></div></div><p>When the complexity of an application grows, we cannot write code without a well-defined structure that gives solidity and robustness and guarantees long-term maintainability. Without such structure, our project may collapse because we lose control over the code, and it becomes more and more complex, unreadable, and unchangeable. The structure we need is an architecture that combines together the various components of a piece of software, in order to satisfy the explicit and implicit requirements of a software project.</p><p>Architecture evolves with technology, and this is particularly true in the web context. So, when we search the right architecture for the goals of our project, we should take into account which architecture is suitable with a certain technology.</p><p>In this chapter, we will explore the main architectures for modern JavaScript applications and will analyze how they work and which benefits they provide. During the discussion, we will analyze a couple of design patterns that allows us to implement a fundamental feature that any architecture should aim—loose coupling.</p><p>We will discuss the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Goals of an application architecture</li><li class="listitem" style="list-style-type: disc">From traditional web applications to Single Page Applications</li><li class="listitem" style="list-style-type: disc">The Zakas/Osmani architecture for scalable applications</li><li class="listitem" style="list-style-type: disc">The facade and mediator patterns</li><li class="listitem" style="list-style-type: disc">The cross-cutting features implementation</li><li class="listitem" style="list-style-type: disc">The isomorphic applications</li></ul></div><div class="section" title="From scripts to applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch12lvl1sec76"></a>From scripts to applications</h1></div></div></div><p>The growing role of JavaScript in application development is clear to everyone. Once it was a simple language to add interactivity to HTML pages, now the role of JavaScript has become increasingly important enough to completely overturn the relationship with HTML, its historical partner. In fact, a few years ago, web applications were primarily HTML markup with the addition of some JavaScript scripts; today, the majority of complex applications are represented by JavaScript code that controls the HTML markup generation and display.</p><p>Even outside of the web browser context, the role of JavaScript is increasing. Today, a JavaScript application is able to run on servers, desktop applications, mobile devices, and even on embedded systems.</p><p>This evolution gives JavaScript more responsibility than it had, when its role was mostly about interactivity management and posting data to the server. What used to be a collection of simple scripts has now become a complex combination of components that interact with each other to perform a certain job—it has become an application.</p><div class="section" title="What is a large-scale application?"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec97"></a>What is a large-scale application?</h2></div></div></div><p>Of course, an application requires a certain organization with respect to a collection of scripts. Indeed, while in most cases each script is limited to exercising its mission and possibly interacting with other scripts, an application requires a greater coordination among the components, a centralized management features such as error handling, logging, and so on. This responsibility, along with others, becomes more evident when an application grows and becomes large.</p><p>But what exactly is a large-scale application?</p><p>The answer to this question is quite subjective, since in most cases it depends on the experience of the single developer. Some people associate the size to the number of lines of code, others combine the number of features or components involved. In any case, it is difficult to give an objective definition of what actually is a very large application.</p><p>A definition with which I can agree with is that provided by Addy Osmani:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>Large-scale JavaScript apps are non-trivial applications requiring significant developer effort to maintain, where most heavy lifting of data manipulation and display falls to the browser.</em></span></p></blockquote></div><p>Although Osmani's definition explicitly refers to web applications, I think that it can be considered valid for any type of application. The key point is that the size of an application does not depend on a specific number of a technical application's elements, but on the <span class="strong"><strong>effort required for its maintenance</strong></span>, that is from an activity in the future. The size of an application essentially depends on its complexity and the energy required to meet future requests for change. So this is not a scientific measurement, but yet another subjective point of view. However, it emphasizes a fundamental aspect of programming—the software changes over time.</p><p>With this basic assumption, we have to design our application so that it has a structure that can make our life easier in future developments. In other words, we need to define an architecture for our applications.</p></div><div class="section" title="What is an application architecture?"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec98"></a>What is an application architecture?</h2></div></div></div><p>The architecture of an application is the definition of its structure and the design of the interactions between its components decided according to specific project goals. It is very important to note that an application's architecture is determined not only by its features, but also by the project's cross requirements, such as performance, extensibility, maintainability, security, reusability, and so on. This means that there is no universal architecture, an architecture valid for any application. There are specific architectures for specific requirements. However, we have architectural patterns used in several common scenarios from which we can be inspired to choose a model for our application. As an example, the most common architectural patterns include the client/server architecture, the layered architecture, the service-oriented architecture, and so on. Of course, these are very general architectural patterns. More specific architectural pattern helps us to structure our applications in a more targeted way, as we will see later in this chapter.</p></div><div class="section" title="Goals of an architecture design"><div class="titlepage"><div><div><h2 class="title"><a id="ch12lvl2sec99"></a>Goals of an architecture design</h2></div></div></div><p>Usually architecture decisions for an application are among the most difficult aspects to modify over time and have long-term consequences on an application's life. For this reason, it is necessary to define the architecture of an application accurately and wisely, trying to balance the three categories of requirements that usually drive a software project:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>User or customer requirements</strong></span>: Generally, these features and their usability are to be implemented, but may include any other constraints explicitly declared by the customer or user.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Business requirements</strong></span>: This category includes requirements concerning the project's cost-effectiveness, both as per the first release and subsequent evolution and maintenance; some constraints, such as access to specific features based on a license, fall also into this category of requirements.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>System requirements</strong></span>: These requirements are related to the hardware and software platform on which the application will run and any constraints on deployment.</li></ul></div><p>The satisfaction of these three categories of requirements must be taken into account when choosing a specific architecture for our application.</p></div></div></div></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781785889103/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com