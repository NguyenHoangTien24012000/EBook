<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 6. Objects"><div class="chapter" id="objects">
        <h1><span class="label">Chapter 6. </span>Objects</h1>
        
        
        <p>Objects<a data-type="indexterm" data-primary="objects" data-secondary="introduction to" id="idm46198552098616"></a> are JavaScript’s most fundamental datatype, and you have
        already seen them many times in the chapters that precede this
        one. Because objects are so important to the JavaScript language, it
        is important that you understand how they work in detail, and this
        chapter provides that detail. It begins with a formal overview of
        objects, then dives into practical sections about creating
        objects and querying, setting, deleting, testing, and enumerating the
        properties of objects. These property-focused sections are followed by
        sections that explain how to extend, serialize, and define important
        methods on objects. Finally, the chapter concludes with a long section
        about new object literal syntax in ES6 and more recent versions of the
        language.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.1 Introduction to Objects"><div class="sect1" id="objectsintro">
        <h1>6.1 Introduction to Objects</h1>
        
        <p>An object is a composite value: it aggregates multiple values
        (primitive values or other objects) and allows you to store and
        retrieve those values by name. An<a data-type="indexterm" data-primary="properties" data-secondary="naming" id="idm46198552094280"></a> object is an unordered collection of
        <em>properties</em>, each of which has a name and a value. Property names
        are usually strings (although, as we’ll see in
        <a data-type="xref" href="#symbols-as-property-names">§6.10.3</a>, property names can also be Symbols), so
        we can say that objects map strings to values.  This string-to-value
        mapping goes by various names—you are probably already familiar with
        the fundamental data structure<a data-type="indexterm" data-primary="hashtables" id="idm46198552091544"></a><a data-type="indexterm" data-primary="dictionaries" id="idm46198552090872"></a><a data-type="indexterm" data-primary="arrays" data-secondary="associative arrays" id="idm46198552090200"></a><a data-type="indexterm" data-primary="associative arrays" id="idm46198552089256"></a> under the name “hash,” “hashtable,”
        “dictionary,” or “associative array.” An object is more than a simple
        string-to-value map, however. In addition to maintaining its own set
        of properties, a JavaScript object also inherits the properties of
        another object, known as its “prototype.” The methods of an object
        are typically inherited properties, and<a data-type="indexterm" data-primary="inheritance" id="idm46198552088072"></a><a data-type="indexterm" data-primary="prototypal inheritance" id="idm46198552087400"></a> this “prototypal inheritance”
        is a key feature of JavaScript.</p>
        
        <p>JavaScript objects are dynamic—properties can usually be added and
        deleted—but they can be used to simulate the static objects and
        “structs” of statically typed languages. They can also be used (by
        ignoring the value part of the string-to-value mapping) to represent
        sets of strings.</p>
        
        <p>Any value in JavaScript that is not a string, a number, a Symbol, or <code>true</code>,
        <code>false</code>, <code>null</code>, or <code>undefined</code> is an object. And even though strings,
        numbers, and booleans are not objects, they can behave like immutable
        objects.</p>
        
        <p>Recall<a data-type="indexterm" data-primary="objects" data-secondary="mutable object references" id="idm46198552082936"></a><a data-type="indexterm" data-primary="mutability" id="idm46198552081992"></a> from <a data-type="xref" href="ch03.html#mutableandimmutable">§3.8</a> that objects are <em>mutable</em> and
        manipulated by reference rather than by value. If the variable <code>x</code>
        refers to an object and the code <code>let y = x;</code> is executed, the
        variable <code>y</code> holds a reference to the same object, not a copy of that
        object. Any <span class="keep-together">modifications</span> made to the object through the variable <code>y</code>
        are also visible through the variable <code>x</code>.</p>
        
        <p>The most common things to do with objects are to create them and set,
        query, delete, test, and enumerate their properties. These fundamental
        operations are described in the opening sections of this chapter. The
        sections after that cover more advanced <span class="keep-together">topics.</span></p>
        
        <p>A <em>property</em> has a name and a value. A property name may be any
        string, including the empty string (or any Symbol), but no object may have two
        properties with the same name. The value may be any JavaScript value,
        or it may be a getter or setter function (or both). We’ll learn
        about getter and setter functions in <a data-type="xref" href="#gettersandsetters">§6.10.6</a>.</p>
        
        <p>It is sometimes important to be able to distinguish between properties
        defined directly on an object and those that are inherited from a
        prototype object. JavaScript<a data-type="indexterm" data-primary="own properties" id="idm46198552073112"></a><a data-type="indexterm" data-primary="non-inherited properties" id="idm46198552072408"></a><a data-type="indexterm" data-primary="properties" data-secondary="non-inherited properties" id="idm46198552071720"></a> uses the term <em>own property</em> to refer
        to non-inherited properties.</p>
        
        <p>In<a data-type="indexterm" data-primary="properties" data-secondary="property attributes" id="idm46198552069800"></a> addition to its name and value, each property has three <em>property
        attributes</em>:</p>
        
        <ul>
        <li>
        <p>The <em>writable</em> attribute<a data-type="indexterm" data-primary="writable attribute" id="idm46198552066664"></a> specifies whether the value of the property
        can be set.</p>
        </li>
        <li>
        <p>The <em>enumerable</em> attribute<a data-type="indexterm" data-primary="enumerable attribute" id="idm46198552064440"></a> specifies whether the property name is
        returned by a <code>for/in</code> loop.</p>
        </li>
        <li>
        <p>The <em>configurable</em> attribute<a data-type="indexterm" data-primary="configurable attribute" id="idm46198552061784"></a> specifies whether the property can be
        deleted and whether its attributes can be altered.</p>
        </li>
        </ul>
        
        <p>Many of JavaScript’s built-in objects have properties that are
        read-only, non-enumerable, or non-configurable. By default, however,
        all properties of the objects you create are writable, enumerable, and
        configurable. <a data-type="xref" href="ch14.html#propertydescriptors">§14.1</a> explains techniques for
        specifying non-default property attribute values for your objects.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.2 Creating Objects"><div class="sect1" id="creatingobjects">
        <h1>6.2 Creating Objects</h1>
        
        <p>Objects<a data-type="indexterm" data-primary="objects" data-secondary="creating" id="Ocreate06"></a> can be created with object literals, with the <code>new</code> keyword,
        and with the <code>Object.create()</code> function. The subsections below
        describe each technique.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.2.1 Object Literals"><div class="sect2" id="objectliterals">
        <h2>6.2.1 Object Literals</h2>
        
        <p>The<a data-type="indexterm" data-primary="object literals" data-secondary="simplest form of" id="idm46198552052984"></a> easiest way to create an object is to include an object literal in
        your JavaScript code. In its simplest form, an <em>object literal</em> is a
        comma-separated list of colon-separated name:value pairs, enclosed
        within curly braces. A property name is a JavaScript identifier or a
        string literal (the empty string is allowed). A property value is any
        JavaScript expression; the value of the expression (it may be a
        primitive value or an object value) becomes the value of the property.
        Here are some examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">empty</code> <code class="o">=</code> <code class="p">{};</code>                          <code class="c1">// An object with no properties</code>
        <code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">0</code> <code class="p">};</code>              <code class="c1">// Two numeric properties</code>
        <code class="kd">let</code> <code class="nx">p2</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">point</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">point</code><code class="p">.</code><code class="nx">y</code><code class="o">+</code><code class="mi">1</code> <code class="p">};</code>   <code class="c1">// More complex values</code>
        <code class="kd">let</code> <code class="nx">book</code> <code class="o">=</code> <code class="p">{</code>
            <code class="s2">"main title"</code><code class="o">:</code> <code class="s2">"JavaScript"</code><code class="p">,</code>          <code class="c1">// These property names include spaces,</code>
            <code class="s2">"sub-title"</code><code class="o">:</code> <code class="s2">"The Definitive Guide"</code><code class="p">,</code> <code class="c1">// and hyphens, so use string literals.</code>
            <code class="k">for</code><code class="o">:</code> <code class="s2">"all audiences"</code><code class="p">,</code>                <code class="c1">// for is reserved, but no quotes.</code>
            <code class="nx">author</code><code class="o">:</code> <code class="p">{</code>                            <code class="c1">// The value of this property is</code>
                <code class="nx">firstname</code><code class="o">:</code> <code class="s2">"David"</code><code class="p">,</code>              <code class="c1">// itself an object.</code>
                <code class="nx">surname</code><code class="o">:</code> <code class="s2">"Flanagan"</code>
            <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>A trailing comma following the last property in an object literal is
        legal, and some programming styles encourage the use of these trailing
        commas so you’re less likely to cause a syntax error if you add a new
        property at the end of the object literal at some later time.</p>
        
        <p>An object literal is an expression that creates and initializes a new
        and distinct object each time it is evaluated. The value of each
        property is evaluated each time the literal is evaluated. This means
        that a single object literal can create many new objects if it appears
        within the body of a loop or in a function that is called repeatedly, and
        that the property values of these objects may differ from each other.</p>
        
        <p>The object literals shown here use simple syntax that has been legal
        since the earliest versions of JavaScript. Recent versions of the
        language have introduced a number of new object literal features,
        which are covered in <a data-type="xref" href="#extended-object-literal-syntax">§6.10</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.2.2 Creating Objects with new"><div class="sect2" id="creatingobjectswithnew">
        <h2>6.2.2 Creating Objects with new</h2>
        
        <p>The<a data-type="indexterm" data-primary="new keyword" id="idm46198551969624"></a><a data-type="indexterm" data-primary="keywords" data-secondary="new keyword" id="idm46198551968888"></a><a data-type="indexterm" data-primary="functions" data-secondary="function invocation" id="idm46198551967944"></a> <code>new</code> operator creates and initializes a new object. The <code>new</code>
        keyword must be followed by a function invocation. A<a data-type="indexterm" data-primary="constructors" data-secondary="examples of" id="idm46198551965976"></a> function used in
        this way is called a <em>constructor</em> and serves to initialize a newly
        created object. JavaScript includes constructors for its built-in
        types. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Object</code><code class="p">();</code>  <code class="c1">// Create an empty object: same as {}.</code>
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Array</code><code class="p">();</code>   <code class="c1">// Create an empty array: same as [].</code>
        <code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">();</code>    <code class="c1">// Create a Date object representing the current time</code>
        <code class="kd">let</code> <code class="nx">r</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">();</code>     <code class="c1">// Create a Map object for key/value mapping</code></pre>
        
        <p>In addition to these built-in constructors, it is common to define
        your own constructor functions to initialize newly created
        objects. Doing so is covered in <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.2.3 Prototypes"><div class="sect2" id="prototypes">
        <h2>6.2.3 Prototypes</h2>
        
        <p>Before<a data-type="indexterm" data-primary="prototypes" id="idm46198551934328"></a> we can cover the third object creation technique, we must pause
        for a moment to explain prototypes. Almost every JavaScript object has
        a second JavaScript object associated with it. This second object is
        known as a <em>prototype</em>, and the first object inherits properties from
        the prototype.</p>
        
        <p>All<a data-type="indexterm" data-primary="Object.prototype" id="idm46198551932424"></a> objects created by object literals have the same prototype object,
        and we can refer to this prototype object in JavaScript code as
        <code>Object.prototype</code>.  Objects created using the <code>new</code> keyword and a
        constructor invocation use the value of the <code>prototype</code> property of
        the constructor function as their prototype. So the object created by
        <code>new Object()</code> inherits from <code>Object.prototype</code>, just as the object
        created by <code>{}</code> does. Similarly, the object created by <code>new Array()</code>
        uses <code>Array.prototype</code> as its prototype, and the object created by
        <code>new Date()</code> uses <code>Date.prototype</code> as its prototype. This can be confusing when first learning JavaScript. Remember: almost all objects have a <em>prototype</em>, but only a relatively small number of objects have a <code>prototype</code> property. It is these objects with <code>prototype</code> properties that define the <em>prototypes</em> for all the other objects.</p>
        
        <p><code>Object.prototype</code> is one of the rare objects that has no prototype:
        it does not inherit any properties. Other prototype objects are normal
        objects that do have a prototype. Most built-in constructors (and most
        user-defined constructors) have a prototype that inherits from
        <code>Object.prototype</code>. For example, <code>Date.prototype</code> inherits properties
        from <code>Object.prototype</code>, so a Date object created by <code>new Date()</code>
        inherits properties from both <code>Date.prototype</code> and
        <code>Object.prototype</code>. This<a data-type="indexterm" data-primary="prototype chains" id="idm46198551921320"></a> linked series of prototype objects is known
        as a <em>prototype chain</em>.</p>
        
        <p>An explanation of how property inheritance works is in
        <a data-type="xref" href="#inheritance">§6.3.2</a>.  <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a> explains the connection between
        prototypes and constructors in more detail: it shows how to define new
        “classes” of objects by writing a constructor function and setting its
        <code>prototype</code> property to the prototype object to be used by the
        “instances” created with that constructor. And we’ll learn how to
        query (and even change) the prototype of an object in <a data-type="xref" href="ch14.html#prototypeattr">§14.3</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.2.4 Object.create()"><div class="sect2" id="objectcreate">
        <h2>6.2.4 Object.create()</h2>
        
        <p><code>Object.create()</code> creates<a data-type="indexterm" data-primary="Object.create() function" id="idm46198551913944"></a> a new object, using its first argument as
        the prototype of that object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o1</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">});</code>     <code class="c1">// o1 inherits properties x and y.</code>
        <code class="nx">o1</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">o1</code><code class="p">.</code><code class="nx">y</code>                               <code class="c1">// =&gt; 3</code></pre>
        
        <p>You can pass <code>null</code> to create a new object that does not have a
        prototype, but if you do this, the newly created object will not
        inherit anything, not even basic methods like <code>toString()</code> (which
        means it won’t work with the <code>+</code> operator either):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o2</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="kc">null</code><code class="p">);</code>             <code class="c1">// o2 inherits no props or methods.</code></pre>
        
        <p>If you want to create an ordinary empty object (like the object returned by
        <code>{}</code> or <code>new Object()</code>), pass <code>Object.prototype</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o3</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">);</code> <code class="c1">// o3 is like {} or new Object().</code></pre>
        
        <p>The ability to create a new object with an arbitrary prototype is a
        powerful one, and we’ll use <code>Object.create()</code> in a number of places
        throughout this chapter. (<code>Object.create()</code> also takes an optional
        second argument that describes the properties of the new object. This
        second argument is an advanced feature covered in
        <a data-type="xref" href="ch14.html#propertydescriptors">§14.1</a>.)</p>
        
        <p>One use for <code>Object.create()</code> is when you want to guard against
        unintended (but nonmalicious) modification of an object by a library
        function that you don’t have control over. Instead of passing the
        object directly to the function, you can pass an object that inherits
        from it. If the function reads properties of that object, it will see
        the inherited values. If it sets properties, however, those writes
        will not affect the original object.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="s2">"don't change this value"</code> <code class="p">};</code>
        <code class="nx">library</code><code class="p">.</code><code class="kd">function</code><code class="p">(</code><code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">o</code><code class="p">));</code>  <code class="c1">// Guard against accidental modifications</code></pre>
        
        <p>To understand why this works, you need to know how properties are
        queried and set in JavaScript. These are the topics of the next
        section.<a data-type="indexterm" data-primary="" data-startref="Ocreate06" id="idm46198551697944"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.3 Querying and Setting Properties"><div class="sect1" id="queryingandsettingprops">
        <h1>6.3 Querying and Setting Properties</h1>
        
        <p>To<a data-type="indexterm" data-primary="objects" data-secondary="querying and setting properties" id="Oquery06"></a><a data-type="indexterm" data-primary="properties" data-secondary="querying and setting" id="Pquery06"></a><a data-type="indexterm" data-primary=". (dot operator)" id="idm46198551692616"></a><a data-type="indexterm" data-primary="dot operator (.)" id="idm46198551691944"></a><a data-type="indexterm" data-primary="[] (square brackets)" id="idm46198551691272"></a><a data-type="indexterm" data-primary="square brackets ([])" id="idm46198551690600"></a> obtain the value of a property, use the dot (<code>.</code>) or square bracket
        (<code>[]</code>) operators described in <a data-type="xref" href="ch04.html#propertyexprs">§4.4</a>. The lefthand side
        should be an expression whose value is an object. If using the dot
        operator, the righthand side must be a simple identifier that names the
        property. If using square brackets, the value within the brackets must
        be an expression that evaluates to a string that contains the desired
        property name:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">author</code> <code class="o">=</code> <code class="nx">book</code><code class="p">.</code><code class="nx">author</code><code class="p">;</code>       <code class="c1">// Get the "author" property of the book.</code>
        <code class="kd">let</code> <code class="nx">name</code> <code class="o">=</code> <code class="nx">author</code><code class="p">.</code><code class="nx">surname</code><code class="p">;</code>      <code class="c1">// Get the "surname" property of the author.</code>
        <code class="kd">let</code> <code class="nx">title</code> <code class="o">=</code> <code class="nx">book</code><code class="p">[</code><code class="s2">"main title"</code><code class="p">];</code> <code class="c1">// Get the "main title" property of the book.</code></pre>
        
        <p>To create or set a property, use a dot or square brackets as you would
        to query the property, but put them on the lefthand side of an
        assignment expression:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">book</code><code class="p">.</code><code class="nx">edition</code> <code class="o">=</code> <code class="mi">7</code><code class="p">;</code>                   <code class="c1">// Create an "edition" property of book.</code>
        <code class="nx">book</code><code class="p">[</code><code class="s2">"main title"</code><code class="p">]</code> <code class="o">=</code> <code class="s2">"ECMAScript"</code><code class="p">;</code>  <code class="c1">// Change the "main title" property.</code></pre>
        
        <p>When using square bracket notation, we’ve said that the expression
        inside the square brackets must evaluate to a string. A more precise
        statement is that the expression must evaluate to a string or a value
        that can be converted to a string or to a Symbol
        (<a data-type="xref" href="#symbols-as-property-names">§6.10.3</a>). In <a data-type="xref" href="ch07.html#arrays">Chapter&nbsp;7</a>, for example, we’ll see
        that it is common to use numbers inside the square brackets.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.3.1 Objects As Associative Arrays"><div class="sect2" id="associativearrays">
        <h2>6.3.1 Objects As Associative Arrays</h2>
        
        <p>As<a data-type="indexterm" data-primary="arrays" data-secondary="associative arrays" id="idm46198551634168"></a><a data-type="indexterm" data-primary="associative arrays" id="idm46198551633160"></a> explained in the preceding section, the following two JavaScript expressions have the same
        value:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">object</code><code class="p">.</code><code class="nx">property</code>
        <code class="nx">object</code><code class="p">[</code><code class="s2">"property"</code><code class="p">]</code></pre>
        
        <p>The first syntax, using the dot and an identifier, is like the syntax
        used to access a static field of a struct or object in C or Java. The
        second syntax, using square brackets and a string, looks like array
        access, but to an array indexed by strings rather than by
        numbers. This<a data-type="indexterm" data-primary="hashtables" id="idm46198551630440"></a><a data-type="indexterm" data-primary="dictionaries" id="idm46198551629944"></a> kind of array is known as an <em>associative array</em> (or hash
        or map or dictionary). JavaScript objects are associative arrays, and
        this section explains why that is important.</p>
        
        <p>In C, C++, Java, and similar strongly typed languages, an object can
        have only a fixed number of properties, and the names of these
        properties must be defined in advance. Since JavaScript is a loosely
        typed language, this rule does not apply: a program can create any
        number of properties in any object. When you use the <code>.</code> operator to
        access a property of an object, however, the name of the property is
        expressed as an identifier. Identifiers must be typed literally into
        your JavaScript program; they are not a datatype, so they cannot be
        manipulated by the program.</p>
        
        <p>On the other hand, when you access a property of an object with the
        <code>[]</code> array notation, the name of the property is expressed as a
        string. Strings are JavaScript datatypes, so they can be manipulated
        and created while a program is running. So, for example, you can write
        the following code in JavaScript:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">addr</code> <code class="o">=</code> <code class="s2">""</code><code class="p">;</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">4</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">addr</code> <code class="o">+=</code> <code class="nx">customer</code><code class="p">[</code><code class="sb">`address</code><code class="si">${</code><code class="nx">i</code><code class="si">}</code><code class="sb">`</code><code class="p">]</code> <code class="o">+</code> <code class="s2">"\n"</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>This code reads and concatenates the <code>address0</code>, <code>address1</code>,
        <code>address2</code>, and <code>address3</code> properties of the <code>customer</code> object.</p>
        
        <p>This brief example demonstrates the flexibility of using array
        notation to access properties of an object with string
        expressions. This code could be rewritten using the dot notation,
        but there are cases in which only the array notation will do. Suppose,
        for example, that you are writing a program that uses network
        resources to compute the current value of the user’s stock market
        investments. The program allows the user to type in the name of each
        stock they own as well as the number of shares of each stock. You
        might use an object named <code>portfolio</code> to hold this information. The
        object has one property for each stock. The name of the property is
        the name of the stock, and the property value is the number of shares
        of that stock. So, for example, if a user holds 50 shares of stock in
        IBM, the <code>portfolio.ibm</code> property has the value <code>50</code>.</p>
        
        <p>Part of this program might be a function for adding a new stock to the
        portfolio:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">addstock</code><code class="p">(</code><code class="nx">portfolio</code><code class="p">,</code> <code class="nx">stockname</code><code class="p">,</code> <code class="nx">shares</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">portfolio</code><code class="p">[</code><code class="nx">stockname</code><code class="p">]</code> <code class="o">=</code> <code class="nx">shares</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>Since the user enters stock names at runtime, there is no way that you
        can know the property names ahead of time. Since you can’t know the
        property names when you write the program, there is no way you can use
        the <code>.</code> operator to access the properties of the <code>portfolio</code>
        object. You can use the <code>[]</code> operator, however, because it uses a
        string value (which is dynamic and can change at runtime) rather than
        an identifier (which is static and must be hardcoded in the program)
        to name the property.</p>
        
        <p>In <a data-type="xref" href="ch05.html#statements">Chapter&nbsp;5</a>, we introduced the <code>for/in</code> loop (and we’ll see it again shortly, in <a data-type="xref" href="#enumeratingprops">§6.6</a>). The power of this JavaScript
        statement becomes clear when you consider its use with associative
        arrays. Here is how you would use it when computing the total value of a
        <span class="keep-together">portfolio:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">computeValue</code><code class="p">(</code><code class="nx">portfolio</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">total</code> <code class="o">=</code> <code class="mf">0.0</code><code class="p">;</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">stock</code> <code class="k">in</code> <code class="nx">portfolio</code><code class="p">)</code> <code class="p">{</code>       <code class="c1">// For each stock in the portfolio:</code>
                <code class="kd">let</code> <code class="nx">shares</code> <code class="o">=</code> <code class="nx">portfolio</code><code class="p">[</code><code class="nx">stock</code><code class="p">];</code>  <code class="c1">// get the number of shares</code>
                <code class="kd">let</code> <code class="nx">price</code> <code class="o">=</code> <code class="nx">getQuote</code><code class="p">(</code><code class="nx">stock</code><code class="p">);</code>    <code class="c1">// look up share price</code>
                <code class="nx">total</code> <code class="o">+=</code> <code class="nx">shares</code> <code class="o">*</code> <code class="nx">price</code><code class="p">;</code>        <code class="c1">// add stock value to total value</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">total</code><code class="p">;</code>                       <code class="c1">// Return total value.</code>
        <code class="p">}</code></pre>
        
        <p>JavaScript objects are commonly used as associative arrays as shown
        here, and it is important to understand how this works. In ES6 and later, however, the Map class described in <a data-type="xref" href="ch11.html#mapclass">§11.1.2</a> is often
        a better choice than using a plain object.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.3.2 Inheritance"><div class="sect2" id="inheritance">
        <h2>6.3.2 Inheritance</h2>
        
        <p>JavaScript<a data-type="indexterm" data-primary="properties" data-secondary="inheriting" id="idm46198551352952"></a><a data-type="indexterm" data-primary="prototypal inheritance" id="idm46198551351944"></a><a data-type="indexterm" data-primary="inheritance" id="idm46198551351272"></a><a data-type="indexterm" data-primary="own properties" id="idm46198551350600"></a> objects have a set of “own properties,” and they also
        inherit a set of properties from their prototype object. To understand
        this, we must consider property access in more detail. The examples in
        this section use the <code>Object.create()</code> function to create objects with
        specified prototypes. We’ll see in <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>, however, that every time
        you create an instance of a class with <code>new</code>, you are creating an
        object that inherits properties from a prototype object.</p>
        
        <p>Suppose you query the property <code>x</code> in the object <code>o</code>. If <code>o</code> does not
        have an own property with that name, the prototype object of <code>o</code><sup><a data-type="noteref" id="idm46198551345848-marker" href="ch06.html#idm46198551345848">1</a></sup> is
        queried for the property <code>x</code>. If the prototype object does not have an
        own property by that name, but has a prototype itself, the query is
        performed on the prototype of the prototype. This continues until the
        property <code>x</code> is found or until an object with a <code>null</code> prototype is
        searched. As you can see, the<a data-type="indexterm" data-primary="prototypes" id="idm46198551342312"></a> <code>prototype</code> attribute of an object
        creates a chain or linked list from which properties are inherited:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{};</code>               <code class="c1">// o inherits object methods from Object.prototype</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>                  <code class="c1">// and it now has an own property x.</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">o</code><code class="p">);</code> <code class="c1">// p inherits properties from o and Object.prototype</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>                  <code class="c1">// and has an own property y.</code>
        <code class="kd">let</code> <code class="nx">q</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">p</code><code class="p">);</code> <code class="c1">// q inherits properties from p, o, and...</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">z</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code>                  <code class="c1">// ...Object.prototype and has an own property z.</code>
        <code class="kd">let</code> <code class="nx">f</code> <code class="o">=</code> <code class="nx">q</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code>     <code class="c1">// toString is inherited from Object.prototype</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">q</code><code class="p">.</code><code class="nx">y</code>                 <code class="c1">// =&gt; 3; x and y are inherited from o and p</code></pre>
        
        <p>Now suppose you assign to the property <code>x</code> of the object <code>o</code>. If <code>o</code>
        already has an own (non-inherited) property named <code>x</code>, then the
        assignment simply changes the value of this existing
        property. Otherwise, the assignment creates a new property named <code>x</code>
        on the object <code>o</code>. If <code>o</code> previously inherited the property <code>x</code>, that
        inherited property is now hidden by the newly created own property
        with the same name.</p>
        
        <p>Property assignment examines the prototype chain only to determine
        whether the assignment is allowed. If <code>o</code> inherits a read-only
        property named <code>x</code>, for example, then the assignment is not
        allowed. (Details about when a property may be set are in
        <a data-type="xref" href="#propertyaccesserrors">§6.3.3</a>.) If the assignment is allowed, however, it
        always creates or sets a property in the original object and never
        modifies objects in the prototype chain. The fact that inheritance
        occurs when querying properties but not when setting them is a key
        feature of JavaScript because it allows us to selectively override
        inherited properties:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">unitcircle</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">r</code><code class="o">:</code> <code class="mi">1</code> <code class="p">};</code>         <code class="c1">// An object to inherit from</code>
        <code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">unitcircle</code><code class="p">);</code> <code class="c1">// c inherits the property r</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">c</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>                  <code class="c1">// c defines two properties of its own</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">r</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>                           <code class="c1">// c overrides its inherited property</code>
        <code class="nx">unitcircle</code><code class="p">.</code><code class="nx">r</code>                       <code class="c1">// =&gt; 1: the prototype is not affected</code></pre>
        
        <p>There is one exception to the rule that a property assignment either
        fails or creates or sets a property in the original object. If <code>o</code>
        inherits the property <code>x</code>, and that property is an accessor property
        with a setter method (see <a data-type="xref" href="#gettersandsetters">§6.10.6</a>), then that setter
        method is called rather than creating a new property <code>x</code> in <code>o</code>. Note,
        however, that the setter method is called on the object <code>o</code>, not on
        the prototype object that defines the <span class="keep-together">property,</span> so if the setter
        method defines any properties, it will do so on <code>o</code>, and it will again
        leave the prototype chain unmodified.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.3.3 Property Access Errors"><div class="sect2" id="propertyaccesserrors">
        <h2>6.3.3 Property Access Errors</h2>
        
        <p>Property<a data-type="indexterm" data-primary="properties" data-secondary="property access errors" id="idm46198551141144"></a> access expressions do not always return or set a value. This
        section explains the things that can go wrong when you query or set a
        property.</p>
        
        <p>It is not an error to query a property that does not exist. If the
        property <code>x</code> is not found as an own property or an inherited property
        of <code>o</code>, the property access expression <code>o.x</code> evaluates to
        <code>undefined</code>. Recall that our book object has a “sub-title” property,
        but not a “subtitle” property:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">book</code><code class="p">.</code><code class="nx">subtitle</code>    <code class="c1">// =&gt; undefined: property doesn't exist</code></pre>
        
        <p>It is an error, however, to attempt to query a property of an object that does
        not exist. The <code>null</code> and <code>undefined</code> values have no properties, and it is an
        error to query properties of these values. Continuing the preceding example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">len</code> <code class="o">=</code> <code class="nx">book</code><code class="p">.</code><code class="nx">subtitle</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="c1">// !TypeError: undefined doesn't have length</code></pre>
        
        <p>Property access expressions will fail if the lefthand side of the <code>.</code>
        is <code>null</code> or <code>undefined</code>. So when writing an expression like
        <code>book.author.surname</code>, you should be careful if you are not certain
        that <code>book</code> and <code>book.author</code> are actually defined. Here are two ways
        to guard against this kind of problem:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// A verbose and explicit technique</code>
        <code class="kd">let</code> <code class="nx">surname</code> <code class="o">=</code> <code class="kc">undefined</code><code class="p">;</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">book</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">book</code><code class="p">.</code><code class="nx">author</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">surname</code> <code class="o">=</code> <code class="nx">book</code><code class="p">.</code><code class="nx">author</code><code class="p">.</code><code class="nx">surname</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// A concise and idiomatic alternative to get surname or null or undefined</code>
        <code class="nx">surname</code> <code class="o">=</code> <code class="nx">book</code> <code class="o">&amp;&amp;</code> <code class="nx">book</code><code class="p">.</code><code class="nx">author</code> <code class="o">&amp;&amp;</code> <code class="nx">book</code><code class="p">.</code><code class="nx">author</code><code class="p">.</code><code class="nx">surname</code><code class="p">;</code></pre>
        
        <p>To understand why this idiomatic expression works to prevent TypeError
        exceptions, you might want to review the short-circuiting behavior of
        the <code>&amp;&amp;</code> operator in <a data-type="xref" href="ch04.html#logicaland">§4.10.1</a>.</p>
        
        <p>As<a data-type="indexterm" data-primary="ES2020" data-secondary="conditional access operator (?.)" id="idm46198551006072"></a> described in <a data-type="xref" href="ch04.html#conditionalpropertyaccess">§4.4.1</a>, ES2020 supports
        conditional property access with <code>?.</code>, which allows us to rewrite the previous assignment expression as:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">surname</code> <code class="o">=</code> <code class="nx">book</code><code class="o">?</code><code class="p">.</code><code class="nx">author</code><code class="o">?</code><code class="p">.</code><code class="nx">surname</code><code class="p">;</code></pre>
        
        <p>Attempting<a data-type="indexterm" data-primary="strict mode" data-secondary="TypeError" id="idm46198550996168"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="TypeError" id="idm46198550995432"></a> to set a property on <code>null</code> or <code>undefined</code> also causes a
        TypeError. Attempts to set properties on other values do not always
        succeed, either: some properties are read-only and cannot be set, and
        some objects do not allow the addition of new properties. In strict
        mode (<a data-type="xref" href="ch05.html#strictmode">§5.6.3</a>), a TypeError is thrown whenever an attempt to set
        a property fails. Outside of strict mode, these failures are usually
        silent.</p>
        
        <p>The rules that specify when a property assignment succeeds and when it
        fails are intuitive but difficult to express concisely. An attempt to
        set a property <code>p</code> of an object <code>o</code> fails in these circumstances:</p>
        
        <ul>
        <li>
        <p><code>o</code> has an own property <code>p</code> that is read-only: it is not possible to
        set read-only <span class="keep-together">properties.</span></p>
        </li>
        <li>
        <p><code>o</code> has an inherited property <code>p</code> that is read-only: it is not
        possible to hide an inherited read-only property with an own property
        of the same name.</p>
        </li>
        <li>
        <p><code>o</code> does not have an own property <code>p</code>; <code>o</code> does not inherit a
        property <code>p</code> with a setter method, and <code>o</code>’s <em>extensible</em> attribute
        (see <a data-type="xref" href="ch14.html#extensibleattr">§14.2</a>) is <code>false</code>. Since <code>p</code> does not already exist in
        <code>o</code>, and if there is no setter method to call, then <code>p</code> must be added
        to <code>o</code>. But if <code>o</code> is not extensible, then no new properties can be
        defined on it.<a data-type="indexterm" data-primary="" data-startref="Oquery06" id="idm46198550974456"></a><a data-type="indexterm" data-primary="" data-startref="Pquery06" id="idm46198550973480"></a></p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.4 Deleting Properties"><div class="sect1" id="deletingproperties">
        <h1>6.4 Deleting Properties</h1>
        
        <p>The<a data-type="indexterm" data-primary="properties" data-secondary="deleting" id="idm46198550970584"></a><a data-type="indexterm" data-primary="delete operator" id="idm46198550969576"></a><a data-type="indexterm" data-primary="objects" data-secondary="deleting properties" id="idm46198550934072"></a> <code>delete</code> operator (<a data-type="xref" href="ch04.html#deleteoperator">§4.13.4</a>) removes a property from an
        object.  Its single operand should be a property access
        expression. Surprisingly, <code>delete</code> does not operate on the value of
        the property but on the property itself:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">delete</code> <code class="nx">book</code><code class="p">.</code><code class="nx">author</code><code class="p">;</code>          <code class="c1">// The book object now has no author property.</code>
        <code class="k">delete</code> <code class="nx">book</code><code class="p">[</code><code class="s2">"main title"</code><code class="p">];</code>   <code class="c1">// Now it doesn't have "main title", either.</code></pre>
        
        <p>The <code>delete</code> operator only deletes own properties, not inherited
        ones. (To delete an inherited property, you must delete it from the
        prototype object in which it is defined. Doing this affects every
        object that inherits from that prototype.)</p>
        
        <p>A <code>delete</code> expression evaluates to <code>true</code> if the delete succeeded or
        if the delete had no effect (such as deleting a nonexistent
        property). <code>delete</code> also evaluates to <code>true</code> when used (meaninglessly)
        with an expression that is not a property access expression:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">};</code>    <code class="c1">// o has own property x and inherits property toString</code>
        <code class="k">delete</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code>         <code class="c1">// =&gt; true: deletes property x</code>
        <code class="k">delete</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code>         <code class="c1">// =&gt; true: does nothing (x doesn't exist) but true anyway</code>
        <code class="k">delete</code> <code class="nx">o</code><code class="p">.</code><code class="nx">toString</code>  <code class="c1">// =&gt; true: does nothing (toString isn't an own property)</code>
        <code class="k">delete</code> <code class="mi">1</code>           <code class="c1">// =&gt; true: nonsense, but true anyway</code></pre>
        
        <p><code>delete</code> does not remove properties that have a <em>configurable</em>
        attribute of <code>false</code>. Certain properties of built-in objects are
        non-configurable, as are properties of the global object created by
        variable declaration and function declaration. In<a data-type="indexterm" data-primary="strict mode" data-secondary="deleting properties" id="idm46198550867368"></a><a data-type="indexterm" data-primary="use strict mode" data-secondary="deleting properties" id="idm46198550866392"></a> strict mode,
        attempting to delete a non-configurable property causes a TypeError. In
        non-strict mode, <code>delete</code> simply evaluates to <code>false</code> in this case:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// In strict mode, all these deletions throw TypeError instead of returning false</code>
        <code class="k">delete</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code> <code class="c1">// =&gt; false: property is non-configurable</code>
        <code class="kd">var</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>              <code class="c1">// Declare a global variable</code>
        <code class="k">delete</code> <code class="nx">globalThis</code><code class="p">.</code><code class="nx">x</code>     <code class="c1">// =&gt; false: can't delete this property</code>
        <code class="kd">function</code> <code class="nx">f</code><code class="p">()</code> <code class="p">{}</code>         <code class="c1">// Declare a global function</code>
        <code class="k">delete</code> <code class="nx">globalThis</code><code class="p">.</code><code class="nx">f</code>     <code class="c1">// =&gt; false: can't delete this property either</code></pre>
        
        <p>When deleting configurable properties of the global object in non-strict mode,
        you can omit the reference to the global object and simply follow the <code>delete</code>
        operator with the property name:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">globalThis</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>       <code class="c1">// Create a configurable global property (no let or var)</code>
        <code class="k">delete</code> <code class="nx">x</code>                <code class="c1">// =&gt; true: this property can be deleted</code></pre>
        
        <p>In strict mode, however, <code>delete</code> raises a SyntaxError if its operand
        is an unqualified identifier like <code>x</code>, and you have to be explicit
        about the property access:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">delete</code> <code class="nx">x</code><code class="p">;</code>               <code class="c1">// SyntaxError in strict mode</code>
        <code class="k">delete</code> <code class="nx">globalThis</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>    <code class="c1">// This works</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.5 Testing Properties"><div class="sect1" id="idm46198550972200">
        <h1>6.5 Testing Properties</h1>
        
        <p>JavaScript<a data-type="indexterm" data-primary="objects" data-secondary="testing properties" id="idm46198550776344"></a><a data-type="indexterm" data-primary="properties" data-secondary="testing" id="idm46198550775336"></a> objects can be thought of as sets of properties, and it is
        often useful to be able to test for membership in the set—to check
        whether an object has a property with a given name. You<a data-type="indexterm" data-primary="in operator" id="idm46198550774056"></a><a data-type="indexterm" data-primary="hasOwnProperty operator" id="idm46198550773384"></a><a data-type="indexterm" data-primary="propertyIsEnumerable() method" id="idm46198550772712"></a> can do this
        with the <code>in</code> operator, with the <code>hasOwnProperty()</code> and
        <code>propertyIsEnumerable()</code> methods, or simply by querying the
        property. The examples shown here all use strings as property names,
        but they also work with Symbols (<a data-type="xref" href="#symbols-as-property-names">§6.10.3</a>).</p>
        
        <p>The <code>in</code> operator expects a property name on its left
        side and an object on its right. It returns <code>true</code> if the object has
        an own property or an inherited property by that name:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code> <code class="p">};</code>
        <code class="s2">"x"</code> <code class="k">in</code> <code class="nx">o</code>         <code class="c1">// =&gt; true: o has an own property "x"</code>
        <code class="s2">"y"</code> <code class="k">in</code> <code class="nx">o</code>         <code class="c1">// =&gt; false: o doesn't have a property "y"</code>
        <code class="s2">"toString"</code> <code class="k">in</code> <code class="nx">o</code>  <code class="c1">// =&gt; true: o inherits a toString property</code></pre>
        
        <p>The <code>hasOwnProperty()</code> method of an object tests whether that object
        has an own property with the given name. It returns <code>false</code> for
        inherited properties:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code> <code class="p">};</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="s2">"x"</code><code class="p">)</code>        <code class="c1">// =&gt; true: o has an own property x</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="s2">"y"</code><code class="p">)</code>        <code class="c1">// =&gt; false: o doesn't have a property y</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="s2">"toString"</code><code class="p">)</code> <code class="c1">// =&gt; false: toString is an inherited property</code></pre>
        
        <p>The <code>propertyIsEnumerable()</code> refines the <code>hasOwnProperty()</code> test. It
        returns <code>true</code> only if the named property is an own property and its
        <em>enumerable</em> attribute is <code>true</code>. Certain built-in properties are
        not enumerable. Properties created by normal JavaScript code are
        enumerable unless you’ve used one of the techniques shown in
        <a data-type="xref" href="ch14.html#propertydescriptors">§14.1</a> to make them non-enumerable.</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code> <code class="p">};</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">propertyIsEnumerable</code><code class="p">(</code><code class="s2">"x"</code><code class="p">)</code>  <code class="c1">// =&gt; true: o has an own enumerable property x</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">propertyIsEnumerable</code><code class="p">(</code><code class="s2">"toString"</code><code class="p">)</code>  <code class="c1">// =&gt; false: not an own property</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">.</code><code class="nx">propertyIsEnumerable</code><code class="p">(</code><code class="s2">"toString"</code><code class="p">)</code> <code class="c1">// =&gt; false: not enumerable</code></pre>
        
        <p>Instead of using the <code>in</code> operator, it is often sufficient to simply query the
        property and use <code>!==</code> to make sure it is not undefined:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code> <code class="p">};</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code> <code class="o">!==</code> <code class="kc">undefined</code>        <code class="c1">// =&gt; true: o has a property x</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">y</code> <code class="o">!==</code> <code class="kc">undefined</code>        <code class="c1">// =&gt; false: o doesn't have a property y</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">toString</code> <code class="o">!==</code> <code class="kc">undefined</code> <code class="c1">// =&gt; true: o inherits a toString property</code></pre>
        
        <p>There is one thing the <code>in</code> operator can do that the simple property
        access technique shown here cannot do. <code>in</code> can distinguish between
        properties that do not exist and properties that exist but have been
        set to <code>undefined</code>. Consider this code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="kc">undefined</code> <code class="p">};</code>  <code class="c1">// Property is explicitly set to undefined</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code> <code class="o">!==</code> <code class="kc">undefined</code>          <code class="c1">// =&gt; false: property exists but is undefined</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">y</code> <code class="o">!==</code> <code class="kc">undefined</code>          <code class="c1">// =&gt; false: property doesn't even exist</code>
        <code class="s2">"x"</code> <code class="k">in</code> <code class="nx">o</code>                   <code class="c1">// =&gt; true: the property exists</code>
        <code class="s2">"y"</code> <code class="k">in</code> <code class="nx">o</code>                   <code class="c1">// =&gt; false: the property doesn't exist</code>
        <code class="k">delete</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>                <code class="c1">// Delete the property x</code>
        <code class="s2">"x"</code> <code class="k">in</code> <code class="nx">o</code>                   <code class="c1">// =&gt; false: it doesn't exist anymore</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.6 Enumerating Properties"><div class="sect1" id="enumeratingprops">
        <h1>6.6 Enumerating Properties</h1>
        
        <p>Instead<a data-type="indexterm" data-primary="objects" data-secondary="enumerating properties" id="idm46198550435944"></a><a data-type="indexterm" data-primary="properties" data-secondary="enumerating properties" id="idm46198550434936"></a> of testing for the existence of individual properties, we
        sometimes want to iterate through or obtain a list of all the
        properties of an object. There are a few different ways to do this.</p>
        
        <p>The<a data-type="indexterm" data-primary="for/in loops" id="idm46198550433272"></a><a data-type="indexterm" data-primary="looping statements" data-secondary="for/in loops" id="idm46198550432536"></a> <code>for/in</code> loop was covered in <a data-type="xref" href="ch05.html#forinloop">§5.4.5</a>. It runs the body of the
        loop once for each enumerable property (own or inherited) of the specified
        object, assigning the name of the property to the loop variable. Built-in
        methods that objects inherit are not enumerable, but the properties that your
        code adds to objects are enumerable by default. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="mi">3</code><code class="p">};</code>          <code class="c1">// Three enumerable own properties</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">propertyIsEnumerable</code><code class="p">(</code><code class="s2">"toString"</code><code class="p">)</code>   <code class="c1">// =&gt; false: not enumerable</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">p</code> <code class="k">in</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code>                    <code class="c1">// Loop through the properties</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">p</code><code class="p">);</code>                  <code class="c1">// Prints x, y, and z, but not toString</code>
        <code class="p">}</code></pre>
        
        <p>To guard against enumerating inherited properties with <code>for/in</code>, you
        can add an explicit check inside the loop body:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">p</code> <code class="k">in</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="nx">o</code><code class="p">.</code><code class="nx">hasOwnProperty</code><code class="p">(</code><code class="nx">p</code><code class="p">))</code> <code class="k">continue</code><code class="p">;</code>       <code class="c1">// Skip inherited properties</code>
        <code class="p">}</code>
        
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">p</code> <code class="k">in</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">o</code><code class="p">[</code><code class="nx">p</code><code class="p">]</code> <code class="o">===</code> <code class="s2">"function"</code><code class="p">)</code> <code class="k">continue</code><code class="p">;</code> <code class="c1">// Skip all methods</code>
        <code class="p">}</code></pre>
        
        <p>As an alternative to using a <code>for/in</code> loop, it is often easier to get
        an array of property names for an object and then loop through that
        array with a <code>for/of</code> loop. There are four functions you can use to
        get an array of property names:</p>
        
        <ul>
        <li>
        <p><code>Object.keys()</code> returns<a data-type="indexterm" data-primary="Object.keys() function" id="idm46198550271240"></a> an array of the names of the enumerable own
        properties of an object. It does not include non-enumerable
        properties, inherited properties, or properties whose name is a Symbol
        (see <a data-type="xref" href="#symbols-as-property-names">§6.10.3</a>).</p>
        </li>
        <li>
        <p><code>Object.getOwnPropertyNames()</code> works<a data-type="indexterm" data-primary="Object.getOwnPropertyNames() function" id="idm46198550268264"></a> like <code>Object.keys()</code> but
        returns an array of the names of non-enumerable own properties as
        well, as long as their names are strings.</p>
        </li>
        <li>
        <p><code>Object.getOwnPropertySymbols()</code> returns<a data-type="indexterm" data-primary="Object.getOwnPropertySymbols() function" id="idm46198550265672"></a> own properties whose names
        are Symbols, whether or not they are enumerable.</p>
        </li>
        <li>
        <p><code>Reflect.ownKeys()</code> returns<a data-type="indexterm" data-primary="Reflect.ownKeys() function" id="idm46198550263560"></a> all own property names, both enumerable
        and non-enumerable, and both string and Symbol. (See <a data-type="xref" href="ch14.html#reflectapi">§14.6</a>.)</p>
        </li>
        </ul>
        
        <p>There are examples of the use of <code>Object.keys()</code> with a <code>for/of</code> loop
        in <a data-type="xref" href="#extending-objects">§6.7</a>.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.6.1 Property Enumeration Order"><div class="sect2" id="property-enumeration-order">
        <h2>6.6.1 Property Enumeration Order</h2>
        
        <p>ES6<a data-type="indexterm" data-primary="ES6" data-secondary="property enumeration order" id="idm46198550257208"></a> formally defines the order in which the own properties of an
        object are enumerated. <code>Object.keys()</code>,
        <code>Object.getOwnPropertyNames()</code>, <code>Object.getOwnPropertySymbols()</code>,
        <code>Reflect.ownKeys()</code>, and related methods such as <code>JSON.stringify()</code> all
        list properties in the following order, subject to their own
        additional constraints about whether they list non-enumerable
        properties or properties whose names are strings or Symbols:</p>
        
        <ul>
        <li>
        <p>String properties whose names are non-negative integers are listed
        first, in numeric order from smallest to largest. This rule means
        that arrays and array-like objects will have their properties
        enumerated in order.</p>
        </li>
        <li>
        <p>After all properties that look like array indexes are listed, all
        remaining properties with string names are listed (including
        properties that look like negative numbers or floating-point
        numbers). These properties are listed in the order in which they
        were added to the object. For properties defined in an object
        literal, this order is the same order they appear in the literal.</p>
        </li>
        <li>
        <p>Finally, the properties whose names are Symbol objects are listed
        in the order in which they were added to the object.</p>
        </li>
        </ul>
        
        <p>The enumeration order for the <code>for/in</code> loop is not as tightly
        specified as it is for these enumeration functions, but
        implementations typically enumerate own properties in the order
        just described, then travel up the prototype chain enumerating
        properties in the same order for each prototype object. Note, however,
        that a property will not be enumerated if a property by that same name
        has already been enumerated, or even if a non-enumerable property by
        the same name has already been considered.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.7 Extending Objects"><div class="sect1" id="extending-objects">
        <h1>6.7 Extending Objects</h1>
        
        <p>A<a data-type="indexterm" data-primary="properties" data-secondary="copying from one object to another" id="idm46198550246728"></a><a data-type="indexterm" data-primary="objects" data-secondary="extending objects" id="idm46198550245752"></a> common operation in JavaScript programs is needing to copy the
        properties of one object to another object. It is easy to do that with
        code like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">target</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">},</code> <code class="nx">source</code> <code class="o">=</code> <code class="p">{</code><code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="mi">3</code><code class="p">};</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">source</code><code class="p">))</code> <code class="p">{</code>
            <code class="nx">target</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">source</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>
        <code class="p">}</code>
        <code class="nx">target</code>  <code class="c1">// =&gt; {x: 1, y: 2, z: 3}</code></pre>
        
        <p>But<a data-type="indexterm" data-primary="Object.assign() function" id="idm46198550134040"></a> because this is a common operation, various JavaScript frameworks
        have defined utility functions, often named <code>extend()</code>, to perform this
        copying operation. Finally, in ES6, this ability comes to the core
        JavaScript language in the form of <code>Object.assign()</code>.</p>
        
        <p><code>Object.assign()</code> expects two or more objects as its arguments. It
        modifies and returns the first argument, which is the target object,
        but does not alter the second or any subsequent arguments, which are
        the source objects. For each source object, it copies the enumerable
        own properties of that object (including those whose names are
        Symbols) into the target object. It processes the source objects in
        argument list order so that properties in the first source object
        override properties by the same name in the target object and
        properties in the second source object (if there is one) override
        properties with the same name in the first source object.</p>
        
        <p><code>Object.assign()</code> copies properties with ordinary property get and set
        operations, so if a source object has a getter method or the target
        object has a setter method, they will be invoked during the copy, but
        they will not themselves be copied.</p>
        
        <p>One reason to assign properties from one object into another is when
        you have an object that defines default values for many properties and
        you want to copy those default properties into another object if a
        property by that name does not already exist in that object. Using
        <code>Object.assign()</code> naively will not do what you want:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">defaults</code><code class="p">);</code>  <code class="c1">// overwrites everything in o with defaults</code></pre>
        
        <p>Instead, what you can do is to create a new object, copy the defaults
        into it, and then override those defaults with the properties in <code>o</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">o</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({},</code> <code class="nx">defaults</code><code class="p">,</code> <code class="nx">o</code><code class="p">);</code></pre>
        
        <p>We’ll see in <a data-type="xref" href="#object-spread-operator">§6.10.4</a> that you can also
        express this object copy-and-override operation using the <code>...</code> spread
        operator like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">o</code> <code class="o">=</code> <code class="p">{...</code><code class="nx">defaults</code><code class="p">,</code> <code class="p">...</code><code class="nx">o</code><code class="p">};</code></pre>
        
        <p>We could also avoid the overhead of the extra object creation and
        copying by writing a version of <code>Object.assign()</code> that copies
        properties only if they are missing:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Like Object.assign() but doesn't override existing properties</code>
        <code class="c1">// (and also doesn't handle Symbol properties)</code>
        <code class="kd">function</code> <code class="nx">merge</code><code class="p">(</code><code class="nx">target</code><code class="p">,</code> <code class="p">...</code><code class="nx">sources</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">source</code> <code class="k">of</code> <code class="nx">sources</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">key</code> <code class="k">of</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">keys</code><code class="p">(</code><code class="nx">source</code><code class="p">))</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">key</code> <code class="k">in</code> <code class="nx">target</code><code class="p">))</code> <code class="p">{</code> <code class="c1">// This is different than Object.assign()</code>
                        <code class="nx">target</code><code class="p">[</code><code class="nx">key</code><code class="p">]</code> <code class="o">=</code> <code class="nx">source</code><code class="p">[</code><code class="nx">key</code><code class="p">];</code>
                    <code class="p">}</code>
                <code class="p">}</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">target</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="nb">Object</code><code class="p">.</code><code class="nx">assign</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">},</code> <code class="p">{</code><code class="nx">y</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="mi">4</code><code class="p">})</code>  <code class="c1">// =&gt; {x: 2, y: 3, z: 4}</code>
        <code class="nx">merge</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">},</code> <code class="p">{</code><code class="nx">y</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="mi">4</code><code class="p">})</code>          <code class="c1">// =&gt; {x: 1, y: 2, z: 4}</code></pre>
        
        <p>It is straightforward to write other property manipulation utilities
        like this <code>merge()</code> function. A <code>restrict()</code> function could delete
        properties of an object if they do not appear in another template
        object, for example. Or a <code>subtract()</code> function could remove all of
        the properties of one object from another object.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.8 Serializing Objects"><div class="sect1" id="serializingobjects">
        <h1>6.8 Serializing Objects</h1>
        
        <p>Object<a data-type="indexterm" data-primary="objects" data-secondary="serializing objects" id="idm46198549910328"></a><a data-type="indexterm" data-primary="serialization" id="idm46198549909320"></a><a data-type="indexterm" data-primary="JSON.stringify() function" id="idm46198549908648"></a><a data-type="indexterm" data-primary="JSON.parse() function" id="idm46198549908008"></a> <em>serialization</em> is the process of converting an object’s state
        to a string from which it can later be restored. The functions
        <code>JSON.stringify()</code> and <code>JSON.parse()</code> serialize and restore JavaScript
        objects. These functions use the JSON data interchange format. JSON
        stands for “JavaScript Object Notation,” and its syntax is very
        similar to that of JavaScript object and array literals:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="p">{</code><code class="nx">z</code><code class="o">:</code> <code class="p">[</code><code class="kc">false</code><code class="p">,</code> <code class="kc">null</code><code class="p">,</code> <code class="s2">""</code><code class="p">]}};</code> <code class="c1">// Define a test object</code>
        <code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">(</code><code class="nx">o</code><code class="p">);</code>   <code class="c1">// s == '{"x":1,"y":{"z":[false,null,""]}}'</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="nx">JSON</code><code class="p">.</code><code class="nx">parse</code><code class="p">(</code><code class="nx">s</code><code class="p">);</code>       <code class="c1">// p == {x: 1, y: {z: [false, null, ""]}}</code></pre>
        
        <p>JSON syntax is a <em>subset</em> of JavaScript syntax, and it cannot
        represent all JavaScript values. Objects, arrays, strings, finite
        numbers, <code>true</code>, <code>false</code>, and <code>null</code> are supported and can be
        serialized and restored. <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> are
        serialized to <code>null</code>. Date objects are serialized to ISO-formatted
        date strings (see the <code>Date.toJSON()</code> function), but <code>JSON.parse()</code>
        leaves these in string form and does not restore the original Date
        object. Function, RegExp, and Error objects and the <code>undefined</code> value
        cannot be serialized or restored. <code>JSON.stringify()</code> serializes only
        the enumerable own properties of an object. If a property value cannot
        be serialized, that property is simply omitted from the stringified
        output. Both <code>JSON.stringify()</code> and <code>JSON.parse()</code> accept optional
        second arguments that can be used to customize the serialization
        and/or restoration process by specifying a list of properties to be
        serialized, for <span class="keep-together">example,</span> or by converting certain values during the
        serialization or stringification process. Complete documentation for
        these functions is in <a data-type="xref" href="ch11.html#jsonapi">§11.6</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.9 Object Methods"><div class="sect1" id="objectmethods">
        <h1>6.9 Object Methods</h1>
        
        <p>As<a data-type="indexterm" data-primary="objects" data-secondary="object methods" id="Oobmeth06"></a><a data-type="indexterm" data-primary="Object.prototype" id="idm46198549871768"></a> discussed earlier, all JavaScript objects (except those explicitly
        created without a prototype) inherit properties from
        <code>Object.prototype</code>. These inherited properties are primarily methods,
        and because they are universally available, they are of particular
        interest to JavaScript programmers. We’ve already seen the
        <code>hasOwnProperty()</code> and <code>propertyIsEnumerable()</code> methods, for example.
        (And we’ve also already covered quite a few static functions defined
        on the <code>Object</code> constructor, such as <code>Object.create()</code> and
        <code>Object.keys()</code>.) This section explains a handful of universal object
        methods that are defined on <code>Object.prototype</code>, but which are intended
        to be replaced by other, more specialized implementations. In the
        sections that follow, we show examples of defining these methods on a
        single object. In <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>, you’ll learn how to define these methods
        more generally for an entire class of objects.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.9.1 The toString() Method"><div class="sect2" id="idm46198549866408">
        <h2>6.9.1 The toString() Method</h2>
        
        <p>The<a data-type="indexterm" data-primary="toString() method" id="idm46198549864872"></a> <code>toString()</code> method takes no arguments; it returns a string that
        somehow represents the value of the object on which it is
        invoked. JavaScript invokes this method of an object whenever it needs
        to convert the object to a string.  This occurs, for example, when you
        use the <code>+</code> operator to concatenate a string with an object or when
        you pass an object to a method that expects a string.</p>
        
        <p>The default <code>toString()</code> method is not very informative (though it is
        useful for determining the class of an object, as we will see in
        <a data-type="xref" href="ch14.html#tostringtag">§14.4.3</a>). For example, the following line of code simply
        evaluates to the string “[object Object]”:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">1</code> <code class="p">}.</code><code class="nx">toString</code><code class="p">();</code>  <code class="c1">// s == "[object Object]"</code></pre>
        
        <p>Because this default method does not display much useful information,
        many classes define their own versions of <code>toString()</code>. For example,
        when an array is converted to a string, you obtain a list of the
        array elements, themselves each converted to a string, and when a
        function is converted to a string, you obtain the source code for the
        function.  You might define your own <code>toString()</code> method like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
            <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
            <code class="nx">toString</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`(</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="si">}</code><code class="sb">)`</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">};</code>
        <code class="nb">String</code><code class="p">(</code><code class="nx">point</code><code class="p">)</code>    <code class="c1">// =&gt; "(1, 2)": toString() is used for string conversions</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.9.2 The toLocaleString() Method"><div class="sect2" id="idm46198549853096">
        <h2>6.9.2 The toLocaleString() Method</h2>
        
        <p>In<a data-type="indexterm" data-primary="toLocaleString() method" id="idm46198549687480"></a> addition to the basic <code>toString()</code> method, objects all have a
        <code>toLocaleString()</code>. The purpose of this method is to return a localized string
        representation of the object. The default <code>toLocaleString()</code> method defined by
        Object doesn’t do any localization itself: it simply calls <code>toString()</code> and
        returns that value. The Date and Number classes define customized versions of
        <code>toLocaleString()</code> that attempt to format numbers, dates, and times according
        to local conventions. Array defines a <code>toLocaleString()</code> method that works like
        <code>toString()</code> except that it formats array elements by calling their
        <code>toLocaleString()</code> methods instead of their <code>toString()</code> methods. You
        might do the same thing with a <code>point</code> object like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">x</code><code class="o">:</code> <code class="mi">1000</code><code class="p">,</code>
            <code class="nx">y</code><code class="o">:</code> <code class="mi">2000</code><code class="p">,</code>
            <code class="nx">toString</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`(</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="si">}</code><code class="sb">)`</code><code class="p">;</code> <code class="p">},</code>
            <code class="nx">toLocaleString</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
                <code class="k">return</code> <code class="sb">`(</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="p">.</code><code class="nx">toLocaleString</code><code class="p">()</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="p">.</code><code class="nx">toLocaleString</code><code class="p">()</code><code class="si">}</code><code class="sb">)`</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">};</code>
        <code class="nx">point</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code>        <code class="c1">// =&gt; "(1000, 2000)"</code>
        <code class="nx">point</code><code class="p">.</code><code class="nx">toLocaleString</code><code class="p">()</code>  <code class="c1">// =&gt; "(1,000, 2,000)": note thousands separators</code></pre>
        
        <p>The internationalization classes documented in <a data-type="xref" href="ch11.html#intlapi">§11.7</a> can be useful
        when implementing a <code>toLocaleString()</code> method.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.9.3 The valueOf() Method"><div class="sect2" id="idm46198549588968">
        <h2>6.9.3 The valueOf() Method</h2>
        
        <p>The<a data-type="indexterm" data-primary="valueOf() method" id="idm46198549587912"></a> <code>valueOf()</code> method is much like the <code>toString()</code> method, but it is
        called when JavaScript needs to convert an object to some primitive
        type other than a string—<span class="keep-together">typically</span>, a number. JavaScript calls this
        method automatically if an object is used in a context where a
        primitive value is required. The default <code>valueOf()</code> method does
        nothing interesting, but some of the built-in classes define their own
        <code>valueOf()</code> method. The Date class defines <code>valueOf()</code> to convert
        dates to numbers, and this allows Date objects to be chronologically
        compared with <code>&lt;</code> and <code>&gt;</code>. You could do something similar with a point
        object, defining a <code>valueOf()</code> method that returns the distance from
        the origin to the point:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">x</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code>
            <code class="nx">y</code><code class="o">:</code> <code class="mi">4</code><code class="p">,</code>
            <code class="nx">valueOf</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">hypot</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code> <code class="p">}</code>
        <code class="p">};</code>
        <code class="nb">Number</code><code class="p">(</code><code class="nx">point</code><code class="p">)</code>  <code class="c1">// =&gt; 5: valueOf() is used for conversions to numbers</code>
        <code class="nx">point</code> <code class="o">&gt;</code> <code class="mi">4</code>      <code class="c1">// =&gt; true</code>
        <code class="nx">point</code> <code class="o">&gt;</code> <code class="mi">5</code>      <code class="c1">// =&gt; false</code>
        <code class="nx">point</code> <code class="o">&lt;</code> <code class="mi">6</code>      <code class="c1">// =&gt; true</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.9.4 The toJSON() Method"><div class="sect2" id="idm46198549577272">
        <h2>6.9.4 The toJSON() Method</h2>
        
        <p><code>Object.prototype</code> does<a data-type="indexterm" data-primary="toJSON() method" id="idm46198549533368"></a><a data-type="indexterm" data-primary="JSON.stringify() function" id="idm46198549532632"></a> not actually define a <code>toJSON()</code> method, but
        the <code>JSON.stringify()</code> method (see <a data-type="xref" href="#serializingobjects">§6.8</a>) looks for a
        <code>toJSON()</code> method on any object it is asked to serialize. If this
        method exists on the object to be serialized, it is invoked, and the
        return value is serialized, instead of the original object. The Date
        class (<a data-type="xref" href="ch11.html#datesandtimes">§11.4</a>) defines a <code>toJSON()</code> method that returns a
        serializable string representation of the date. We could do the same
        for our Point object like<a data-type="indexterm" data-primary="" data-startref="Oobmeth06" id="idm46198549483480"></a> this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
            <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code>
            <code class="nx">toString</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="sb">`(</code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="si">}</code><code class="sb">, </code><code class="si">${</code><code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="si">}</code><code class="sb">)`</code><code class="p">;</code> <code class="p">},</code>
            <code class="nx">toJSON</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">toString</code><code class="p">();</code> <code class="p">}</code>
        <code class="p">};</code>
        <code class="nx">JSON</code><code class="p">.</code><code class="nx">stringify</code><code class="p">([</code><code class="nx">point</code><code class="p">])</code>   <code class="c1">// =&gt; '["(1, 2)"]'</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.10 Extended Object Literal Syntax"><div class="sect1" id="extended-object-literal-syntax">
        <h1>6.10 Extended Object Literal Syntax</h1>
        
        <p>Recent<a data-type="indexterm" data-primary="object literals" data-secondary="extended syntax for" id="OLsyntax06"></a><a data-type="indexterm" data-primary="syntax" data-secondary="extended for object literals" id="Soblit06"></a><a data-type="indexterm" data-primary="objects" data-secondary="extended object literal syntax" id="Oextend06"></a> versions of JavaScript have extended the syntax for object
        literals in a number of useful ways. The following subsections explain
        these extensions.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.10.1 Shorthand Properties"><div class="sect2" id="idm46198549406008">
        <h2>6.10.1 Shorthand Properties</h2>
        
        <p>Suppose you have values stored in variables <code>x</code> and <code>y</code> and want to
        create an object with properties named <code>x</code> and <code>y</code> that hold those
        values. With basic object literal syntax, you’d end up repeating each
        identifier twice:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">x</code><code class="o">:</code> <code class="nx">x</code><code class="p">,</code>
            <code class="nx">y</code><code class="o">:</code> <code class="nx">y</code>
        <code class="p">};</code></pre>
        
        <p>In<a data-type="indexterm" data-primary="ES6" data-secondary="extended object literal syntax" id="idm46198549318120"></a> ES6 and later, you can drop the colon and one copy of the
        identifier and end up with much simpler code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">y</code> <code class="p">};</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">o</code><code class="p">.</code><code class="nx">y</code>  <code class="c1">// =&gt; 3</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="6.10.2 Computed Property Names"><div class="sect2" id="computed-property-names">
        <h2>6.10.2 Computed Property Names</h2>
        
        <p>Sometimes<a data-type="indexterm" data-primary="properties" data-secondary="computed property names" id="idm46198549287816"></a><a data-type="indexterm" data-primary="computed properties" id="idm46198549286808"></a><a data-type="indexterm" data-primary="ES6" data-secondary="computed properties" id="idm46198549286136"></a> you need to create an object with a specific property, but
        the name of that property is not a compile-time constant that you can
        type literally in your source code. Instead, the property name you
        need is stored in a variable or is the return value of a function that
        you invoke. You can’t use a basic object literal for this kind of
        property. Instead, you have to create an object and then add the
        desired properties as an extra step:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">PROPERTY_NAME</code> <code class="o">=</code> <code class="s2">"p1"</code><code class="p">;</code>
        <code class="kd">function</code> <code class="nx">computePropertyName</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="s2">"p"</code> <code class="o">+</code> <code class="mi">2</code><code class="p">;</code> <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{};</code>
        <code class="nx">o</code><code class="p">[</code><code class="nx">PROPERTY_NAME</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>
        <code class="nx">o</code><code class="p">[</code><code class="nx">computePropertyName</code><code class="p">()]</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code></pre>
        
        <p>It is much simpler to set up an object like this with an ES6 feature
        known as <em>computed properties</em> that lets you take the square brackets
        from the preceding code and move them directly into the object literal:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">PROPERTY_NAME</code> <code class="o">=</code> <code class="s2">"p1"</code><code class="p">;</code>
        <code class="kd">function</code> <code class="nx">computePropertyName</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="s2">"p"</code> <code class="o">+</code> <code class="mi">2</code><code class="p">;</code> <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code>
            <code class="p">[</code><code class="nx">PROPERTY_NAME</code><code class="p">]</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
            <code class="p">[</code><code class="nx">computePropertyName</code><code class="p">()]</code><code class="o">:</code> <code class="mi">2</code>
        <code class="p">};</code>
        
        <code class="nx">p</code><code class="p">.</code><code class="nx">p1</code> <code class="o">+</code> <code class="nx">p</code><code class="p">.</code><code class="nx">p2</code> <code class="c1">// =&gt; 3</code></pre>
        
        <p>With this new syntax, the square brackets delimit an arbitrary
        JavaScript expression. That expression is evaluated, and the resulting
        value (converted to a string, if necessary) is used as the property
        name.</p>
        
        <p>One situation where you might want to use computed properties is when
        you have a library of JavaScript code that expects to be passed
        objects with a particular set of properties, and the names of those
        properties are defined as constants in that library. If you are
        writing code to create the objects that will be passed to that
        library, you could hardcode the property names, but you’d risk bugs if
        you type the property name wrong anywhere, and you’d risk version
        mismatch issues if a new version of the library changes the required
        property names. Instead, you might find that it makes your code
        more robust to use computed property syntax with the property name
        constants defined by the library.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="6.10.3 Symbols as Property Names"><div class="sect2" id="symbols-as-property-names">
        <h2>6.10.3 Symbols as Property Names</h2>
        
        <p>The<a data-type="indexterm" data-primary="Symbols" data-secondary="property names" id="idm46198549143464"></a><a data-type="indexterm" data-primary="properties" data-secondary="naming" id="idm46198549142456"></a><a data-type="indexterm" data-primary="ES6" data-secondary="symbols as property names" id="idm46198549141512"></a> computed property syntax enables one other very important object
        literal feature. In ES6 and later, property names can be strings or
        symbols. If you assign a symbol to a variable or constant, then you
        can use that symbol as a property name using the computed property
        syntax:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">extension</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">(</code><code class="s2">"my extension symbol"</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="p">[</code><code class="nx">extension</code><code class="p">]</code><code class="o">:</code> <code class="p">{</code> <code class="cm">/* extension data stored in this object */</code> <code class="p">}</code>
        <code class="p">};</code>
        <code class="nx">o</code><code class="p">[</code><code class="nx">extension</code><code class="p">].</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="c1">// This won't conflict with other properties of o</code></pre>
        
        <p>As explained in <a data-type="xref" href="ch03.html#symbols">§3.6</a>, Symbols are opaque values. You can’t do
        anything with them other than use them as property names. Every Symbol
        is different from every other Symbol, however, which means that
        Symbols are good for creating unique property names. Create a new
        Symbol by calling the <code>Symbol()</code> factory function. (Symbols are
        primitive values, not objects, so <code>Symbol()</code> is not a constructor
        function that you invoke with <code>new</code>.) The value returned by <code>Symbol()</code>
        is not equal to any other Symbol or other value. You can pass a string
        to <code>Symbol()</code>, and this string is used when your Symbol is converted
        to a string. But this is a debugging aid only: two Symbols created
        with the same string argument are still different from one another.</p>
        
        <p>The point of Symbols is not security, but to define a safe extension
        mechanism for JavaScript objects. If you get an object from third-party code that you do not control and need to add some of your
        own properties to that object but want to be sure that your
        properties will not conflict with any properties that may already
        exist on the object, you can safely use Symbols as your property
        names. If you do this, you can also be confident that the third-party
        code will not accidentally alter your symbolically named properties.
        (That third-party code could, of course, use
        <code>Object.getOwnPropertySymbols()</code> to discover the Symbols you’re using
        and could then alter or delete your properties. This is why Symbols
        are not a security mechanism.)</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.10.4 Spread Operator"><div class="sect2" id="object-spread-operator">
        <h2>6.10.4 Spread Operator</h2>
        
        <p>In<a data-type="indexterm" data-primary="spread operator (…)" id="idm46198549070296"></a><a data-type="indexterm" data-primary="… (spread operator)" id="idm46198549069560"></a><a data-type="indexterm" data-primary="ES2018" data-secondary="spread operator (…)" id="idm46198549068888"></a> ES2018 and later, you can copy the properties of an existing object
        into a new object using the “spread operator” <code>...</code> inside an object
        literal:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">position</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">0</code> <code class="p">};</code>
        <code class="kd">let</code> <code class="nx">dimensions</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">width</code><code class="o">:</code> <code class="mi">100</code><code class="p">,</code> <code class="nx">height</code><code class="o">:</code> <code class="mi">75</code> <code class="p">};</code>
        <code class="kd">let</code> <code class="nx">rect</code> <code class="o">=</code> <code class="p">{</code> <code class="p">...</code><code class="nx">position</code><code class="p">,</code> <code class="p">...</code><code class="nx">dimensions</code> <code class="p">};</code>
        <code class="nx">rect</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">rect</code><code class="p">.</code><code class="nx">y</code> <code class="o">+</code> <code class="nx">rect</code><code class="p">.</code><code class="nx">width</code> <code class="o">+</code> <code class="nx">rect</code><code class="p">.</code><code class="nx">height</code> <code class="c1">// =&gt; 175</code></pre>
        
        <p>In this code, the properties of the <code>position</code> and <code>dimensions</code> objects
        are “spread out” into the <code>rect</code> object literal as if they had been
        written literally inside those curly braces. Note that this
        <code>...</code> syntax is often called a spread operator but is not a
        true JavaScript operator in any sense. Instead, it is a special-case
        syntax available only within object literals. (Three dots are used for
        other purposes in other JavaScript contexts, but object literals are
        the only context where the three dots cause this kind of interpolation
        of one object into another one.)</p>
        
        <p>If the object that is spread and the object it is being spread into
        both have a property with the same name, then the value of that
        property will be the one that comes last:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code> <code class="p">};</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> <code class="p">...</code><code class="nx">o</code> <code class="p">};</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">x</code>   <code class="c1">// =&gt; 1: the value from object o overrides the initial value</code>
        <code class="kd">let</code> <code class="nx">q</code> <code class="o">=</code> <code class="p">{</code> <code class="p">...</code><code class="nx">o</code><code class="p">,</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">2</code> <code class="p">};</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">x</code>   <code class="c1">// =&gt; 2: the value 2 overrides the previous value from o.</code></pre>
        
        <p>Also note that the spread operator only spreads the own properties of
        an object, not any inherited ones:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">});</code> <code class="c1">// o inherits the property x</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code> <code class="p">...</code><code class="nx">o</code> <code class="p">};</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">x</code>                            <code class="c1">// =&gt; undefined</code></pre>
        
        <p>Finally, it is worth noting that, although the spread operator is just
        three little dots in your code, it can represent a substantial amount
        of work to the JavaScript interpreter. If an object has <em>n</em>
        properties, the process of spreading those properties into another
        object is likely to be an <em>O(n)</em> operation. This means that if you
        find yourself using <code>...</code> within a loop or recursive function as a way
        to accumulate data into one large object, you may be writing an
        inefficient <em>O(n<sup>2</sup>)</em> algorithm that will not scale well as <em>n</em> gets
        larger.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.10.5 Shorthand Methods"><div class="sect2" id="object-literal-shorthand-methods">
        <h2>6.10.5 Shorthand Methods</h2>
        
        <p>When<a data-type="indexterm" data-primary="methods" data-secondary="shorthand syntax" id="idm46198548885400"></a><a data-type="indexterm" data-primary="shorthand methods" id="idm46198548884392"></a><a data-type="indexterm" data-primary="syntax" data-secondary="shorthand methods" id="idm46198548883720"></a><a data-type="indexterm" data-primary="ES6" data-secondary="shorthand methods" id="idm46198548882776"></a> a function is defined as a property of an object, we call that
        function a <em>method</em> (we’ll have a lot more to say about methods in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch08.html#functions">8</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch09.html#classes">9</a>). Prior to ES6, you would define a
        method in an object literal using a function definition expression just
        as you would define any other property of an object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">square</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">area</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">side</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">side</code><code class="p">;</code> <code class="p">},</code>
            <code class="nx">side</code><code class="o">:</code> <code class="mi">10</code>
        <code class="p">};</code>
        <code class="nx">square</code><code class="p">.</code><code class="nx">area</code><code class="p">()</code> <code class="c1">// =&gt; 100</code></pre>
        
        <p>In ES6, however, the object literal syntax (and also the class
        definition syntax we’ll see in <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>) has been extended to allow
        a shortcut where the <code>function</code> keyword and the colon are omitted,
        resulting in code like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">square</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">area</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">side</code> <code class="o">*</code> <code class="k">this</code><code class="p">.</code><code class="nx">side</code><code class="p">;</code> <code class="p">},</code>
            <code class="nx">side</code><code class="o">:</code> <code class="mi">10</code>
        <code class="p">};</code>
        <code class="nx">square</code><code class="p">.</code><code class="nx">area</code><code class="p">()</code> <code class="c1">// =&gt; 100</code></pre>
        
        <p>Both forms of the code are equivalent: both add a property named <code>area</code>
        to the object literal, and both set the value of that property to the
        specified function. The shorthand syntax makes it clearer that <code>area()</code>
        is a method and not a data property like <code>side</code>.</p>
        
        <p>When you write a method using this shorthand syntax, the property name
        can take any of the forms that are legal in an object literal: in
        addition to a regular JavaScript identifier like the name <code>area</code>
        above, you can also use string literals and computed property names,
        which can include Symbol property names:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">METHOD_NAME</code> <code class="o">=</code> <code class="s2">"m"</code><code class="p">;</code>
        <code class="kr">const</code> <code class="nx">symbol</code> <code class="o">=</code> <code class="nx">Symbol</code><code class="p">();</code>
        <code class="kd">let</code> <code class="nx">weirdMethods</code> <code class="o">=</code> <code class="p">{</code>
            <code class="s2">"method With Spaces"</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">1</code><code class="p">;</code> <code class="p">},</code>
            <code class="p">[</code><code class="nx">METHOD_NAME</code><code class="p">](</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">2</code><code class="p">;</code> <code class="p">},</code>
            <code class="p">[</code><code class="nx">symbol</code><code class="p">](</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="mi">3</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">};</code>
        <code class="nx">weirdMethods</code><code class="p">[</code><code class="s2">"method With Spaces"</code><code class="p">](</code><code class="mi">1</code><code class="p">)</code>  <code class="c1">// =&gt; 2</code>
        <code class="nx">weirdMethods</code><code class="p">[</code><code class="nx">METHOD_NAME</code><code class="p">](</code><code class="mi">1</code><code class="p">)</code>           <code class="c1">// =&gt; 3</code>
        <code class="nx">weirdMethods</code><code class="p">[</code><code class="nx">symbol</code><code class="p">](</code><code class="mi">1</code><code class="p">)</code>                <code class="c1">// =&gt; 4</code></pre>
        
        <p>Using a Symbol as a method name is not as strange as it seems. In
        order to make an object iterable (so it can be used with a <code>for/of</code>
        loop), you must define a method with the symbolic name
        <code>Symbol.iterator</code>, and there are examples of doing exactly that in
        <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="6.10.6 Property Getters and Setters"><div class="sect2" id="gettersandsetters">
        <h2>6.10.6 Property Getters and Setters</h2>
        
        <p>All<a data-type="indexterm" data-primary="properties" data-secondary="property getters and setters" id="idm46198548617768"></a><a data-type="indexterm" data-primary="getter methods" id="idm46198548616792"></a><a data-type="indexterm" data-primary="setter methods" id="idm46198548616120"></a><a data-type="indexterm" data-primary="data properties" id="idm46198548615448"></a><a data-type="indexterm" data-primary="accessor properties" id="idm46198548614776"></a> of the object properties we’ve discussed so far in this chapter
        have been <em>data properties</em> with a name and an ordinary
        value. JavaScript also supports <em>accessor properties</em>, which do not
        have a single value but instead have one or two accessor methods: a
        <em>getter</em> and/or a <em>setter</em>.</p>
        
        <p>When a program queries the value of an
        accessor property, JavaScript invokes the getter method (passing no
        arguments). The return value of this method becomes the value of the
        property access expression. When a program sets the value of an
        accessor property, JavaScript invokes the setter method, passing the
        value of the righthand side of the assignment. This method is
        responsible for “setting,” in some sense, the property value. The
        return value of the setter method is ignored.</p>
        
        <p>If a property has both a getter and a setter method, it is a
        read/write property. If it has only a getter method, it is a read-only
        property. And if it has only a setter method, it is a write-only
        property (something that is not possible with data properties), and
        attempts to read it always evaluate to <code>undefined</code>.</p>
        
        <p>Accessor properties can be defined with an extension to the object
        literal syntax (unlike the other ES6 extensions we’ve<a data-type="indexterm" data-primary="ES5" data-secondary="getters and setters" id="idm46198548609752"></a> seen here,
        getters and setters were introduced in ES5):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// An ordinary data property</code>
            <code class="nx">dataProp</code><code class="o">:</code> <code class="nx">value</code><code class="p">,</code>
        
            <code class="c1">// An accessor property defined as a pair of functions.</code>
            <code class="nx">get</code> <code class="nx">accessorProp</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">dataProp</code><code class="p">;</code> <code class="p">},</code>
            <code class="nx">set</code> <code class="nx">accessorProp</code><code class="p">(</code><code class="nx">value</code><code class="p">)</code> <code class="p">{</code> <code class="k">this</code><code class="p">.</code><code class="nx">dataProp</code> <code class="o">=</code> <code class="nx">value</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>Accessor properties are defined as one or two methods whose name is
        the same as the property name. These look like ordinary methods
        defined using the ES6 shorthand except that getter and setter
        definitions are prefixed with <code>get</code> or <code>set</code>.  (In ES6, you can also
        use computed property names when defining getters and setters. Simply
        replace the property name after <code>get</code> or <code>set</code> with an expression in
        square brackets.)</p>
        
        <p>The accessor methods defined above simply get and set the value of a
        data property, and there is no reason to prefer the accessor property
        over the data property. But as a more interesting example, consider
        the following object that represents a 2D Cartesian point. It has
        ordinary data properties to represent the <em>x</em> and <em>y</em> coordinates of the
        point, and it has accessor properties that give the equivalent polar
        coordinates of the point:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// x and y are regular read-write data properties.</code>
            <code class="nx">x</code><code class="o">:</code> <code class="mf">1.0</code><code class="p">,</code>
            <code class="nx">y</code><code class="o">:</code> <code class="mf">1.0</code><code class="p">,</code>
        
            <code class="c1">// r is a read-write accessor property with getter and setter.</code>
            <code class="c1">// Don't forget to put a comma after accessor methods.</code>
            <code class="nx">get</code> <code class="nx">r</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">hypot</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code> <code class="p">},</code>
            <code class="nx">set</code> <code class="nx">r</code><code class="p">(</code><code class="nx">newvalue</code><code class="p">)</code> <code class="p">{</code>
                <code class="kd">let</code> <code class="nx">oldvalue</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">hypot</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="p">);</code>
                <code class="kd">let</code> <code class="nx">ratio</code> <code class="o">=</code> <code class="nx">newvalue</code><code class="o">/</code><code class="nx">oldvalue</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">*=</code> <code class="nx">ratio</code><code class="p">;</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">y</code> <code class="o">*=</code> <code class="nx">ratio</code><code class="p">;</code>
            <code class="p">},</code>
        
            <code class="c1">// theta is a read-only accessor property with getter only.</code>
            <code class="nx">get</code> <code class="nx">theta</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">atan2</code><code class="p">(</code><code class="k">this</code><code class="p">.</code><code class="nx">y</code><code class="p">,</code> <code class="k">this</code><code class="p">.</code><code class="nx">x</code><code class="p">);</code> <code class="p">}</code>
        <code class="p">};</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">r</code>     <code class="c1">// =&gt; Math.SQRT2</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">theta</code> <code class="c1">// =&gt; Math.PI / 4</code></pre>
        
        <p>Note the use of the keyword <code>this</code> in the getters and setter
        in this example. JavaScript invokes these functions as methods of the object on
        which they are defined, which means that within the body of the
        function, <code>this</code> refers to the point object <code>p</code>. So the getter method
        for the <code>r</code> property can refer to the <code>x</code> and <code>y</code> properties as
        <code>this.x</code> and <code>this.y</code>. Methods and the <code>this</code> keyword are covered in
        more detail in <a data-type="xref" href="ch08.html#methodinvocation">§8.2.2</a>.</p>
        
        <p>Accessor properties are inherited, just as data properties are, so you
        can use the object <code>p</code> defined above as a prototype for other
        points. You can give the new objects their own <code>x</code> and <code>y</code> properties,
        and they’ll inherit the <code>r</code> and <code>theta</code> properties:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">q</code> <code class="o">=</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">create</code><code class="p">(</code><code class="nx">p</code><code class="p">);</code> <code class="c1">// A new object that inherits getters and setters</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">3</code><code class="p">;</code> <code class="nx">q</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="mi">4</code><code class="p">;</code>         <code class="c1">// Create q's own data properties</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">r</code>                       <code class="c1">// =&gt; 5: the inherited accessor properties work</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">theta</code>                   <code class="c1">// =&gt; Math.atan2(4, 3)</code></pre>
        
        <p>The code above uses accessor properties to define an API that provides two
        representations (Cartesian coordinates and polar coordinates) of a single set
        of data. Other reasons to use accessor properties include sanity checking of
        property writes and returning different values on each property read:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This object generates strictly increasing serial numbers</code>
        <code class="kr">const</code> <code class="nx">serialnum</code> <code class="o">=</code> <code class="p">{</code>
            <code class="c1">// This data property holds the next serial number.</code>
            <code class="c1">// The _ in the property name hints that it is for internal use only.</code>
            <code class="nx">_n</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code>
        
            <code class="c1">// Return the current value and increment it</code>
            <code class="nx">get</code> <code class="nx">next</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">_n</code><code class="o">++</code><code class="p">;</code> <code class="p">},</code>
        
            <code class="c1">// Set a new value of n, but only if it is larger than current</code>
            <code class="nx">set</code> <code class="nx">next</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">&gt;</code> <code class="k">this</code><code class="p">.</code><code class="nx">_n</code><code class="p">)</code> <code class="k">this</code><code class="p">.</code><code class="nx">_n</code> <code class="o">=</code> <code class="nx">n</code><code class="p">;</code>
                <code class="k">else</code> <code class="k">throw</code> <code class="k">new</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"serial number can only be set to a larger value"</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">};</code>
        <code class="nx">serialnum</code><code class="p">.</code><code class="nx">next</code> <code class="o">=</code> <code class="mi">10</code><code class="p">;</code>    <code class="c1">// Set the starting serial number</code>
        <code class="nx">serialnum</code><code class="p">.</code><code class="nx">next</code>          <code class="c1">// =&gt; 10</code>
        <code class="nx">serialnum</code><code class="p">.</code><code class="nx">next</code>          <code class="c1">// =&gt; 11: different value each time we get next</code></pre>
        
        <p>Finally, here<a data-type="indexterm" data-primary="" data-startref="Soblit06" id="idm46198548264392"></a><a data-type="indexterm" data-primary="" data-startref="OLsyntax06" id="idm46198548263544"></a><a data-type="indexterm" data-primary="" data-startref="Oextend06" id="idm46198548219272"></a> is one more example that uses a getter method to implement a
        property with “magical” behavior:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This object has accessor properties that return random numbers.</code>
        <code class="c1">// The expression "random.octet", for example, yields a random number</code>
        <code class="c1">// between 0 and 255 each time it is evaluated.</code>
        <code class="kr">const</code> <code class="nx">random</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">get</code> <code class="nx">octet</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code><code class="o">*</code><code class="mi">256</code><code class="p">);</code> <code class="p">},</code>
            <code class="nx">get</code> <code class="nx">uint16</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code><code class="o">*</code><code class="mi">65536</code><code class="p">);</code> <code class="p">},</code>
            <code class="nx">get</code> <code class="nx">int16</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">floor</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">random</code><code class="p">()</code><code class="o">*</code><code class="mi">65536</code><code class="p">)</code><code class="o">-</code><code class="mi">32768</code><code class="p">;</code> <code class="p">}</code>
        <code class="p">};</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="6.11 Summary"><div class="sect1" id="idm46198548619336">
        <h1>6.11 Summary</h1>
        
        <p>This chapter has documented JavaScript objects in great detail,
        covering topics that include:</p>
        
        <ul>
        <li>
        <p>Basic object terminology, including the meaning of terms like
        <em>enumerable</em> and <em>own property</em>.</p>
        </li>
        <li>
        <p>Object literal syntax, including the many new features in ES6 and
        later.</p>
        </li>
        <li>
        <p>How to read, write, delete, enumerate, and check for the presence of the
        properties of an object.</p>
        </li>
        <li>
        <p>How prototype-based inheritance works in JavaScript and how to
        create an object that inherits from another object with
        <code>Object.create()</code>.</p>
        </li>
        <li>
        <p>How to copy properties from one object into another with
        <code>Object.assign()</code>.</p>
        </li>
        </ul>
        
        <p>All JavaScript values that are not primitive values are objects. This
        includes both arrays and functions, which are the topics of the next
        two chapters.</p>
        </div></section>
        
        
        
        
        
        
        
        <div data-type="footnotes"><p data-type="footnote" id="idm46198551345848"><sup><a href="ch06.html#idm46198551345848-marker">1</a></sup> Remember; almost all objects have a prototype but most do not have a property named <code>prototype</code>. JavaScript inheritance works even if you can’t access the prototype object directly. But see <a data-type="xref" href="ch14.html#prototypeattr">§14.3</a> if you want to learn how to do that.</p></div></div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->