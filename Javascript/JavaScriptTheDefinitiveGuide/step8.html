<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 8. Functions"><div class="chapter" id="functions">
        <h1><span class="label">Chapter 8. </span>Functions</h1>
        
        
        <p>This<a data-type="indexterm" data-primary="functions" data-secondary="overview of" id="idm46198543280024"></a><a data-type="indexterm" data-primary="subroutines" id="idm46198543279016"></a><a data-type="indexterm" data-primary="procedures" id="idm46198543278344"></a> chapter covers JavaScript functions. Functions are a fundamental
        building block for JavaScript programs and a common feature in
        almost all programming languages. You may already be familiar with the
        concept of a function under a name such as <em>subroutine</em> or
        <em>procedure</em>.</p>
        
        <p>A <em>function</em> is a block of JavaScript code that is defined once but
        may be executed, or <em>invoked</em>, any number of times. JavaScript
        functions<a data-type="indexterm" data-primary="parameterization" id="idm46198543274760"></a> are <em>parameterized</em>: a function definition may include a
        list of identifiers, known as <em>parameters</em>, that work as local
        variables for the body of the function. Function invocations provide
        values, or<a data-type="indexterm" data-primary="arguments" data-secondary="definition of term" id="idm46198543272984"></a> <em>arguments</em>, for the function’s parameters. Functions often
        use their argument values to compute a<a data-type="indexterm" data-primary="return values" id="idm46198543271352"></a> <em>return value</em> that becomes the
        value of the function-invocation expression. In addition to the
        arguments, each invocation has another value—the <em>invocation
        context</em>—that is the value of the <code>this</code> keyword.</p>
        
        <p>If<a data-type="indexterm" data-primary="methods" data-secondary="definition of term" id="idm46198543268776"></a><a data-type="indexterm" data-primary="constructors" data-secondary="definition of term" id="idm46198543267768"></a> a function is assigned to a property of an object, it is known as
        a <em>method</em> of that object. When a function is invoked <em>on</em> or
        <em>through</em> an object, that object is the invocation context or <code>this</code>
        value for the function. Functions designed to initialize a newly
        created object are called <em>constructors</em>. Constructors were described
        in <a data-type="xref" href="ch06.html#creatingobjects">§6.2</a> and will be covered again in <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>.</p>
        
        <p>In JavaScript, functions are objects, and they can be manipulated by
        programs. JavaScript can assign functions to variables and pass them
        to other functions, for example. Since functions are objects, you can
        set properties on them and even invoke methods on them.</p>
        
        <p>JavaScript function definitions can be nested within other functions,
        and they have access to any variables that are in scope where they are
        defined. This means that JavaScript functions are <em>closures</em>, and it
        enables important and powerful programming techniques.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="8.1 Defining Functions"><div class="sect1" id="definingfunctions">
        <h1>8.1 Defining Functions</h1>
        
        <p>The<a data-type="indexterm" data-primary="functions" data-secondary="defining" id="Fdefine07"></a><a data-type="indexterm" data-primary="function keyword" id="idm46198543241672"></a><a data-type="indexterm" data-primary="keywords" data-secondary="function keyword" id="idm46198543240968"></a> most straightforward way to define a JavaScript function is with the
        <code>function</code> keyword, which can be used as a declaration or as an
        expression. ES6<a data-type="indexterm" data-primary="ES6" data-secondary="arrow functions" id="idm46198543239512"></a><a data-type="indexterm" data-primary="arrow functions" id="idm46198543238536"></a><a data-type="indexterm" data-primary="functions" data-secondary="arrow functions" id="idm46198543237864"></a> defines an important new way to define
        functions without the <code>function</code> keyword: “arrow functions” have a
        particularly compact syntax and are useful when passing one function as
        an argument to another function. The subsections that follow cover these three
        ways of defining functions. Note that some details of function
        definition syntax involving function parameters are deferred to
        <a data-type="xref" href="#functionargumentsandparameters">§8.3</a>.</p>
        
        <p>In object literals and class definitions, there is a convenient shorthand
        syntax for defining methods. This shorthand syntax was covered in
        <a data-type="xref" href="ch06.html#object-literal-shorthand-methods">§6.10.5</a> and is equivalent to using a
        function definition expression and assigning it to an object property
        using the basic <code>name:value</code> object literal syntax. In another special
        case, you can use keywords <code>get</code> and <code>set</code> in object literals to define
        special property getter and setter methods. This function definition
        syntax was covered in <a data-type="xref" href="ch06.html#gettersandsetters">§6.10.6</a>.</p>
        
        <p>Note that functions can also be defined with the <code>Function()</code>
        constructor, which is the subject of
        <a data-type="xref" href="#functionconstructor">§8.7.7</a>. Also, JavaScript defines some
        specialized kinds of functions. 
        <span class="keep-together"><code>function*</code></span> defines generator functions
        (see <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a>) and <code>async function</code> defines asynchronous functions
        (see <a data-type="xref" href="ch13.html#async">Chapter&nbsp;13</a>).</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.1.1 Function Declarations"><div class="sect2" id="functiondeclarations">
        <h2>8.1.1 Function Declarations</h2>
        
        <p>Function declarations consist of the <code>function</code> keyword, followed by
        these <span class="keep-together">components:</span></p>
        
        <ul>
        <li>
        <p>An identifier that names the function. The name is a required part
        of function declarations: it is used as the name of a
        variable, and the newly defined function object is assigned to the
        variable.</p>
        </li>
        <li>
        <p>A pair of parentheses around a comma-separated list of zero or more
        identifiers. These identifiers are the parameter names for the
        function, and they behave like local variables within the body of
        the function.</p>
        </li>
        <li>
        <p>A pair of curly braces with zero or more JavaScript statements
        inside. These statements are the body of the function: they are
        executed whenever the function is invoked.</p>
        </li>
        </ul>
        
        <p>Here are some example function declarations:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Print the name and value of each property of o.  Return undefined.</code>
        <code class="kd">function</code> <code class="nx">printprops</code><code class="p">(</code><code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">p</code> <code class="k">in</code> <code class="nx">o</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`</code><code class="si">${</code><code class="nx">p</code><code class="si">}</code><code class="sb">: </code><code class="si">${</code><code class="nx">o</code><code class="p">[</code><code class="nx">p</code><code class="p">]</code><code class="si">}</code><code class="err">\</code><code class="sb">n`</code><code class="p">);</code>
            <code class="p">}</code>
        <code class="p">}</code>
        
        <code class="c1">// Compute the distance between Cartesian points (x1,y1) and (x2,y2).</code>
        <code class="kd">function</code> <code class="nx">distance</code><code class="p">(</code><code class="nx">x1</code><code class="p">,</code> <code class="nx">y1</code><code class="p">,</code> <code class="nx">x2</code><code class="p">,</code> <code class="nx">y2</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">dx</code> <code class="o">=</code> <code class="nx">x2</code> <code class="o">-</code> <code class="nx">x1</code><code class="p">;</code>
            <code class="kd">let</code> <code class="nx">dy</code> <code class="o">=</code> <code class="nx">y2</code> <code class="o">-</code> <code class="nx">y1</code><code class="p">;</code>
            <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">dx</code><code class="o">*</code><code class="nx">dx</code> <code class="o">+</code> <code class="nx">dy</code><code class="o">*</code><code class="nx">dy</code><code class="p">);</code>
        <code class="p">}</code>
        
        <code class="c1">// A recursive function (one that calls itself) that computes factorials</code>
        <code class="c1">// Recall that x! is the product of x and all positive integers less than it.</code>
        <code class="kd">function</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&lt;=</code> <code class="mi">1</code><code class="p">)</code> <code class="k">return</code> <code class="mi">1</code><code class="p">;</code>
            <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">x</code><code class="o">-</code><code class="mi">1</code><code class="p">);</code>
        <code class="p">}</code></pre>
        
        <p>One of the important things to understand about function declarations
        is that the name of the function becomes a variable whose
        value is the function itself. Function declaration statements are
        “hoisted” to the top of the enclosing script, function, or block so
        that functions defined in this way may be invoked from code that
        appears before the definition. Another way to say this is that all of
        the functions declared in a block of JavaScript code will be defined
        throughout that block, and they will be defined before the JavaScript
        interpreter begins to execute any of the code in that block.</p>
        
        <p>The<a data-type="indexterm" data-primary="distance() function" id="idm46198543113240"></a> <code>distance()</code> and<a data-type="indexterm" data-primary="factorial() function" id="idm46198543111896"></a> <code>factorial()</code> functions we’ve described are designed to
        compute a value, and they use <code>return</code> to return that value to their
        caller. The <code>return</code> statement causes the function to stop executing
        and to return the value of its expression (if any) to the caller. If
        the <code>return</code> statement does not have an associated expression, the
        return value of the function is <code>undefined</code>.</p>
        
        <p>The<a data-type="indexterm" data-primary="printprops() function" id="idm46198543108200"></a> <code>printprops()</code> function is different: its job is to output the
        names and values of an object’s properties. No return value is
        necessary, and the function does not include a <code>return</code> statement. The
        value of an invocation of the <code>printprops()</code> function is always
        <code>undefined</code>. If a function does not contain a <code>return</code> statement, it
        simply executes each statement in the function body until it reaches
        the end, and returns the <code>undefined</code> value to the caller.</p>
        
        <p>Prior to ES6, function declarations were only allowed
        at the top level within a JavaScript file or within another
        function. While some implementations bent the rule, it was not
        technically legal to define functions inside the body of loops,
        conditionals, or other blocks. In<a data-type="indexterm" data-primary="strict mode" data-secondary="function declarations" id="idm46198543103832"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="function declarations" id="idm46198543102856"></a> the strict mode of ES6, however,
        function declarations are allowed within blocks. A function
        defined within a block only exists within that block, however, and is
        not visible outside the block.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.1.2 Function Expressions"><div class="sect2" id="functionexpressions">
        <h2>8.1.2 Function Expressions</h2>
        
        <p>Function expressions<a data-type="indexterm" data-primary="expressions" data-secondary="function expressions" id="idm46198543099768"></a><a data-type="indexterm" data-primary="function expressions" id="idm46198543098760"></a> look a lot like function declarations,
        but they appear within the context of a larger expression
        or statement, and the name is optional. Here are some example
        function expressions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This function expression defines a function that squares its argument.</code>
        <code class="c1">// Note that we assign it to a variable</code>
        <code class="kr">const</code> <code class="nx">square</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;</code> <code class="p">};</code>
        
        <code class="c1">// Function expressions can include names, which is useful for recursion.</code>
        <code class="kr">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="kd">function</code> <code class="nx">fact</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">if</code> <code class="p">(</code><code class="nx">x</code> <code class="o">&lt;=</code> <code class="mi">1</code><code class="p">)</code> <code class="k">return</code> <code class="mi">1</code><code class="p">;</code> <code class="k">else</code> <code class="k">return</code> <code class="nx">x</code><code class="o">*</code><code class="nx">fact</code><code class="p">(</code><code class="nx">x</code><code class="o">-</code><code class="mi">1</code><code class="p">);</code> <code class="p">};</code>
        
        <code class="c1">// Function expressions can also be used as arguments to other functions:</code>
        <code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">1</code><code class="p">].</code><code class="nx">sort</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code class="nx">b</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">a</code><code class="o">-</code><code class="nx">b</code><code class="p">;</code> <code class="p">});</code>
        
        <code class="c1">// Function expressions are sometimes defined and immediately invoked:</code>
        <code class="kd">let</code> <code class="nx">tensquared</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code><code class="k">return</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;}(</code><code class="mi">10</code><code class="p">));</code></pre>
        
        <p>Note that the function name is optional for functions defined as
        expressions, and most of the preceding function expressions we’ve shown omit it. A function declaration actually <em>declares</em> a
        variable and assigns a function object to it. A function
        expression, on the other hand, does not declare a variable: it is up
        to you to assign the newly defined function object to a constant or
        variable if you are going to need to refer to it multiple times. It is
        a good practice to use <code>const</code> with function expressions so you don’t
        accidentally overwrite your functions by assigning new values.</p>
        
        <p>A name is allowed for functions, like the factorial function,
        that need to refer to themselves. If a function expression
        includes a name, the local function scope for that function will
        include a binding of that name to the function object. In effect, the
        function name becomes a local variable within the function. Most
        functions defined as expressions do not need names, which makes their
        definition more compact (though not nearly as compact as arrow
        functions, described below).</p>
        
        <p>There is an important difference between defining a function <code>f()</code>
        with a function declaration and assigning a function to the variable <code>f</code>
        after creating it as an expression. When you use the declaration form,
        the function objects are created before the code that contains them
        starts to run, and the definitions are hoisted so that you can call
        these functions from code that appears above the definition
        statement. This is not true for functions defined as expressions,
        however: these functions do not exist until the expression that
        defines them are actually evaluated. Furthermore, in order to invoke a
        function, you must be able to refer to it, and you can’t refer to a
        function defined as an expression until it is assigned to a
        variable, so functions
        defined with expressions cannot be invoked before they are defined.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.1.3 Arrow Functions"><div class="sect2" id="arrowfunctions">
        <h2>8.1.3 Arrow Functions</h2>
        
        <p>In<a data-type="indexterm" data-primary="functions" data-secondary="arrow functions" id="idm46198542950392"></a><a data-type="indexterm" data-primary="arrow functions" id="idm46198542949384"></a><a data-type="indexterm" data-primary="ES6" data-secondary="arrow functions" id="idm46198542948712"></a> ES6, you can define functions using a particularly compact syntax
        known as “arrow functions.” This<a data-type="indexterm" data-primary="arrows (=>)" id="idm46198542947528"></a><a data-type="indexterm" data-primary="=> (arrows)" id="idm46198542946856"></a> syntax is reminiscent of mathematical
        notation and uses an <code>=&gt;</code> “arrow” to separate the function parameters
        from the function body. The <code>function</code> keyword is not used, and, since
        arrow functions are expressions instead of statements, there is no need
        for a function name, either. The general form of an arrow function is
        a comma-separated list of parameters in parentheses, followed by the
        <code>=&gt;</code> arrow, followed by the function body in curly braces:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">sum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">;</code> <code class="p">};</code></pre>
        
        <p>But arrow functions support an even more compact syntax. If the body
        of the function is a single <code>return</code> statement, you can omit the
        <code>return</code> keyword, the semicolon that goes with it, and the curly
        braces, and write the body of the function as the expression whose
        value is to be returned:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">sum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">;</code></pre>
        
        <p>Furthermore, if an arrow function has exactly one parameter, you can
        omit the parentheses around the parameter list:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">polynomial</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code> <code class="o">+</code> <code class="mi">2</code><code class="o">*</code><code class="nx">x</code> <code class="o">+</code> <code class="mi">3</code><code class="p">;</code></pre>
        
        <p>Note, however, that an arrow function with no arguments at all must be
        written with an empty pair of parentheses:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">constantFunc</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="mi">42</code><code class="p">;</code></pre>
        
        <p>Note that, when writing an arrow function, you must not put a new line
        between the function parameters and the <code>=&gt;</code> arrow. Otherwise, you could
        end up with a line like <code>const polynomial = x</code>, which is a syntactically
        valid assignment statement on its own.</p>
        
        <p>Also, if the body of your arrow function is a single <code>return</code> statement
        but the expression to be returned is an object literal, then you have to
        put the object literal inside parentheses to avoid syntactic ambiguity
        between the curly braces of a function body and the curly braces of an
        object literal:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="k">return</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">x</code> <code class="p">};</code> <code class="p">};</code>  <code class="c1">// Good: f() returns an object</code>
        <code class="kr">const</code> <code class="nx">g</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="p">({</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">x</code> <code class="p">});</code>            <code class="c1">// Good: g() returns an object</code>
        <code class="kr">const</code> <code class="nx">h</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">value</code><code class="o">:</code> <code class="nx">x</code> <code class="p">};</code>              <code class="c1">// Bad: h() returns nothing</code>
        <code class="kr">const</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="p">{</code> <code class="nx">v</code><code class="o">:</code> <code class="nx">x</code><code class="p">,</code> <code class="nx">w</code><code class="o">:</code> <code class="nx">x</code> <code class="p">};</code>            <code class="c1">// Bad: Syntax Error</code></pre>
        
        <p>In the third line of this code, the function <code>h()</code> is truly ambiguous:
        the code you intended as an object literal can be parsed as a labeled
        statement, so a function that returns undefined is created. On the
        fourth line, however, the more complicated object literal is not a valid
        statement, and this illegal code causes a syntax error.</p>
        
        <p>The concise syntax of arrow functions makes them ideal when you need to
        pass one function to another function, which is a common thing to do
        with array methods like <code>map()</code>, <code>filter()</code>, and <code>reduce()</code> (see
        <a data-type="xref" href="ch07.html#arrayiteratormethods">§7.8.1</a>), for example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Make a copy of an array with null elements removed.</code>
        <code class="kd">let</code> <code class="nx">filtered</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="kc">null</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">].</code><code class="nx">filter</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">!==</code> <code class="kc">null</code><code class="p">);</code> <code class="c1">// filtered == [1,2,3]</code>
        <code class="c1">// Square some numbers:</code>
        <code class="kd">let</code> <code class="nx">squares</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">].</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">);</code>               <code class="c1">// squares == [1,4,9,16]</code></pre>
        
        <p>Arrow functions differ from functions defined in other ways in one
        critical way: they inherit the value of the <code>this</code> keyword from
        the environment in which they are defined rather than defining their
        own invocation context as functions defined in other ways do. This is
        an important and very useful feature of arrow functions, and we’ll
        return to it again later in this chapter. Arrow functions also differ
        from other functions in that they do not have a <code>prototype</code> property,
        which means that they cannot be used as constructor functions for new
        classes (see <a data-type="xref" href="ch09.html#classesandconstructors">§9.2</a>).</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.1.4 Nested Functions"><div class="sect2" id="idm46198542951720">
        <h2>8.1.4 Nested Functions</h2>
        
        <p>In<a data-type="indexterm" data-primary="nested functions" id="idm46198542611592"></a> JavaScript, functions may be nested within other functions. For
        example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">hypotenuse</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;</code> <code class="p">}</code>
            <code class="k">return</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">square</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code> <code class="o">+</code> <code class="nx">square</code><code class="p">(</code><code class="nx">b</code><code class="p">));</code>
        <code class="p">}</code></pre>
        
        <p>The<a data-type="indexterm" data-primary="variables" data-secondary="scope of" id="idm46198542609528"></a> interesting thing about nested functions is their variable scoping
        rules: they can access the parameters and variables of the function
        (or functions) they are nested within. In the code shown here, for example,
        the inner function <code>square()</code> can read and write the parameters <code>a</code>
        and <code>b</code> defined by the outer function <code>hypotenuse()</code>. These scope
        rules for nested functions are very important, and we will
        consider them again in <a data-type="xref" href="#closures">§8.6</a>.<a data-type="indexterm" data-primary="" data-startref="Fdefine07" id="idm46198542534552"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="8.2 Invoking Functions"><div class="sect1" id="invokingfunctions">
        <h1>8.2 Invoking Functions</h1>
        
        <p>The<a data-type="indexterm" data-primary="functions" data-secondary="invoking" data-tertiary="approaches to" id="idm46198542531640"></a> JavaScript code that makes up the body of a function is not
        executed when the function is defined, but rather when it is
        invoked. JavaScript functions can be invoked in five ways:</p>
        
        <ul>
        <li>
        <p>As functions</p>
        </li>
        <li>
        <p>As methods</p>
        </li>
        <li>
        <p>As constructors</p>
        </li>
        <li>
        <p>Indirectly through their <code>call()</code> and <code>apply()</code> methods</p>
        </li>
        <li>
        <p>Implicitly, via JavaScript language features that do not appear like
        normal function invocations</p>
        </li>
        </ul>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.2.1 Function Invocation"><div class="sect2" id="functioninvocation">
        <h2>8.2.1 Function Invocation</h2>
        
        <p>Functions<a data-type="indexterm" data-primary="functions" data-secondary="invoking" data-tertiary="invocation expressions" id="idm46198542521976"></a><a data-type="indexterm" data-primary="expressions" data-secondary="invocation expressions" id="Einvocexp01"></a><a data-type="indexterm" data-primary="invocation expressions" data-secondary="overview of" id="idm46198542519480"></a> are invoked as functions or as methods with an invocation
        expression (<a data-type="xref" href="ch04.html#invocationexprs">§4.5</a>). An invocation expression consists of
        a function expression that evaluates to a function object followed by
        an open parenthesis, a comma-separated list of zero or more argument
        expressions, and a close parenthesis. If the function expression is a
        property-access expression—if the function is the property of an
        object or an element of an array—then it is a method invocation
        expression. That case will be explained in the following example. The following code
        includes a number of regular function invocation expressions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">printprops</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">});</code>
        <code class="kd">let</code> <code class="nx">total</code> <code class="o">=</code> <code class="nx">distance</code><code class="p">(</code><code class="mi">0</code><code class="p">,</code><code class="mi">0</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">1</code><code class="p">)</code> <code class="o">+</code> <code class="nx">distance</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">5</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">probability</code> <code class="o">=</code> <code class="nx">factorial</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code><code class="o">/</code><code class="nx">factorial</code><code class="p">(</code><code class="mi">13</code><code class="p">);</code></pre>
        
        <p>In an invocation, each argument expression (the ones between the
        parentheses) is evaluated, and the resulting values become the
        arguments to the function. These values are assigned to the parameters
        named in the function definition. In the body of the function, a
        reference to a parameter evaluates to the corresponding argument
        value.</p>
        
        <p>For regular function invocation, the return value of the function
        becomes the value of the invocation expression. If the function
        returns because the interpreter reaches the end, the return value is
        <code>undefined</code>. If the function returns because the interpreter executes
        a <code>return</code> statement, then the return value is the value of the
        expression that follows the <code>return</code> or is <code>undefined</code> if the <code>return</code>
        statement has no value.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198542450808">
        <h5>Conditional Invocation</h5>
        <p>In<a data-type="indexterm" data-primary="conditional invocation" id="idm46198542449256"></a><a data-type="indexterm" data-primary="invocation expressions" data-secondary="conditional invocation" id="idm46198542448520"></a><a data-type="indexterm" data-primary="?. (conditional access operator)" id="idm46198542447576"></a><a data-type="indexterm" data-primary="conditional access operator (?.)" id="idm46198542446936"></a><a data-type="indexterm" data-primary="ES2020" data-secondary="conditional access operator (?.)" id="idm46198542446296"></a> ES2020 you can insert <code>?.</code> after the function expression and before
        the open parenthesis in a function invocation in order to invoke the
        function only if it is not <code>null</code> or <code>undefined</code>. That is, the
        expression <code>f?.(x)</code> is equivalent (assuming no side effects) to:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">(</code><code class="nx">f</code> <code class="o">!==</code> <code class="kc">null</code> <code class="o">&amp;&amp;</code> <code class="nx">f</code> <code class="o">!==</code> <code class="kc">undefined</code><code class="p">)</code> <code class="o">?</code> <code class="nx">f</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="o">:</code> <code class="kc">undefined</code></pre>
        
        <p>Full details on this conditional invocation syntax are in
        <a data-type="xref" href="ch04.html#conditionalinvocation">§4.5.1</a>.</p>
        </div></aside>
        
        <p>For<a data-type="indexterm" data-primary="strict mode" data-secondary="function invocation" id="idm46198542433096"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="function invocation" id="idm46198542432120"></a> function invocation in non-strict mode, the invocation context (the
        <code>this</code> value) is the global object. In strict mode, however, the
        invocation context is <code>undefined</code>.  Note that functions defined using
        the arrow syntax behave differently: they always inherit the <code>this</code>
        value that is in effect where they are defined.</p>
        
        <p>Functions<a data-type="indexterm" data-primary="this keyword" id="idm46198542429304"></a><a data-type="indexterm" data-primary="keywords" data-secondary="this keyword" id="idm46198542428568"></a> written to be invoked as functions (and not as methods) do not
        typically use the <code>this</code> keyword at all. The keyword can be used, however, to
        determine whether strict mode is in effect:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Define and invoke a function to determine if we're in strict mode.</code>
        <code class="kr">const</code> <code class="nx">strict</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="o">!</code><code class="k">this</code><code class="p">;</code> <code class="p">}());</code></pre>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198542378776">
        <h5>Recursive Functions and the Stack</h5>
        <p>A <em>recursive</em> function<a data-type="indexterm" data-primary="functions" data-secondary="recursive functions" id="idm46198542371624"></a><a data-type="indexterm" data-primary="recursive functions" id="idm46198542350168"></a><a data-type="indexterm" data-primary="factorial() function" id="idm46198542349464"></a> is one, like the <code>factorial()</code> function at the
        start of this chapter, that calls itself. Some algorithms, such as those
        involving tree-based data structures, can be implemented particularly
        elegantly with recursive functions. When writing a recursive function,
        however, it is important to think about memory constraints. When a
        function A calls function B, and then function B calls function C, the
        JavaScript interpreter needs to keep track of the execution contexts for
        all three functions. When function C completes, the interpreter needs to
        know where to resume executing function B, and when function B
        completes, it needs to know where to resume executing function A. You
        can imagine these execution contexts as a stack. When a function calls
        another function, a new execution context is pushed onto the stack. When
        that function returns, its execution context object is popped off the
        stack. If a function calls itself recursively 100 times, the stack will
        have 100 objects pushed onto it, and then have those 100 objects popped
        off. This call stack takes memory. On modern hardware, it is typically
        fine to write recursive functions that call themselves hundreds of
        times. But if a function calls itself ten thousand times, it is likely
        to fail with an error such as “Maximum call-stack size exceeded.”</p>
        </div></aside>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.2.2 Method Invocation"><div class="sect2" id="methodinvocation">
        <h2>8.2.2 Method Invocation</h2>
        
        <p>A<a data-type="indexterm" data-primary="methods" data-secondary="method invocation" id="Minvo08"></a><a data-type="indexterm" data-primary="functions" data-secondary="invoking" data-tertiary="method invocation" id="Finmeth08"></a><a data-type="indexterm" data-primary="methods" data-secondary="definition of term" id="idm46198542341736"></a> <em>method</em> is nothing more than a JavaScript function that is stored
        in a property of an object. If you have a function <code>f</code> and an object
        <code>o</code>, you can define a method named <code>m</code> of <code>o</code> with the following line:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">o</code><code class="p">.</code><code class="nx">m</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code></pre>
        
        <p>Having defined the method <code>m()</code> of the object <code>o</code>, invoke it like
        this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">o</code><code class="p">.</code><code class="nx">m</code><code class="p">();</code></pre>
        
        <p>Or, if <code>m()</code> expects two arguments, you might invoke it like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">o</code><code class="p">.</code><code class="nx">m</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">);</code></pre>
        
        <p>The<a data-type="indexterm" data-primary="invocation expressions" data-secondary="method invocation" id="idm46198542270056"></a> code in this example is an invocation expression: it includes a function
        expression <code>o.m</code> and two argument expressions, <code>x</code> and <code>y</code>. The
        function expression is itself a property access expression, and this
        means that the function is invoked as a method rather than as a
        regular function.</p>
        
        <p>The arguments and return value of a method invocation are handled
        exactly as described for regular function invocation. Method
        invocations differ from function invocations in one important way,
        however: the invocation context. Property access expressions consist
        of two parts: an object (in this case <code>o</code>) and a property name
        (<code>m</code>). In a method-invocation expression like this, the object <code>o</code>
        becomes the invocation context, and the function body can refer to
        that object by using the keyword <code>this</code>. Here is a concrete example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">calculator</code> <code class="o">=</code> <code class="p">{</code> <code class="c1">// An object literal</code>
            <code class="nx">operand1</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
            <code class="nx">operand2</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code>
            <code class="nx">add</code><code class="p">()</code> <code class="p">{</code>        <code class="c1">// We're using method shorthand syntax for this function</code>
                <code class="c1">// Note the use of the this keyword to refer to the containing object.</code>
                <code class="k">this</code><code class="p">.</code><code class="nx">result</code> <code class="o">=</code> <code class="k">this</code><code class="p">.</code><code class="nx">operand1</code> <code class="o">+</code> <code class="k">this</code><code class="p">.</code><code class="nx">operand2</code><code class="p">;</code>
            <code class="p">}</code>
        <code class="p">};</code>
        <code class="nx">calculator</code><code class="p">.</code><code class="nx">add</code><code class="p">();</code>  <code class="c1">// A method invocation to compute 1+1.</code>
        <code class="nx">calculator</code><code class="p">.</code><code class="nx">result</code>  <code class="c1">// =&gt; 2</code></pre>
        
        <p>Most method invocations use the dot notation for property access, but
        property access expressions that use square brackets also cause method
        invocation. The following are both method invocations, for example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">o</code><code class="p">[</code><code class="s2">"m"</code><code class="p">](</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">);</code>   <code class="c1">// Another way to write o.m(x,y).</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">](</code><code class="nx">z</code><code class="p">)</code>        <code class="c1">// Also a method invocation (assuming a[0] is a function).</code></pre>
        
        <p>Method invocations may also involve more complex property access
        expressions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">customer</code><code class="p">.</code><code class="nx">surname</code><code class="p">.</code><code class="nx">toUpperCase</code><code class="p">();</code> <code class="c1">// Invoke method on customer.surname</code>
        <code class="nx">f</code><code class="p">().</code><code class="nx">m</code><code class="p">();</code>                        <code class="c1">// Invoke method m() on return value of f()</code></pre>
        
        <p>Methods and the <code>this</code> keyword are central to the object-oriented
        programming paradigm. Any function that is used as a method is
        effectively passed an implicit argument—the object through which it is
        invoked. Typically, a method performs some sort of operation on that
        object, and the method-invocation syntax is an elegant way to express
        the fact that a function is operating on an object. Compare the
        following two lines:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">rect</code><code class="p">.</code><code class="nx">setSize</code><code class="p">(</code><code class="nx">width</code><code class="p">,</code> <code class="nx">height</code><code class="p">);</code>
        <code class="nx">setRectSize</code><code class="p">(</code><code class="nx">rect</code><code class="p">,</code> <code class="nx">width</code><code class="p">,</code> <code class="nx">height</code><code class="p">);</code></pre>
        
        <p>The hypothetical functions invoked in these two lines of code may
        perform exactly the same operation on the (hypothetical) object
        <code>rect</code>, but the method-invocation syntax in the first line more
        clearly indicates the idea that it is the object <code>rect</code> that is the
        primary focus of the operation.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198542090360">
        <h5>Method Chaining</h5>
        <p>When<a data-type="indexterm" data-primary="methods" data-secondary="method chaining" id="idm46198542088888"></a> methods return objects, you can use the return value of one
        method invocation as part of a subsequent invocation. This results in
        a series (or “chain”) of method invocations as a single
        expression. When working with Promise-based asynchronous operations
        (see <a data-type="xref" href="ch13.html#async">Chapter&nbsp;13</a>), for example, it is common to write code structured like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Run three asynchronous operations in sequence, handling errors.</code>
        <code class="nx">doStepOne</code><code class="p">().</code><code class="nx">then</code><code class="p">(</code><code class="nx">doStepTwo</code><code class="p">).</code><code class="nx">then</code><code class="p">(</code><code class="nx">doStepThree</code><code class="p">).</code><code class="k">catch</code><code class="p">(</code><code class="nx">handleErrors</code><code class="p">);</code></pre>
        
        <p>When you write a method that does not have a return value of its own,
        consider having the method return <code>this</code>. If you do this consistently
        throughout your API, you will enable a style of programming known as
        <em>method chaining</em><sup><a data-type="noteref" id="idm46198542019096-marker" href="ch08.html#idm46198542019096">1</a></sup> in
        which an object can be named once and then multiple methods can be
        invoked on it:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">new</code> <code class="nx">Square</code><code class="p">().</code><code class="nx">x</code><code class="p">(</code><code class="mi">100</code><code class="p">).</code><code class="nx">y</code><code class="p">(</code><code class="mi">100</code><code class="p">).</code><code class="nx">size</code><code class="p">(</code><code class="mi">50</code><code class="p">).</code><code class="nx">outline</code><code class="p">(</code><code class="s2">"red"</code><code class="p">).</code><code class="nx">fill</code><code class="p">(</code><code class="s2">"blue"</code><code class="p">).</code><code class="nx">draw</code><code class="p">();</code></pre>
        </div></aside>
        
        <p>Note that <code>this</code> is a keyword, not a variable or property
        name. JavaScript syntax does not allow you to assign a value to
        <code>this</code>.</p>
        
        <p>The <code>this</code> keyword is not scoped the way variables are, and, except for
        arrow functions, nested functions do not inherit the
        <code>this</code> value of the containing function. If a nested function is invoked
        as a method, its <code>this</code> value is the object it was invoked on. If a
        nested function (that is not an arrow function) is invoked as a function,
        then its <code>this</code> value will be either the global object (non-strict mode)
        or <code>undefined</code> (strict mode). It is a common mistake to assume that a
        nested function defined within a method and invoked as a function can
        use <code>this</code> to obtain the invocation context of the method. The following
        code demonstrates the problem:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code>                 <code class="c1">// An object o.</code>
            <code class="nx">m</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code>       <code class="c1">// Method m of the object.</code>
                <code class="kd">let</code> <code class="nx">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>  <code class="c1">// Save the "this" value in a variable.</code>
                <code class="k">this</code> <code class="o">===</code> <code class="nx">o</code>        <code class="c1">// =&gt; true: "this" is the object o.</code>
                <code class="nx">f</code><code class="p">();</code>              <code class="c1">// Now call the helper function f().</code>
        
                <code class="kd">function</code> <code class="nx">f</code><code class="p">()</code> <code class="p">{</code>    <code class="c1">// A nested function f</code>
                    <code class="k">this</code> <code class="o">===</code> <code class="nx">o</code>    <code class="c1">// =&gt; false: "this" is global or undefined</code>
                    <code class="nx">self</code> <code class="o">===</code> <code class="nx">o</code>    <code class="c1">// =&gt; true: self is the outer "this" value.</code>
                <code class="p">}</code>
            <code class="p">}</code>
        <code class="p">};</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">m</code><code class="p">();</code>                    <code class="c1">// Invoke the method m on the object o.</code></pre>
        
        <p>Inside the nested function <code>f()</code>, the <code>this</code> keyword is not equal to the
        object <code>o</code>. This is widely considered to be a flaw in the JavaScript
        language, and it is important to be aware of it. The code above
        demonstrates one common workaround. Within the method <code>m</code>, we assign the
        <code>this</code> value to a variable <code>self</code>, and within the nested function <code>f</code>, we
        can use <code>self</code> instead of <code>this</code> to refer to the containing object.</p>
        
        <p>In ES6 and later, another workaround to this issue is to convert the
        nested function <code>f</code> into an arrow function, which will properly inherit
        the <code>this</code> value:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="p">{</code>
            <code class="k">this</code> <code class="o">===</code> <code class="nx">o</code>  <code class="c1">// true, since arrow functions inherit this</code>
        <code class="p">};</code></pre>
        
        <p>Functions defined as expressions instead of statements are not hoisted,
        so in order to make this code work, the function definition for <code>f</code> will
        need to be moved within the method <code>m</code> so that it appears before it is
        invoked.</p>
        
        <p>Another workaround is to invoke the <code>bind()</code> method of the nested
        function to define a new function that is implicitly invoked on a
        specified object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">this</code> <code class="o">===</code> <code class="nx">o</code>  <code class="c1">// true, since we bound this function to the outer this</code>
        <code class="p">}).</code><code class="nx">bind</code><code class="p">(</code><code class="k">this</code><code class="p">);</code></pre>
        
        <p>We’ll<a data-type="indexterm" data-primary="" data-startref="Minvo08" id="idm46198541806184"></a><a data-type="indexterm" data-primary="" data-startref="Finmeth08" id="idm46198541805672"></a> talk more about <code>bind()</code> in <a data-type="xref" href="#bind">§8.7.5</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.2.3 Constructor Invocation"><div class="sect2" id="constructorinvocation">
        <h2>8.2.3 Constructor Invocation</h2>
        
        <p>If<a data-type="indexterm" data-primary="functions" data-secondary="invoking" data-tertiary="constructor invocation" id="idm46198541801640"></a><a data-type="indexterm" data-primary="new keyword" id="idm46198541800360"></a><a data-type="indexterm" data-primary="keywords" data-secondary="new keyword" id="idm46198541799688"></a><a data-type="indexterm" data-primary="constructors" data-secondary="constructor invocation" id="idm46198541798744"></a> a function or method invocation is preceded by the keyword <code>new</code>,
        then it is a constructor invocation. (Constructor invocations were
        introduced in <a data-type="xref" href="ch04.html#newexprs">§4.6</a> and <a data-type="xref" href="ch06.html#creatingobjectswithnew">§6.2.2</a>, and
        constructors will be covered in more detail in <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>.)
        Constructor invocations differ from regular function and method
        invocations in their handling of arguments, invocation context, and
        return value.</p>
        
        <p>If a constructor invocation includes an argument list in parentheses,
        those argument expressions are evaluated and passed to the function in
        the same way they would be for function and method invocations. It is
        not common practice, but you can omit a pair of empty parentheses in a
        constructor invocation. The following two lines, for example, are
        equivalent:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">o</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Object</code><code class="p">();</code>
        <code class="nx">o</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Object</code><code class="p">;</code></pre>
        
        <p>A constructor invocation creates a new, empty object that inherits
        from the object specified by the
        <code>prototype</code> property of the constructor. Constructor
        functions are intended to initialize objects, and this newly created
        object is used as the invocation context, so the constructor function
        can refer to it with the <code>this</code> keyword. Note that the new object is
        used as the invocation context even if the constructor invocation
        looks like a method invocation. That is, in the expression <code>new
        o.m()</code>, <code>o</code> is not used as the invocation context.</p>
        
        <p>Constructor functions do not normally use the <code>return</code> keyword. They
        typically initialize the new object and then return implicitly when
        they reach the end of their body. In this case, the new object is the
        value of the constructor invocation expression. If, however, a
        constructor explicitly uses the <code>return</code> statement to return an
        object, then that object becomes the value of the invocation
        expression. If the constructor uses <code>return</code> with no value, or if it
        returns a primitive value, that return value is ignored and the new
        object is used as the value of the invocation.<a data-type="indexterm" data-primary="" data-startref="Einvocexp01" id="idm46198541754488"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.2.4 Indirect Invocation"><div class="sect2" id="indirectinvocation">
        <h2>8.2.4 Indirect Invocation</h2>
        
        <p>JavaScript<a data-type="indexterm" data-primary="functions" data-secondary="invoking" data-tertiary="indirect invocation" id="idm46198541751944"></a><a data-type="indexterm" data-primary="indirect invocation" id="idm46198541750280"></a><a data-type="indexterm" data-primary="call() method" id="idm46198541749608"></a><a data-type="indexterm" data-primary="apply() method" id="idm46198541748936"></a> functions are objects, and like all JavaScript objects, they
        have methods. Two of these methods, <code>call()</code> and <code>apply()</code>, invoke the
        function indirectly. Both methods allow you to explicitly specify the
        <code>this</code> value for the invocation, which means you can invoke any
        function as a method of any object, even if it is not actually a
        method of that object. Both methods also allow you to specify the
        arguments for the invocation. The <code>call()</code> method uses its own
        argument list as arguments to the function, and the <code>apply()</code> method
        expects an array of values to be used as arguments. The <code>call()</code> and
        <code>apply()</code> methods are described in detail in <a data-type="xref" href="#applyandcall">§8.7.4</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.2.5 Implicit Function Invocation"><div class="sect2" id="implicit-invocation">
        <h2>8.2.5 Implicit Function Invocation</h2>
        
        <p>There<a data-type="indexterm" data-primary="implicit function invocation" id="idm46198541742264"></a><a data-type="indexterm" data-primary="functions" data-secondary="invoking" data-tertiary="implicit function invocation" id="idm46198541741560"></a> are various JavaScript language features that do not look like
        function invocations but that cause functions to be invoked. Be extra
        careful when writing functions that may be implicitly invoked, because
        bugs, side effects, and performance issues in these functions are harder
        to diagnose and fix than in regular functions for the simple reason that
        it may not be obvious from a simple inspection of your code when they
        are being called.</p>
        
        <p>The language features that can cause implicit function invocation
        include:</p>
        
        <ul>
        <li>
        <p>If an object has getters or setters defined, then querying or setting
        the value of its properties may invoke those methods. See
        <a data-type="xref" href="ch06.html#gettersandsetters">§6.10.6</a> for more information.</p>
        </li>
        <li>
        <p>When an object is used in a string context (such as when it is
        concatenated with a string), its <code>toString()</code> method is
        called. Similarly, when an object is used in a numeric context, its
        <code>valueOf()</code> method is invoked. See <a data-type="xref" href="ch03.html#objtoprim">§3.9.3</a> for details.</p>
        </li>
        <li>
        <p>When you loop over the elements of an iterable object, there are a
        number of method calls that occur. <a data-type="xref" href="ch12.html#itergene">Chapter&nbsp;12</a> explains how iterators
        work at the function call level and demonstrates how to write these
        methods so that you can define your own iterable types.</p>
        </li>
        <li>
        <p>A tagged template literal is a function invocation in
        disguise. <a data-type="xref" href="ch14.html#templatetags">§14.5</a> demonstrates how to write functions that
        can be used in conjunction with template literal strings.</p>
        </li>
        <li>
        <p>Proxy objects (described in <a data-type="xref" href="ch14.html#proxy">§14.7</a>) have their behavior
        completely controlled by functions. Just about any operation on one of
        these objects will cause a function to be invoked.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="8.3 Function Arguments and Parameters"><div class="sect1" id="functionargumentsandparameters">
        <h1>8.3 Function Arguments and Parameters</h1>
        
        <p>JavaScript function definitions<a data-type="indexterm" data-primary="functions" data-secondary="function arguments and parameters" data-tertiary="overview of" id="idm46198541709064"></a> do not specify an expected type for
        the function parameters, and function invocations do not do any type
        checking on the argument values you pass. In fact, JavaScript function
        invocations do not even check the number of arguments being
        passed. The subsections that follow describe what happens when a
        function is invoked with fewer arguments than declared parameters or
        with more arguments than declared parameters. They also demonstrate
        how you can explicitly test the type of function arguments if you need
        to ensure that a function is not invoked with inappropriate arguments.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.3.1 Optional Parameters and Defaults"><div class="sect2" id="idm46198541706952">
        <h2>8.3.1 Optional Parameters and Defaults</h2>
        
        <p>When<a data-type="indexterm" data-primary="functions" data-secondary="function arguments and parameters" data-tertiary="optional parameters and defaults" id="idm46198541705352"></a> a function is invoked with fewer arguments than declared
        parameters, the additional parameters are set to their default value,
        which is normally <code>undefined</code>.  It is often useful to write functions so
        that some arguments are optional. Following is an example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Append the names of the enumerable properties of object o to the</code>
        <code class="c1">// array a, and return a.  If a is omitted, create and return a new array.</code>
        <code class="kd">function</code> <code class="nx">getPropertyNames</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">a</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">===</code> <code class="kc">undefined</code><code class="p">)</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[];</code>  <code class="c1">// If undefined, use a new array</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">in</code> <code class="nx">o</code><code class="p">)</code> <code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">property</code><code class="p">);</code>
            <code class="k">return</code> <code class="nx">a</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="c1">// getPropertyNames() can be invoked with one or two arguments:</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">},</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code><code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="mi">3</code><code class="p">};</code>  <code class="c1">// Two objects for testing</code>
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="nx">getPropertyNames</code><code class="p">(</code><code class="nx">o</code><code class="p">);</code> <code class="c1">// a == ["x"]; get o's properties in a new array</code>
        <code class="nx">getPropertyNames</code><code class="p">(</code><code class="nx">p</code><code class="p">,</code> <code class="nx">a</code><code class="p">);</code>      <code class="c1">// a == ["x","y","z"]; add p's properties to it</code></pre>
        
        <p>Instead of using an <code>if</code> statement in the first line of this function,
        you can use the <code>||</code> operator in this idiomatic way:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">a</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">||</code> <code class="p">[];</code></pre>
        
        <p>Recall from <a data-type="xref" href="ch04.html#logicalor">§4.10.2</a> that the <code>||</code> operator returns its first
        argument if that argument is truthy and otherwise returns its second
        argument. In this case, if any object is passed as the second
        argument, the function will use that object. But if the second
        argument is omitted (or <code>null</code> or another falsy value is passed), a
        newly created empty array will be used instead.</p>
        
        <p>Note that when designing functions with optional arguments, you should
        be sure to put the optional ones at the end of the argument list so
        that they can be omitted. The programmer who calls your function
        cannot omit the first argument and pass the second: they would have to
        explicitly pass <code>undefined</code> as the first argument.</p>
        
        <p>In ES6 and later, you can define a default value for each of your
        function parameters directly in the parameter list of your
        function. Simply follow the parameter name with an equals sign and the
        default value to use when no argument is supplied for that parameter:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Append the names of the enumerable properties of object o to the</code>
        <code class="c1">// array a, and return a.  If a is omitted, create and return a new array.</code>
        <code class="kd">function</code> <code class="nx">getPropertyNames</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[])</code> <code class="p">{</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">property</code> <code class="k">in</code> <code class="nx">o</code><code class="p">)</code> <code class="nx">a</code><code class="p">.</code><code class="nx">push</code><code class="p">(</code><code class="nx">property</code><code class="p">);</code>
            <code class="k">return</code> <code class="nx">a</code><code class="p">;</code>
        <code class="p">}</code></pre>
        
        <p>Parameter default expressions are evaluated when your function is
        called, not when it is defined, so each time this <code>getPropertyNames()</code>
        function is invoked with one argument, a new empty array is created and
        passed.<sup><a data-type="noteref" id="idm46198541553560-marker" href="ch08.html#idm46198541553560">2</a></sup> It is probably easiest to reason about functions if the
        parameter defaults are constants (or literal expressions like <code>[]</code> and
        <code>{}</code>). But this is not required: you can use variables, or function
        invocations, for example, to compute the default value of a
        parameter. One interesting case is that, for functions with multiple
        parameters, you can use the value of a previous parameter to define the
        default value of the parameters that follow it:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This function returns an object representing a rectangle's dimensions.</code>
        <code class="c1">// If only width is supplied, make it twice as high as it is wide.</code>
        <code class="kr">const</code> <code class="nx">rectangle</code> <code class="o">=</code> <code class="p">(</code><code class="nx">width</code><code class="p">,</code> <code class="nx">height</code><code class="o">=</code><code class="nx">width</code><code class="o">*</code><code class="mi">2</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="p">({</code><code class="nx">width</code><code class="p">,</code> <code class="nx">height</code><code class="p">});</code>
        <code class="nx">rectangle</code><code class="p">(</code><code class="mi">1</code><code class="p">)</code>  <code class="c1">// =&gt; { width: 1, height: 2 }</code></pre>
        
        <p>This code demonstrates that parameter defaults work with arrow
        functions. The same is true for method shorthand functions and all other
        forms of function definitions.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.3.2 Rest Parameters and Variable-Length Argument Lists"><div class="sect2" id="restparameters">
        <h2>8.3.2 Rest Parameters and Variable-Length Argument Lists</h2>
        
        <p>Parameter<a data-type="indexterm" data-primary="functions" data-secondary="function arguments and parameters" data-tertiary="rest parameters" id="idm46198541468200"></a><a data-type="indexterm" data-primary="functions" data-secondary="function arguments and parameters" data-tertiary="variable-length argument lists" id="idm46198541467064"></a><a data-type="indexterm" data-primary="rest parameters" id="idm46198541465912"></a><a data-type="indexterm" data-primary="arguments" data-secondary="variable-length argument lists" id="idm46198541465240"></a> defaults enable us to write functions that can be invoked with
        fewer arguments than parameters. <em>Rest parameters</em> enable the opposite
        case: they allow us to write functions that can be invoked with
        arbitrarily more arguments than parameters. Here is an example function
        that expects one or more numeric arguments and returns the largest one:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">max</code><code class="p">(</code><code class="nx">first</code><code class="o">=-</code><code class="kc">Infinity</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">maxValue</code> <code class="o">=</code> <code class="nx">first</code><code class="p">;</code> <code class="c1">// Start by assuming the first arg is biggest</code>
            <code class="c1">// Then loop through the rest of the arguments, looking for bigger</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">n</code> <code class="k">of</code> <code class="nx">rest</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">n</code> <code class="o">&gt;</code> <code class="nx">maxValue</code><code class="p">)</code> <code class="p">{</code>
                    <code class="nx">maxValue</code> <code class="o">=</code> <code class="nx">n</code><code class="p">;</code>
                <code class="p">}</code>
            <code class="p">}</code>
            <code class="c1">// Return the biggest</code>
            <code class="k">return</code> <code class="nx">maxValue</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="nx">max</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">100</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">1000</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code>  <code class="c1">// =&gt; 1000</code></pre>
        
        <p>A rest parameter is preceded by three periods, and it must be the last
        parameter in a function declaration. When you invoke a function with a
        rest parameter, the arguments you pass are first assigned to the
        non-rest parameters, and then any remaining arguments (i.e., the “rest”
        of the arguments) are stored in an array that becomes the value of the
        rest parameter. This last point is important: within the body of a
        function, the value of a rest parameter will always be an array. The
        array may be empty, but a rest parameter will never be <code>undefined</code>. (It
        follows from this that it is never useful—and not legal—to define a
        parameter default for a rest parameter.)</p>
        
        <p>Functions<a data-type="indexterm" data-primary="variadic functions" id="idm46198541347912"></a><a data-type="indexterm" data-primary="variable arity functions" id="idm46198541347272"></a><a data-type="indexterm" data-primary="varargs" id="idm46198541346632"></a> like the previous example that can accept any number of arguments are
        called <em>variadic functions</em>, <em>variable arity functions</em>, or <em>vararg functions</em>. This book uses the most colloquial term, <em>varargs</em>, which
        dates to the early days of the C programming language.</p>
        
        <p>Don’t confuse the <code>...</code> that defines a rest parameter in a function
        definition with the <code>...</code> spread operator, described in <a data-type="xref" href="#spread-operator-for-functions">§8.3.4</a>, which can be
        used in function <span class="keep-together">invocations.</span></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.3.3 The Arguments Object"><div class="sect2" id="argumentsobject">
        <h2>8.3.3 The Arguments Object</h2>
        
        <p>Rest<a data-type="indexterm" data-primary="arguments" data-secondary="Arguments object" id="idm46198541339496"></a><a data-type="indexterm" data-primary="objects" data-secondary="Arguments object" id="idm46198541338488"></a><a data-type="indexterm" data-primary="functions" data-secondary="function arguments and parameters" data-tertiary="arguments object" id="idm46198541337544"></a> parameters were introduced into JavaScript in ES6. Before
        that version of the language, varargs functions were written using the
        Arguments object: within the body of any function, the identifier
        <code>arguments</code> refers to the Arguments object for that invocation. The
        Arguments object is an array-like object (see <a data-type="xref" href="ch07.html#arraylike">§7.9</a>) that allows
        the argument values passed to the function to be retrieved by number,
        rather than by name. Here is the <code>max()</code> function from earlier, rewritten
        to use the Arguments object instead of a rest parameter:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">max</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">maxValue</code> <code class="o">=</code> <code class="o">-</code><code class="kc">Infinity</code><code class="p">;</code>
            <code class="c1">// Loop through the arguments, looking for, and remembering, the biggest.</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">arguments</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">arguments</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">&gt;</code> <code class="nx">maxValue</code><code class="p">)</code> <code class="nx">maxValue</code> <code class="o">=</code> <code class="nx">arguments</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
            <code class="p">}</code>
            <code class="c1">// Return the biggest</code>
            <code class="k">return</code> <code class="nx">maxValue</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="nx">max</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">100</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">1000</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code>  <code class="c1">// =&gt; 1000</code></pre>
        
        <p>The Arguments object dates back to the earliest days of JavaScript and
        carries with it some strange historical baggage that makes it
        inefficient and hard to optimize, especially outside of strict
        mode. You may still encounter code that uses the Arguments object, but
        you should avoid using it in any new code you write. When refactoring
        old code, if you encounter a function that uses <code>arguments</code>, you can
        often replace it with a <code>...args</code> rest parameter. Part of the
        unfortunate legacy of the Arguments object is that, in strict mode,
        <code>arguments</code> is treated as a reserved word, and you cannot declare a
        function parameter or a local variable with that name.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.3.4 The Spread Operator for Function Calls"><div class="sect2" id="spread-operator-for-functions">
        <h2>8.3.4 The Spread Operator for Function Calls</h2>
        
        <p>The<a data-type="indexterm" data-primary="functions" data-secondary="function arguments and parameters" data-tertiary="spread operator for function calls" id="idm46198541255416"></a><a data-type="indexterm" data-primary="spread operator (…)" id="idm46198541254200"></a><a data-type="indexterm" data-primary="… (spread operator)" id="idm46198541253528"></a> spread operator <code>...</code> is used to unpack, or “spread out,” the elements
        of an array (or any other iterable object, such as strings) in a context
        where individual values are expected. We’ve seen the spread operator
        used with array literals in <a data-type="xref" href="ch07.html#spread-operator-in-array-literals">§7.1.2</a>. The
        operator can be used, in the same way, in function invocations:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">numbers</code> <code class="o">=</code> <code class="p">[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">,</code> <code class="mi">9</code><code class="p">,</code> <code class="mi">100</code><code class="p">,</code> <code class="mi">1</code><code class="p">];</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">min</code><code class="p">(...</code><code class="nx">numbers</code><code class="p">)</code>  <code class="c1">// =&gt; -1</code></pre>
        
        <p>Note that <code>...</code> is not a true operator in the sense that it cannot be
        evaluated to produce a value. Instead, it is a special JavaScript syntax
        that can be used in array literals and function invocations.</p>
        
        <p>When we use the same <code>...</code> syntax in a function definition rather than a
        function invocation, it has the opposite effect to the spread
        operator. As we saw in <a data-type="xref" href="#restparameters">§8.3.2</a>, using <code>...</code> in a function
        definition gathers multiple function arguments into an array. Rest
        parameters and the spread operator are often useful together, as in the
        following function, which takes a function argument and returns an
        instrumented version of the function for testing:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This function takes a function and returns a wrapped version</code>
        <code class="kd">function</code> <code class="nx">timed</code><code class="p">(</code><code class="nx">f</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>  <code class="c1">// Collect args into a rest parameter array</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Entering function </code><code class="si">${</code><code class="nx">f</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
                <code class="kd">let</code> <code class="nx">startTime</code> <code class="o">=</code> <code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">();</code>
                <code class="k">try</code> <code class="p">{</code>
                    <code class="c1">// Pass all of our arguments to the wrapped function</code>
                    <code class="k">return</code> <code class="nx">f</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code>  <code class="c1">// Spread the args back out again</code>
                <code class="p">}</code>
                <code class="k">finally</code> <code class="p">{</code>
                    <code class="c1">// Before we return the wrapped return value, print elapsed time.</code>
                    <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="sb">`Exiting </code><code class="si">${</code><code class="nx">f</code><code class="p">.</code><code class="nx">name</code><code class="si">}</code><code class="sb"> after </code><code class="si">${</code><code class="nb">Date</code><code class="p">.</code><code class="nx">now</code><code class="p">()</code><code class="o">-</code><code class="nx">startTime</code><code class="si">}</code><code class="sb">ms`</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="c1">// Compute the sum of the numbers between 1 and n by brute force</code>
        <code class="kd">function</code> <code class="nx">benchmark</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;=</code> <code class="nx">n</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">sum</code> <code class="o">+=</code> <code class="nx">i</code><code class="p">;</code>
            <code class="k">return</code> <code class="nx">sum</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="c1">// Now invoke the timed version of that test function</code>
        <code class="nx">timed</code><code class="p">(</code><code class="nx">benchmark</code><code class="p">)(</code><code class="mi">1000000</code><code class="p">)</code> <code class="c1">// =&gt; 500000500000; this is the sum of the numbers</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.3.5 Destructuring Function Arguments into Parameters"><div class="sect2" id="destructuring-for-functions">
        <h2>8.3.5 Destructuring Function Arguments into Parameters</h2>
        
        <p>When<a data-type="indexterm" data-primary="functions" data-secondary="function arguments and parameters" data-tertiary="destructuring function arguments into parameters" id="Ffapdest08"></a><a data-type="indexterm" data-primary="arguments" data-secondary="destructuring function arguments into parameters" id="Adest08"></a><a data-type="indexterm" data-primary="destructuring assignment" id="dest08"></a> you invoke a function with a list of argument values, those values
        end up being assigned to the parameters declared in the function
        definition. This initial phase of function invocation is a lot like
        variable assignment. So it should not be surprising that we can use the
        techniques of destructuring assignment (see
        <a data-type="xref" href="ch03.html#destructuring-assignment">§3.10.3</a>) with <span class="keep-together">functions.</span></p>
        
        <p>If you define a function that has parameter names within square
        brackets, you are telling the function to expect an array value to be
        passed for each pair of square brackets. As part of the invocation
        process, the array arguments will be unpacked into the individually
        named parameters. As an example, suppose we are representing 2D vectors
        as arrays of two numbers, where the first element is the X coordinate
        and the second element is the Y coordinate. With this simple data
        structure, we could write the following function to add two vectors:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">vectorAdd</code><code class="p">(</code><code class="nx">v1</code><code class="p">,</code> <code class="nx">v2</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">[</code><code class="nx">v1</code><code class="p">[</code><code class="mi">0</code><code class="p">]</code> <code class="o">+</code> <code class="nx">v2</code><code class="p">[</code><code class="mi">0</code><code class="p">],</code> <code class="nx">v1</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">+</code> <code class="nx">v2</code><code class="p">[</code><code class="mi">1</code><code class="p">]];</code>
        <code class="p">}</code>
        <code class="nx">vectorAdd</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">],</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">])</code>  <code class="c1">// =&gt; [4,6]</code></pre>
        
        <p>The code would be easier to understand if we destructured the two vector
        arguments into more clearly named parameters:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">vectorAdd</code><code class="p">([</code><code class="nx">x1</code><code class="p">,</code><code class="nx">y1</code><code class="p">],</code> <code class="p">[</code><code class="nx">x2</code><code class="p">,</code><code class="nx">y2</code><code class="p">])</code> <code class="p">{</code> <code class="c1">// Unpack 2 arguments into 4 parameters</code>
            <code class="k">return</code> <code class="p">[</code><code class="nx">x1</code> <code class="o">+</code> <code class="nx">x2</code><code class="p">,</code> <code class="nx">y1</code> <code class="o">+</code> <code class="nx">y2</code><code class="p">];</code>
        <code class="p">}</code>
        <code class="nx">vectorAdd</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">],</code> <code class="p">[</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">])</code>  <code class="c1">// =&gt; [4,6]</code></pre>
        
        <p>Similarly, if you are defining a function that expects an object
        argument, you can destructure parameters of that object. Let’s use a
        vector example again, except this time, let’s suppose that we represent
        vectors as objects with <code>x</code> and <code>y</code> parameters:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Multiply the vector {x,y} by a scalar value</code>
        <code class="kd">function</code> <code class="nx">vectorMultiply</code><code class="p">({</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">},</code> <code class="nx">scalar</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">x</code><code class="o">*</code><code class="nx">scalar</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y</code><code class="o">*</code><code class="nx">scalar</code> <code class="p">};</code>
        <code class="p">}</code>
        <code class="nx">vectorMultiply</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">},</code> <code class="mi">2</code><code class="p">)</code>  <code class="c1">// =&gt; {x: 2, y: 4}</code></pre>
        
        <p>This example of destructuring a single object argument into two
        parameters is a fairly clear one because the parameter names we use match
        the property names of the incoming object. The syntax is more verbose
        and more confusing when you need to destructure properties with one name
        into parameters with different names. Here’s the vector addition
        example, implemented for object-based vectors:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">vectorAdd</code><code class="p">(</code>
            <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="nx">x1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y1</code><code class="p">},</code> <code class="c1">// Unpack 1st object into x1 and y1 params</code>
            <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="nx">x2</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y2</code><code class="p">}</code>  <code class="c1">// Unpack 2nd object into x2 and y2 params</code>
        <code class="p">)</code>
        <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">x1</code> <code class="o">+</code> <code class="nx">x2</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y1</code> <code class="o">+</code> <code class="nx">y2</code> <code class="p">};</code>
        <code class="p">}</code>
        <code class="nx">vectorAdd</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">},</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">4</code><code class="p">})</code>  <code class="c1">// =&gt; {x: 4, y: 6}</code></pre>
        
        <p>The tricky thing about destructuring syntax like <code>{x:x1, y:y1}</code> is
        remembering which are the property names and which are the parameter
        names. The rule to keep in mind for destructuring assignment and
        destructuring function calls is that the variables or parameters being
        declared go in the spots where you’d expect values to go in an object
        literal. So property names are always on the lefthand side of the
        colon, and the parameter (or variable) names are on the right.</p>
        
        <p>You can define parameter defaults with destructured parameters. Here’s
        vector multiplication that works with 2D or 3D vectors:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Multiply the vector {x,y} or {x,y,z} by a scalar value</code>
        <code class="kd">function</code> <code class="nx">vectorMultiply</code><code class="p">({</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="o">=</code><code class="mi">0</code><code class="p">},</code> <code class="nx">scalar</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">x</code><code class="o">*</code><code class="nx">scalar</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y</code><code class="o">*</code><code class="nx">scalar</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="nx">z</code><code class="o">*</code><code class="nx">scalar</code> <code class="p">};</code>
        <code class="p">}</code>
        <code class="nx">vectorMultiply</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">},</code> <code class="mi">2</code><code class="p">)</code>  <code class="c1">// =&gt; {x: 2, y: 4, z: 0}</code></pre>
        
        <p>Some languages (like Python) allow the caller of a function to invoke a
        function with arguments specified in <code>name=value</code> form, which is
        convenient when there are many optional arguments or when the parameter
        list is long enough that it is hard to remember the correct
        order. JavaScript does not allow this directly, but you can approximate
        it by destructuring an object argument into your function
        parameters. Consider a function that copies a specified number of
        elements from one array into another array with optionally specified
        starting offsets for each array. Since there are five possible parameters,
        some of which have defaults, and it would be hard for a caller to remember
        which order to pass the arguments in, we can define and invoke the
        <code>arraycopy()</code> function like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">arraycopy</code><code class="p">({</code><code class="nx">from</code><code class="p">,</code> <code class="nx">to</code><code class="o">=</code><code class="nx">from</code><code class="p">,</code> <code class="nx">n</code><code class="o">=</code><code class="nx">from</code><code class="p">.</code><code class="nx">length</code><code class="p">,</code> <code class="nx">fromIndex</code><code class="o">=</code><code class="mi">0</code><code class="p">,</code> <code class="nx">toIndex</code><code class="o">=</code><code class="mi">0</code><code class="p">})</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">valuesToCopy</code> <code class="o">=</code> <code class="nx">from</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="nx">fromIndex</code><code class="p">,</code> <code class="nx">fromIndex</code> <code class="o">+</code> <code class="nx">n</code><code class="p">);</code>
            <code class="nx">to</code><code class="p">.</code><code class="nx">splice</code><code class="p">(</code><code class="nx">toIndex</code><code class="p">,</code> <code class="mi">0</code><code class="p">,</code> <code class="p">...</code><code class="nx">valuesToCopy</code><code class="p">);</code>
            <code class="k">return</code> <code class="nx">to</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">],</code> <code class="nx">b</code> <code class="o">=</code> <code class="p">[</code><code class="mi">9</code><code class="p">,</code><code class="mi">8</code><code class="p">,</code><code class="mi">7</code><code class="p">,</code><code class="mi">6</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="nx">arraycopy</code><code class="p">({</code><code class="nx">from</code><code class="o">:</code> <code class="nx">a</code><code class="p">,</code> <code class="nx">n</code><code class="o">:</code> <code class="mi">3</code><code class="p">,</code> <code class="nx">to</code><code class="o">:</code> <code class="nx">b</code><code class="p">,</code> <code class="nx">toIndex</code><code class="o">:</code> <code class="mi">4</code><code class="p">})</code> <code class="c1">// =&gt; [9,8,7,6,1,2,3,5]</code></pre>
        
        <p>When you destructure an array, you can define a rest parameter for extra
        values within the array that is being unpacked. That rest parameter
        within the square brackets is completely different than the true rest
        parameter for the function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This function expects an array argument. The first two elements of that</code>
        <code class="c1">// array are unpacked into the x and y parameters. Any remaining elements</code>
        <code class="c1">// are stored in the coords array. And any arguments after the first array</code>
        <code class="c1">// are packed into the rest array.</code>
        <code class="kd">function</code> <code class="nx">f</code><code class="p">([</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="p">...</code><code class="nx">coords</code><code class="p">],</code> <code class="p">...</code><code class="nx">rest</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">[</code><code class="nx">x</code><code class="o">+</code><code class="nx">y</code><code class="p">,</code> <code class="p">...</code><code class="nx">rest</code><code class="p">,</code> <code class="p">...</code><code class="nx">coords</code><code class="p">];</code>  <code class="c1">// Note: spread operator here</code>
        <code class="p">}</code>
        <code class="nx">f</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">,</code> <code class="mi">4</code><code class="p">],</code> <code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">)</code>   <code class="c1">// =&gt; [3, 5, 6, 3, 4]</code></pre>
        
        <p>In ES2018, you<a data-type="indexterm" data-primary="ES2018" data-secondary="destructuring with rest parameters" id="idm46198540322840"></a> can also use a rest parameter when you destructure an
        object. The value of that rest parameter will be an object that has any
        properties that did not get destructured. Object<a data-type="indexterm" data-primary="ES2018" data-secondary="spread operator (…)" id="idm46198540328408"></a> rest parameters are
        often useful with the object spread operator, which is also a new
        feature of ES2018:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Multiply the vector {x,y} or {x,y,z} by a scalar value, retain other props</code>
        <code class="kd">function</code> <code class="nx">vectorMultiply</code><code class="p">({</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">z</code><code class="o">=</code><code class="mi">0</code><code class="p">,</code> <code class="p">...</code><code class="nx">props</code><code class="p">},</code> <code class="nx">scalar</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="nx">x</code><code class="o">*</code><code class="nx">scalar</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="nx">y</code><code class="o">*</code><code class="nx">scalar</code><code class="p">,</code> <code class="nx">z</code><code class="o">:</code> <code class="nx">z</code><code class="o">*</code><code class="nx">scalar</code><code class="p">,</code> <code class="p">...</code><code class="nx">props</code> <code class="p">};</code>
        <code class="p">}</code>
        <code class="nx">vectorMultiply</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">w</code><code class="o">:</code> <code class="o">-</code><code class="mi">1</code><code class="p">},</code> <code class="mi">2</code><code class="p">)</code>  <code class="c1">// =&gt; {x: 2, y: 4, z: 0, w: -1}</code></pre>
        
        <p>Finally, keep in mind that, in addition to destructuring argument
        objects and arrays, you can also destructure arrays of objects,
        objects that have array properties, and objects that have object
        properties, to essentially any depth. Consider graphics code that
        represents circles as objects with <code>x</code>, <code>y</code>, <code>radius</code>, and <code>color</code>
        properties, where the <code>color</code> property is an array of red, green, and
        blue color components. You might define a function that expects a
        single circle object to be passed to it but destructures that circle
        object into six separate parameters:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">drawCircle</code><code class="p">({</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">,</code> <code class="nx">radius</code><code class="p">,</code> <code class="nx">color</code><code class="o">:</code> <code class="p">[</code><code class="nx">r</code><code class="p">,</code> <code class="nx">g</code><code class="p">,</code> <code class="nx">b</code><code class="p">]})</code> <code class="p">{</code>
            <code class="c1">// Not yet implemented</code>
        <code class="p">}</code></pre>
        
        <p>If function argument destructuring is any more complicated than this, I
        find that the code becomes harder to read, rather than
        simpler. Sometimes, it is clearer to be explicit about your object
        property access and array indexing.<a data-type="indexterm" data-primary="" data-startref="dest08" id="idm46198540270264"></a><a data-type="indexterm" data-primary="" data-startref="Adest08" id="idm46198540269528"></a><a data-type="indexterm" data-primary="" data-startref="Ffapdest08" id="idm46198540268616"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.3.6 Argument Types"><div class="sect2" id="idm46198541219448">
        <h2>8.3.6 Argument Types</h2>
        
        <p>JavaScript<a data-type="indexterm" data-primary="functions" data-secondary="function arguments and parameters" data-tertiary="argument types" id="idm46198540263816"></a><a data-type="indexterm" data-primary="arguments" data-secondary="argument types" id="idm46198540262568"></a> method parameters have no declared types, and no type
        checking is performed on the values you pass to a function. You can help
         make your code self-documenting by choosing descriptive names for
        function arguments and by documenting them carefully in the comments for
        each function. (Alternatively, see <a data-type="xref" href="ch17.html#flow">§17.8</a> for a language extension
        that allows you to layer type checking on top of regular JavaScript.)</p>
        
        <p>As described in <a data-type="xref" href="ch03.html#conversions">§3.9</a>, JavaScript performs liberal type
        conversion as needed. So if you write a function that expects a string
        argument and then call that function with a value of some other type,
        the value you passed will simply be converted to a string when the
        function tries to use it as a string. All primitive types can be
        converted to strings, and all objects have <code>toString()</code> methods (if
        not necessarily useful ones), so an error never occurs in this case.</p>
        
        <p>This is not always true, however. Consider again the <code>arraycopy()</code>
        method shown earlier. It expects one or two array arguments and will
        fail if these arguments are of the wrong type. Unless you are writing a
        private function that will only be called from nearby parts of your
        code, it may be worth adding code to check the types of arguments like
        this. It is better for a function to fail immediately and predictably
        when passed bad values than to begin executing and fail later with an
        error message that is likely to be unclear. Here is an example function
        that performs type-checking:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Return the sum of the elements an iterable object a.</code>
        <code class="c1">// The elements of a must all be numbers.</code>
        <code class="kd">function</code> <code class="nx">sum</code><code class="p">(</code><code class="nx">a</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">total</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">element</code> <code class="k">of</code> <code class="nx">a</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// Throws TypeError if a is not iterable</code>
                <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">element</code> <code class="o">!==</code> <code class="s2">"number"</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="s2">"sum(): elements must be numbers"</code><code class="p">);</code>
                <code class="p">}</code>
                <code class="nx">total</code> <code class="o">+=</code> <code class="nx">element</code><code class="p">;</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">total</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="nx">sum</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">])</code>    <code class="c1">// =&gt; 6</code>
        <code class="nx">sum</code><code class="p">(</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">);</code>   <code class="c1">// !TypeError: 1 is not iterable</code>
        <code class="nx">sum</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="s2">"3"</code><code class="p">]);</code> <code class="c1">// !TypeError: element 2 is not a number</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="8.4 Functions as Values"><div class="sect1" id="idm46198540255160">
        <h1>8.4 Functions as Values</h1>
        
        <p>The<a data-type="indexterm" data-primary="functions" data-secondary="functions as values" id="Fvalue08"></a><a data-type="indexterm" data-primary="values" data-secondary="functions as values" id="Vfunc08"></a> most important features of functions are that they can be defined
        and invoked. Function definition and invocation are syntactic features
        of JavaScript and of most other programming languages. In JavaScript,
        however, functions are not only syntax but also values, which means
        they can be assigned to variables, stored in the properties of objects
        or the elements of arrays, passed as arguments to functions, and so
        on.<sup><a data-type="noteref" id="idm46198540105128-marker" href="ch08.html#idm46198540105128">3</a></sup></p>
        
        <p>To understand how functions can be JavaScript data as well as
        JavaScript syntax, consider this function definition:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;</code> <code class="p">}</code></pre>
        
        <p>This definition creates a new function object and assigns it to the
        variable <code>square</code>. The name of a function is really immaterial; it is
        simply the name of a variable that refers to the function object. The
        function can be assigned to another variable and still work the same
        way:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="nx">square</code><code class="p">;</code>  <code class="c1">// Now s refers to the same function that square does</code>
        <code class="nx">square</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>        <code class="c1">// =&gt; 16</code>
        <code class="nx">s</code><code class="p">(</code><code class="mi">4</code><code class="p">)</code>             <code class="c1">// =&gt; 16</code></pre>
        
        <p>Functions can also be assigned to object properties rather than
        variables. As we’ve already discussed, we call the functions “methods”
        when we do this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">square</code><code class="o">:</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;</code> <code class="p">}};</code> <code class="c1">// An object literal</code>
        <code class="kd">let</code> <code class="nx">y</code> <code class="o">=</code> <code class="nx">o</code><code class="p">.</code><code class="nx">square</code><code class="p">(</code><code class="mi">16</code><code class="p">);</code>                          <code class="c1">// y == 256</code></pre>
        
        <p>Functions don’t even require names at all, as when they’re
        assigned to array elements:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">,</code> <code class="mi">20</code><code class="p">];</code> <code class="c1">// An array literal</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">](</code><code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">])</code>              <code class="c1">// =&gt; 400</code></pre>
        
        <p>The syntax of this last example looks strange, but it is still a legal
        function invocation expression!</p>
        
        <p>As<a data-type="indexterm" data-primary="Array.sort() method" id="idm46198539955416"></a> an example of how useful it is to treat functions as values,
        consider the <code>Array.sort()</code> method. This method sorts the elements of
        an array. Because there are many possible orders to sort by (numerical
        order, alphabetical order, date order, ascending, descending, and so
        on), the <code>sort()</code> method optionally takes a function as an argument to
        tell it how to perform the sort. This function has a simple job: for
        any two values it is passed, it returns a value that specifies which
        element would come first in a sorted array. This function argument
        makes <code>Array.sort()</code> perfectly general and infinitely flexible; it can
        sort any type of data into any conceivable order. Examples are shown
        in <a data-type="xref" href="ch07.html#arraysearchandsort">§7.8.6</a>.</p>
        
        <p><a data-type="xref" href="#functions-EX-2">Example&nbsp;8-1</a> demonstrates the kinds of things that can be done
        when functions are used as values. This example may be a little
        tricky, but the comments explain what is going on.</p>
        <div id="functions-EX-2" data-type="example">
        <h5><span class="label">Example 8-1. </span>Using functions as data</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// We define some simple functions here</code>
        <code class="kd">function</code> <code class="nx">add</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">;</code> <code class="p">}</code>
        <code class="kd">function</code> <code class="nx">subtract</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">-</code> <code class="nx">y</code><code class="p">;</code> <code class="p">}</code>
        <code class="kd">function</code> <code class="nx">multiply</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">y</code><code class="p">;</code> <code class="p">}</code>
        <code class="kd">function</code> <code class="nx">divide</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">/</code> <code class="nx">y</code><code class="p">;</code> <code class="p">}</code>
        
        <code class="c1">// Here's a function that takes one of the preceding functions</code>
        <code class="c1">// as an argument and invokes it on two operands</code>
        <code class="kd">function</code> <code class="nx">operate</code><code class="p">(</code><code class="nx">operator</code><code class="p">,</code> <code class="nx">operand1</code><code class="p">,</code> <code class="nx">operand2</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">operator</code><code class="p">(</code><code class="nx">operand1</code><code class="p">,</code> <code class="nx">operand2</code><code class="p">);</code>
        <code class="p">}</code>
        
        <code class="c1">// We could invoke this function like this to compute the value (2+3) + (4*5):</code>
        <code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="nx">operate</code><code class="p">(</code><code class="nx">add</code><code class="p">,</code> <code class="nx">operate</code><code class="p">(</code><code class="nx">add</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">),</code> <code class="nx">operate</code><code class="p">(</code><code class="nx">multiply</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="mi">5</code><code class="p">));</code>
        
        <code class="c1">// For the sake of the example, we implement the simple functions again,</code>
        <code class="c1">// this time within an object literal;</code>
        <code class="kr">const</code> <code class="nx">operators</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">add</code><code class="o">:</code>      <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">+</code><code class="nx">y</code><code class="p">,</code>
            <code class="nx">subtract</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">-</code><code class="nx">y</code><code class="p">,</code>
            <code class="nx">multiply</code><code class="o">:</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">y</code><code class="p">,</code>
            <code class="nx">divide</code><code class="o">:</code>   <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">/</code><code class="nx">y</code><code class="p">,</code>
            <code class="nx">pow</code><code class="o">:</code>      <code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code>  <code class="c1">// This works for predefined functions too</code>
        <code class="p">};</code>
        
        <code class="c1">// This function takes the name of an operator, looks up that operator</code>
        <code class="c1">// in the object, and then invokes it on the supplied operands. Note</code>
        <code class="c1">// the syntax used to invoke the operator function.</code>
        <code class="kd">function</code> <code class="nx">operate2</code><code class="p">(</code><code class="nx">operation</code><code class="p">,</code> <code class="nx">operand1</code><code class="p">,</code> <code class="nx">operand2</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="k">typeof</code> <code class="nx">operators</code><code class="p">[</code><code class="nx">operation</code><code class="p">]</code> <code class="o">===</code> <code class="s2">"function"</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">return</code> <code class="nx">operators</code><code class="p">[</code><code class="nx">operation</code><code class="p">](</code><code class="nx">operand1</code><code class="p">,</code> <code class="nx">operand2</code><code class="p">);</code>
            <code class="p">}</code>
            <code class="k">else</code> <code class="k">throw</code> <code class="s2">"unknown operator"</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="nx">operate2</code><code class="p">(</code><code class="s2">"add"</code><code class="p">,</code> <code class="s2">"hello"</code><code class="p">,</code> <code class="nx">operate2</code><code class="p">(</code><code class="s2">"add"</code><code class="p">,</code> <code class="s2">" "</code><code class="p">,</code> <code class="s2">"world"</code><code class="p">))</code> <code class="c1">// =&gt; "hello world"</code>
        <code class="nx">operate2</code><code class="p">(</code><code class="s2">"pow"</code><code class="p">,</code> <code class="mi">10</code><code class="p">,</code> <code class="mi">2</code><code class="p">)</code>  <code class="c1">// =&gt; 100</code></pre></div>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.4.1 Defining Your Own Function Properties"><div class="sect2" id="yourownfunctionprops">
        <h2>8.4.1 Defining Your Own Function Properties</h2>
        
        <p>Functions<a data-type="indexterm" data-primary="functions" data-secondary="defining your own function properties" id="idm46198539902488"></a><a data-type="indexterm" data-primary="properties" data-secondary="defining your own function properties" id="idm46198539901416"></a> are not primitive values in JavaScript, but a specialized
        kind of object, which means that functions can have properties. When a
        function needs a “static” variable whose value persists
        across invocations, it is often convenient to use a property of the
        function itself. For example, suppose you want to write a function that
        returns a unique integer whenever it is invoked. The function must
        never return the same value twice. In order to manage this, the
        function needs to keep track of the values it has already returned,
        and this information must persist across function invocations. You
        could store this information in a global variable, but that is
        unnecessary, because the information is used only by the function
        itself. It is better to store the information in a property of the
        Function object. Here is an example that returns a unique integer
        whenever it is called:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Initialize the counter property of the function object.</code>
        <code class="c1">// Function declarations are hoisted so we really can</code>
        <code class="c1">// do this assignment before the function declaration.</code>
        <code class="nx">uniqueInteger</code><code class="p">.</code><code class="nx">counter</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        
        <code class="c1">// This function returns a different integer each time it is called.</code>
        <code class="c1">// It uses a property of itself to remember the next value to be returned.</code>
        <code class="kd">function</code> <code class="nx">uniqueInteger</code><code class="p">()</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">uniqueInteger</code><code class="p">.</code><code class="nx">counter</code><code class="o">++</code><code class="p">;</code>  <code class="c1">// Return and increment counter property</code>
        <code class="p">}</code>
        <code class="nx">uniqueInteger</code><code class="p">()</code>  <code class="c1">// =&gt; 0</code>
        <code class="nx">uniqueInteger</code><code class="p">()</code>  <code class="c1">// =&gt; 1</code></pre>
        
        <p>As another example, consider the following <code>factorial()</code> function that
        uses properties of itself (treating itself as an array) to cache
        previously computed<a data-type="indexterm" data-primary="" data-startref="Fvalue08" id="idm46198539627608"></a><a data-type="indexterm" data-primary="" data-startref="Vfunc08" id="idm46198539626760"></a> results:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Compute factorials and cache results as properties of the function itself.</code>
        <code class="kd">function</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">if</code> <code class="p">(</code><code class="nb">Number</code><code class="p">.</code><code class="nx">isInteger</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="nx">n</code> <code class="o">&gt;</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>           <code class="c1">// Positive integers only</code>
                <code class="k">if</code> <code class="p">(</code><code class="o">!</code><code class="p">(</code><code class="nx">n</code> <code class="k">in</code> <code class="nx">factorial</code><code class="p">))</code> <code class="p">{</code>                  <code class="c1">// If no cached result</code>
                    <code class="nx">factorial</code><code class="p">[</code><code class="nx">n</code><code class="p">]</code> <code class="o">=</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">1</code><code class="p">);</code>    <code class="c1">// Compute and cache it</code>
                <code class="p">}</code>
                <code class="k">return</code> <code class="nx">factorial</code><code class="p">[</code><code class="nx">n</code><code class="p">];</code>                      <code class="c1">// Return the cached result</code>
            <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                <code class="k">return</code> <code class="kc">NaN</code><code class="p">;</code>                               <code class="c1">// If input was bad</code>
            <code class="p">}</code>
        <code class="p">}</code>
        <code class="nx">factorial</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>  <code class="c1">// Initialize the cache to hold this base case.</code>
        <code class="nx">factorial</code><code class="p">(</code><code class="mi">6</code><code class="p">)</code>  <code class="c1">// =&gt; 720</code>
        <code class="nx">factorial</code><code class="p">[</code><code class="mi">5</code><code class="p">]</code>  <code class="c1">// =&gt; 120; the call above caches this value</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="8.5 Functions as Namespaces"><div class="sect1" id="functionsasnamespaces">
        <h1>8.5 Functions as Namespaces</h1>
        
        <p>Variables<a data-type="indexterm" data-primary="functions" data-secondary="functions as namespaces" id="idm46198539623688"></a> declared within a function are not visible outside of the
        function. For this reason, it is sometimes useful to define a function
        simply to act as a temporary namespace in which you can define variables
        without cluttering the global namespace.</p>
        
        <p>Suppose, for example, you have a chunk of JavaScript code that you
        want to use in a number of different JavaScript programs (or, for
        client-side JavaScript, on a number of different web pages). Assume
        that this code, like most code, defines variables to store the
        intermediate results of its computation. The problem is that since
        this chunk of code will be used in many different programs, you don’t
        know whether the variables it creates will conflict with variables
        created by the programs that use it. The solution is to put the chunk
        of code into a function and then invoke the function. This way,
        variables that would have been global become local to the function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">chunkNamespace</code><code class="p">()</code> <code class="p">{</code>
            <code class="c1">// Chunk of code goes here</code>
            <code class="c1">// Any variables defined in the chunk are local to this function</code>
            <code class="c1">// instead of cluttering up the global namespace.</code>
        <code class="p">}</code>
        <code class="nx">chunkNamespace</code><code class="p">();</code>  <code class="c1">// But don't forget to invoke the function!</code></pre>
        
        <p>This code defines only a single global variable: the function name
        <code>chunkNamespace</code>. If defining even a single property is too
        much, you can define and invoke an anonymous function in a single
        expression:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>  <code class="c1">// chunkNamespace() function rewritten as an unnamed expression.</code>
            <code class="c1">// Chunk of code goes here</code>
        <code class="p">}());</code>          <code class="c1">// End the function literal and invoke it now.</code></pre>
        
        <p>This<a data-type="indexterm" data-primary="immediately invoked function expression" id="idm46198539328264"></a><a data-type="indexterm" data-primary="function expressions" id="idm46198539327656"></a><a data-type="indexterm" data-primary="expressions" data-secondary="function expressions" id="idm46198539326984"></a> technique of defining and invoking a function in a single
        expression is used frequently enough that it has become
        idiomatic and has been given the name “immediately invoked function
        expression.” Note the use of parentheses in the previous code example. The open
        parenthesis before <code>function</code> is required because without it, the
        JavaScript interpreter tries to parse the <code>function</code> keyword as a
        function declaration statement. With the parenthesis, the interpreter
        correctly recognizes this as a function definition expression. The
        leading parenthesis also helps human readers recognize when a
        function is being defined to be immediately invoked instead of defined
        for later use.</p>
        
        <p>This use of functions as namespaces becomes really useful when we define
        one or more functions inside the namespace function using variables
        within that namesapce, but then pass them back out as
        the return value of the namespace function. Functions like this are
        known as <em>closures</em>, and they’re the topic of the next section.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="8.6 Closures"><div class="sect1" id="closures">
        <h1>8.6 Closures</h1>
        
        <p>Like<a data-type="indexterm" data-primary="functions" data-secondary="closures" id="Fclos08"></a><a data-type="indexterm" data-primary="lexical scoping" id="idm46198539370952"></a> most modern programming languages, JavaScript uses <em>lexical
        scoping</em>. This means that functions are executed using the variable
        scope that was in effect when they were defined, not the variable
        scope that is in effect when they are invoked. In order to implement
        lexical scoping, the internal state of a JavaScript function object
        must include not only the code of the function but also a reference to
        the scope in which the function definition appears. This<a data-type="indexterm" data-primary="closures" data-secondary="definition of term" id="idm46198539369304"></a> combination
        of a function object and a scope (a set of variable bindings) in which
        the function’s variables are resolved is called a <em>closure</em> in the
        computer science literature.</p>
        
        <p>Technically, all<a data-type="indexterm" data-primary="closures" data-secondary="nested function closures" id="idm46198539367240"></a> JavaScript functions are closures, but because most
        functions are invoked from the same scope that they were defined in,
        it normally doesn’t really matter that there is a closure
        involved. Closures become interesting when they are invoked from a
        different scope than the one they were defined in. This happens most
        commonly when a nested function object is returned from the function
        within which it was defined. There are a number of powerful
        programming techniques that involve this kind of nested function
        closures, and their use has become relatively common in JavaScript
        programming. Closures may seem confusing when you first encounter
        them, but it is important that you understand them well enough to use
        them <span class="keep-together">comfortably.</span></p>
        
        <p>The<a data-type="indexterm" data-primary="closures" data-secondary="lexical scoping rules and" id="idm46198539364456"></a> first step to understanding closures is to review the lexical
        scoping rules for nested functions. Consider the following code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">scope</code> <code class="o">=</code> <code class="s2">"global scope"</code><code class="p">;</code>          <code class="c1">// A global variable</code>
        <code class="kd">function</code> <code class="nx">checkscope</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">scope</code> <code class="o">=</code> <code class="s2">"local scope"</code><code class="p">;</code>       <code class="c1">// A local variable</code>
            <code class="kd">function</code> <code class="nx">f</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">scope</code><code class="p">;</code> <code class="p">}</code>   <code class="c1">// Return the value in scope here</code>
            <code class="k">return</code> <code class="nx">f</code><code class="p">();</code>
        <code class="p">}</code>
        <code class="nx">checkscope</code><code class="p">()</code>                         <code class="c1">// =&gt; "local scope"</code></pre>
        
        <p>The<a data-type="indexterm" data-primary="checkscope() function" id="idm46198539216776"></a> <code>checkscope()</code> function declares a local variable and then defines
        and invokes a function that returns the value of that variable. It
        should be clear to you why the call to <code>checkscope()</code> returns “local
        scope”. Now, let’s change the code just slightly. Can you tell what
        this code will return?</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">scope</code> <code class="o">=</code> <code class="s2">"global scope"</code><code class="p">;</code>          <code class="c1">// A global variable</code>
        <code class="kd">function</code> <code class="nx">checkscope</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">scope</code> <code class="o">=</code> <code class="s2">"local scope"</code><code class="p">;</code>       <code class="c1">// A local variable</code>
            <code class="kd">function</code> <code class="nx">f</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">scope</code><code class="p">;</code> <code class="p">}</code>   <code class="c1">// Return the value in scope here</code>
            <code class="k">return</code> <code class="nx">f</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="kd">let</code> <code class="nx">s</code> <code class="o">=</code> <code class="nx">checkscope</code><code class="p">()();</code>              <code class="c1">// What does this return?</code></pre>
        
        <p>In this code, a pair of parentheses has moved from inside
        <code>checkscope()</code> to outside of it. Instead of invoking the nested
        function and returning its result, <code>checkscope()</code> now just returns the
        nested function object itself. What happens when we invoke that nested
        function (with the second pair of parentheses in the last line of
        code) outside of the function in which it was defined?</p>
        
        <p>Remember the fundamental rule of lexical scoping: JavaScript functions
        are executed using the scope they were defined in. The nested function
        <code>f()</code> was defined in a scope where the variable <code>scope</code> was bound to
        the value “local scope”. That binding is still in effect when <code>f</code> is
        executed, no matter where it is executed from. So the last line of
        the preceding code example returns “local scope”, not “global scope”. This, in a
        nutshell, is the surprising and powerful nature of closures: they
        capture the local variable (and parameter) bindings of the outer
        function within which they are defined.</p>
        
        <p>In <a data-type="xref" href="#yourownfunctionprops">§8.4.1</a>, we defined a <code>uniqueInteger()</code> function
        that used a property of the function itself to keep track of the next
        value to be returned. A shortcoming of that approach is that buggy or
        malicious code could reset the counter or set it to a noninteger,
        causing the <code>uniqueInteger()</code> function to violate the
        “unique” or the “integer” part of its
        contract. Closures capture the local variables of a single function
        invocation and can use those variables as private state. Here is how
        we could rewrite the <code>uniqueInteger()</code> using an immediately invoked
        function expression to define a namespace and a closure that
        uses that namespace to keep its state private:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">uniqueInteger</code> <code class="o">=</code> <code class="p">(</code><code class="kd">function</code><code class="p">()</code> <code class="p">{</code>  <code class="c1">// Define and invoke</code>
            <code class="kd">let</code> <code class="nx">counter</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>               <code class="c1">// Private state of function below</code>
            <code class="k">return</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">counter</code><code class="o">++</code><code class="p">;</code> <code class="p">};</code>
        <code class="p">}());</code>
        <code class="nx">uniqueInteger</code><code class="p">()</code>  <code class="c1">// =&gt; 0</code>
        <code class="nx">uniqueInteger</code><code class="p">()</code>  <code class="c1">// =&gt; 1</code></pre>
        
        <p>In order to understand this code, you have to read it carefully. At
        first glance, the first line of code looks like it is assigning a
        function to the variable <code>uniqueInteger</code>. In fact, the code is
        defining and invoking (as hinted by the open parenthesis on the first
        line) a function, so it is the return value of the function that is
        being assigned to <code>uniqueInteger</code>. Now, if we study the body of the
        function, we see that its return value is another function. It is this
        nested function object that gets assigned to <code>uniqueInteger</code>. The
        nested function has access to the variables in its scope and can use the
        <code>counter</code> variable defined in the outer function. Once that outer
        function returns, no other code can see the <code>counter</code> variable: the
        inner function has exclusive access to it.</p>
        
        <p>Private variables like <code>counter</code> need not be exclusive to a single
        closure: it is perfectly possible for two or more nested functions to
        be defined within the same outer function and share the same
        scope. Consider the following code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">counter</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
            <code class="k">return</code> <code class="p">{</code>
                <code class="nx">count</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">n</code><code class="o">++</code><code class="p">;</code> <code class="p">},</code>
                <code class="nx">reset</code><code class="o">:</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="p">}</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">counter</code><code class="p">(),</code> <code class="nx">d</code> <code class="o">=</code> <code class="nx">counter</code><code class="p">();</code>   <code class="c1">// Create two counters</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">count</code><code class="p">()</code>                           <code class="c1">// =&gt; 0</code>
        <code class="nx">d</code><code class="p">.</code><code class="nx">count</code><code class="p">()</code>                           <code class="c1">// =&gt; 0: they count independently</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">reset</code><code class="p">();</code>                          <code class="c1">// reset() and count() methods share state</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">count</code><code class="p">()</code>                           <code class="c1">// =&gt; 0: because we reset c</code>
        <code class="nx">d</code><code class="p">.</code><code class="nx">count</code><code class="p">()</code>                           <code class="c1">// =&gt; 1: d was not reset</code></pre>
        
        <p>The <code>counter()</code> function returns a “counter” object. This
        object has two methods: <code>count()</code> returns the next integer, and
        <code>reset()</code> resets the internal state. The first thing to understand is
        that the two methods share access to the private variable <code>n</code>. The
        second thing to understand is that each invocation of <code>counter()</code>
        creates a new scope—independent of the scopes used by previous
        invocations—and a new private variable within that scope. So if you call
        <code>counter()</code> twice, you get two counter objects with different private
        variables. Calling <code>count()</code> or <code>reset()</code> on one counter object has no
        effect on the other.</p>
        
        <p>It<a data-type="indexterm" data-primary="closures" data-secondary="combining with property getters and setters" id="idm46198539015128"></a> is worth noting here that you can combine this closure technique
        with property getters and setters. The following version of the
        <code>counter()</code> function is a variation on code that appeared in
        <a data-type="xref" href="ch06.html#gettersandsetters">§6.10.6</a>, but it uses closures for private state rather
        than relying on a regular object property:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">counter</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>  <code class="c1">// Function argument n is the private variable</code>
            <code class="k">return</code> <code class="p">{</code>
                <code class="c1">// Property getter method returns and increments private counter var.</code>
                <code class="nx">get</code> <code class="nx">count</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">n</code><code class="o">++</code><code class="p">;</code> <code class="p">},</code>
                <code class="c1">// Property setter doesn't allow the value of n to decrease</code>
                <code class="nx">set</code> <code class="nx">count</code><code class="p">(</code><code class="nx">m</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">m</code> <code class="o">&gt;</code> <code class="nx">n</code><code class="p">)</code> <code class="nx">n</code> <code class="o">=</code> <code class="nx">m</code><code class="p">;</code>
                    <code class="k">else</code> <code class="k">throw</code> <code class="nb">Error</code><code class="p">(</code><code class="s2">"count can only be set to a larger value"</code><code class="p">);</code>
                <code class="p">}</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">c</code> <code class="o">=</code> <code class="nx">counter</code><code class="p">(</code><code class="mi">1000</code><code class="p">);</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">count</code>            <code class="c1">// =&gt; 1000</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">count</code>            <code class="c1">// =&gt; 1001</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">count</code> <code class="o">=</code> <code class="mi">2000</code><code class="p">;</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">count</code>            <code class="c1">// =&gt; 2000</code>
        <code class="nx">c</code><code class="p">.</code><code class="nx">count</code> <code class="o">=</code> <code class="mi">2000</code><code class="p">;</code>    <code class="c1">// !Error: count can only be set to a larger value</code></pre>
        
        <p>Note that this version of the <code>counter()</code> function does not declare a
        local variable but just uses its parameter <code>n</code> to hold the private
        state shared by the property accessor methods. This allows the caller
        of <code>counter()</code> to specify the initial value of the private variable.</p>
        
        <p><a data-type="xref" href="#addPrivateProperty.js">Example&nbsp;8-2</a> is a<a data-type="indexterm" data-primary="closures" data-secondary="shared private state" id="idm46198538885576"></a> generalization of the shared private
        state through the closures technique we’ve been demonstrating
        here. This example defines an <code>addPrivateProperty()</code> function that
        defines a private variable and two nested functions to get and set the
        value of that variable. It adds these nested functions as methods of
        the object you specify.</p>
        <div id="addPrivateProperty.js" data-type="example">
        <h5><span class="label">Example 8-2. </span>Private property accessor methods using closures</h5>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This function adds property accessor methods for a property with</code>
        <code class="c1">// the specified name to the object o. The methods are named get&lt;name&gt;</code>
        <code class="c1">// and set&lt;name&gt;. If a predicate function is supplied, the setter</code>
        <code class="c1">// method uses it to test its argument for validity before storing it.</code>
        <code class="c1">// If the predicate returns false, the setter method throws an exception.</code>
        <code class="c1">//</code>
        <code class="c1">// The unusual thing about this function is that the property value</code>
        <code class="c1">// that is manipulated by the getter and setter methods is not stored in</code>
        <code class="c1">// the object o. Instead, the value is stored only in a local variable</code>
        <code class="c1">// in this function. The getter and setter methods are also defined</code>
        <code class="c1">// locally to this function and therefore have access to this local variable.</code>
        <code class="c1">// This means that the value is private to the two accessor methods, and it</code>
        <code class="c1">// cannot be set or modified except through the setter method.</code>
        <code class="kd">function</code> <code class="nx">addPrivateProperty</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">name</code><code class="p">,</code> <code class="nx">predicate</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">value</code><code class="p">;</code>  <code class="c1">// This is the property value</code>
        
            <code class="c1">// The getter method simply returns the value.</code>
            <code class="nx">o</code><code class="p">[</code><code class="sb">`get</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">]</code> <code class="o">=</code> <code class="kd">function</code><code class="p">()</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">value</code><code class="p">;</code> <code class="p">};</code>
        
            <code class="c1">// The setter method stores the value or throws an exception if</code>
            <code class="c1">// the predicate rejects the value.</code>
            <code class="nx">o</code><code class="p">[</code><code class="sb">`set</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">`</code><code class="p">]</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code> <code class="p">{</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">predicate</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">predicate</code><code class="p">(</code><code class="nx">v</code><code class="p">))</code> <code class="p">{</code>
                    <code class="k">throw</code> <code class="k">new</code> <code class="nx">TypeError</code><code class="p">(</code><code class="sb">`set</code><code class="si">${</code><code class="nx">name</code><code class="si">}</code><code class="sb">: invalid value </code><code class="si">${</code><code class="nx">v</code><code class="si">}</code><code class="sb">`</code><code class="p">);</code>
                <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                    <code class="nx">value</code> <code class="o">=</code> <code class="nx">v</code><code class="p">;</code>
                <code class="p">}</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="c1">// The following code demonstrates the addPrivateProperty() method.</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{};</code>  <code class="c1">// Here is an empty object</code>
        
        <code class="c1">// Add property accessor methods getName and setName()</code>
        <code class="c1">// Ensure that only string values are allowed</code>
        <code class="nx">addPrivateProperty</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="s2">"Name"</code><code class="p">,</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="k">typeof</code> <code class="nx">x</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">);</code>
        
        <code class="nx">o</code><code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="s2">"Frank"</code><code class="p">);</code>       <code class="c1">// Set the property value</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">getName</code><code class="p">()</code>               <code class="c1">// =&gt; "Frank"</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">setName</code><code class="p">(</code><code class="mi">0</code><code class="p">);</code>             <code class="c1">// !TypeError: try to set a value of the wrong type</code></pre></div>
        
        <p>We’ve<a data-type="indexterm" data-primary="closures" data-secondary="common errors" id="idm46198538879032"></a> now seen a number of examples in which two closures are
        defined in the same scope and share access to the same private
        variable or variables. This is an important technique, but it is just
        as important to recognize when closures inadvertently share access to
        a variable that they should not share. Consider the following code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This function returns a function that always returns v</code>
        <code class="kd">function</code> <code class="nx">constfunc</code><code class="p">(</code><code class="nx">v</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">v</code><code class="p">;</code> <code class="p">}</code>
        
        <code class="c1">// Create an array of constant functions:</code>
        <code class="kd">let</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[];</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">funcs</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">constfunc</code><code class="p">(</code><code class="nx">i</code><code class="p">);</code>
        
        <code class="c1">// The function at array element 5 returns the value 5.</code>
        <code class="nx">funcs</code><code class="p">[</code><code class="mi">5</code><code class="p">]()</code>    <code class="c1">// =&gt; 5</code></pre>
        
        <p>When working with code like this that creates multiple closures using
        a loop, it is a common error to try to move the loop within the
        function that defines the closures. Think about the following code,
        for example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Return an array of functions that return the values 0-9</code>
        <code class="kd">function</code> <code class="nx">constfuncs</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="p">[];</code>
            <code class="k">for</code><code class="p">(</code><code class="kd">var</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="mi">10</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                <code class="nx">funcs</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="nx">i</code><code class="p">;</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">funcs</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kd">let</code> <code class="nx">funcs</code> <code class="o">=</code> <code class="nx">constfuncs</code><code class="p">();</code>
        <code class="nx">funcs</code><code class="p">[</code><code class="mi">5</code><code class="p">]()</code>    <code class="c1">// =&gt; 10; Why doesn't this return 5?</code></pre>
        
        <p>This code creates 10 closures and stores them in an array. The
        closures are all defined within the same invocation of the function,
        so they share access to the variable <code>i</code>. When <code>constfuncs()</code> returns,
        the value of the variable <code>i</code> is 10, and all 10 closures share this
        value. Therefore, all the functions in the returned array of functions
        return the same value, which is not what we wanted at all. It is
        important to remember that the scope associated with a closure is
        “live.” Nested functions do not make private copies of the scope or
        make static snapshots of the variable bindings. Fundamentally, the
        problem here is that variables declared with <code>var</code> are defined
        throughout the function. Our <code>for</code> loop declares the loop
        variable with <code>var i</code>, so the variable <code>i</code> is defined throughout the
        function rather than being more narrowly scoped to the body of the
        loop. The<a data-type="indexterm" data-primary="ES5" data-secondary="bugs addressed by block-scoped variables" id="idm46198538603512"></a> code demonstrates a common category of bugs in ES5 and
        before, but the introduction of block-scoped variables in ES6
        addresses the issue. If we just replace the <code>var</code> with a <code>let</code> or a
        <code>const</code>, then the problem goes away. Because <code>let</code> and <code>const</code> are
        block scoped, each iteration of the loop defines a scope that is
        independent of the scopes for all other iterations, and each of these
        scopes has its own independent binding of <code>i</code>.</p>
        
        <p>Another thing to remember when writing closures is that <code>this</code> is a
        JavaScript keyword, not a variable. As discussed earlier, arrow
        functions inherit the <code>this</code> value of the function that contains them,
        but functions defined with the <code>function</code> keyword do not. So if you’re
        writing a closure that needs to use the <code>this</code> value of its containing
        function, you should use an arrow function, or call <code>bind()</code>, on the
        closure before returning it, or assign the outer <code>this</code> value to a
        variable that your closure will<a data-type="indexterm" data-primary="" data-startref="Fclos08" id="idm46198538491112"></a> inherit:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">self</code> <code class="o">=</code> <code class="k">this</code><code class="p">;</code>  <code class="c1">// Make the this value available to nested functions</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="8.7 Function Properties, Methods, and Constructor"><div class="sect1" id="idm46198539373528">
        <h1>8.7 Function Properties, Methods, and Constructor</h1>
        
        <p>We’ve<a data-type="indexterm" data-primary="functions" data-secondary="function properties, methods, and constructor" id="Fprop08"></a> seen that functions are values in JavaScript programs. The
        <code>typeof</code> operator returns the string “function” when applied to a
        function, but functions are really a specialized kind of JavaScript
        object. Since functions are objects, they can have properties and
        methods, just like any other object. There is even a <code>Function()</code>
        constructor to create new function objects. The subsections that
        follow document the <code>length</code>, <code>name</code>, and <code>prototype</code> properties; the
        <code>call()</code>, <code>apply()</code>, <code>bind()</code>, and <code>toString()</code> methods; and the
        <code>Function()</code> constructor.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.7.1 The length Property"><div class="sect2" id="idm46198538484184">
        <h2>8.7.1 The length Property</h2>
        
        <p>The<a data-type="indexterm" data-primary="functions" data-secondary="function properties, methods, and constructor" data-tertiary="length property" id="idm46198538471720"></a> read-only <code>length</code> property of a function specifies
        the <em>arity</em> of the function—the number of parameters it declares in its
        parameter list, which is usually the number of arguments that the
        function expects. If a function has a rest parameter, that parameter is
        not counted for the purposes of this <code>length</code> property.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.7.2 The name Property"><div class="sect2" id="idm46198538468520">
        <h2>8.7.2 The name Property</h2>
        
        <p>The<a data-type="indexterm" data-primary="functions" data-secondary="function properties, methods, and constructor" data-tertiary="name property" id="idm46198538467160"></a> read-only <code>name</code> property of a function specifies the name that was
        used when the function was defined, if it was defined with a name, or
        the name of the variable or property that an unnamed function expression
        was assigned to when it was first created. This property is primarily
        useful when writing debugging or error messages.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.7.3 The prototype Property"><div class="sect2" id="idm46198538464712">
        <h2>8.7.3 The prototype Property</h2>
        
        <p>All<a data-type="indexterm" data-primary="functions" data-secondary="function properties, methods, and constructor" data-tertiary="prototype property" id="idm46198538463160"></a><a data-type="indexterm" data-primary="prototypes" id="idm46198538461848"></a> functions, except arrow functions, have a <code>prototype</code> property that
        refers to an object known as the <em>prototype object</em>. Every function has
        a different prototype object. When a function is used as a constructor,
        the newly created object inherits properties from the prototype
        object. Prototypes and the <code>prototype</code> property were discussed in
        <a data-type="xref" href="ch06.html#prototypes">§6.2.3</a> and will be covered again in <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.7.4 The call() and apply() Methods"><div class="sect2" id="applyandcall">
        <h2>8.7.4 The call() and apply() Methods</h2>
        
        <p><code>call()</code> and <code>apply()</code> allow<a data-type="indexterm" data-primary="functions" data-secondary="function properties, methods, and constructor" data-tertiary="call() and apply() methods" id="idm46198538413304"></a><a data-type="indexterm" data-primary="call() method" id="idm46198538412088"></a><a data-type="indexterm" data-primary="apply() method" id="idm46198538411416"></a> you to indirectly invoke
        (<a data-type="xref" href="#indirectinvocation">§8.2.4</a>) a function as if it were a method of some
        other object. The first argument to both <code>call()</code> and
        <code>apply()</code> is the object on which the function is to be invoked; this
        argument is the invocation context and becomes the value of the <code>this</code>
        keyword within the body of the function. To invoke the function <code>f()</code>
        as a method of the object <code>o</code> (passing no arguments), you could use
        either <code>call()</code> or <code>apply()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">f</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">o</code><code class="p">);</code>
        <code class="nx">f</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">o</code><code class="p">);</code></pre>
        
        <p>Either of these lines of code are similar to the following (which
        assume that <code>o</code> does not already have a property named <code>m</code>):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">o</code><code class="p">.</code><code class="nx">m</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code>     <code class="c1">// Make f a temporary method of o.</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">m</code><code class="p">();</code>       <code class="c1">// Invoke it, passing no arguments.</code>
        <code class="k">delete</code> <code class="nx">o</code><code class="p">.</code><code class="nx">m</code><code class="p">;</code>  <code class="c1">// Remove the temporary method.</code></pre>
        
        <p>Remember that arrow functions inherit the <code>this</code> value of the context
        where they are defined. This cannot be overridden with the <code>call()</code> and
        <code>apply()</code> methods. If you call either of those methods on an arrow
        function, the first argument is effectively ignored.</p>
        
        <p>Any arguments to <code>call()</code> after the first invocation context argument
        are the values that are passed to the function that is invoked (and
        these arguments are not ignored for arrow functions). For example, to
        pass two numbers to the function <code>f()</code> and invoke it as if it were a
        method of the object <code>o</code>, you could use code like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">f</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">);</code></pre>
        
        <p>The <code>apply()</code> method is like the <code>call()</code> method, except that the
        arguments to be passed to the function are specified as an array:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">f</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">]);</code></pre>
        
        <p>If a function is defined to accept an arbitrary number of arguments, the
        <code>apply()</code> method allows you to invoke that function on the contents of
        an array of arbitrary length. In ES6 and later, we can just use the
        spread operator, but you may see<a data-type="indexterm" data-primary="ES5" data-secondary="apply() method" id="idm46198538303272"></a> ES5 code that uses <code>apply()</code> instead. For
        example, to find the largest number in an array of numbers without
        using the spread operator, you could use the <code>apply()</code> method to pass the
        elements of the array to the <code>Math.max()</code> function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">biggest</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="nb">Math</code><code class="p">,</code> <code class="nx">arrayOfNumbers</code><code class="p">);</code></pre>
        
        <p>The <code>trace()</code> function defined in the following is similar to the <code>timed()</code>
        function defined in <a data-type="xref" href="#spread-operator-for-functions">§8.3.4</a>, but it works for
        methods instead of functions. It uses the <code>apply()</code> method instead of a
        spread operator, and by doing that, it is able to invoke the wrapped
        method with the same arguments and the same <code>this</code> value as the wrapper
        method:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Replace the method named m of the object o with a version that logs</code>
        <code class="c1">// messages before and after invoking the original method.</code>
        <code class="kd">function</code> <code class="nx">trace</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">m</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">original</code> <code class="o">=</code> <code class="nx">o</code><code class="p">[</code><code class="nx">m</code><code class="p">];</code>         <code class="c1">// Remember original method in the closure.</code>
            <code class="nx">o</code><code class="p">[</code><code class="nx">m</code><code class="p">]</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>   <code class="c1">// Now define the new method.</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">(),</code> <code class="s2">"Entering:"</code><code class="p">,</code> <code class="nx">m</code><code class="p">);</code>      <code class="c1">// Log message.</code>
                <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">original</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>      <code class="c1">// Invoke original.</code>
                <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="k">new</code> <code class="nb">Date</code><code class="p">(),</code> <code class="s2">"Exiting:"</code><code class="p">,</code> <code class="nx">m</code><code class="p">);</code>       <code class="c1">// Log message.</code>
                <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>                                <code class="c1">// Return result.</code>
            <code class="p">};</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.7.5 The bind() Method"><div class="sect2" id="bind">
        <h2>8.7.5 The bind() Method</h2>
        
        <p>The<a data-type="indexterm" data-primary="functions" data-secondary="function properties, methods, and constructor" data-tertiary="bind() method" id="idm46198538136872"></a><a data-type="indexterm" data-primary="bind() method" id="idm46198538135624"></a> primary purpose of <code>bind()</code> is to <em>bind</em> a
        function to an object. When you invoke the <code>bind()</code> method on a function
        <code>f</code> and pass an object <code>o</code>, the method returns a new function. Invoking
        the new function (as a function) invokes the original function <code>f</code> as a
        method of <code>o</code>. Any arguments you pass to the new function are passed to
        the original function. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">y</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">;</code> <code class="p">}</code> <code class="c1">// This function needs to be bound</code>
        <code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code> <code class="p">};</code>                    <code class="c1">// An object we'll bind to</code>
        <code class="kd">let</code> <code class="nx">g</code> <code class="o">=</code> <code class="nx">f</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="nx">o</code><code class="p">);</code>                   <code class="c1">// Calling g(x) invokes f() on o</code>
        <code class="nx">g</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>                                 <code class="c1">// =&gt; 3</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">10</code><code class="p">,</code> <code class="nx">g</code> <code class="p">};</code>                <code class="c1">// Invoke g() as a method of this object</code>
        <code class="nx">p</code><code class="p">.</code><code class="nx">g</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>                               <code class="c1">// =&gt; 3: g is still bound to o, not p.</code></pre>
        
        <p>Arrow functions inherit their <code>this</code> value from the environment in which
        they are defined, and that value cannot be overridden with <code>bind()</code>, so
        if the function <code>f()</code> in the preceding code was defined as an arrow
        function, the binding would not work. The most common use case for
        calling <code>bind()</code> is to make non-arrow functions behave like arrow
        functions, however, so this limitation on binding arrow functions is not
        a problem in practice.</p>
        
        <p>The <code>bind()</code> method does more than just bind a function to an object,
        however. It can also perform partial application: any arguments you pass
        to <code>bind()</code> after the first are bound along with the <code>this</code> value. This
        partial application feature of <code>bind()</code> does work with arrow
        functions. Partial application is a common technique in functional
        programming and is sometimes called <em>currying</em>. Here are some examples
        of the <code>bind()</code> method used for partial application:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">sum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">;</code>      <code class="c1">// Return the sum of 2 args</code>
        <code class="kd">let</code> <code class="nx">succ</code> <code class="o">=</code> <code class="nx">sum</code><code class="p">.</code><code class="nx">bind</code><code class="p">(</code><code class="kc">null</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>  <code class="c1">// Bind the first argument to 1</code>
        <code class="nx">succ</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>  <code class="c1">// =&gt; 3: x is bound to 1, and we pass 2 for the y argument</code>
        
        <code class="kd">function</code> <code class="nx">f</code><code class="p">(</code><code class="nx">y</code><code class="p">,</code><code class="nx">z</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="k">this</code><code class="p">.</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code> <code class="o">+</code> <code class="nx">z</code><code class="p">;</code> <code class="p">}</code>
        <code class="kd">let</code> <code class="nx">g</code> <code class="o">=</code> <code class="nx">f</code><code class="p">.</code><code class="nx">bind</code><code class="p">({</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">},</code> <code class="mi">2</code><code class="p">);</code>     <code class="c1">// Bind this and y</code>
        <code class="nx">g</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code>     <code class="c1">// =&gt; 6: this.x is bound to 1, y is bound to 2 and z is 3</code></pre>
        
        <p>The <code>name</code> property of the function returned by <code>bind()</code> is the name
        property of the function that <code>bind()</code> was called on, prefixed with
        the word “bound”.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.7.6 The toString() Method"><div class="sect2" id="idm46198537920888">
        <h2>8.7.6 The toString() Method</h2>
        
        <p>Like<a data-type="indexterm" data-primary="functions" data-secondary="function properties, methods, and constructor" data-tertiary="toString() method" id="idm46198537919704"></a><a data-type="indexterm" data-primary="toString() method" id="idm46198537918328"></a> all JavaScript objects, functions have a <code>toString()</code> method. The
        ECMAScript spec requires this method to return a string that follows
        the syntax of the function declaration statement. In practice, most
        (but not all) implementations of this <code>toString()</code> method return the
        complete source code for the function. Built-in functions typically
        return a string that includes something like “[native
        code]” as the function body.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.7.7 The Function() Constructor"><div class="sect2" id="functionconstructor">
        <h2>8.7.7 The Function() Constructor</h2>
        
        <p>Because<a data-type="indexterm" data-primary="functions" data-secondary="function properties, methods, and constructor" data-tertiary="Function() constructor" id="idm46198537914104"></a><a data-type="indexterm" data-primary="Function() constructor" id="idm46198537912792"></a><a data-type="indexterm" data-primary="constructors" data-secondary="Function() constructor" id="idm46198537912120"></a> functions are objects, there is a <code>Function()</code> constructor that
        can be used to create new functions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Function</code><code class="p">(</code><code class="s2">"x"</code><code class="p">,</code> <code class="s2">"y"</code><code class="p">,</code> <code class="s2">"return x*y;"</code><code class="p">);</code></pre>
        
        <p>This line of code creates a new function that is more or less
        equivalent to a function defined with the familiar syntax:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">y</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code><code class="o">*</code><code class="nx">y</code><code class="p">;</code> <code class="p">};</code></pre>
        
        <p>The <code>Function()</code> constructor expects any number of string
        arguments. The last argument is the text of the function body; it can
        contain arbitrary JavaScript statements, separated from each other by
        semicolons. All other arguments to the constructor are strings that
        specify the parameter names for the function. If you are defining a
        <span class="keep-together">function</span> that takes no arguments, you would simply pass a single string—the
        function body—to the constructor.</p>
        
        <p>Notice that the <code>Function()</code> constructor is not passed any argument
        that specifies a name for the function it creates. Like function
        literals, the <code>Function()</code> constructor creates anonymous functions.</p>
        
        <p>There are a few points that are important to understand about the
        <code>Function()</code> <span class="keep-together">constructor:</span></p>
        
        <ul>
        <li>
        <p>The <code>Function()</code> constructor allows JavaScript functions to be
        dynamically created and compiled at runtime.</p>
        </li>
        <li>
        <p>The <code>Function()</code> constructor parses the function body and creates a
        new function object each time it is called. If the call to the
        constructor appears within a loop or within a frequently called
        function, this process can be inefficient. By contrast, nested
        functions and function expressions that appear within
        loops are not recompiled each time they are encountered.</p>
        </li>
        <li>
        <p>A last, very important point about the <code>Function()</code> constructor is
        that the functions it creates do not use lexical scoping; instead,
        they are always compiled as if they were top-level functions, as the
        following code demonstrates:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">scope</code> <code class="o">=</code> <code class="s2">"global"</code><code class="p">;</code>
        <code class="kd">function</code> <code class="nx">constructFunction</code><code class="p">()</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">scope</code> <code class="o">=</code> <code class="s2">"local"</code><code class="p">;</code>
            <code class="k">return</code> <code class="k">new</code> <code class="nb">Function</code><code class="p">(</code><code class="s2">"return scope"</code><code class="p">);</code>  <code class="c1">// Doesn't capture local scope!</code>
        <code class="p">}</code>
        <code class="c1">// This line returns "global" because the function returned by the</code>
        <code class="c1">// Function() constructor does not use the local scope.</code>
        <code class="nx">constructFunction</code><code class="p">()()</code>  <code class="c1">// =&gt; "global"</code></pre>
        </li>
        </ul>
        
        <p>The <code>Function()</code> constructor is best thought of as a globally scoped
        version of <code>eval()</code> (see <a data-type="xref" href="ch04.html#globaleval">§4.12.2</a>) that defines new variables and
        functions in its own private scope. You will probably never need to use
        this constructor in your code.<a data-type="indexterm" data-primary="" data-startref="Fprop08" id="idm46198537769912"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="8.8 Functional Programming"><div class="sect1" id="functional">
        <h1>8.8 Functional Programming</h1>
        
        <p>JavaScript<a data-type="indexterm" data-primary="functions" data-secondary="functional programming" data-tertiary="exploring" id="idm46198537767160"></a> is not a functional programming language like Lisp or
        Haskell, but the fact that JavaScript can manipulate functions as
        objects means that we can use functional programming techniques in
        JavaScript. Array methods such as <code>map()</code> and
        <code>reduce()</code> lend themselves particularly well to a functional
        programming style. The sections that follow demonstrate techniques for
        functional programming in JavaScript. They are intended as a
        mind-expanding exploration of the power of JavaScript’s
        functions, not as a prescription for good programming
        style.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.8.1 Processing Arrays with Functions"><div class="sect2" id="idm46198537764232">
        <h2>8.8.1 Processing Arrays with Functions</h2>
        
        <p>Suppose<a data-type="indexterm" data-primary="functions" data-secondary="functional programming" data-tertiary="processing arrays with function" id="idm46198537762696"></a><a data-type="indexterm" data-primary="arrays" data-secondary="processing with functions" id="idm46198537761448"></a> we have an array of numbers and we want to compute the mean
        and standard deviation of those values. We might do that in
        nonfunctional style like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>  <code class="c1">// This is our array of numbers</code>
        
        <code class="c1">// The mean is the sum of the elements divided by the number of elements</code>
        <code class="kd">let</code> <code class="nx">total</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="nx">total</code> <code class="o">+=</code> <code class="nx">data</code><code class="p">[</code><code class="nx">i</code><code class="p">];</code>
        <code class="kd">let</code> <code class="nx">mean</code> <code class="o">=</code> <code class="nx">total</code><code class="o">/</code><code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>  <code class="c1">// mean == 3; The mean of our data is 3</code>
        
        <code class="c1">// To compute the standard deviation, we first sum the squares of</code>
        <code class="c1">// the deviation of each element from the mean.</code>
        <code class="nx">total</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
            <code class="kd">let</code> <code class="nx">deviation</code> <code class="o">=</code> <code class="nx">data</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">-</code> <code class="nx">mean</code><code class="p">;</code>
            <code class="nx">total</code> <code class="o">+=</code> <code class="nx">deviation</code> <code class="o">*</code> <code class="nx">deviation</code><code class="p">;</code>
        <code class="p">}</code>
        <code class="kd">let</code> <code class="nx">stddev</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">total</code><code class="o">/</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">));</code>  <code class="c1">// stddev == 2</code></pre>
        
        <p>We can perform these same computations in concise functional style
        using the array methods <code>map()</code> and <code>reduce()</code> like this (see
        <a data-type="xref" href="ch07.html#arrayiteratormethods">§7.8.1</a> to review these methods):</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// First, define two simple functions</code>
        <code class="kr">const</code> <code class="nx">sum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">+</code><code class="nx">y</code><code class="p">;</code>
        <code class="kr">const</code> <code class="nx">square</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;</code>
        
        <code class="c1">// Then use those functions with Array methods to compute mean and stddev</code>
        <code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="kd">let</code> <code class="nx">mean</code> <code class="o">=</code> <code class="nx">data</code><code class="p">.</code><code class="nx">reduce</code><code class="p">(</code><code class="nx">sum</code><code class="p">)</code><code class="o">/</code><code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>  <code class="c1">// mean == 3</code>
        <code class="kd">let</code> <code class="nx">deviations</code> <code class="o">=</code> <code class="nx">data</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">-</code><code class="nx">mean</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">stddev</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">deviations</code><code class="p">.</code><code class="nx">map</code><code class="p">(</code><code class="nx">square</code><code class="p">).</code><code class="nx">reduce</code><code class="p">(</code><code class="nx">sum</code><code class="p">)</code><code class="o">/</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">));</code>
        <code class="nx">stddev</code>  <code class="c1">// =&gt; 2</code></pre>
        
        <p>This new version of the code looks quite different than the first one,
        but it is still invoking methods on objects, so it has some object-oriented
        conventions remaining. Let’s write functional versions of the <code>map()</code>
        and <code>reduce()</code> methods:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">map</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">a</code><code class="p">.</code><code class="nx">map</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code> <code class="p">};</code>
        <code class="kr">const</code> <code class="nx">reduce</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="p">...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">a</code><code class="p">.</code><code class="nx">reduce</code><code class="p">(...</code><code class="nx">args</code><code class="p">);</code> <code class="p">};</code></pre>
        
        <p>With these <code>map()</code> and <code>reduce()</code> functions defined, our code to compute the
        mean and standard deviation now looks like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">sum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">+</code><code class="nx">y</code><code class="p">;</code>
        <code class="kr">const</code> <code class="nx">square</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;</code>
        
        <code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>
        <code class="kd">let</code> <code class="nx">mean</code> <code class="o">=</code> <code class="nx">reduce</code><code class="p">(</code><code class="nx">data</code><code class="p">,</code> <code class="nx">sum</code><code class="p">)</code><code class="o">/</code><code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">deviations</code> <code class="o">=</code> <code class="nx">map</code><code class="p">(</code><code class="nx">data</code><code class="p">,</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">-</code><code class="nx">mean</code><code class="p">);</code>
        <code class="kd">let</code> <code class="nx">stddev</code> <code class="o">=</code> <code class="nb">Math</code><code class="p">.</code><code class="nx">sqrt</code><code class="p">(</code><code class="nx">reduce</code><code class="p">(</code><code class="nx">map</code><code class="p">(</code><code class="nx">deviations</code><code class="p">,</code> <code class="nx">square</code><code class="p">),</code> <code class="nx">sum</code><code class="p">)</code><code class="o">/</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="o">-</code><code class="mi">1</code><code class="p">));</code>
        <code class="nx">stddev</code>  <code class="c1">// =&gt; 2</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.8.2 Higher-Order Functions"><div class="sect2" id="idm46198537340552">
        <h2>8.8.2 Higher-Order Functions</h2>
        
        <p>A <em>higher-order function</em> is<a data-type="indexterm" data-primary="functions" data-secondary="functional programming" data-tertiary="higher-order functions" id="idm46198537259112"></a><a data-type="indexterm" data-primary="higher-order functions" id="idm46198537257832"></a> a function that operates on functions,
        taking one or more functions as arguments and returning a new
        function. Here is an example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This higher-order function returns a new function that passes its</code>
        <code class="c1">// arguments to f and returns the logical negation of f's return value;</code>
        <code class="kd">function</code> <code class="nx">not</code><code class="p">(</code><code class="nx">f</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>             <code class="c1">// Return a new function</code>
                <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">f</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>  <code class="c1">// that calls f</code>
                <code class="k">return</code> <code class="o">!</code><code class="nx">result</code><code class="p">;</code>                    <code class="c1">// and negates its result.</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="kr">const</code> <code class="nx">even</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">===</code> <code class="mi">0</code><code class="p">;</code> <code class="c1">// A function to determine if a number is even</code>
        <code class="kr">const</code> <code class="nx">odd</code> <code class="o">=</code> <code class="nx">not</code><code class="p">(</code><code class="nx">even</code><code class="p">);</code>         <code class="c1">// A new function that does the opposite</code>
        <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">5</code><code class="p">].</code><code class="nx">every</code><code class="p">(</code><code class="nx">odd</code><code class="p">)</code>         <code class="c1">// =&gt; true: every element of the array is odd</code></pre>
        
        <p>This <code>not()</code> function is a higher-order function because it takes a
        function argument and returns a new function. As another example, consider the
        <code>mapper()</code> function that follows. It takes a function argument and returns a new
        function that maps one array to another using that function. This function uses
        the <code>map()</code> function defined earlier, and it is important that you understand
        how the two functions are different:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Return a function that expects an array argument and applies f to</code>
        <code class="c1">// each element, returning the array of return values.</code>
        <code class="c1">// Contrast this with the map() function from earlier.</code>
        <code class="kd">function</code> <code class="nx">mapper</code><code class="p">(</code><code class="nx">f</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="nx">a</code> <code class="o">=&gt;</code> <code class="nx">map</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code> <code class="nx">f</code><code class="p">);</code>
        <code class="p">}</code>
        
        <code class="kr">const</code> <code class="nx">increment</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">+</code><code class="mi">1</code><code class="p">;</code>
        <code class="kr">const</code> <code class="nx">incrementAll</code> <code class="o">=</code> <code class="nx">mapper</code><code class="p">(</code><code class="nx">increment</code><code class="p">);</code>
        <code class="nx">incrementAll</code><code class="p">([</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">])</code>  <code class="c1">// =&gt; [2,3,4]</code></pre>
        
        <p>Here is another, more general, example that takes two functions, <code>f</code> and <code>g</code>, and
        returns a new function that computes <code>f(g())</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Return a new function that computes f(g(...)).</code>
        <code class="c1">// The returned function h passes all of its arguments to g, then passes</code>
        <code class="c1">// the return value of g to f, then returns the return value of f.</code>
        <code class="c1">// Both f and g are invoked with the same this value as h was invoked with.</code>
        <code class="kd">function</code> <code class="nx">compose</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="nx">g</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// We use call for f because we're passing a single value and</code>
                <code class="c1">// apply for g because we're passing an array of values.</code>
                <code class="k">return</code> <code class="nx">f</code><code class="p">.</code><code class="nx">call</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">g</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">));</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="kr">const</code> <code class="nx">sum</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">+</code><code class="nx">y</code><code class="p">;</code>
        <code class="kr">const</code> <code class="nx">square</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">x</code><code class="p">;</code>
        <code class="nx">compose</code><code class="p">(</code><code class="nx">square</code><code class="p">,</code> <code class="nx">sum</code><code class="p">)(</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code>  <code class="c1">// =&gt; 25; the square of the sum</code></pre>
        
        <p>The <code>partial()</code> and <code>memoize()</code> functions defined in the sections that follow
        are two more important higher-order functions.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.8.3 Partial Application of Functions"><div class="sect2" id="idm46198536946536">
        <h2>8.8.3 Partial Application of Functions</h2>
        
        <p>The<a data-type="indexterm" data-primary="functions" data-secondary="functional programming" data-tertiary="partial application of functions" id="idm46198536945096"></a><a data-type="indexterm" data-primary="bind() method" id="idm46198536943848"></a> <code>bind()</code> method of a function <code>f</code> (see <a data-type="xref" href="#bind">§8.7.5</a>) returns a new function that
        invokes <code>f</code> in a specified context and with a specified set of arguments. We
        say that it binds the function to an object and partially applies the
        arguments. The <code>bind()</code> method partially applies arguments on the left—that is,
        the arguments you pass to <code>bind()</code> are placed at the start of the argument list
        that is passed to the original function. But it is also possible to partially
        apply arguments on the right:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// The arguments to this function are passed on the left</code>
        <code class="kd">function</code> <code class="nx">partialLeft</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="p">...</code><code class="nx">outerArgs</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">innerArgs</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// Return this function</code>
                <code class="kd">let</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">outerArgs</code><code class="p">,</code> <code class="p">...</code><code class="nx">innerArgs</code><code class="p">];</code> <code class="c1">// Build the argument list</code>
                <code class="k">return</code> <code class="nx">f</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>              <code class="c1">// Then invoke f with it</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="c1">// The arguments to this function are passed on the right</code>
        <code class="kd">function</code> <code class="nx">partialRight</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="p">...</code><code class="nx">outerArgs</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">innerArgs</code><code class="p">)</code> <code class="p">{</code>  <code class="c1">// Return this function</code>
                <code class="kd">let</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">innerArgs</code><code class="p">,</code> <code class="p">...</code><code class="nx">outerArgs</code><code class="p">];</code> <code class="c1">// Build the argument list</code>
                <code class="k">return</code> <code class="nx">f</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>              <code class="c1">// Then invoke f with it</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="c1">// The arguments to this function serve as a template. Undefined values</code>
        <code class="c1">// in the argument list are filled in with values from the inner set.</code>
        <code class="kd">function</code> <code class="nx">partial</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="p">...</code><code class="nx">outerArgs</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">innerArgs</code><code class="p">)</code> <code class="p">{</code>
                <code class="kd">let</code> <code class="nx">args</code> <code class="o">=</code> <code class="p">[...</code><code class="nx">outerArgs</code><code class="p">];</code> <code class="c1">// local copy of outer args template</code>
                <code class="kd">let</code> <code class="nx">innerIndex</code><code class="o">=</code><code class="mi">0</code><code class="p">;</code>          <code class="c1">// which inner arg is next</code>
                <code class="c1">// Loop through the args, filling in undefined values from inner args</code>
                <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">args</code><code class="p">.</code><code class="nx">length</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">)</code> <code class="p">{</code>
                    <code class="k">if</code> <code class="p">(</code><code class="nx">args</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">===</code> <code class="kc">undefined</code><code class="p">)</code> <code class="nx">args</code><code class="p">[</code><code class="nx">i</code><code class="p">]</code> <code class="o">=</code> <code class="nx">innerArgs</code><code class="p">[</code><code class="nx">innerIndex</code><code class="o">++</code><code class="p">];</code>
                <code class="p">}</code>
                <code class="c1">// Now append any remaining inner arguments</code>
                <code class="nx">args</code><code class="p">.</code><code class="nx">push</code><code class="p">(...</code><code class="nx">innerArgs</code><code class="p">.</code><code class="nx">slice</code><code class="p">(</code><code class="nx">innerIndex</code><code class="p">));</code>
                <code class="k">return</code> <code class="nx">f</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
            <code class="p">};</code>
        <code class="p">}</code>
        
        <code class="c1">// Here is a function with three arguments</code>
        <code class="kr">const</code> <code class="nx">f</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">,</code><code class="nx">z</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="p">(</code><code class="nx">y</code> <code class="o">-</code> <code class="nx">z</code><code class="p">);</code> <code class="p">};</code>
        <code class="c1">// Notice how these three partial applications differ</code>
        <code class="nx">partialLeft</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="mi">2</code><code class="p">)(</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">)</code>         <code class="c1">// =&gt; -2: Bind first argument: 2 * (3 - 4)</code>
        <code class="nx">partialRight</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="mi">2</code><code class="p">)(</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">)</code>        <code class="c1">// =&gt;  6: Bind last argument: 3 * (4 - 2)</code>
        <code class="nx">partial</code><code class="p">(</code><code class="nx">f</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">,</code> <code class="mi">2</code><code class="p">)(</code><code class="mi">3</code><code class="p">,</code><code class="mi">4</code><code class="p">)</code>  <code class="c1">// =&gt; -6: Bind middle argument: 3 * (2 - 4)</code></pre>
        
        <p>These partial application functions allow us to easily define interesting
        functions out of functions we already have defined. Here are some examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">increment</code> <code class="o">=</code> <code class="nx">partialLeft</code><code class="p">(</code><code class="nx">sum</code><code class="p">,</code> <code class="mi">1</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">cuberoot</code> <code class="o">=</code> <code class="nx">partialRight</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">,</code> <code class="mi">1</code><code class="o">/</code><code class="mi">3</code><code class="p">);</code>
        <code class="nx">cuberoot</code><code class="p">(</code><code class="nx">increment</code><code class="p">(</code><code class="mi">26</code><code class="p">))</code>  <code class="c1">// =&gt; 3</code></pre>
        
        <p>Partial application becomes even more interesting when we combine it with other
        higher-order functions. Here, for example, is a way to define the preceding <code>not()</code>
        function just shown using composition and partial application:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">not</code> <code class="o">=</code> <code class="nx">partialLeft</code><code class="p">(</code><code class="nx">compose</code><code class="p">,</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="o">!</code><code class="nx">x</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">even</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=&gt;</code> <code class="nx">x</code> <code class="o">%</code> <code class="mi">2</code> <code class="o">===</code> <code class="mi">0</code><code class="p">;</code>
        <code class="kr">const</code> <code class="nx">odd</code> <code class="o">=</code> <code class="nx">not</code><code class="p">(</code><code class="nx">even</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">isNumber</code> <code class="o">=</code> <code class="nx">not</code><code class="p">(</code><code class="nb">isNaN</code><code class="p">);</code>
        <code class="nx">odd</code><code class="p">(</code><code class="mi">3</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="nx">isNumber</code><code class="p">(</code><code class="mi">2</code><code class="p">)</code>  <code class="c1">// =&gt; true</code></pre>
        
        <p>We can also use composition and partial application to redo our mean and
        standard deviation calculations in extreme functional style:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// sum() and square() functions are defined above. Here are some more:</code>
        <code class="kr">const</code> <code class="nx">product</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">)</code> <code class="o">=&gt;</code> <code class="nx">x</code><code class="o">*</code><code class="nx">y</code><code class="p">;</code>
        <code class="kr">const</code> <code class="nx">neg</code> <code class="o">=</code> <code class="nx">partial</code><code class="p">(</code><code class="nx">product</code><code class="p">,</code> <code class="o">-</code><code class="mi">1</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">sqrt</code> <code class="o">=</code> <code class="nx">partial</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">,</code> <code class="p">.</code><code class="mi">5</code><code class="p">);</code>
        <code class="kr">const</code> <code class="nx">reciprocal</code> <code class="o">=</code> <code class="nx">partial</code><code class="p">(</code><code class="nb">Math</code><code class="p">.</code><code class="nx">pow</code><code class="p">,</code> <code class="kc">undefined</code><code class="p">,</code> <code class="nx">neg</code><code class="p">(</code><code class="mi">1</code><code class="p">));</code>
        
        <code class="c1">// Now compute the mean and standard deviation.</code>
        <code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">1</code><code class="p">,</code><code class="mi">3</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">5</code><code class="p">];</code>   <code class="c1">// Our data</code>
        <code class="kd">let</code> <code class="nx">mean</code> <code class="o">=</code> <code class="nx">product</code><code class="p">(</code><code class="nx">reduce</code><code class="p">(</code><code class="nx">data</code><code class="p">,</code> <code class="nx">sum</code><code class="p">),</code> <code class="nx">reciprocal</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">));</code>
        <code class="kd">let</code> <code class="nx">stddev</code> <code class="o">=</code> <code class="nx">sqrt</code><code class="p">(</code><code class="nx">product</code><code class="p">(</code><code class="nx">reduce</code><code class="p">(</code><code class="nx">map</code><code class="p">(</code><code class="nx">data</code><code class="p">,</code>
                                             <code class="nx">compose</code><code class="p">(</code><code class="nx">square</code><code class="p">,</code>
                                                     <code class="nx">partial</code><code class="p">(</code><code class="nx">sum</code><code class="p">,</code> <code class="nx">neg</code><code class="p">(</code><code class="nx">mean</code><code class="p">)))),</code>
                                         <code class="nx">sum</code><code class="p">),</code>
                                  <code class="nx">reciprocal</code><code class="p">(</code><code class="nx">sum</code><code class="p">(</code><code class="nx">data</code><code class="p">.</code><code class="nx">length</code><code class="p">,</code><code class="nx">neg</code><code class="p">(</code><code class="mi">1</code><code class="p">)))));</code>
        <code class="p">[</code><code class="nx">mean</code><code class="p">,</code> <code class="nx">stddev</code><code class="p">]</code>  <code class="c1">// =&gt; [3, 2]</code></pre>
        
        <p>Notice that this code to compute mean and standard deviation is
        entirely function invocations; there are no operators involved, and
        the number of parentheses has grown so large that this JavaScript is
        beginning to look like Lisp code. Again, this is not a style that I
        advocate for JavaScript programming, but it is an interesting exercise
        to see how deeply functional JavaScript code can be.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="8.8.4 Memoization"><div class="sect2" id="idm46198536945944">
        <h2>8.8.4 Memoization</h2>
        
        <p>In <a data-type="xref" href="#yourownfunctionprops">§8.4.1</a>, we defined<a data-type="indexterm" data-primary="functions" data-secondary="functional programming" data-tertiary="memoization" id="idm46198536289512"></a><a data-type="indexterm" data-primary="memoization" id="idm46198536288264"></a> a factorial function that cached its
        previously computed results. In functional programming, this kind of caching is
        called <em>memoization</em>. The code that follows shows a higher-order function, <code>memoize()</code>,
        that accepts a function as its argument and returns a memoized version of the
        function:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Return a memoized version of f.</code>
        <code class="c1">// It only works if arguments to f all have distinct string representations.</code>
        <code class="kd">function</code> <code class="nx">memoize</code><code class="p">(</code><code class="nx">f</code><code class="p">)</code> <code class="p">{</code>
            <code class="kr">const</code> <code class="nx">cache</code> <code class="o">=</code> <code class="k">new</code> <code class="nx">Map</code><code class="p">();</code>  <code class="c1">// Value cache stored in the closure.</code>
        
            <code class="k">return</code> <code class="kd">function</code><code class="p">(...</code><code class="nx">args</code><code class="p">)</code> <code class="p">{</code>
                <code class="c1">// Create a string version of the arguments to use as a cache key.</code>
                <code class="kd">let</code> <code class="nx">key</code> <code class="o">=</code> <code class="nx">args</code><code class="p">.</code><code class="nx">length</code> <code class="o">+</code> <code class="nx">args</code><code class="p">.</code><code class="nx">join</code><code class="p">(</code><code class="s2">"+"</code><code class="p">);</code>
                <code class="k">if</code> <code class="p">(</code><code class="nx">cache</code><code class="p">.</code><code class="nx">has</code><code class="p">(</code><code class="nx">key</code><code class="p">))</code> <code class="p">{</code>
                    <code class="k">return</code> <code class="nx">cache</code><code class="p">.</code><code class="nx">get</code><code class="p">(</code><code class="nx">key</code><code class="p">);</code>
                <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
                    <code class="kd">let</code> <code class="nx">result</code> <code class="o">=</code> <code class="nx">f</code><code class="p">.</code><code class="nx">apply</code><code class="p">(</code><code class="k">this</code><code class="p">,</code> <code class="nx">args</code><code class="p">);</code>
                    <code class="nx">cache</code><code class="p">.</code><code class="nx">set</code><code class="p">(</code><code class="nx">key</code><code class="p">,</code> <code class="nx">result</code><code class="p">);</code>
                    <code class="k">return</code> <code class="nx">result</code><code class="p">;</code>
                <code class="p">}</code>
            <code class="p">};</code>
        <code class="p">}</code></pre>
        
        <p>The <code>memoize()</code> function creates a new object to use as the cache and assigns
        this object to a local variable so that it is private to (in the closure of)
        the returned function. The returned function converts its arguments array to a
        string and uses that string as a property name for the cache object. If a
        value exists in the cache, it returns it directly. Otherwise, it calls the
        specified function to compute the value for these arguments, caches that value,
        and returns it. Here is how we might use <code>memoize()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Return the Greatest Common Divisor of two integers using the Euclidian</code>
        <code class="c1">// algorithm: http://en.wikipedia.org/wiki/Euclidean_algorithm</code>
        <code class="kd">function</code> <code class="nx">gcd</code><code class="p">(</code><code class="nx">a</code><code class="p">,</code><code class="nx">b</code><code class="p">)</code> <code class="p">{</code>  <code class="c1">// Type checking for a and b has been omitted</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">&lt;</code> <code class="nx">b</code><code class="p">)</code> <code class="p">{</code>           <code class="c1">// Ensure that a &gt;= b when we start</code>
                <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">b</code><code class="p">,</code> <code class="nx">a</code><code class="p">];</code>   <code class="c1">// Destructuring assignment to swap variables</code>
            <code class="p">}</code>
            <code class="k">while</code><code class="p">(</code><code class="nx">b</code> <code class="o">!==</code> <code class="mi">0</code><code class="p">)</code> <code class="p">{</code>       <code class="c1">// This is Euclid's algorithm for GCD</code>
                <code class="p">[</code><code class="nx">a</code><code class="p">,</code> <code class="nx">b</code><code class="p">]</code> <code class="o">=</code> <code class="p">[</code><code class="nx">b</code><code class="p">,</code> <code class="nx">a</code><code class="o">%</code><code class="nx">b</code><code class="p">];</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">a</code><code class="p">;</code>
        <code class="p">}</code>
        
        <code class="kr">const</code> <code class="nx">gcdmemo</code> <code class="o">=</code> <code class="nx">memoize</code><code class="p">(</code><code class="nx">gcd</code><code class="p">);</code>
        <code class="nx">gcdmemo</code><code class="p">(</code><code class="mi">85</code><code class="p">,</code> <code class="mi">187</code><code class="p">)</code>  <code class="c1">// =&gt; 17</code>
        
        <code class="c1">// Note that when we write a recursive function that we will be memoizing,</code>
        <code class="c1">// we typically want to recurse to the memoized version, not the original.</code>
        <code class="kr">const</code> <code class="nx">factorial</code> <code class="o">=</code> <code class="nx">memoize</code><code class="p">(</code><code class="kd">function</code><code class="p">(</code><code class="nx">n</code><code class="p">)</code> <code class="p">{</code>
            <code class="k">return</code> <code class="p">(</code><code class="nx">n</code> <code class="o">&lt;=</code> <code class="mi">1</code><code class="p">)</code> <code class="o">?</code> <code class="mi">1</code> <code class="o">:</code> <code class="nx">n</code> <code class="o">*</code> <code class="nx">factorial</code><code class="p">(</code><code class="nx">n</code><code class="o">-</code><code class="mi">1</code><code class="p">);</code>
        <code class="p">});</code>
        <code class="nx">factorial</code><code class="p">(</code><code class="mi">5</code><code class="p">)</code>      <code class="c1">// =&gt; 120: also caches values for 4, 3, 2 and 1.</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="8.9 Summary"><div class="sect1" id="idm46198536241432">
        <h1>8.9 Summary</h1>
        
        <p>Some key points to remember about this chapter are as follows:</p>
        
        <ul>
        <li>
        <p>You can define functions with the <code>function</code> keyword and with the ES6
        <code>=&gt;</code> arrow syntax.</p>
        </li>
        <li>
        <p>You can invoke functions, which can be used as methods and
        constructors.</p>
        </li>
        <li>
        <p>Some ES6 features allow you to define default values for
        optional function parameters, to gather multiple arguments into an
        array using a rest parameter, and to destructure object and array
        arguments into function parameters.</p>
        </li>
        <li>
        <p>You can use the <code>...</code> spread operator to pass the elements of an
        array or other iterable object as arguments in a function
        invocation.</p>
        </li>
        <li>
        <p>A function defined inside of and returned by an enclosing
        function retains access to its lexical scope and can therefore read
        and write the variables defined inside the outer function. Functions
        used in this way are called <em>closures</em>, and this is a technique that is
        worth understanding.</p>
        </li>
        <li>
        <p>Functions are objects that can be manipulated by JavaScript,
        and this enables a functional style of programming.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        <div data-type="footnotes"><p data-type="footnote" id="idm46198542019096"><sup><a href="ch08.html#idm46198542019096-marker">1</a></sup> The term was coined by Martin Fowler. See <a href="http://martinfowler.com/dslCatalog/methodChaining.html"><em class="hyperlink">http://martinfowler.com/dslCatalog/methodChaining.html</em></a>.</p><p data-type="footnote" id="idm46198541553560"><sup><a href="ch08.html#idm46198541553560-marker">2</a></sup> If you are familiar with Python, note that this is different than Python, in which every invocation shares the same default value.</p><p data-type="footnote" id="idm46198540105128"><sup><a href="ch08.html#idm46198540105128-marker">3</a></sup> This may not seem like a particularly interesting point unless you are familiar with more static languages, in which functions are part of a program but cannot be manipulated by the program.</p></div></div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->