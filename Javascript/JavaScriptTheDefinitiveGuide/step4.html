<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
</style>
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 4. Expressions and Operators"><div class="chapter" id="expressions">
        <h1><span class="label">Chapter 4. </span>Expressions and Operators</h1>
        
        
        <p>This<a data-type="indexterm" data-primary="expressions" data-secondary="forming with operators" id="idm46198577121848"></a> chapter documents JavaScript expressions and the operators with which many of those expressions are built. An<a data-type="indexterm" data-primary="expressions" data-secondary="definition of term" id="idm46198577120584"></a> <em>expression</em> is a phrase
        of JavaScript that can be <em>evaluated</em> to produce a value. A constant
        embedded literally in your program is a very simple kind of
        expression. A variable name is also a simple expression that evaluates
        to whatever value has been assigned to that variable. Complex
        expressions are built from simpler expressions.  An array access
        expression, for example, consists of one expression that evaluates to
        an array followed by an open square bracket, an expression that
        evaluates to an integer, and a close square bracket.  This new, more
        complex expression evaluates to the value stored at the specified
        index of the specified array. Similarly, a function invocation
        expression consists of one expression that evaluates to a function
        object and zero or more additional expressions that are used as the
        arguments to the function.</p>
        
        <p>The<a data-type="indexterm" data-primary="operators" data-secondary="forming expressions with" id="idm46198577117240"></a> most common way to build a complex expression out of simpler
        expressions is with an <em>operator</em>. An operator combines the values of
        its operands (usually two of them) in some way and evaluates to a new
        value. The<a data-type="indexterm" data-primary="* (multiplication operator)" id="idm46198577115624"></a><a data-type="indexterm" data-primary="multiplication operator (*)" id="idm46198577114952"></a> multiplication operator <code>*</code> is a simple example. The
        expression <code>x * y</code> evaluates to the product of the values of the
        expressions <code>x</code> and <code>y</code>. For simplicity, we sometimes say that an
        operator <em>returns</em> a value rather than “evaluates to” a value.</p>
        
        <p>This chapter documents all of JavaScript’s operators, and it also
        explains expressions (such as array indexing and function invocation)
        that do not use operators. If you already know another programming
        language that uses C-style syntax, you’ll find that the syntax of most
        of JavaScript’s expressions and operators is already familiar to you.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.1 Primary Expressions"><div class="sect1" id="primaryexpressions">
        <h1>4.1 Primary Expressions</h1>
        
        <p>The<a data-type="indexterm" data-primary="expressions" data-secondary="primary expressions" id="idm46198577109256"></a><a data-type="indexterm" data-primary="primary expressions" id="idm46198577108248"></a> simplest expressions, known as <em>primary expressions</em>, are those that
        stand alone—they do not include any simpler expressions. Primary
        expressions in JavaScript are constant or <em>literal</em> values, certain
        language keywords, and variable references.</p>
        
        <p>Literals are constant values that are embedded directly in your
        program. They look like these:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mf">1.23</code>         <code class="c1">// A number literal</code>
        <code class="s2">"hello"</code>      <code class="c1">// A string literal</code>
        <code class="sr">/pattern/</code>    <code class="c1">// A regular expression literal</code></pre>
        
        <p>JavaScript syntax for number literals was covered in <a data-type="xref" href="ch03.html#numbers">§3.2</a>.
        String literals were documented in <a data-type="xref" href="ch03.html#text">§3.3</a>. The regular expression
        literal syntax was introduced in <a data-type="xref" href="ch03.html#regexpintro">§3.3.5</a> and will be documented
        in detail in <a data-type="xref" href="ch11.html#regexps">§11.3</a>.</p>
        
        <p>Some<a data-type="indexterm" data-primary="identifiers" data-secondary="reserved words" id="idm46198577098104"></a><a data-type="indexterm" data-primary="keywords" data-secondary="reserved words" id="idm46198577097096"></a><a data-type="indexterm" data-primary="lexical structure" data-secondary="reserved words" id="idm46198577096152"></a><a data-type="indexterm" data-primary="reserved words" id="idm46198577095208"></a><a data-type="indexterm" data-primary="syntax" data-secondary="lexical structure" data-tertiary="reserved words" id="idm46198577094536"></a> of JavaScript’s reserved words are primary expressions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kc">true</code>       <code class="c1">// Evalutes to the boolean true value</code>
        <code class="kc">false</code>      <code class="c1">// Evaluates to the boolean false value</code>
        <code class="kc">null</code>       <code class="c1">// Evaluates to the null value</code>
        <code class="k">this</code>       <code class="c1">// Evaluates to the "current" object</code></pre>
        
        <p>We learned about <code>true</code>, <code>false</code>, and <code>null</code> in <a data-type="xref" href="ch03.html#booleans">§3.4</a> and
        <a data-type="xref" href="ch03.html#nullundefined">§3.5</a>. Unlike<a data-type="indexterm" data-primary="this keyword" id="idm46198577088520"></a><a data-type="indexterm" data-primary="keywords" data-secondary="this keyword" id="idm46198577087816"></a> the other keywords, <code>this</code> is not a
        constant—it evaluates to different values in different places in the
        program. The <code>this</code> keyword is used in object-oriented programming.
        Within the body of a method, <code>this</code> evaluates to the object on which
        the method was invoked. See <a data-type="xref" href="#invocationexprs">§4.5</a>, <a data-type="xref" href="ch08.html#functions">Chapter&nbsp;8</a>
        (especially <a data-type="xref" href="ch08.html#methodinvocation">§8.2.2</a>), and <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a> for more on <code>this</code>.</p>
        
        <p>Finally, the third type of primary expression is a reference to a
        variable, constant, or property of the global object:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">i</code>             <code class="c1">// Evaluates to the value of the variable i.</code>
        <code class="nx">sum</code>           <code class="c1">// Evaluates to the value of the variable sum.</code>
        <code class="kc">undefined</code>     <code class="c1">// The value of the "undefined" property of the global object</code></pre>
        
        <p>When any identifier appears by itself in a program, JavaScript assumes
        it is a variable or constant or property of the global object and
        looks up its value. If no variable with that name exists, an attempt
        to evaluate a nonexistent variable throws a ReferenceError instead.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.2 Object and Array Initializers"><div class="sect1" id="initializerexprs">
        <h1>4.2 Object and Array Initializers</h1>
        
        <p><em>Object</em> and <em>array initializers</em> are<a data-type="indexterm" data-primary="initializer expression" id="idm46198577009416"></a><a data-type="indexterm" data-primary="arrays" data-secondary="initializer expressions" id="idm46198577008680"></a><a data-type="indexterm" data-primary="expressions" data-secondary="initializer expression" id="idm46198577007736"></a><a data-type="indexterm" data-primary="expressions" data-secondary="object and array initializers" id="idm46198577006792"></a><a data-type="indexterm" data-primary="object literals" data-secondary="overview of" id="idm46198576983944"></a><a data-type="indexterm" data-primary="array literals" id="idm46198576983000"></a> expressions whose value is a newly
        created object or array. These initializer expressions are sometimes
        called <em>object literals</em> and <em>array literals</em>. Unlike true
        literals, however, they are not primary expressions, because they
        include a number of subexpressions that specify property and element
        values. Array initializers have a slightly simpler syntax, and we’ll
        begin with those.</p>
        
        <p>An<a data-type="indexterm" data-primary="[] (square brackets)" id="idm46198576980696"></a><a data-type="indexterm" data-primary="square brackets ([])" id="idm46198576979960"></a> array initializer is a comma-separated list of expressions contained
        within square brackets. The value of an array initializer is a newly
        created array. The elements of this new array are initialized to the
        values of the comma-separated expressions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">[]</code>         <code class="c1">// An empty array: no expressions inside brackets means no elements</code>
        <code class="p">[</code><code class="mi">1</code><code class="o">+</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="o">+</code><code class="mi">4</code><code class="p">]</code>  <code class="c1">// A 2-element array.  First element is 3, second is 7</code></pre>
        
        <p>The<a data-type="indexterm" data-primary="arrays" data-secondary="nested" id="idm46198576976616"></a> element expressions in an array initializer can themselves be array
        initializers, which means that these expressions can create nested
        arrays:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">matrix</code> <code class="o">=</code> <code class="p">[[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">],</code> <code class="p">[</code><code class="mi">4</code><code class="p">,</code><code class="mi">5</code><code class="p">,</code><code class="mi">6</code><code class="p">],</code> <code class="p">[</code><code class="mi">7</code><code class="p">,</code><code class="mi">8</code><code class="p">,</code><code class="mi">9</code><code class="p">]];</code></pre>
        
        <p>The element expressions in an array initializer are evaluated each time
        the array initializer is evaluated. This means that the value of an
        array initializer expression may be different each time it is evaluated.</p>
        
        <p>Undefined elements can be included in an array literal by simply
        omitting a value between commas. For example, the following array
        contains five elements, including three undefined elements:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">sparseArray</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,,,,</code><code class="mi">5</code><code class="p">];</code></pre>
        
        <p>A single trailing comma is allowed after the last expression in an
        array initializer and does not create an undefined element. However,
        any array access expression for an index after that of the last
        expression will necessarily evaluate to undefined.</p>
        
        <p>Object<a data-type="indexterm" data-primary="{} (curly braces)" id="idm46198576837976"></a><a data-type="indexterm" data-primary="curly braces ({})" id="idm46198576837336"></a> initializer expressions are like array initializer expressions,
        but the square brackets are replaced by curly brackets, and each
        subexpression is prefixed with a property name and a colon:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mf">2.3</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="o">-</code><code class="mf">1.2</code> <code class="p">};</code>  <code class="c1">// An object with 2 properties</code>
        <code class="kd">let</code> <code class="nx">q</code> <code class="o">=</code> <code class="p">{};</code>                   <code class="c1">// An empty object with no properties</code>
        <code class="nx">q</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mf">2.3</code><code class="p">;</code> <code class="nx">q</code><code class="p">.</code><code class="nx">y</code> <code class="o">=</code> <code class="o">-</code><code class="mf">1.2</code><code class="p">;</code>        <code class="c1">// Now q has the same properties as p</code></pre>
        
        <p>In ES6, object literals have a much more feature-rich syntax (you can find details in <a data-type="xref" href="ch06.html#extended-object-literal-syntax">§6.10</a>). Object literals can be nested. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">rectangle</code> <code class="o">=</code> <code class="p">{</code>
            <code class="nx">upperLeft</code><code class="o">:</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">2</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code> <code class="p">},</code>
            <code class="nx">lowerRight</code><code class="o">:</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">4</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">5</code> <code class="p">}</code>
        <code class="p">};</code></pre>
        
        <p>We’ll see object and array initializers again in Chapters <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch06.html#objects">6</a> and <a data-type="xref" data-xrefstyle="select:labelnumber" href="ch07.html#arrays">7</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.3 Function Definition Expressions"><div class="sect1" id="functionexprs">
        <h1>4.3 Function Definition Expressions</h1>
        
        <p>A<a data-type="indexterm" data-primary="expressions" data-secondary="function definition expressions" id="idm46198576773064"></a><a data-type="indexterm" data-primary="functions" data-secondary="function definition expressions" id="idm46198576772088"></a> <em>function definition expression</em> defines a JavaScript function, and the
        value of such an expression is the newly defined function. In a sense,
        a function definition expression is a “function literal” in the same
        way that an object initializer is an “object literal.” A function
        definition expression typically consists of the keyword <code>function</code>
        followed by a comma-separated list of zero or more identifiers (the
        parameter names) in <span class="keep-together">parentheses</span> and a block of JavaScript code (the
        function body) in curly braces. For <span class="keep-together">example:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// This function returns the square of the value passed to it.</code>
        <code class="kd">let</code> <code class="nx">square</code> <code class="o">=</code> <code class="kd">function</code><code class="p">(</code><code class="nx">x</code><code class="p">)</code> <code class="p">{</code> <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code> <code class="p">};</code></pre>
        
        <p>A function definition expression can also include a name for the
        function. Functions can also be defined using a function statement
        rather than a function expression. And in ES6 and later, function
        expressions can use a compact new “arrow function” syntax. Complete
        details on function definition are in <a data-type="xref" href="ch08.html#functions">Chapter&nbsp;8</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.4 Property Access Expressions"><div class="sect1" id="propertyexprs">
        <h1>4.4 Property Access Expressions</h1>
        
        <p>A<a data-type="indexterm" data-primary="expressions" data-secondary="property access expressions" id="Eprop04"></a><a data-type="indexterm" data-primary="properties" data-secondary="property access expressions" id="idm46198576694952"></a> <em>property access expression</em> evaluates to the value of an object
        property or an array element. JavaScript defines two syntaxes for
        property access:</p>
        <pre id="I_programlisting3_d1e5432" data-type="programlisting" data-code-language="js"><em><code>expression</code></em> . <em>identifier</em>
        <em>expression</em> [ <em>expression</em> ]</pre>
        
        <p>The first style of property access is an expression followed by a
        period and an identifier. The expression specifies the object, and the
        identifier specifies the name of the desired property. The second style
        of property access follows the first expression (the object or array)
        with another expression in square brackets. This second expression
        specifies the name of the desired property or the index of the desired
        array element. Here are some concrete examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="p">{</code><code class="nx">z</code><code class="o">:</code> <code class="mi">3</code><code class="p">}};</code> <code class="c1">// An example object</code>
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="nx">o</code><code class="p">,</code> <code class="mi">4</code><code class="p">,</code> <code class="p">[</code><code class="mi">5</code><code class="p">,</code> <code class="mi">6</code><code class="p">]];</code>    <code class="c1">// An example array that contains the object</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code>                        <code class="c1">// =&gt; 1: property x of expression o</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">y</code><code class="p">.</code><code class="nx">z</code>                      <code class="c1">// =&gt; 3: property z of expression o.y</code>
        <code class="nx">o</code><code class="p">[</code><code class="s2">"x"</code><code class="p">]</code>                     <code class="c1">// =&gt; 1: property x of object o</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">1</code><code class="p">]</code>                       <code class="c1">// =&gt; 4: element at index 1 of expression a</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">2</code><code class="p">][</code><code class="s2">"1"</code><code class="p">]</code>                  <code class="c1">// =&gt; 6: element at index 1 of expression a[2]</code>
        <code class="nx">a</code><code class="p">[</code><code class="mi">0</code><code class="p">].</code><code class="nx">x</code>                     <code class="c1">// =&gt; 1: property x of expression a[0]</code></pre>
        
        <p>With either type of property access expression, the expression before
        the <code>.</code> or <code>[</code> is first evaluated. If the value is <code>null</code> or <code>undefined</code>,
        the expression throws a TypeError, since these are the two JavaScript
        values that cannot have properties. If the object
        expression is followed by a dot and an identifier, the value of the
        property named by that identifier is looked up and becomes the overall
        value of the expression. If the object expression is followed by
        another expression in square brackets, that second expression is
        evaluated and converted to a string. The overall value of the
        expression is then the value of the property named by that string. In
        either case, if the named property does not exist, then the value of
        the property access expression is <code>undefined</code>.</p>
        
        <p>The <em>.identifier</em> syntax is the simpler of the two property access
        options, but notice that it can only be used when the property you
        want to access has a name that is a legal identifier, and when you
        know the name when you write the program. If the property name
        includes spaces or punctuation characters, or when it is a number (for
        arrays), you must use the square bracket notation. Square brackets are
        also used when the property name is not static but is itself the
        result of a computation (see <a data-type="xref" href="ch06.html#associativearrays">§6.3.1</a> for an example).</p>
        
        <p>Objects and their properties are covered in detail in <a data-type="xref" href="ch06.html#objects">Chapter&nbsp;6</a>, and
        arrays and their elements are covered in <a data-type="xref" href="ch07.html#arrays">Chapter&nbsp;7</a>.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.4.1 Conditional Property Access"><div class="sect2" id="conditionalpropertyaccess">
        <h2>4.4.1 Conditional Property Access</h2>
        
        <p>ES2020<a data-type="indexterm" data-primary="properties" data-secondary="conditional property access" id="idm46198576595160"></a><a data-type="indexterm" data-primary="ES2020" data-secondary="property access expressions" id="idm46198576594088"></a> adds two new kinds of property access expressions:</p>
        <pre data-type="programlisting" data-code-language="js"><em><code>expression</code></em> ?. <em>identifier</em>
        <em>expression</em> ?.[ <em>expression</em> ]</pre>
        
        <p>In JavaScript, the values <code>null</code> and <code>undefined</code> are the only two
        values that do not have properties. In a regular property access
        expression using <code>.</code> or <code>[]</code>, you get a TypeError if the expression on
        the left evaluates to <code>null</code> or <code>undefined</code>. You can use <code>?.</code>
        and <code>?.[]</code> syntax to guard against errors of this type.</p>
        
        <p>Consider the expression <code>a?.b</code>. If <code>a</code> is <code>null</code> or <code>undefined</code>, then
        the expression evaluates to <code>undefined</code> without any attempt to access
        the property <code>b</code>. If <code>a</code> is some other value, then <code>a?.b</code> evaluates
        to whatever <code>a.b</code> would evaluate to (and if <code>a</code> does not have a property
        named <code>b</code>, then the value will again be <code>undefined</code>).</p>
        
        <p>This form of property access expression is sometimes called “optional
        chaining” because it also works for longer “chained” property access
        expressions like this one:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">b</code><code class="o">:</code> <code class="kc">null</code> <code class="p">};</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">b</code><code class="o">?</code><code class="p">.</code><code class="nx">c</code><code class="p">.</code><code class="nx">d</code>   <code class="c1">// =&gt; undefined</code></pre>
        
        <p><code>a</code> is an object, so <code>a.b</code> is a valid property access expression. But
        the value of <code>a.b</code> is <code>null</code>, so <code>a.b.c</code> would throw a TypeError. By
        using <code>?.</code> instead of <code>.</code> we avoid the TypeError, and <code>a.b?.c</code>
        evaluates to <code>undefined</code>. This means that <code>(a.b?.c).d</code> will throw a
        TypeError, because that expression attempts to access a property of
        the value <code>undefined</code>. But—and this is a very important part of
        “optional chaining”—<code>a.b?.c.d</code> (without the parentheses) simply
        evaluates to <code>undefined</code> and does not throw an error. This is because
        property access with <code>?.</code> is “short-circuiting”: if the subexpression
        to the left of <code>?.</code> evaluates to <code>null</code> or <code>undefined</code>, then the
        entire expression immediately evaluates to <code>undefined</code> without any
        further property access attempts.</p>
        
        <p>Of course, if <code>a.b</code> is an object, and if that object has no property
        named <code>c</code>, then <code>a.b?.c.d</code> will again throw a TypeError, and we will want to use another conditional property access:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">b</code><code class="o">:</code> <code class="p">{}</code> <code class="p">};</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">b</code><code class="o">?</code><code class="p">.</code><code class="nx">c</code><code class="o">?</code><code class="p">.</code><code class="nx">d</code>  <code class="c1">// =&gt; undefined</code></pre>
        
        <p>Conditional property access is also possible using <code>?.[]</code> instead of
        <code>[]</code>.  In the expression <code>a?.[b][c]</code>, if the value of <code>a</code> is <code>null</code> or
        <code>undefined</code>, then the entire expression immediately evaluates to
        <code>undefined</code>, and subexpressions <code>b</code> and <code>c</code> are never even
        evaluated. If either of those expressions has side effects, the side
        effect will not occur if <code>a</code> is not defined:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">a</code><code class="p">;</code>          <code class="c1">// Oops, we forgot to initialize this variable!</code>
        <code class="kd">let</code> <code class="nx">index</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="k">try</code> <code class="p">{</code>
            <code class="nx">a</code><code class="p">[</code><code class="nx">index</code><code class="o">++</code><code class="p">];</code> <code class="c1">// Throws TypeError</code>
        <code class="p">}</code> <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">index</code>       <code class="c1">// =&gt; 1: increment occurs before TypeError is thrown</code>
        <code class="p">}</code>
        <code class="nx">a</code><code class="o">?</code><code class="p">.[</code><code class="nx">index</code><code class="o">++</code><code class="p">]</code>    <code class="c1">// =&gt; undefined: because a is undefined</code>
        <code class="nx">index</code>           <code class="c1">// =&gt; 1: not incremented because ?.[] short-circuits</code>
        <code class="nx">a</code><code class="p">[</code><code class="nx">index</code><code class="o">++</code><code class="p">]</code>      <code class="c1">// !TypeError: can't index undefined.</code></pre>
        
        <p>Conditional property access with <code>?.</code> and <code>?.[]</code> is one of the newest
        features of JavaScript. As of early 2020, this new syntax is supported in
        the current or beta versions of most major browsers.<a data-type="indexterm" data-primary="" data-startref="Eprop04" id="idm46198576389304"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.5 Invocation Expressions"><div class="sect1" id="invocationexprs">
        <h1>4.5 Invocation Expressions</h1>
        
        <p>An <em>invocation expression</em> is<a data-type="indexterm" data-primary="expressions" data-secondary="invocation expressions" id="Einvocation04"></a> JavaScript’s syntax for calling (or
        executing) a function or method. It starts with a function expression
        that identifies the function to be called. The function expression is
        followed by an open parenthesis, a comma-separated list of zero or more
        argument expressions, and a close parenthesis. Some examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">f</code><code class="p">(</code><code class="mi">0</code><code class="p">)</code>            <code class="c1">// f is the function expression; 0 is the argument expression.</code>
        <code class="nb">Math</code><code class="p">.</code><code class="nx">max</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code><code class="nx">y</code><code class="p">,</code><code class="nx">z</code><code class="p">)</code> <code class="c1">// Math.max is the function; x, y, and z are the arguments.</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">sort</code><code class="p">()</code>        <code class="c1">// a.sort is the function; there are no arguments.</code></pre>
        
        <p>When an invocation expression is evaluated, the function expression is
        evaluated first, and then the argument expressions are evaluated to
        produce a list of argument values. If the value of the function
        expression is not a function, a TypeError is thrown. Next, the argument
        values are assigned, in order, to the parameter names specified when
        the function was defined, and then the body of the function is
        executed. If the function uses a <code>return</code> statement to return a value,
        then that value becomes the value of the invocation expression.
        Otherwise, the value of the invocation expression is <code>undefined</code>.
        Complete details on function invocation, including an explanation of
        what happens when the number of argument expressions does not match the
        number of parameters in the function definition, are in <a data-type="xref" href="ch08.html#functions">Chapter&nbsp;8</a>.</p>
        
        <p>Every<a data-type="indexterm" data-primary="invocation expressions" data-secondary="method invocation" id="idm46198576315048"></a><a data-type="indexterm" data-primary="methods" data-secondary="method invocation" id="idm46198576362360"></a> invocation expression includes a pair of parentheses and an
        expression before the open parenthesis. If that expression is a
        property access expression, then the invocation is known as a <em>method
        invocation</em>. In method invocations, the object or array that is the
        subject of the property access becomes the value of the <code>this</code> keyword
        while the body of the function is being executed. This enables an
        object-oriented programming paradigm in which functions (which we call
        “methods” when used this way) operate on the object of which they
        are part. See <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a> for details.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.5.1 Conditional Invocation"><div class="sect2" id="conditionalinvocation">
        <h2>4.5.1 Conditional Invocation</h2>
        
        <p>In ES2020, you<a data-type="indexterm" data-primary="ES2020" data-secondary="conditional invocation" id="idm46198576356952"></a><a data-type="indexterm" data-primary="invocation expressions" data-secondary="conditional invocation" id="idm46198576355560"></a><a data-type="indexterm" data-primary="conditional invocation" id="idm46198576354616"></a> can also invoke a function using <code>?.()</code> instead of
        <code>()</code>. Normally when you invoke a function, if the expression to the
        left of the parentheses is <code>null</code> or <code>undefined</code> or any other
        non-function, a TypeError is thrown. With the new <code>?.()</code> invocation
        syntax, if the expression to the left of the <code>?.</code> evaluates to <code>null</code>
        or <code>undefined</code>, then the entire invocation expression evaluates to
        <code>undefined</code> and no exception is thrown.</p>
        
        <p>Array<a data-type="indexterm" data-primary="sort() method" id="idm46198576377928"></a> objects have a <code>sort()</code> method that can optionally be passed a
        function argument that defines the desired sorting order for the array
        elements. Before ES2020, if you wanted to write a method like <code>sort()</code>
        that takes an optional function argument, you would typically use an
        <code>if</code> statement to check that the function argument was defined before
        invoking it in the body of the <code>if</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">log</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// The second argument is an optional function</code>
            <code class="k">if</code> <code class="p">(</code><code class="nx">log</code><code class="p">)</code> <code class="p">{</code>            <code class="c1">// If the optional function is passed</code>
                <code class="nx">log</code><code class="p">(</code><code class="nx">x</code><code class="p">);</code>           <code class="c1">// Invoke it</code>
            <code class="p">}</code>
            <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code>         <code class="c1">// Return the square of the argument</code>
        <code class="p">}</code></pre>
        
        <p>With this conditional invocation syntax of ES2020, however, you can
        simply write the function invocation using <code>?.()</code>, knowing that
        invocation will only happen if there is actually a value to be
        invoked:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">function</code> <code class="nx">square</code><code class="p">(</code><code class="nx">x</code><code class="p">,</code> <code class="nx">log</code><code class="p">)</code> <code class="p">{</code> <code class="c1">// The second argument is an optional function</code>
            <code class="nx">log</code><code class="o">?</code><code class="p">.(</code><code class="nx">x</code><code class="p">);</code>             <code class="c1">// Call the function if there is one</code>
            <code class="k">return</code> <code class="nx">x</code> <code class="o">*</code> <code class="nx">x</code><code class="p">;</code>         <code class="c1">// Return the square of the argument</code>
        <code class="p">}</code></pre>
        
        <p>Note, however, that <code>?.()</code> only checks whether the lefthand side is
        <code>null</code> or <code>undefined</code>. It does not verify that the value is actually a
        function. So the <code>square()</code> function in this example would still throw an
        exception if you passed two numbers to it, for example.</p>
        
        <p>Like conditional property access expressions
        (<a data-type="xref" href="#conditionalpropertyaccess">§4.4.1</a>), function invocation with <code>?.()</code> is
        short-circuiting: if the value to the left of <code>?.</code> is <code>null</code> or
        <code>undefined</code>, then none of the argument expressions within the
        parentheses are evaluated:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">f</code> <code class="o">=</code> <code class="kc">null</code><code class="p">,</code> <code class="nx">x</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="k">try</code> <code class="p">{</code>
            <code class="nx">f</code><code class="p">(</code><code class="nx">x</code><code class="o">++</code><code class="p">);</code> <code class="c1">// Throws TypeError because f is null</code>
        <code class="p">}</code> <code class="k">catch</code><code class="p">(</code><code class="nx">e</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">x</code>       <code class="c1">// =&gt; 1: x gets incremented before the exception is thrown</code>
        <code class="p">}</code>
        <code class="nx">f</code><code class="o">?</code><code class="p">.(</code><code class="nx">x</code><code class="o">++</code><code class="p">)</code>    <code class="c1">// =&gt; undefined: f is null, but no exception thrown</code>
        <code class="nx">x</code>           <code class="c1">// =&gt; 1: increment is skipped because of short-circuiting</code></pre>
        
        <p>Conditional invocation expressions with <code>?.()</code> work just as well for
        methods as they do for functions. But because method invocation also
        involves property access, it is worth taking a moment to be sure you
        understand the differences between the following expressions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">o</code><code class="p">.</code><code class="nx">m</code><code class="p">()</code>     <code class="c1">// Regular property access, regular invocation</code>
        <code class="nx">o</code><code class="o">?</code><code class="p">.</code><code class="nx">m</code><code class="p">()</code>    <code class="c1">// Conditional property access, regular invocation</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">m</code><code class="o">?</code><code class="p">.()</code>   <code class="c1">// Regular property access, conditional invocation</code></pre>
        
        <p>In the first expression, <code>o</code> must be an object with a property <code>m</code> and
        the value of that property must be a function. In the second
        expression, if <code>o</code> is <code>null</code> or <code>undefined</code>, then the expression
        evaluates to <code>undefined</code>. But if <code>o</code> has any other value, then it must
        have a property <code>m</code> whose value is a function. And in the third
        expression, <code>o</code> must not be <code>null</code> or <code>undefined</code>. If it does not have
        a property <code>m</code>, or if the value of that property is <code>null</code>, then the
        entire expression evaluates to <code>undefined</code>.</p>
        
        <p>Conditional invocation with <code>?.()</code> is one of the newest features of
        JavaScript. As of the first months of 2020, this new syntax is supported in the current
        or beta versions of most major browsers.<a data-type="indexterm" data-primary="" data-startref="Einvocation04" id="idm46198576075832"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.6 Object Creation Expressions"><div class="sect1" id="newexprs">
        <h1>4.6 Object Creation Expressions</h1>
        
        <p>An <em>object creation expression</em> creates<a data-type="indexterm" data-primary="objects" data-secondary="object creation expressions" id="idm46198576130952"></a><a data-type="indexterm" data-primary="expressions" data-secondary="object creation expressions" id="idm46198576129912"></a> a new object and invokes a
        function (called a constructor) to initialize the properties of that
        object. Object creation expressions are like invocation expressions
        except that they are prefixed with the keyword <code>new</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">new</code> <code class="nb">Object</code><code class="p">()</code>
        <code class="k">new</code> <code class="nx">Point</code><code class="p">(</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">)</code></pre>
        
        <p>If no arguments are passed to the constructor function in an object
        creation expression, the empty pair of parentheses can be omitted:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">new</code> <code class="nb">Object</code>
        <code class="k">new</code> <code class="nb">Date</code></pre>
        
        <p>The value of an object creation expression is the newly created object.
        Constructors are explained in more detail in <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.7 Operator Overview"><div class="sect1" id="I_sect13_d1e5618">
        <h1>4.7 Operator Overview</h1>
        
        <p>Operators<a data-type="indexterm" data-primary="operators" data-secondary="overview of" id="idm46198576041288"></a> are used for JavaScript’s arithmetic expressions, comparison
        expressions, logical expressions, assignment expressions, and more.
        <a data-type="xref" href="#operators">Table&nbsp;4-1</a> summarizes the operators and serves as a convenient
        reference.</p>
        
        <p>Note that most operators are represented by punctuation characters such
        as <code>+</code> and <code>=</code>. Some, however, are represented by keywords such
        as <code>delete</code> and <code>instanceof</code>. Keyword operators are regular operators,
        just like those expressed with punctuation; they simply have a less
        succinct syntax.</p>
        
        <p><a data-type="xref" href="#operators">Table&nbsp;4-1</a> is organized by operator precedence. The operators
        listed first have higher precedence than those listed last. Operators
        separated by a horizontal line have different precedence levels. The
        column labeled A gives the operator associativity, which can be L
        (left-to-right) or R (right-to-left), and the column N specifies the
        number of operands. The column labeled Types lists the expected types
        of the operands and (after the → symbol) the result type for the
        operator. The subsections that follow the table explain the concepts
        of precedence, associativity, and operand type. The<a data-type="indexterm" data-primary="operators" data-secondary="table of" id="idm46198576051304"></a> operators
        themselves are individually documented following that discussion.</p>
        <table id="operators">
        <caption><span class="label">Table 4-1. </span>JavaScript operators</caption>
        <thead>
        <tr>
        <th>Operator</th>
        <th>Operation</th>
        <th>A</th>
        <th>N</th>
        <th>Types</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p><code>++</code></p></td>
        <td><p>Pre- or post-increment</p></td>
        <td><p>R</p></td>
        <td><p>1</p></td>
        <td><p>lval→num</p></td>
        </tr>
        <tr>
        <td><p><code>--</code></p></td>
        <td><p>Pre- or post-decrement</p></td>
        <td><p>R</p></td>
        <td><p>1</p></td>
        <td><p>lval→num</p></td>
        </tr>
        <tr>
        <td><p><code>-</code></p></td>
        <td><p>Negate number</p></td>
        <td><p>R</p></td>
        <td><p>1</p></td>
        <td><p>num→num</p></td>
        </tr>
        <tr>
        <td><p><code>+</code></p></td>
        <td><p>Convert to number</p></td>
        <td><p>R</p></td>
        <td><p>1</p></td>
        <td><p>any→num</p></td>
        </tr>
        <tr>
        <td><p><code>~</code></p></td>
        <td><p>Invert bits</p></td>
        <td><p>R</p></td>
        <td><p>1</p></td>
        <td><p>int→int</p></td>
        </tr>
        <tr>
        <td><p><code>!</code></p></td>
        <td><p>Invert boolean value</p></td>
        <td><p>R</p></td>
        <td><p>1</p></td>
        <td><p>bool→bool</p></td>
        </tr>
        <tr>
        <td><p><code>delete</code></p></td>
        <td><p>Remove a property</p></td>
        <td><p>R</p></td>
        <td><p>1</p></td>
        <td><p>lval→bool</p></td>
        </tr>
        <tr>
        <td><p><code>typeof</code></p></td>
        <td><p>Determine type of operand</p></td>
        <td><p>R</p></td>
        <td><p>1</p></td>
        <td><p>any→str</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>void</code></p></td>
        <td><p>Return undefined value</p></td>
        <td><p>R</p></td>
        <td><p>1</p></td>
        <td><p>any→undef</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>**</code></p></td>
        <td><p>Exponentiate</p></td>
        <td><p>R</p></td>
        <td><p>2</p></td>
        <td><p>num,num→num</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>*</code>, <code>/</code>, <code>%</code></p></td>
        <td><p>Multiply, divide, remainder</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>num,num→num</p></td>
        </tr>
        <tr>
        <td><p><code>+</code>, <code>-</code></p></td>
        <td><p>Add, subtract</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>num,num→num</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>+</code></p></td>
        <td><p>Concatenate strings</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>str,str→str</p></td>
        </tr>
        <tr>
        <td><p><code>&lt;&lt;</code></p></td>
        <td><p>Shift left</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>int,int→int</p></td>
        </tr>
        <tr>
        <td><p><code>&gt;&gt;</code></p></td>
        <td><p>Shift right with sign extension</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>int,int→int</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>&gt;&gt;&gt;</code></p></td>
        <td><p>Shift right with zero extension</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>int,int→int</p></td>
        </tr>
        <tr>
        <td><p><code>&lt;</code>, <code>&lt;=</code>,<code>&gt;</code>, <code>&gt;=</code></p></td>
        <td><p>Compare in numeric order</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>num,num→bool</p></td>
        </tr>
        <tr>
        <td><p><code>&lt;</code>, <code>&lt;=</code>,<code>&gt;</code>, <code>&gt;=</code></p></td>
        <td><p>Compare in alphabetical order</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>str,str→bool</p></td>
        </tr>
        <tr>
        <td><p><code>instanceof</code></p></td>
        <td><p>Test object class</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>obj,func→bool</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>in</code></p></td>
        <td><p>Test whether property exists</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>any,obj→bool</p></td>
        </tr>
        <tr>
        <td><p><code>==</code></p></td>
        <td><p>Test for non-strict equality</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>any,any→bool</p></td>
        </tr>
        <tr>
        <td><p><code>!=</code></p></td>
        <td><p>Test for non-strict inequality</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>any,any→bool</p></td>
        </tr>
        <tr>
        <td><p><code>===</code></p></td>
        <td><p>Test for strict equality</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>any,any→bool</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>!==</code></p></td>
        <td><p>Test for strict inequality</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>any,any→bool</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>&amp;</code></p></td>
        <td><p>Compute bitwise AND</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>int,int→int</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>^</code></p></td>
        <td><p>Compute bitwise XOR</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>int,int→int</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>|</code></p></td>
        <td><p>Compute bitwise OR</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>int,int→int</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>&amp;&amp;</code></p></td>
        <td><p>Compute logical AND</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>any,any→any</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>||</code></p></td>
        <td><p>Compute logical OR</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>any,any→any</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>??</code></p></td>
        <td><p>Choose 1st defined operand</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>any,any→any</p></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>?:</code></p></td>
        <td><p>Choose 2nd or 3rd operand</p></td>
        <td><p>R</p></td>
        <td><p>3</p></td>
        <td><p>bool,any,any→any</p></td>
        </tr>
        <tr>
        <td><p><code>=</code></p></td>
        <td><p>Assign to a variable or property</p></td>
        <td><p>R</p></td>
        <td><p>2</p></td>
        <td><p>lval,any→any</p></td>
        </tr>
        <tr>
        <td><p><code>**=</code>, <code>*=</code>, <code>/=</code>, <code>%=</code>,</p></td>
        <td><p>Operate and assign</p></td>
        <td><p>R</p></td>
        <td><p>2</p></td>
        <td><p>lval,any→any</p></td>
        </tr>
        <tr>
        <td><p><code>+=</code>, <code>-=</code>, <code>&amp;=</code>, <code>^=</code>, <code>|=</code>,</p></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        </tr>
        <tr class="tablerule">
        <td><p><code>&lt;&lt;=</code>, <code>&gt;&gt;=</code>, <code>&gt;&gt;&gt;=</code></p></td>
        <td></td>
        <td></td>
        <td></td>
        <td></td>
        </tr>
        <tr>
        <td><p><code>,</code></p></td>
        <td><p>Discard 1st operand, return 2nd</p></td>
        <td><p>L</p></td>
        <td><p>2</p></td>
        <td><p>any,any→any</p></td>
        </tr>
        </tbody>
        </table>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.7.1 Number of Operands"><div class="sect2" id="idm46198576016744">
        <h2>4.7.1 Number of Operands</h2>
        
        <p>Operators<a data-type="indexterm" data-primary="operators" data-secondary="number of operands" id="idm46198575863048"></a> can be categorized based on the number of operands they
        expect (their <em>arity</em>). Most<a data-type="indexterm" data-primary="operators" data-secondary="binary operators" id="idm46198575861176"></a><a data-type="indexterm" data-primary="binary operators" id="idm46198575860168"></a> JavaScript operators, like the <code>*</code>
        multiplication operator, are <em>binary operators</em> that combine two
        expressions into a single, more complex expression. That is, they
        expect two operands. JavaScript<a data-type="indexterm" data-primary="unary operators" data-secondary="JavaScript support for" id="idm46198575858440"></a> also supports a number of <em>unary
        operators</em>, which convert a single expression into a single, more
        complex expression. The <code>−</code> operator in the expression <code>−x</code> is a unary
        operator that performs the operation of negation on the operand <code>x</code>.
        Finally, JavaScript<a data-type="indexterm" data-primary="ternary operators" id="idm46198575855608"></a><a data-type="indexterm" data-primary="operators" data-secondary="ternary operators" id="idm46198575854872"></a> supports one <em>ternary operator</em>, the conditional
        operator <code>?:</code>, which combines three expressions into a single
        expression.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.7.2 Operand and Result Type"><div class="sect2" id="idm46198575852920">
        <h2>4.7.2 Operand and Result Type</h2>
        
        <p>Some<a data-type="indexterm" data-primary="operators" data-secondary="operand and result type" id="idm46198575851352"></a> operators work on values of any type, but most expect their
        operands to be of a specific type, and most operators return (or
        evaluate to) a value of a specific type. The Types column in
        <a data-type="xref" href="#operators">Table&nbsp;4-1</a> specifies operand types (before the arrow) and result
        type (after the arrow) for the operators.</p>
        
        <p>JavaScript operators usually convert the type (see <a data-type="xref" href="ch03.html#conversions">§3.9</a>) of
        their operands as needed. The multiplication operator <code>*</code> expects
        numeric operands, but the expression <code>"3" * "5"</code> is legal because
        JavaScript can convert the operands to numbers. The value of this
        expression is the number 15, not the string “15”, of course. Remember
        also that every JavaScript value is either “truthy” or “falsy,” so
        operators that expect boolean operands will work with an operand of any
        type.</p>
        
        <p>Some operators behave differently depending on the type of the operands
        used with them. Most notably, the <code>+</code> operator adds numeric
        operands but concatenates string operands. Similarly, the comparison
        operators such as <code>&lt;</code> perform comparison in numerical or alphabetical
        order depending on the type of the operands. The descriptions of
        individual operators explain their type-dependencies and specify what
        type conversions they perform.</p>
        
        <p>Notice<a data-type="indexterm" data-primary="lvalue" id="idm46198575844552"></a> that the assignment operators and a few of the other operators
        listed in <a data-type="xref" href="#operators">Table&nbsp;4-1</a> expect an operand of type <code>lval</code>. <em>lvalue</em> is
        a historical term that means “an expression that can legally appear on
        the left side of an assignment expression.” In JavaScript, variables,
        properties of objects, and elements of arrays are lvalues.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.7.3 Operator Side Effects"><div class="sect2" id="idm46198575841656">
        <h2>4.7.3 Operator Side Effects</h2>
        
        <p>Evaluating<a data-type="indexterm" data-primary="operators" data-secondary="operator side effects" id="idm46198575840104"></a><a data-type="indexterm" data-primary="side effects" id="idm46198575839096"></a> a simple expression like <code>2 * 3</code> never affects the
        state of your program, and any future computation your program performs
        will be unaffected by that evaluation. Some expressions, however, have
        <em>side effects</em>, and their evaluation may affect the result of future
        evaluations. The assignment operators are the most obvious example: if
        you assign a value to a variable or property, that changes the value of
        any expression that uses that variable or property. The <code>++</code> and
        <code>--</code> increment and decrement operators are similar, since they perform
        an implicit assignment. The <code>delete</code> operator also has side effects:
        deleting a property is like (but not the same as) assigning <span class="keep-together"><code>undefined</code></span>
        to the property.</p>
        
        <p>No other JavaScript operators have side effects, but function
        invocation and object creation expressions will have side effects if
        any of the operators used in the function or constructor body have side
        effects.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.7.4 Operator Precedence"><div class="sect2" id="idm46198575833928">
        <h2>4.7.4 Operator Precedence</h2>
        
        <p>The<a data-type="indexterm" data-primary="operators" data-secondary="operator precedence" id="idm46198575832200"></a> operators listed in <a data-type="xref" href="#operators">Table&nbsp;4-1</a> are arranged in order from high
        precedence to low precedence, with horizontal lines separating groups
        of operators at the same precedence level. Operator precedence controls
        the order in which operations are performed. Operators with higher
        precedence (nearer the top of the table) are performed before those
        with lower precedence (nearer to the bottom).</p>
        
        <p>Consider the following expression:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">w</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="o">*</code><code class="nx">z</code><code class="p">;</code></pre>
        
        <p>The multiplication operator <code>*</code> has a higher precedence than the
        addition operator <code>+</code>, so the multiplication is performed before
        the addition. Furthermore, the assignment operator <code>=</code> has the lowest
        precedence, so the assignment is performed after all the operations on
        the right side are completed.</p>
        
        <p>Operator precedence can be overridden with the explicit use of
        parentheses. To force the addition in the previous example to be
        performed first, write:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">w</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code> <code class="o">+</code> <code class="nx">y</code><code class="p">)</code><code class="o">*</code><code class="nx">z</code><code class="p">;</code></pre>
        
        <p>Note that property access and invocation expressions have higher
        precedence than any of the operators listed in <a data-type="xref" href="#operators">Table&nbsp;4-1</a>. Consider
        this expression:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// my is an object with a property named functions whose value is an</code>
        <code class="c1">// array of functions. We invoke function number x, passing it argument</code>
        <code class="c1">// y, and then we ask for the type of the value returned.</code>
        <code class="k">typeof</code> <code class="nx">my</code><code class="p">.</code><code class="nx">functions</code><code class="p">[</code><code class="nx">x</code><code class="p">](</code><code class="nx">y</code><code class="p">)</code></pre>
        
        <p>Although <code>typeof</code> is one of the highest-priority operators, the
        <code>typeof</code> operation is performed on the result of the property
        access, array index, and function invocation, all of which have higher
        priority than operators.</p>
        
        <p>In practice, if you are at all unsure about the precedence of your
        operators, the simplest thing to do is to use parentheses to make the
        evaluation order explicit. The rules that are important to know are
        these: multiplication and division are performed before addition and
        subtraction, and assignment has very low precedence and is almost
        always performed last.</p>
        
        <p>When new operators are added to JavaScript, they do not always fit
        naturally into this precedence scheme. The <code>??</code> operator
        (<a data-type="xref" href="#firstdefined">§4.13.2</a>) is shown in the table as lower-precedence than <code>||</code>
        and <code>&amp;&amp;</code>, but, in fact, its precedence relative to those operators is
        not defined, and ES2020<a data-type="indexterm" data-primary="ES2020" data-secondary="operator precedence" id="idm46198575775624"></a> requires you to explicitly use parentheses if
        you mix <code>??</code> with either <code>||</code> or <code>&amp;&amp;</code>. Similarly, the new <code>**</code>
        exponentiation operator does not have a well-defined precedence
        relative to the unary negation operator, and you must use parentheses
        when combining negation with exponentiation.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.7.5 Operator Associativity"><div class="sect2" id="idm46198575833304">
        <h2>4.7.5 Operator Associativity</h2>
        
        <p>In <a data-type="xref" href="#operators">Table&nbsp;4-1</a>, the<a data-type="indexterm" data-primary="operators" data-secondary="operator associativity" id="idm46198575741304"></a><a data-type="indexterm" data-primary="associativity" id="idm46198575740328"></a> column labeled A specifies the <em>associativity</em> of
        the operator. A value of L specifies left-to-right associativity, and a
        value of R specifies right-to-left associativity. The associativity of
        an operator specifies the order in which operations of the same
        precedence are performed. Left-to-right associativity means that
        operations are performed from left to right. For example, the
        subtraction operator has left-to-right associativity, so:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">w</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">-</code> <code class="nx">y</code> <code class="o">-</code> <code class="nx">z</code><code class="p">;</code></pre>
        
        <p>is the same as:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">w</code> <code class="o">=</code> <code class="p">((</code><code class="nx">x</code> <code class="o">-</code> <code class="nx">y</code><code class="p">)</code> <code class="o">-</code> <code class="nx">z</code><code class="p">);</code></pre>
        
        <p>On the other hand, the following expressions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">y</code> <code class="o">=</code> <code class="nx">a</code> <code class="o">**</code> <code class="nx">b</code> <code class="o">**</code> <code class="nx">c</code><code class="p">;</code>
        <code class="nx">x</code> <code class="o">=</code> <code class="o">~-</code><code class="nx">y</code><code class="p">;</code>
        <code class="nx">w</code> <code class="o">=</code> <code class="nx">x</code> <code class="o">=</code> <code class="nx">y</code> <code class="o">=</code> <code class="nx">z</code><code class="p">;</code>
        <code class="nx">q</code> <code class="o">=</code> <code class="nx">a</code><code class="o">?</code><code class="nx">b</code><code class="o">:</code><code class="nx">c</code><code class="o">?</code><code class="nx">d</code><code class="o">:</code><code class="nx">e</code><code class="o">?</code><code class="nx">f</code><code class="o">:</code><code class="nx">g</code><code class="p">;</code></pre>
        
        <p>are equivalent to:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">y</code> <code class="o">=</code> <code class="p">(</code><code class="nx">a</code> <code class="o">**</code> <code class="p">(</code><code class="nx">b</code> <code class="o">**</code> <code class="nx">c</code><code class="p">));</code>
        <code class="nx">x</code> <code class="o">=</code> <code class="o">~</code><code class="p">(</code><code class="o">-</code><code class="nx">y</code><code class="p">);</code>
        <code class="nx">w</code> <code class="o">=</code> <code class="p">(</code><code class="nx">x</code> <code class="o">=</code> <code class="p">(</code><code class="nx">y</code> <code class="o">=</code> <code class="nx">z</code><code class="p">));</code>
        <code class="nx">q</code> <code class="o">=</code> <code class="nx">a</code><code class="o">?</code><code class="nx">b</code><code class="o">:</code><code class="p">(</code><code class="nx">c</code><code class="o">?</code><code class="nx">d</code><code class="o">:</code><code class="p">(</code><code class="nx">e</code><code class="o">?</code><code class="nx">f</code><code class="o">:</code><code class="nx">g</code><code class="p">));</code></pre>
        
        <p>because the exponentiation, unary, assignment, and ternary conditional
        operators have right-to-left associativity.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.7.6 Order of Evaluation"><div class="sect2" id="idm46198575772200">
        <h2>4.7.6 Order of Evaluation</h2>
        
        <p>Operator<a data-type="indexterm" data-primary="operators" data-secondary="order of evaluation" id="idm46198575529368"></a> precedence and associativity specify the order in which
        operations are performed in a complex expression, but they do not
        specify the order in which the subexpressions are evaluated. JavaScript
        always evaluates expressions in strictly left-to-right order. In the
        expression <code>w = x + y * z</code>, for example, the subexpression <code>w</code> is
        evaluated first, followed by <code>x</code>, <code>y</code>, and <code>z</code>. Then the values of <code>y</code>
        and <code>z</code> are multiplied, added to the value of <code>x</code>, and assigned to the
        variable or property specified by expression <code>w</code>. Adding parentheses to
        the expressions can change the relative order of the multiplication,
        addition, and assignment, but not the left-to-right order of evaluation.</p>
        
        <p>Order of evaluation only makes a difference if any of the expressions
        being evaluated has side effects that affect the value of another
        expression. If expression <code>x</code> increments a variable that is used by
        expression <code>z</code>, then the fact that <code>x</code> is evaluated before <code>z</code> is
        important.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.8 Arithmetic Expressions"><div class="sect1" id="arithmeticoperators">
        <h1>4.8 Arithmetic Expressions</h1>
        
        <p>This<a data-type="indexterm" data-primary="operators" data-secondary="arithmetic operators" id="Oarith04"></a><a data-type="indexterm" data-primary="arithmetic operators" id="aritho04"></a><a data-type="indexterm" data-primary="expressions" data-secondary="arithmetic expressions" id="Earith04"></a> section covers the operators that perform arithmetic or other
        numerical manipulations on their operands. The exponentiation, multiplication,
        division, and subtraction operators are straightforward and are
        covered first. The addition operator gets a subsection of its own
        because it can also perform string concatenation and has some unusual
        type conversion rules. The unary operators and the bitwise operators
        are also covered in subsections of their own.</p>
        
        <p>Most of these arithmetic operators (except as noted as follows) can be used
        with BigInt (see <a data-type="xref" href="ch03.html#bigint">§3.2.5</a>) operands or with regular numbers, as long
        as you don’t mix the two types.</p>
        
        <p>The<a data-type="indexterm" data-primary="** (exponentiation operator)" id="idm46198575513688"></a><a data-type="indexterm" data-primary="exponentiation operator (**)" id="idm46198575512632"></a><a data-type="indexterm" data-primary="* (multiplication operator)" id="idm46198575511992"></a><a data-type="indexterm" data-primary="multiplication operator (*)" id="idm46198575511352"></a><a data-type="indexterm" data-primary="/ (division operator)" id="idm46198575510712"></a><a data-type="indexterm" data-primary="division operator (/)" id="idm46198575510040"></a><a data-type="indexterm" data-primary="% (modulo operator)" id="idm46198575509368"></a><a data-type="indexterm" data-primary="modulo operator (%)" id="idm46198575508696"></a><a data-type="indexterm" data-primary="minus sign (-)" data-secondary="subtraction operator" id="idm46198575508024"></a><a data-type="indexterm" data-primary="- (minus sign)" data-secondary="subtraction operator" id="idm46198575507080"></a><a data-type="indexterm" data-primary="" id="idm46198575506136"></a> basic arithmetic operators are <code>**</code> (exponentiation), <code>*</code>
        (multiplication), <code>/</code> (division), <code>%</code> (modulo: remainder after
        division), <code>+</code> (addition), and <code>-</code> (subtraction). As noted,
        we’ll discuss the <code>+</code> operator in a section of its
        own. The other five basic operators simply evaluate their operands,
        convert the values to numbers if necessary, and then compute the
        power, product, quotient, remainder, or difference. Non-numeric
        operands that cannot convert to numbers convert to
        the <code>NaN</code> value. If either operand is (or converts to) <code>NaN</code>, the
        result of the operation is (almost always) <code>NaN</code>.</p>
        
        <p>The <code>**</code> operator has higher precedence than <code>*</code>, <code>/</code>, and <code>%</code> (which
        in turn have higher precedence than <code>+</code> and <code>-</code>). Unlike the other
        operators, <code>**</code> works right-to-left, so <code>2**2**3</code> is the same as
        <code>2**8</code>, not <code>4**3</code>. There is a natural ambiguity to expressions like
        <code>-3**2</code>. Depending on the relative precedence of unary minus and
        exponentiation, that expression could mean <code>(-3)**2</code> or
        <code>-(3**2)</code>. Different languages handle this differently, and rather
        than pick sides, JavaScript simply makes it a syntax error to omit
        parentheses in this case, forcing you to write an unambiguous
        expression. <code>**</code> is<a data-type="indexterm" data-primary="ES2016" data-secondary="exponentiation operator (**)" id="idm46198575493704"></a> <span class="keep-together">JavaScript’s</span> newest arithmetic operator: it was
        added to the language with ES2016. The<a data-type="indexterm" data-primary="Math.pow function" id="idm46198575491864"></a> <code>Math.pow()</code> function
        has been available since the earliest versions of JavaScript, however,
        and it performs exactly the same operation as the <code>**</code> operator.</p>
        
        <p>The <code>/</code> operator divides its first operand by its second. If you
        are used to programming languages that distinguish between integer and
        floating-point numbers, you might expect to get an integer result when
        you divide one integer by another. In JavaScript, however, all numbers
        are floating-point, so all division operations have floating-point
        results: <code>5/2</code> evaluates to <code>2.5</code>, not <code>2</code>. Division by zero
        yields positive or negative infinity, while <code>0/0</code> evaluates to
        <code>NaN</code>: neither of these cases raises an error.</p>
        
        <p>The <code>%</code> operator computes the first operand modulo the second operand.
        In other words, it returns the remainder after whole-number division of
        the first operand by the second operand. The sign of the result is the
        same as the sign of the first operand. For example, <code>5 % 2</code> evaluates
        to <code>1</code>, and <code>-5 % 2</code> evaluates to <code>-1</code>.</p>
        
        <p>While the modulo operator is typically used with integer operands, it
        also works for floating-point values. For example, <code>6.5 % 2.1</code>
        evaluates to <code>0.2</code>.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.8.1 The + Operator"><div class="sect2" id="plusoperator">
        <h2>4.8.1 The + Operator</h2>
        
        <p>The<a data-type="indexterm" data-primary="+ (plus sign)" data-secondary="addition operator" id="idm46198575461720"></a><a data-type="indexterm" data-primary="plus sign (+)" data-secondary="addition operator" id="idm46198575460712"></a><a data-type="indexterm" data-primary="+ (plus sign)" data-secondary="string concatenation" id="idm46198575459768"></a><a data-type="indexterm" data-primary="plus sign (+)" data-secondary="string concatenation" id="idm46198575458824"></a><a data-type="indexterm" data-primary="addition operator (+)" id="idm46198575457880"></a> binary <code>+</code> operator adds numeric operands or concatenates
        string operands:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mi">1</code> <code class="o">+</code> <code class="mi">2</code>                        <code class="c1">// =&gt; 3</code>
        <code class="s2">"hello"</code> <code class="o">+</code> <code class="s2">" "</code> <code class="o">+</code> <code class="s2">"there"</code>      <code class="c1">// =&gt; "hello there"</code>
        <code class="s2">"1"</code> <code class="o">+</code> <code class="s2">"2"</code>                    <code class="c1">// =&gt; "12"</code></pre>
        
        <p>When the values of both operands are numbers, or are both strings, then
        it is obvious what the <code>+</code> operator does. In any other case,
        however, type conversion is necessary, and the operation to be
        performed depends on the conversion performed. The conversion rules
        for <code>+</code> give priority to string concatenation: if either of the
        operands is a string or an object that converts to a string, the other
        operand is converted to a string and concatenation is performed.
        Addition is performed only if neither operand is string-like.</p>
        
        <p>Technically, the <code>+</code> operator behaves like this:</p>
        
        <ul>
        <li>
        <p>If either of its operand values is an object, it converts it to a
        primitive using the object-to-primitive algorithm described in
        <a data-type="xref" href="ch03.html#objtoprim">§3.9.3</a>. Date objects are converted by their<a data-type="indexterm" data-primary="toString() method" id="idm46198575433864"></a> <code>toString()</code> method,
        and all other objects are converted via <code>valueOf()</code>, if that method
        returns a primitive value. However, most objects do not have a useful
        <code>valueOf()</code> method, so they are converted via <code>toString()</code> as
        well.</p>
        </li>
        <li>
        <p>After object-to-primitive conversion, if either operand is a string,
        the other is converted to a string and concatenation is performed.</p>
        </li>
        <li>
        <p>Otherwise, both operands are converted to numbers (or to <code>NaN</code>) and
        addition is performed.</p>
        </li>
        </ul>
        
        <p>Here are some examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mi">1</code> <code class="o">+</code> <code class="mi">2</code>         <code class="c1">// =&gt; 3: addition</code>
        <code class="s2">"1"</code> <code class="o">+</code> <code class="s2">"2"</code>     <code class="c1">// =&gt; "12": concatenation</code>
        <code class="s2">"1"</code> <code class="o">+</code> <code class="mi">2</code>       <code class="c1">// =&gt; "12": concatenation after number-to-string</code>
        <code class="mi">1</code> <code class="o">+</code> <code class="p">{}</code>        <code class="c1">// =&gt; "1[object Object]": concatenation after object-to-string</code>
        <code class="kc">true</code> <code class="o">+</code> <code class="kc">true</code>   <code class="c1">// =&gt; 2: addition after boolean-to-number</code>
        <code class="mi">2</code> <code class="o">+</code> <code class="kc">null</code>      <code class="c1">// =&gt; 2: addition after null converts to 0</code>
        <code class="mi">2</code> <code class="o">+</code> <code class="kc">undefined</code> <code class="c1">// =&gt; NaN: addition after undefined converts to NaN</code></pre>
        
        <p>Finally, it is important to note that when the <code>+</code> operator is
        used with strings and numbers, it may not be associative. That is, the
        result may depend on the order in which operations are performed.</p>
        
        <p>For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mi">1</code> <code class="o">+</code> <code class="mi">2</code> <code class="o">+</code> <code class="s2">" blind mice"</code>    <code class="c1">// =&gt; "3 blind mice"</code>
        <code class="mi">1</code> <code class="o">+</code> <code class="p">(</code><code class="mi">2</code> <code class="o">+</code> <code class="s2">" blind mice"</code><code class="p">)</code>  <code class="c1">// =&gt; "12 blind mice"</code></pre>
        
        <p>The first line has no parentheses, and the <code>+</code> operator has
        left-to-right associativity, so the two numbers are added first, and
        their sum is concatenated with the string. In the second line,
        parentheses alter this order of operations: the number 2 is
        concatenated with the string to produce a new string. Then the number 1
        is concatenated with the new string to produce the final result.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.8.2 Unary Arithmetic Operators"><div class="sect2" id="idm46198575463096">
        <h2>4.8.2 Unary Arithmetic Operators</h2>
        
        <p>Unary<a data-type="indexterm" data-primary="unary operators" data-secondary="arithmetic operators" id="idm46198575377288"></a> operators modify the value of a single operand to produce a new
        value. In JavaScript, the unary operators all have high precedence and
        are all right-associative. The arithmetic unary operators described in
        this section (<code>+</code>, <code>-</code>, <code>++</code>, and <code>--</code>) all convert their
        single operand to a number, if necessary. Note that the punctuation
        characters <code>+</code> and <code>-</code> are used as both unary and binary
        operators.</p>
        
        <p>The unary arithmetic operators are the following:</p>
        <dl>
        <dt><em>Unary plus</em> (<code>+</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary="+ (plus sign)" data-secondary="unary arithmetic operator" id="idm46198575370328"></a><a data-type="indexterm" data-primary="plus sign (+)" data-secondary="unary arithmetic operator" id="idm46198575369352"></a> unary plus operator converts its operand to
        a number (or to <code>NaN</code>) and returns that converted value. When used
        with an operand that is already a number, it doesn’t do anything. This
        operator may not be used with BigInt values, since they cannot be
        converted to regular numbers.</p>
        </dd>
        <dt><em>Unary minus</em> (<code>-</code>)</dt>
        <dd>
        <p>When<a data-type="indexterm" data-primary="- (minus sign)" data-secondary="unary arithmetic operator" id="idm46198575365656"></a><a data-type="indexterm" data-primary="minus sign (-)" data-secondary="unary arithmetic operator" id="idm46198575364680"></a> <code>-</code> is used as a unary operator, it
        converts its operand to a number, if necessary, and then changes the
        sign of the result.</p>
        </dd>
        <dt><em>Increment</em> (<code>++</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary="increment operator (++)" id="idm46198575360760"></a><a data-type="indexterm" data-primary="++ (increment operator)" id="idm46198575360024"></a> <code>++</code> operator increments (i.e., adds 1 to)
        its single operand, which must be an lvalue (a variable, an element of
        an array, or a property of an object). The operator converts its
        operand to a number, adds 1 to that number, and assigns the
        incremented value back into the variable, element, or property.</p>
        
        <p>The return value of the <code>++</code> operator depends on its position
        relative to the operand. When used before the operand, where it is
        known as the pre-increment operator, it increments the operand and
        evaluates to the incremented value of that operand. When used after the
        operand, where it is known as the post-increment operator, it
        increments its operand but evaluates to the <em>unincremented</em> value of
        that operand. Consider the difference between these two lines of code:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">i</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">j</code> <code class="o">=</code> <code class="o">++</code><code class="nx">i</code><code class="p">;</code>    <code class="c1">// i and j are both 2</code>
        <code class="kd">let</code> <code class="nx">n</code> <code class="o">=</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">m</code> <code class="o">=</code> <code class="nx">n</code><code class="o">++</code><code class="p">;</code>    <code class="c1">// n is 2, m is 1</code></pre>
        
        <p>Note that the expression <code>x++</code> is not always the same as
        <code>x=x+1</code>. The <code>++</code> operator never performs string
        concatenation: it always converts its operand to a number and
        increments it. If <code>x</code> is the string “1”, <code>++x</code> is the number 2,
        but <code>x+1</code> is the string “11”.</p>
        
        <p>Also note that, because of JavaScript’s automatic semicolon insertion,
        you cannot insert a line break between the post-increment operator and
        the operand that precedes it. If you do so, JavaScript will treat the
        operand as a complete statement by itself and insert a semicolon before
        it.</p>
        
        <p>This operator, in both its pre- and post-increment forms, is most
        commonly used to increment a counter that controls a <code>for</code> loop
        (<a data-type="xref" href="ch05.html#forloop">§5.4.3</a>).</p>
        </dd>
        <dt><em>Decrement</em> (<code>--</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary="-- (decrement operator)" id="idm46198558210184"></a><a data-type="indexterm" data-primary="decrement operator (--)" id="idm46198558209448"></a> <code>--</code> operator expects an lvalue operand. It
        converts the value of the operand to a number, subtracts 1, and
        assigns the decremented value back to the operand. Like the <code>++</code>
        operator, the return value of <code>--</code> depends on its position relative to
        the operand. When used before the operand, it decrements and returns
        the decremented value. When used after the operand, it decrements the
        operand but returns the <em>undecremented</em> value. When used after its
        operand, no line break is allowed between the operand and the
        operator.</p>
        </dd>
        </dl>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.8.3 Bitwise Operators"><div class="sect2" id="bitwiseoperators">
        <h2>4.8.3 Bitwise Operators</h2>
        
        <p>The<a data-type="indexterm" data-primary="bitwise operators" id="idm46198558204376"></a> bitwise operators perform low-level manipulation of the bits in
        the binary representation of numbers. Although they do not perform
        traditional arithmetic operations, they are categorized as arithmetic
        operators here because they operate on numeric operands and return a
        numeric value. Four of these operators perform Boolean algebra on the
        individual bits of the operands, behaving as if each bit in each
        operand were a boolean value (1=true, 0=false). The other three
        bitwise operators are used to shift bits left and right.  These
        operators are not commonly used in JavaScript programming, and if you
        are not familiar with the binary representation of integers, including
        the two’s complement representation of negative integers, you can
        probably skip this section.</p>
        
        <p>The bitwise operators expect integer operands and behave as if those
        values were represented as 32-bit integers rather than 64-bit
        floating-point values. These operators convert their operands to
        numbers, if necessary, and then coerce the numeric values to 32-bit
        integers by dropping any fractional part and any bits beyond the 32nd.
        The shift operators require a right-side operand between 0 and 31.
        After converting this operand to an unsigned 32-bit integer, they drop
        any bits beyond the 5th, which yields a number in the appropriate
        range. Surprisingly, <code>NaN</code>, <code>Infinity</code>, and <code>-Infinity</code> all convert to
        0 when used as operands of these bitwise operators.</p>
        
        <p>All of these bitwise operators except <code>&gt;&gt;&gt;</code> can be used with regular
        number operands or with BigInt (see <a data-type="xref" href="ch03.html#bigint">§3.2.5</a>) operands.</p>
        <dl>
        <dt><em>Bitwise AND</em> (<code>&amp;</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary="&amp; (bitwise AND operator)" id="idm46198558196168"></a> <code>&amp;</code> operator performs a Boolean AND
        operation on each bit of its integer arguments. A bit is set in the
        result only if the corresponding bit is set in both operands. For
        example, <code>0x1234 &amp; 0x00FF</code> evaluates to <code>0x0034</code>.</p>
        </dd>
        <dt><em>Bitwise OR</em> (<code>|</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary="ǀ (bitwise OR operator)" id="idm46198558191784"></a> <code>|</code> operator performs a Boolean OR
        operation on each bit of its integer arguments. A bit is set in the
        result if the corresponding bit is set in one or both of the
        operands. For example, <code>0x1234 | 0x00FF</code> evaluates to <code>0x12FF</code>.</p>
        </dd>
        <dt><em>Bitwise XOR</em> (<code>^</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary="^ (bitwise XOR operator)" id="idm46198558160248"></a> <code>^</code> operator performs a Boolean exclusive
        OR operation on each bit of its integer arguments. Exclusive OR means
        that either operand one is <code>true</code> or operand two is <code>true</code>, but not
        both. A bit is set in this operation’s result if a corresponding bit
        is set in one (but not both) of the two operands. For example, <code>0xFF00
        ^ 0xF0F0</code> evaluates to <code>0x0FF0</code>.</p>
        </dd>
        <dt><em>Bitwise NOT</em> (<code>~</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary="~ (bitwise NOT operator)" id="idm46198558154776"></a> <code>~</code> operator is a unary operator that
        appears before its single integer operand. It operates by reversing
        all bits in the operand. Because of the way signed integers are
        represented in JavaScript, applying the <code>~</code> operator to a value is
        equivalent to changing its sign and subtracting 1. For example, <code>~0x0F</code>
        evaluates to <code>0xFFFFFFF0</code>, or −16.</p>
        </dd>
        <dt><em>Shift left</em> (<code>&lt;&lt;</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary="shift left operator (<<)" id="idm46198558149736"></a><a data-type="indexterm" data-primary="<< (shift left operator)" id="idm46198558149064"></a> <code>&lt;&lt;</code> operator moves all bits in its first
        operand to the left by the number of places specified in the second
        operand, which should be an integer between 0 and 31. For example, in
        the operation <code>a &lt;&lt; 1</code>, the first bit (the ones bit) of <code>a</code> becomes
        the second bit (the twos bit), the second bit of <code>a</code> becomes the
        third, etc. A zero is used for the new first bit, and the value of the
        32nd bit is lost. Shifting a value left by one position is equivalent
        to multiplying by 2, shifting two positions is equivalent to
        multiplying by 4, and so on.  For example, <code>7 &lt;&lt; 2</code> evaluates to 28.</p>
        </dd>
        <dt><em>Shift right with sign</em> (<code>&gt;&gt;</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary=">> (shift right with sign operator)" id="idm46198558143752"></a><a data-type="indexterm" data-primary="shift right with sign operator (>>)" id="idm46198558143048"></a> <code>&gt;&gt;</code> operator moves all bits in
        its first operand to the right by the number of places specified in
        the second operand (an integer between 0 and 31). Bits that are
        shifted off the right are lost. The bits filled in on the left depend
        on the sign bit of the original operand, in order to preserve the sign
        of the result. If the first operand is positive, the result has zeros
        placed in the high bits; if the first operand is negative, the result
        has ones placed in the high bits. Shifting a positive value right one
        place is equivalent to dividing by 2 (discarding the remainder),
        shifting right two places is equivalent to integer division by 4, and
        so on. <code>7 &gt;&gt; 1</code> evaluates to 3, for example, but note that and <code>−7 &gt;&gt;
        1</code> evaluates to −4.</p>
        </dd>
        <dt><em>Shift right with zero fill</em> (<code>&gt;&gt;&gt;</code>)</dt>
        <dd>
        <p>The<a data-type="indexterm" data-primary="shift right with zero fill operator (>>>)" id="idm46198558138024"></a><a data-type="indexterm" data-primary=">>> (shift right with zero fill operator)" id="idm46198558137224"></a> <code>&gt;&gt;&gt;</code> operator is just
        like the <code>&gt;&gt;</code> operator, except that the bits shifted in on the left
        are always zero, regardless of the sign of the first operand. This is
        useful when you want to treat signed 32-bit values as if they are
        unsigned integers. <code>−1 &gt;&gt; 4</code> evaluates to −1, but <code>−1 &gt;&gt;&gt; 4</code> evaluates
        to <code>0x0FFFFFFF</code>, for example. This is the only one of the JavaScript
        bitwise operators that cannot be used with BigInt values. BigInt does
        not represent negative numbers by setting the high bit the way that
        32-bit integers do, and this operator only makes sense for that
        particular two’s complement representation.<a data-type="indexterm" data-primary="" data-startref="Earith04" id="idm46198558133656"></a><a data-type="indexterm" data-primary="" data-startref="aritho04" id="idm46198558132680"></a><a data-type="indexterm" data-primary="" data-startref="Oarith04" id="idm46198558131736"></a></p>
        </dd>
        </dl>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.9 Relational Expressions"><div class="sect1" id="relationalexprs">
        <h1>4.9 Relational Expressions</h1>
        
        <p>This<a data-type="indexterm" data-primary="relational expressions" id="relexp04"></a><a data-type="indexterm" data-primary="expressions" data-secondary="relational expressions" id="Erelat04"></a><a data-type="indexterm" data-primary="operators" data-secondary="relational operators" id="Orelation04"></a> section describes JavaScript’s relational operators. These
        operators test for a relationship (such as “equals,” “less than,”
        or “property of”) between two values and return <code>true</code> or <code>false</code>
        depending on whether that relationship exists. Relational expressions
        always evaluate to a boolean value, and that value is often used to
        control the flow of program execution in <code>if</code>, <code>while</code>, and <code>for</code>
        statements (see <a data-type="xref" href="ch05.html#statements">Chapter&nbsp;5</a>). The subsections that follow document
        the equality and inequality operators, the comparison operators, and
        JavaScript’s other two relational operators, <code>in</code> and <code>instanceof</code>.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.9.1 Equality and Inequality Operators"><div class="sect2" id="equalityops">
        <h2>4.9.1 Equality and Inequality Operators</h2>
        
        <p>The<a data-type="indexterm" data-primary="operators" data-secondary="equality and inequality operators" id="idm46198558119144"></a><a data-type="indexterm" data-primary="== (equality operator)" data-secondary="overview of" id="idm46198558118200"></a><a data-type="indexterm" data-primary="equality operator (==)" data-secondary="overview of" id="idm46198558117224"></a><a data-type="indexterm" data-primary="strict equality operator (===)" data-secondary="overview of" id="idm46198558116280"></a><a data-type="indexterm" data-primary="=== (strict equality operator)" data-secondary="overview of" id="idm46198558115368"></a> <code>==</code> and <code>===</code> operators check whether two values are the same,
        using two different definitions of sameness. Both operators accept
        operands of any type, and both return <code>true</code> if their operands are the
        same and <code>false</code> if they are different. The <code>===</code> operator is known as
        the strict equality operator (or sometimes the identity operator), and
        it checks whether its two operands are “identical” using a strict
        definition of sameness. The <code>==</code> operator is known as the equality
        operator; it checks whether its two operands are “equal” using a more
        relaxed definition of sameness that allows type conversions.</p>
        
        <p>The<a data-type="indexterm" data-primary="!== (inequality operator)" data-secondary="overview of" id="idm46198558110840"></a><a data-type="indexterm" data-primary="inequality operator (!==)" data-secondary="overview of" id="idm46198558109464"></a><a data-type="indexterm" data-primary="!= (non-strict inequality operator)" data-secondary="relational expressions" id="idm46198558108520"></a><a data-type="indexterm" data-primary="non-strict inequality operator (!=)" data-secondary="relational expressions" id="idm46198558107560"></a> <code>!=</code> and <code>!==</code> operators test for the exact opposite of the <code>==</code>
        and <code>===</code> operators. The <code>!=</code> inequality operator returns <code>false</code> if
        two values are equal to each other according to <code>==</code> and returns <code>true</code>
        otherwise. The <code>!==</code> operator returns <code>false</code> if two values are
        strictly equal to each other and returns <code>true</code> otherwise. As you’ll
        see in <a data-type="xref" href="#logicalexprs">§4.10</a>, the <code>!</code> operator computes the Boolean NOT
        operation. This makes it easy to remember that <code>!=</code> and <code>!==</code> stand for
        “not equal to” and “not strictly equal to.”</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm46198558110536">
        <h5>The <code>=</code>, <code>==</code>, and <code>===</code> operators</h5>
        <p>JavaScript<a data-type="indexterm" data-primary="= (assignment operator)" id="idm46198558096776"></a><a data-type="indexterm" data-primary="assignment operator (=)" id="idm46198558096072"></a> supports <code>=</code>, <code>==</code>, and <code>===</code> operators. Be sure you
        understand the differences between these assignment, equality, and
        strict equality operators, and be careful to use the correct one when
        coding! Although it is tempting to read all three operators as
        “equals,” it may help to reduce confusion if you read “gets” or “is
        assigned” for <code>=</code>, “is equal to” for <code>==</code>, and “is strictly equal
        to” for <code>===</code>.</p>
        
        <p>The <code>==</code> operator is a legacy feature of JavaScript and is widely
        considered to be a source of bugs. You should almost always use <code>===</code>
        instead of <code>==</code>, and <code>!==</code> instead of <code>!=</code>.</p>
        </div></aside>
        
        <p>As mentioned in <a data-type="xref" href="ch03.html#mutableandimmutable">§3.8</a>, JavaScript objects are
        compared by reference, not by value. An object is equal to itself, but
        not to any other object. If two distinct objects have the same number
        of properties, with the same names and values, they are still not
        equal. Similarly, two arrays that have the same elements in the same
        order are not equal to each other.</p>
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Strict equality"><div class="sect3" id="idm46198558087640">
        <h3>Strict equality</h3>
        
        <p>The strict equality operator <code>===</code> evaluates its operands, then
        compares the two values as follows, performing no type conversion:</p>
        
        <ul>
        <li>
        <p>If the two values have different types, they are not equal.</p>
        </li>
        <li>
        <p>If both values are <code>null</code> or both values are <code>undefined</code>, they are
        equal.</p>
        </li>
        <li>
        <p>If both values are the boolean value <code>true</code> or both are the boolean
        value <code>false</code>, they are equal.</p>
        </li>
        <li>
        <p>If one or both values is <code>NaN</code>, they are not equal. (This is
        surprising, but the <code>NaN</code> value is never equal to any other value,
        including itself! To check whether a value <code>x</code> is <code>NaN</code>, use <code>x !==
        x</code>, or the global <code>isNaN()</code> function.)</p>
        </li>
        <li>
        <p>If both values are numbers and have the same value, they are equal.
        If one value is <code>0</code> and the other is <code>-0</code>, they are also equal.</p>
        </li>
        <li>
        <p>If both values are strings and contain exactly the same 16-bit values
        (see the sidebar in <a data-type="xref" href="ch03.html#text">§3.3</a>) in the same positions, they are equal. If
        the strings differ in length or content, they are not equal. Two
        strings may have the same meaning and the same visual appearance, but
        still be encoded using different sequences of 16-bit values. JavaScript
        performs no Unicode normalization, and a pair of strings like this is
        not considered equal to the <code>===</code> or <code>==</code> operators.</p>
        </li>
        <li>
        <p>If both values refer to the same object, array, or function, they are
        equal. If they refer to different objects, they are not equal, even if
        both objects have identical properties.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect3" data-pdf-bookmark="Equality with type conversion"><div class="sect3" id="idm46198558071048">
        <h3>Equality with type conversion</h3>
        
        <p>The<a data-type="indexterm" data-primary="type conversions" data-secondary="equality and" id="idm46198558069576"></a> equality operator <code>==</code> is like the strict equality operator, but it
        is less strict. If the values of the two operands are not the same
        type, it attempts some type conversions and tries the comparison again:</p>
        
        <ul>
        <li>
        <p>If the two values have the same type, test them for strict equality
        as described previously. If they are strictly equal, they are equal. If they
        are not strictly equal, they are not equal.</p>
        </li>
        <li>
        <p>If the two values do not have the same type, the <code>==</code> operator may
        still consider them equal. It uses the following rules and type
        conversions to check for equality:</p>
        
        <ul>
        <li>
        <p>If one value is <code>null</code> and the other is <code>undefined</code>, they are equal.</p>
        </li>
        <li>
        <p>If one value is a number and the other is a string, convert the
        string to a number and try the comparison again, using the converted
        value.</p>
        </li>
        <li>
        <p>If either value is <code>true</code>, convert it to 1 and try the comparison
        again. If either value is <code>false</code>, convert it to 0 and try the
        comparison again.</p>
        </li>
        <li>
        <p>If one value is an object and the other is a number or string,
        convert the object to a primitive using the algorithm described in
        <a data-type="xref" href="ch03.html#objtoprim">§3.9.3</a> and try the comparison again. An<a data-type="indexterm" data-primary="toString() method" id="idm46198558057816"></a> object is converted to a
        primitive value by either its <code>toString()</code> method or its <code>valueOf()</code>
        method. The built-in classes of core JavaScript attempt <code>valueOf()</code>
        conversion before <code>toString()</code> conversion, except for the Date class,
        which performs <code>toString()</code> conversion.</p>
        </li>
        <li>
        <p>Any other combinations of values are not equal.</p>
        </li>
        </ul>
        </li>
        </ul>
        
        <p>As an example of testing for equality, consider the comparison:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="s2">"1"</code> <code class="o">==</code> <code class="kc">true</code>  <code class="c1">// =&gt; true</code></pre>
        
        <p>This expression evaluates to <code>true</code>, indicating that these very
        different-looking values are in fact equal. The boolean value <code>true</code> is
        first converted to the number 1, and the comparison is done again.
        Next, the string <code>"1"</code> is converted to the number 1. Since both values
        are now the same, the comparison returns <code>true</code>.</p>
        </div></section>
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.9.2 Comparison Operators"><div class="sect2" id="comparisonops">
        <h2>4.9.2 Comparison Operators</h2>
        
        <p>The<a data-type="indexterm" data-primary="comparison operators" id="idm46198558046280"></a><a data-type="indexterm" data-primary="operators" data-secondary="comparison operators" id="idm46198558045544"></a> comparison operators test the relative order (numerical or
        alphabetical) of their two operands:</p>
        <dl>
        <dt><em>Less than</em> (<code>&lt;</code>)</dt>
        <dd>
        <p>    The<a data-type="indexterm" data-primary="< (less than operator)" data-secondary="overview of" id="idm46198558041928"></a><a data-type="indexterm" data-primary="less than operator (<)" data-secondary="overview of" id="idm46198558040920"></a> <code>&lt;</code> operator evaluates to <code>true</code> if its first operand is less
        than its second operand; otherwise, it evaluates to <code>false</code>.</p>
        </dd>
        <dt><em>Greater than</em> (<code>&gt;</code>)</dt>
        <dd>
        <p>    The<a data-type="indexterm" data-primary="> (greater than operator)" data-secondary="overview of" id="idm46198558034472"></a><a data-type="indexterm" data-primary="greater than operator (>)" data-secondary="overview of" id="idm46198558033496"></a> <code>&gt;</code> operator evaluates to <code>true</code> if its first operand is
        greater than its second operand; otherwise, it evaluates to <code>false</code>.</p>
        </dd>
        <dt><em>Less than or equal</em> (<code>&lt;=</code>)</dt>
        <dd>
        <p>    The<a data-type="indexterm" data-primary="<= (less than or equal to operator)" data-secondary="overview of" id="idm46198558029096"></a><a data-type="indexterm" data-primary="less than or equal to operator (<=)" data-secondary="overview of" id="idm46198558028120"></a> <code>&lt;=</code> operator evaluates to <code>true</code> if its first operand is less
        than or equal to its second operand; otherwise, it evaluates to <code>false</code>.</p>
        </dd>
        <dt><em>Greater than or equal</em> (<code>&gt;=</code>)</dt>
        <dd>
        <p>    The<a data-type="indexterm" data-primary=">= (greater than or equal to operator)" data-secondary="overview of" id="idm46198558003352"></a><a data-type="indexterm" data-primary="greater than or equal to operator (>=)" data-secondary="overview of" id="idm46198558002328"></a> <code>&gt;=</code> operator evaluates to <code>true</code> if its first operand is
        greater than or equal to its second operand; otherwise, it evaluates to
        <code>false</code>.</p>
        </dd>
        </dl>
        
        <p>The operands of these comparison operators may be of any type.
        Comparison can be performed only on numbers and strings, however, so
        operands that are not numbers or strings are converted.</p>
        
        <p>Comparison and conversion occur as follows:</p>
        
        <ul>
        <li>
        <p>If either operand evaluates to an object, that object is converted to
        a primitive value, as described at the end of <a data-type="xref" href="ch03.html#objtoprim">§3.9.3</a>; if its
        <code>valueOf()</code> method returns a primitive value, that value is used.
        Otherwise, the return value of its <code>toString()</code> method is used.</p>
        </li>
        <li>
        <p>If, after any required object-to-primitive conversion, both operands
        are strings, the two strings are compared, using alphabetical order,
        where “alphabetical order” is defined by the numerical order of the
        16-bit Unicode values that make up the strings.</p>
        </li>
        <li>
        <p>If, after object-to-primitive conversion, at least one operand is not
        a string, both operands are converted to numbers and compared
        numerically. <code>0</code> and <code>-0</code> are considered equal. <code>Infinity</code> is larger
        than any number other than itself, and <span class="keep-together"><code>-Infinity</code></span> is smaller than any
        number other than itself. If either operand is (or converts to) <code>NaN</code>,
        then the comparison operator always returns <code>false</code>. Although the
        arithmetic operators do not allow BigInt values to be mixed with
        regular numbers, the comparison operators do allow comparisons between
        numbers and BigInts.</p>
        </li>
        </ul>
        
        <p>Remember that JavaScript strings are sequences of 16-bit integer
        values, and that string comparison is just a numerical comparison of
        the values in the two strings. The numerical encoding order defined by
        Unicode may not match the traditional collation order used in any
        particular language or locale. Note in particular that string
        comparison is case-sensitive, and all capital ASCII letters are “less
        than” all lowercase ASCII letters. This rule can cause confusing
        results if you do not expect it. For example, according to the <code>&lt;</code>
        operator, the string “Zoo” comes before the string “aardvark”.</p>
        
        <p>For a more robust string-comparison algorithm, try the
        <code>String.localeCompare()</code> method, which also takes locale-specific
        definitions of alphabetical order into account. For case-insensitive
        comparisons, you can convert the strings to all lowercase or all
        uppercase using <code>String.toLowerCase()</code> or <code>String.toUpperCase()</code>. And,
        for a more general and better localized string comparison tool,
        use the Intl.Collator class described in <a data-type="xref" href="ch11.html#collator">§11.7.3</a>.</p>
        
        <p>Both the <code>+</code> operator and the comparison operators behave
        differently for numeric and string operands. <code>+</code> favors strings:
        it performs concatenation if either operand is a string. The comparison
        operators favor numbers and only perform string comparison if both
        operands are strings:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="mi">1</code> <code class="o">+</code> <code class="mi">2</code>        <code class="c1">// =&gt; 3: addition.</code>
        <code class="s2">"1"</code> <code class="o">+</code> <code class="s2">"2"</code>    <code class="c1">// =&gt; "12": concatenation.</code>
        <code class="s2">"1"</code> <code class="o">+</code> <code class="mi">2</code>      <code class="c1">// =&gt; "12": 2 is converted to "2".</code>
        <code class="mi">11</code> <code class="o">&lt;</code> <code class="mi">3</code>       <code class="c1">// =&gt; false: numeric comparison.</code>
        <code class="s2">"11"</code> <code class="o">&lt;</code> <code class="s2">"3"</code>   <code class="c1">// =&gt; true: string comparison.</code>
        <code class="s2">"11"</code> <code class="o">&lt;</code> <code class="mi">3</code>     <code class="c1">// =&gt; false: numeric comparison, "11" converted to 11.</code>
        <code class="s2">"one"</code> <code class="o">&lt;</code> <code class="mi">3</code>    <code class="c1">// =&gt; false: numeric comparison, "one" converted to NaN.</code></pre>
        
        <p>Finally, note that the <code>&lt;=</code> (less than or equal) and <code>&gt;=</code> (greater than
        or equal) operators do not rely on the equality or strict equality
        operators for determining whether two values are “equal.” Instead,
        the less-than-or-equal operator is simply defined as “not greater
        than,” and the greater-than-or-equal operator is defined as “not less
        than.” The one exception occurs when either operand is (or converts
        to) <code>NaN</code>, in which case, all four comparison operators return <code>false</code>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.9.3 The in Operator"><div class="sect2" id="inoperator">
        <h2>4.9.3 The in Operator</h2>
        
        <p>The<a data-type="indexterm" data-primary="in operator" id="idm46198557946072"></a> <code>in</code> operator expects a left-side operand that is a string, symbol, or value that can be converted to a string. It expects a
        right-side operand that is an object. It evaluates to <code>true</code> if the
        left-side value is the name of a property of the right-side
        object. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">point</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">1</code><code class="p">};</code>  <code class="c1">// Define an object</code>
        <code class="s2">"x"</code> <code class="k">in</code> <code class="nx">point</code>               <code class="c1">// =&gt; true: object has property named "x"</code>
        <code class="s2">"z"</code> <code class="k">in</code> <code class="nx">point</code>               <code class="c1">// =&gt; false: object has no "z" property.</code>
        <code class="s2">"toString"</code> <code class="k">in</code> <code class="nx">point</code>        <code class="c1">// =&gt; true: object inherits toString method</code>
        
        <code class="kd">let</code> <code class="nx">data</code> <code class="o">=</code> <code class="p">[</code><code class="mi">7</code><code class="p">,</code><code class="mi">8</code><code class="p">,</code><code class="mi">9</code><code class="p">];</code>        <code class="c1">// An array with elements (indices) 0, 1, and 2</code>
        <code class="s2">"0"</code> <code class="k">in</code> <code class="nx">data</code>                <code class="c1">// =&gt; true: array has an element "0"</code>
        <code class="mi">1</code> <code class="k">in</code> <code class="nx">data</code>                  <code class="c1">// =&gt; true: numbers are converted to strings</code>
        <code class="mi">3</code> <code class="k">in</code> <code class="nx">data</code>                  <code class="c1">// =&gt; false: no element 3</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.9.4 The instanceof Operator"><div class="sect2" id="instanceof">
        <h2>4.9.4 The instanceof Operator</h2>
        
        <p>The<a data-type="indexterm" data-primary="instanceof operator" id="idm46198557857400"></a> <code>instanceof</code> operator expects a left-side operand that is an object
        and a right-side operand that identifies a class of objects. The
        operator evaluates to <code>true</code> if the left-side object is an instance of
        the right-side class and evaluates to <code>false</code> otherwise. <a data-type="xref" href="ch09.html#classes">Chapter&nbsp;9</a>
        explains that, in JavaScript, classes of objects are defined by the
        constructor function that initializes them. Thus, the right-side
        operand of <code>instanceof</code> should be a function. Here are examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">d</code> <code class="o">=</code> <code class="k">new</code> <code class="nb">Date</code><code class="p">();</code>  <code class="c1">// Create a new object with the Date() constructor</code>
        <code class="nx">d</code> <code class="k">instanceof</code> <code class="nb">Date</code>    <code class="c1">// =&gt; true: d was created with Date()</code>
        <code class="nx">d</code> <code class="k">instanceof</code> <code class="nb">Object</code>  <code class="c1">// =&gt; true: all objects are instances of Object</code>
        <code class="nx">d</code> <code class="k">instanceof</code> <code class="nb">Number</code>  <code class="c1">// =&gt; false: d is not a Number object</code>
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code> <code class="mi">2</code><code class="p">,</code> <code class="mi">3</code><code class="p">];</code>   <code class="c1">// Create an array with array literal syntax</code>
        <code class="nx">a</code> <code class="k">instanceof</code> <code class="nb">Array</code>   <code class="c1">// =&gt; true: a is an array</code>
        <code class="nx">a</code> <code class="k">instanceof</code> <code class="nb">Object</code>  <code class="c1">// =&gt; true: all arrays are objects</code>
        <code class="nx">a</code> <code class="k">instanceof</code> <code class="nb">RegExp</code>  <code class="c1">// =&gt; false: arrays are not regular expressions</code></pre>
        
        <p>Note that all objects are instances of <code>Object</code>. <code>instanceof</code> considers
        the “superclasses” when deciding whether an object is an instance of
        a class. If the left-side operand of <code>instanceof</code> is not an object,
        <code>instanceof</code> returns <code>false</code>. If the righthand side is not a class of
        objects, it throws a <code>TypeError</code>.</p>
        
        <p>In order to understand how the <code>instanceof</code> operator works, you must
        understand the “prototype chain.” This is JavaScript’s inheritance
        mechanism, and it is described in <a data-type="xref" href="ch06.html#inheritance">§6.3.2</a>. To evaluate the
        expression <code>o instanceof f</code>, JavaScript evaluates <code>f.prototype</code>, and
        then looks for that value in the prototype chain of <code>o</code>. If it finds
        it, then <code>o</code> is an instance of <code>f</code> (or of a subclass of <code>f</code>) and the
        operator returns <code>true</code>. If <code>f.prototype</code> is not one of the values in
        the prototype chain of <code>o</code>, then <code>o</code> is not an instance of <code>f</code> and
        <code>instanceof</code> returns <code>false</code>.<a data-type="indexterm" data-primary="" data-startref="Orelation04" id="idm46198557763688"></a><a data-type="indexterm" data-primary="" data-startref="Erelat04" id="idm46198557762680"></a><a data-type="indexterm" data-primary="" data-startref="relexp04" id="idm46198557761736"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.10 Logical Expressions"><div class="sect1" id="logicalexprs">
        <h1>4.10 Logical Expressions</h1>
        
        <p>The<a data-type="indexterm" data-primary="logical operators" id="logical04"></a><a data-type="indexterm" data-primary="expressions" data-secondary="logical expressions" id="Elogical04"></a><a data-type="indexterm" data-primary="operators" data-secondary="logical operators" id="Ological04"></a> logical operators <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> perform Boolean
        algebra and are often used in conjunction with the relational operators
        to combine two relational expressions into one more complex expression.
        These operators are described in the subsections that follow. In order
        to fully understand them, you may want to review the concept of
        “truthy” and “falsy” values introduced in <a data-type="xref" href="ch03.html#booleans">§3.4</a>.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.10.1 Logical AND (&amp;&amp;)"><div class="sect2" id="logicaland">
        <h2>4.10.1 Logical AND (&amp;&amp;)</h2>
        
        <p>The<a data-type="indexterm" data-primary="&amp;&amp; (Boolean AND operator)" id="idm46198557750584"></a><a data-type="indexterm" data-primary="Boolean AND operator (&amp;&amp;)" id="idm46198557749880"></a> <code>&amp;&amp;</code> operator can be understood at three different levels.
        At the simplest level, when used with boolean operands, <code>&amp;&amp;</code>
        performs the Boolean AND operation on the two values: it returns <code>true</code>
        if and only if both its first operand <em>and</em> its second operand are
        <code>true</code>. If one or both of these operands is <code>false</code>, it returns <code>false</code>.</p>
        
        <p><code>&amp;&amp;</code> is often used as a conjunction to join two relational
        expressions:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">x</code> <code class="o">===</code> <code class="mi">0</code> <code class="o">&amp;&amp;</code> <code class="nx">y</code> <code class="o">===</code> <code class="mi">0</code>   <code class="c1">// true if, and only if, x and y are both 0</code></pre>
        
        <p>Relational expressions always evaluate to <code>true</code> or <code>false</code>, so when
        used like this, the <code>&amp;&amp;</code> operator itself returns <code>true</code> or
        <code>false</code>. Relational operators have higher precedence than <code>&amp;&amp;</code>
        (and <code>||</code>), so expressions like these can safely be written without
        parentheses.</p>
        
        <p>But <code>&amp;&amp;</code> does not require that its operands be boolean values.
        Recall that all JavaScript values are either “truthy” or “falsy.”
        (See <a data-type="xref" href="ch03.html#booleans">§3.4</a> for details. The falsy values are <code>false</code>, <code>null</code>,
        <code>undefined</code>, <code>0</code>, <code>-0</code>, <code>NaN</code>, and <code>""</code>. All other values, including
        all objects, are truthy.) The second level at which <code>&amp;&amp;</code> can be
        understood is as a Boolean AND operator for truthy and falsy values. If
        both operands are truthy, the operator returns a truthy value.
        Otherwise, one or both operands must be falsy, and the operator returns
        a falsy value. In JavaScript, any expression or statement that expects
        a boolean value will work with a truthy or falsy value, so the fact
        that <code>&amp;&amp;</code> does not always return <code>true</code> or <code>false</code> does not
        cause practical problems.</p>
        
        <p>Notice that this description says that the operator returns “a
        truthy value” or “a falsy value” but does not specify what that
        value is. For that, we need to describe <code>&amp;&amp;</code> at the third and
        final level. This operator starts by evaluating its first operand, the
        expression on its left. If the value on the left is falsy, the value of
        the entire expression must also be falsy, so <code>&amp;&amp;</code> simply
        returns the value on the left and does not even evaluate the expression
        on the right.</p>
        
        <p>On the other hand, if the value on the left is truthy, then the overall
        value of the expression depends on the value on the righthand side. If
        the value on the right is truthy, then the overall value must be
        truthy, and if the value on the right is falsy, then the overall value
        must be falsy. So when the value on the left is truthy, the
        <code>&amp;&amp;</code> operator evaluates and returns the value on the right:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">};</code>
        <code class="kd">let</code> <code class="nx">p</code> <code class="o">=</code> <code class="kc">null</code><code class="p">;</code>
        <code class="nx">o</code> <code class="o">&amp;&amp;</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code>     <code class="c1">// =&gt; 1: o is truthy, so return value of o.x</code>
        <code class="nx">p</code> <code class="o">&amp;&amp;</code> <code class="nx">p</code><code class="p">.</code><code class="nx">x</code>     <code class="c1">// =&gt; null: p is falsy, so return it and don't evaluate p.x</code></pre>
        
        <p>It is important to understand that <code>&amp;&amp;</code> may or may not evaluate
        its right-side operand. In this code example, the variable <code>p</code> is set to
        <code>null</code>, and the expression <code>p.x</code> would, if evaluated, cause a
        TypeError. But the code uses <code>&amp;&amp;</code> in an idiomatic way so that
        <code>p.x</code> is evaluated only if <code>p</code> is truthy—not <code>null</code> or <code>undefined</code>.</p>
        
        <p>The behavior of <code>&amp;&amp;</code> is sometimes called short circuiting,
        and you may sometimes see code that purposely exploits this behavior to
        conditionally execute code. For example, the following two lines of
        JavaScript code have equivalent effects:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="k">if</code> <code class="p">(</code><code class="nx">a</code> <code class="o">===</code> <code class="nx">b</code><code class="p">)</code> <code class="nx">stop</code><code class="p">();</code>   <code class="c1">// Invoke stop() only if a === b</code>
        <code class="p">(</code><code class="nx">a</code> <code class="o">===</code> <code class="nx">b</code><code class="p">)</code> <code class="o">&amp;&amp;</code> <code class="nx">stop</code><code class="p">();</code>   <code class="c1">// This does the same thing</code></pre>
        
        <p>In general, you must be careful whenever you write an expression with
        side effects (assignments, increments, decrements, or function
        invocations) on the righthand side of <code>&amp;&amp;</code>. Whether those side
        effects occur depends on the value of the lefthand side.</p>
        
        <p>Despite the somewhat complex way that this operator actually works, it
        is most commonly used as a simple Boolean algebra operator that works
        on truthy and falsy <span class="keep-together">values.</span></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.10.2 Logical OR (||)"><div class="sect2" id="logicalor">
        <h2>4.10.2 Logical OR (||)</h2>
        
        <p>The<a data-type="indexterm" data-primary="|| (Boolean OR operator)" id="idm46198557632536"></a><a data-type="indexterm" data-primary="Boolean OR operator (||)" id="idm46198557631832"></a> <code>||</code> operator performs the Boolean OR operation on its two
        operands. If one or both operands is truthy, it returns a truthy value.
        If both operands are falsy, it returns a falsy value.</p>
        
        <p>Although the <code>||</code> operator is most often used simply as a Boolean OR
        operator, it, like the <code>&amp;&amp;</code> operator, has more complex behavior. It
        starts by evaluating its first operand, the expression on its left. If
        the value of this first operand is truthy, it short-circuits and
        returns that truthy value without ever evaluating the expression on
        the right. If, on the other hand, the value of the first operand is
        falsy, then <code>||</code> evaluates its second operand and returns the value of
        that expression.</p>
        
        <p>As with the <code>&amp;&amp;</code> operator, you should avoid right-side operands
        that include side effects, unless you purposely want to use the fact
        that the right-side expression may not be evaluated.</p>
        
        <p>An idiomatic usage of this operator is to select the first truthy value
        in a set of <span class="keep-together">alternatives:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// If maxWidth is truthy, use that. Otherwise, look for a value in</code>
        <code class="c1">// the preferences object. If that is not truthy, use a hardcoded constant.</code>
        <code class="kd">let</code> <code class="nx">max</code> <code class="o">=</code> <code class="nx">maxWidth</code> <code class="o">||</code> <code class="nx">preferences</code><code class="p">.</code><code class="nx">maxWidth</code> <code class="o">||</code> <code class="mi">500</code><code class="p">;</code></pre>
        
        <p>Note that if 0 is a legal value for <code>maxWidth</code>, then this code will not work correctly, since 0 is a falsy value. See the <code>??</code>
        operator (<a data-type="xref" href="#firstdefined">§4.13.2</a>) for an alternative.</p>
        
        <p>Prior to ES6, this idiom is often used in functions to supply
        default values for <span class="keep-together">parameters:</span></p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// Copy the properties of o to p, and return p</code>
        <code class="kd">function</code> <code class="nx">copy</code><code class="p">(</code><code class="nx">o</code><code class="p">,</code> <code class="nx">p</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">p</code> <code class="o">=</code> <code class="nx">p</code> <code class="o">||</code> <code class="p">{};</code>  <code class="c1">// If no object passed for p, use a newly created object.</code>
            <code class="c1">// function body goes here</code>
        <code class="p">}</code></pre>
        
        <p>In ES6 and later, however, this trick is no longer needed because the
        default parameter value could simply be written in the function
        definition itself: <code>function copy(o, p={}) { ... }</code>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.10.3 Logical NOT (!)"><div class="sect2" id="idm46198557633912">
        <h2>4.10.3 Logical NOT (!)</h2>
        
        <p>The<a data-type="indexterm" data-primary="! (Boolean NOT operator)" id="idm46198557526440"></a><a data-type="indexterm" data-primary="Boolean NOT operator (!)" id="idm46198557525736"></a> <code>!</code> operator is a unary operator; it is placed before a single
        operand. Its purpose is to invert the boolean value of its operand. For
        example, if <code>x</code> is truthy, <code>!x</code> evaluates to <code>false</code>. If <code>x</code> is falsy,
        then <code>!x</code> is <code>true</code>.</p>
        
        <p>Unlike the <code>&amp;&amp;</code> and <code>||</code> operators, the <code>!</code> operator converts
        its operand to a boolean value (using the rules described in
        <a data-type="xref" href="ch03.html#datatypes">Chapter&nbsp;3</a>) before inverting the converted value. This means that
        <code>!</code> always returns <code>true</code> or <code>false</code> and that you can convert any
        value <code>x</code> to its equivalent boolean value by applying this operator
        twice: <code>!!x</code> (see <a data-type="xref" href="ch03.html#explicitconversions">§3.9.2</a>).</p>
        
        <p>As a unary operator, <code>!</code> has high precedence and binds tightly. If you
        want to invert the value of an expression like <code>p &amp;&amp; q</code>, you
        need to use parentheses: <code>!(p &amp;&amp; q)</code>. It is worth noting two
        laws of Boolean algebra here that we can express using<a data-type="indexterm" data-primary="" data-startref="Ological04" id="idm46198557493064"></a><a data-type="indexterm" data-primary="" data-startref="Elogical04" id="idm46198557492088"></a><a data-type="indexterm" data-primary="" data-startref="logical04" id="idm46198557491144"></a> JavaScript
        syntax:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// DeMorgan's Laws</code>
        <code class="o">!</code><code class="p">(</code><code class="nx">p</code> <code class="o">&amp;&amp;</code> <code class="nx">q</code><code class="p">)</code> <code class="o">===</code> <code class="p">(</code><code class="o">!</code><code class="nx">p</code> <code class="o">||</code> <code class="o">!</code><code class="nx">q</code><code class="p">)</code>  <code class="c1">// =&gt; true: for all values of p and q</code>
        <code class="o">!</code><code class="p">(</code><code class="nx">p</code> <code class="o">||</code> <code class="nx">q</code><code class="p">)</code> <code class="o">===</code> <code class="p">(</code><code class="o">!</code><code class="nx">p</code> <code class="o">&amp;&amp;</code> <code class="o">!</code><code class="nx">q</code><code class="p">)</code>  <code class="c1">// =&gt; true: for all values of p and q</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.11 Assignment Expressions"><div class="sect1" id="I_sect13_d1e8479">
        <h1>4.11 Assignment Expressions</h1>
        
        <p>JavaScript<a data-type="indexterm" data-primary="assignment operator (=)" id="idm46198557426008"></a><a data-type="indexterm" data-primary="= (assignment operator)" id="idm46198557425272"></a><a data-type="indexterm" data-primary="expressions" data-secondary="assignment expressions" id="Eassign04"></a><a data-type="indexterm" data-primary="operators" data-secondary="assignment operators" id="Oassign04"></a> uses the <code>=</code> operator to assign a value to a variable or
        property. For example:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>     <code class="c1">// Set the variable i to 0.</code>
        <code class="nx">o</code><code class="p">.</code><code class="nx">x</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code>   <code class="c1">// Set the property x of object o to 1.</code></pre>
        
        <p>The <code>=</code> operator expects its left-side operand to be an lvalue: a
        variable or object property (or array element). It expects its
        right-side operand to be an arbitrary value of any type. The value of
        an assignment expression is the value of the right-side operand. As a
        side effect, the <code>=</code> operator assigns the value on the right to the
        variable or property on the left so that future references to the
        variable or property evaluate to the value.</p>
        
        <p>Although assignment expressions are usually quite simple, you may
        sometimes see the value of an assignment expression used as part of a
        larger expression. For example, you can assign and test a value in the
        same expression with code like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">(</code><code class="nx">a</code> <code class="o">=</code> <code class="nx">b</code><code class="p">)</code> <code class="o">===</code> <code class="mi">0</code></pre>
        
        <p>If you do this, be sure you are clear on the difference between the <code>=</code>
        and <code>===</code> operators! Note that <code>=</code> has very low precedence, and
        parentheses are usually necessary when the value of an assignment is to
        be used in a larger expression.</p>
        
        <p>The assignment operator has right-to-left associativity, which means
        that when multiple assignment operators appear in an expression, they
        are evaluated from right to left. Thus, you can write code like this to
        assign a single value to multiple variables:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">i</code> <code class="o">=</code> <code class="nx">j</code> <code class="o">=</code> <code class="nx">k</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>       <code class="c1">// Initialize 3 variables to 0</code></pre>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.11.1 Assignment with Operation"><div class="sect2" id="idm46198557278856">
        <h2>4.11.1 Assignment with Operation</h2>
        
        <p>Besides<a data-type="indexterm" data-primary="+ (plus sign)" data-secondary="addition and assignment operator (+=)" id="idm46198557397960"></a><a data-type="indexterm" data-primary="plus sign (+)" data-secondary="addition and assignment operator (+=)" id="idm46198557397016"></a> the normal <code>=</code> assignment operator, JavaScript supports a
        number of other assignment operators that provide shortcuts by
        combining assignment with some other operation. For example, the
        <code>+=</code> operator performs addition and assignment. The following
        expression:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">total</code> <code class="o">+=</code> <code class="nx">salesTax</code><code class="p">;</code></pre>
        
        <p>is equivalent to this one:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">total</code> <code class="o">=</code> <code class="nx">total</code> <code class="o">+</code> <code class="nx">salesTax</code><code class="p">;</code></pre>
        
        <p>As you might expect, the <code>+=</code> operator works for numbers or
        strings. For numeric operands, it performs addition and assignment; for
        string operands, it performs concatenation and assignment.</p>
        
        <p>Similar operators include <code>-=</code>, <code>*=</code>, <code>&amp;=</code>, and so on.
        <a data-type="xref" href="#expressions-TABLE-2">Table&nbsp;4-2</a> lists them all.</p>
        <table id="expressions-TABLE-2">
        <caption><span class="label">Table 4-2. </span>Assignment operators</caption>
        <thead>
        <tr>
        <th>Operator</th>
        <th>Example</th>
        <th>Equivalent</th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p><code>+=</code></p></td>
        <td><p><code>a += b</code></p></td>
        <td><p><code>a = a + b</code></p></td>
        </tr>
        <tr>
        <td><p><code>-=</code></p></td>
        <td><p><code>a -= b</code></p></td>
        <td><p><code>a = a - b</code></p></td>
        </tr>
        <tr>
        <td><p><code>*=</code></p></td>
        <td><p><code>a *= b</code></p></td>
        <td><p><code>a = a * b</code></p></td>
        </tr>
        <tr>
        <td><p><code>/=</code></p></td>
        <td><p><code>a /= b</code></p></td>
        <td><p><code>a = a / b</code></p></td>
        </tr>
        <tr>
        <td><p><code>%=</code></p></td>
        <td><p><code>a %= b</code></p></td>
        <td><p><code>a = a % b</code></p></td>
        </tr>
        <tr>
        <td><p><code>**=</code></p></td>
        <td><p><code>a **= b</code></p></td>
        <td><p><code>a = a ** b</code></p></td>
        </tr>
        <tr>
        <td><p><code>&lt;&lt;=</code></p></td>
        <td><p><code>a &lt;&lt;= b</code></p></td>
        <td><p><code>a = a &lt;&lt; b</code></p></td>
        </tr>
        <tr>
        <td><p><code>&gt;&gt;=</code></p></td>
        <td><p><code>a &gt;&gt;= b</code></p></td>
        <td><p><code>a = a &gt;&gt; b</code></p></td>
        </tr>
        <tr>
        <td><p><code>&gt;&gt;&gt;=</code></p></td>
        <td><p><code>a &gt;&gt;&gt;= b</code></p></td>
        <td><p><code>a = a &gt;&gt;&gt; b</code></p></td>
        </tr>
        <tr>
        <td><p><code>&amp;=</code></p></td>
        <td><p><code>a &amp;= b</code></p></td>
        <td><p><code>a = a &amp; b</code></p></td>
        </tr>
        <tr>
        <td><p><code>|=</code></p></td>
        <td><p><code>a |= b</code></p></td>
        <td><p><code>a = a | b</code></p></td>
        </tr>
        <tr>
        <td><p><code>^=</code></p></td>
        <td><p><code>a ^= b</code></p></td>
        <td><p><code>a = a ^ b</code></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>In most cases, the expression:</p>
        
        <pre data-type="programlisting">a op= b</pre>
        
        <p>where <code>op</code> is an operator, is equivalent to the expression:</p>
        
        <pre data-type="programlisting">a = a op b</pre>
        
        <p>In the first line, the expression <code>a</code> is evaluated once. In the second,
        it is evaluated twice. The two cases will differ only if <code>a</code> includes
        side effects such as a function call or an increment operator. The
        following two assignments, for example, are not<a data-type="indexterm" data-primary="" data-startref="Oassign04" id="idm46198557203160"></a><a data-type="indexterm" data-primary="" data-startref="Eassign04" id="idm46198557202184"></a> the same:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">data</code><code class="p">[</code><code class="nx">i</code><code class="o">++</code><code class="p">]</code> <code class="o">*=</code> <code class="mi">2</code><code class="p">;</code>
        <code class="nx">data</code><code class="p">[</code><code class="nx">i</code><code class="o">++</code><code class="p">]</code> <code class="o">=</code> <code class="nx">data</code><code class="p">[</code><code class="nx">i</code><code class="o">++</code><code class="p">]</code> <code class="o">*</code> <code class="mi">2</code><code class="p">;</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.12 Evaluation Expressions"><div class="sect1" id="evalexprs">
        <h1>4.12 Evaluation Expressions</h1>
        
        <p>Like<a data-type="indexterm" data-primary="eval() function" id="eval04"></a><a data-type="indexterm" data-primary="evaluation expressions" id="evalexp04"></a><a data-type="indexterm" data-primary="expressions" data-secondary="evaluation expressions" id="Eeval04"></a> many interpreted languages, JavaScript has the ability to
        interpret strings of JavaScript source code, evaluating them to produce
        a value. JavaScript does this with the global function <code>eval()</code>:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">eval</code><code class="p">(</code><code class="s2">"3+2"</code><code class="p">)</code>    <code class="c1">// =&gt; 5</code></pre>
        
        <p>Dynamic evaluation of strings of source code is a powerful language
        feature that is almost never necessary in practice. If you find
        yourself using <code>eval()</code>, you should think carefully about whether you
        really need to use it. In particular, <code>eval()</code> can be a security
        hole, and you should never pass any string derived from user input to
        <code>eval()</code>. With a language as complicated as JavaScript, there is no way
        to sanitize user input to make it safe to use with <code>eval()</code>. Because
        of these security issues, some web servers use the HTTP
        “Content-Security-Policy” header to disable <code>eval()</code> for an entire
        website.</p>
        
        <p>The subsections that follow explain the basic use of <code>eval()</code> and explain two restricted versions of it that have less impact on the
        optimizer.</p>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="I_sidebar3_d1e8818">
        <h5>Is eval() a Function or an Operator?</h5>
        <p><code>eval()</code> is a function, but it is included in this chapter on
        expressions because it really should have been an operator. The
        earliest versions of the language defined an <code>eval()</code> function, and
        ever since then, language designers and interpreter writers have been
        placing restrictions on it that make it more and more operator-like.
        Modern JavaScript interpreters perform a lot of code analysis and
        optimization. Generally speaking, if a function calls
        <code>eval()</code>, the interpreter cannot optimize that function. The problem
        with defining <code>eval()</code> as a function is that it can be given other
        names:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">f</code> <code class="o">=</code> <code class="nb">eval</code><code class="p">;</code>
        <code class="kd">let</code> <code class="nx">g</code> <code class="o">=</code> <code class="nx">f</code><code class="p">;</code></pre>
        
        <p>If this is allowed, then the interpreter can’t know for sure which
        functions call <code>eval()</code>, so it cannot optimize aggressively. This issue could have been avoided if <code>eval()</code>
        was an operator (and a reserved word). We’ll learn (in
        <a data-type="xref" href="#globaleval">§4.12.2</a> and <a data-type="xref" href="#stricteval">§4.12.3</a>) about restrictions placed on
        <code>eval()</code> to make it more operator-like.</p>
        </div></aside>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.12.1 eval()"><div class="sect2" id="basiceval">
        <h2>4.12.1 eval()</h2>
        
        <p><code>eval()</code> expects one argument. If you pass any value other than a
        string, it simply returns that value. If you pass a string, it attempts
        to parse the string as JavaScript code, throwing a SyntaxError if it
        fails. If it successfully parses the string, then it evaluates the code
        and returns the value of the last expression or statement in the string
        or <code>undefined</code> if the last expression or statement had no value. If the
        evaluated string throws an exception, that exception propogates from
        the call to <code>eval()</code>.</p>
        
        <p>The key thing about <code>eval()</code> (when invoked like this) is that it uses
        the variable environment of the code that calls it. That is, it looks
        up the values of variables and defines new variables and functions in
        the same way that local code does. If a function defines a local
        variable <code>x</code> and then calls <code>eval("x")</code>, it will obtain the value of
        the local variable. If it calls <code>eval("x=1")</code>, it changes the value of
        the local variable. And if the function calls <code>eval("var y = 3;")</code>,
        it declares a new local variable <code>y</code>. On the other hand, if the
        evaluated string uses <code>let</code> or <code>const</code>, the variable or constant
        declared will be local to the evaluation and will not be defined in
        the calling environment.</p>
        
        <p>Similarly, a function can declare a local function with code like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nb">eval</code><code class="p">(</code><code class="s2">"function f() { return x+1; }"</code><code class="p">);</code></pre>
        
        <p>If you call <code>eval()</code> from top-level code, it operates on global
        variables and global functions, of course.</p>
        
        <p>Note that the string of code you pass to <code>eval()</code> must make syntactic
        sense on its own: you cannot use it to paste code fragments into a
        function. It makes no sense to write <code>eval("return;")</code>, for example,
        because <code>return</code> is only legal within functions, and the fact that the
        evaluated string uses the same variable environment as the calling
        function does not make it part of that function. If your string would
        make sense as a standalone script (even a very short one like <code>x=0</code> ),
        it is legal to pass to <code>eval()</code>. Otherwise, <code>eval()</code> will throw a
        SyntaxError.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.12.2 Global eval()"><div class="sect2" id="globaleval">
        <h2>4.12.2 Global eval()</h2>
        
        <p>It<a data-type="indexterm" data-primary="eval() function" data-secondary="global eval()" id="idm46198557045080"></a><a data-type="indexterm" data-primary="global eval()" id="idm46198557044072"></a> is the ability of <code>eval()</code> to change local variables that is so
        problematic to JavaScript optimizers. As a workaround, however,
        interpreters simply do less optimization on any function that calls
        <code>eval()</code>. But what should a JavaScript interpreter do, however, if a
        script defines an alias for <code>eval()</code> and then calls that function by
        another name? The JavaScript specification declares that when <code>eval()</code>
        is invoked by any name other than “eval”, it should evaluate the
        string as if it were top-level global code. The evaluated code may
        define new global variables or global functions, and it may set global
        variables, but it will not use or modify any variables local to the
        calling function, and will not, therefore, interfere with local
        optimizations.</p>
        
        <p>A “direct eval” is a call to the <code>eval()</code>
        function with an expression that uses the exact, unqualified name
        “eval” (which is beginning to feel like a reserved word). Direct
        calls to <code>eval()</code> use the variable environment of the calling context.
        Any other call—an indirect call—uses the global object as its variable
        environment and cannot read, write, or define local variables or
        functions. (Both direct and indirect calls can define new variables
        only with <code>var</code>. Uses of <code>let</code> and <code>const</code> inside an evaluated string
        create variables and constants that are local to the evaluation and do
        not alter the calling or global environment.)</p>
        
        <p>The following code demonstrates:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kr">const</code> <code class="nx">geval</code> <code class="o">=</code> <code class="nb">eval</code><code class="p">;</code>               <code class="c1">// Using another name does a global eval</code>
        <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="s2">"global"</code><code class="p">,</code> <code class="nx">y</code> <code class="o">=</code> <code class="s2">"global"</code><code class="p">;</code>   <code class="c1">// Two global variables</code>
        <code class="kd">function</code> <code class="nx">f</code><code class="p">()</code> <code class="p">{</code>                    <code class="c1">// This function does a local eval</code>
            <code class="kd">let</code> <code class="nx">x</code> <code class="o">=</code> <code class="s2">"local"</code><code class="p">;</code>              <code class="c1">// Define a local variable</code>
            <code class="nb">eval</code><code class="p">(</code><code class="s2">"x += 'changed';"</code><code class="p">);</code>      <code class="c1">// Direct eval sets local variable</code>
            <code class="k">return</code> <code class="nx">x</code><code class="p">;</code>                     <code class="c1">// Return changed local variable</code>
        <code class="p">}</code>
        <code class="kd">function</code> <code class="nx">g</code><code class="p">()</code> <code class="p">{</code>                    <code class="c1">// This function does a global eval</code>
            <code class="kd">let</code> <code class="nx">y</code> <code class="o">=</code> <code class="s2">"local"</code><code class="p">;</code>              <code class="c1">// A local variable</code>
            <code class="nx">geval</code><code class="p">(</code><code class="s2">"y += 'changed';"</code><code class="p">);</code>     <code class="c1">// Indirect eval sets global variable</code>
            <code class="k">return</code> <code class="nx">y</code><code class="p">;</code>                     <code class="c1">// Return unchanged local variable</code>
        <code class="p">}</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">f</code><code class="p">(),</code> <code class="nx">x</code><code class="p">);</code> <code class="c1">// Local variable changed: prints "localchanged global":</code>
        <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">g</code><code class="p">(),</code> <code class="nx">y</code><code class="p">);</code> <code class="c1">// Global variable changed: prints "local globalchanged":</code></pre>
        
        <p>Notice that the ability to do a global eval is not just an
        accommodation to the needs of the optimizer; it is actually a
        tremendously useful feature that allows you to execute strings of code
        as if they were independent, top-level scripts. As noted at the
        <span class="keep-together">beginning</span> of this section, it is rare to truly need to evaluate a
        string of code. But if you do find it necessary, you are more likely to
        want to do a global eval than a local eval.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.12.3 Strict eval()"><div class="sect2" id="stricteval">
        <h2>4.12.3 Strict eval()</h2>
        
        <p>Strict<a data-type="indexterm" data-primary="eval() function" data-secondary="strict eval()" id="idm46198556949736"></a> mode (see <a data-type="xref" href="ch05.html#strictmode">§5.6.3</a>) imposes further
        restrictions on the behavior of the <code>eval()</code> function and even on the
        use of the identifier “eval”. When <code>eval()</code> is called from strict-mode code, or when the string of code to be evaluated itself begins
        with a “use strict” directive, then <code>eval()</code> does a local eval with a
        private variable environment. This<a data-type="indexterm" data-primary="strict mode" data-secondary="eval() function" id="idm46198556946344"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="eval() function" id="idm46198556945368"></a> means that in strict mode, evaluated
        code can query and set local variables, but it cannot define new
        variables or functions in the local scope.</p>
        
        <p>Furthermore, strict mode makes <code>eval()</code> even more operator-like by
        effectively making “eval” into a reserved word. You are not allowed
        to overwrite the <code>eval()</code> function with a new value. And you are not
        allowed to declare a variable, function, function parameter, or catch
        block parameter with the name “eval”.<a data-type="indexterm" data-primary="" data-startref="Eeval04" id="idm46198556942744"></a><a data-type="indexterm" data-primary="" data-startref="evalexp04" id="idm46198556941768"></a><a data-type="indexterm" data-primary="" data-startref="eval04" id="idm46198556940824"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.13 Miscellaneous Operators"><div class="sect1" id="I_sect13_d1e9018">
        <h1>4.13 Miscellaneous Operators</h1>
        
        <p>JavaScript supports a number of other miscellaneous operators,
        described in the following sections.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.13.1 The Conditional Operator (?:)"><div class="sect2" id="idm46198556938008">
        <h2>4.13.1 The Conditional Operator (?:)</h2>
        
        <p>The<a data-type="indexterm" data-primary="operators" data-secondary="miscellaneous operators" data-tertiary="conditional operator (?:)" id="idm46198556936200"></a><a data-type="indexterm" data-primary="conditional operator (?:)" id="idm46198556934904"></a><a data-type="indexterm" data-primary="?: (conditional operator)" id="idm46198556934216"></a> conditional operator is the only ternary operator (three operands)
        in JavaScript and is sometimes actually called the <em>ternary operator</em>.
        This operator is sometimes written <code>?:</code>, although it does not appear
        quite that way in code. Because this operator has three operands, the
        first goes before the <code>?</code>, the second goes between the <code>?</code> and the <code>:</code>,
        and the third goes after the <code>:</code>. It is used like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">x</code> <code class="o">&gt;</code> <code class="mi">0</code> <code class="o">?</code> <code class="nx">x</code> <code class="o">:</code> <code class="o">-</code><code class="nx">x</code>     <code class="c1">// The absolute value of x</code></pre>
        
        <p>The operands of the conditional operator may be of any type. The first
        operand is evaluated and interpreted as a boolean. If the value of the
        first operand is truthy, then the second operand is evaluated, and its
        value is returned. Otherwise, if the first operand is falsy, then the
        third operand is evaluated and its value is returned. Only one of the
        second and third operands is evaluated; never both.</p>
        
        <p>While you can achieve similar results using the <code>if</code> statement
        (<a data-type="xref" href="ch05.html#ifstatement">§5.3.1</a>), the <code>?:</code> operator often provides a handy shortcut.
        Here is a typical usage, which checks to be sure that a variable is
        defined (and has a meaningful, truthy value) and uses it if so or
        provides a default value if not:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">greeting</code> <code class="o">=</code> <code class="s2">"hello "</code> <code class="o">+</code> <code class="p">(</code><code class="nx">username</code> <code class="o">?</code> <code class="nx">username</code> <code class="o">:</code> <code class="s2">"there"</code><code class="p">);</code></pre>
        
        <p>This is equivalent to, but more compact than, the following <code>if</code>
        statement:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">greeting</code> <code class="o">=</code> <code class="s2">"hello "</code><code class="p">;</code>
        <code class="k">if</code> <code class="p">(</code><code class="nx">username</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">greeting</code> <code class="o">+=</code> <code class="nx">username</code><code class="p">;</code>
        <code class="p">}</code> <code class="k">else</code> <code class="p">{</code>
            <code class="nx">greeting</code> <code class="o">+=</code> <code class="s2">"there"</code><code class="p">;</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.13.2 First-Defined (??)"><div class="sect2" id="firstdefined">
        <h2>4.13.2 First-Defined (??)</h2>
        
        <p>The<a data-type="indexterm" data-primary="first-defined operator (??)" id="idm46198556793128"></a><a data-type="indexterm" data-primary="?? (first-defined operator)" id="idm46198556792072"></a><a data-type="indexterm" data-primary="operators" data-secondary="miscellaneous operators" data-tertiary="first-defined operator (??)" id="idm46198556791400"></a> first-defined operator <code>??</code> evaluates to its first defined
        operand: if its left operand is not <code>null</code> and not <code>undefined</code>, it
        returns that value. Otherwise, it returns the value of the right
        operand. Like the <code>&amp;&amp;</code> and <code>||</code> operators, <code>??</code> is short-circuiting:
        it only evaluates its second operand if the first operand evaluates to
        <code>null</code> or <code>undefined</code>.  If the expression <code>a</code> has no side effects, then
        the expression <code>a ?? b</code> is equivalent to:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">(</code><code class="nx">a</code> <code class="o">!==</code> <code class="kc">null</code> <code class="o">&amp;&amp;</code> <code class="nx">a</code> <code class="o">!==</code> <code class="kc">undefined</code><code class="p">)</code> <code class="o">?</code> <code class="nx">a</code> <code class="o">:</code> <code class="nx">b</code></pre>
        
        <p><code>??</code> is a useful alternative to <code>||</code> (<a data-type="xref" href="#logicalor">§4.10.2</a>) when you want to
        select the first <em>defined</em> operand rather than the first truthy
        operand. Although <code>||</code> is nominally a logical OR operator, it is also
        used idiomatically to select the first non-falsy operand with code
        like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// If maxWidth is truthy, use that. Otherwise, look for a value in</code>
        <code class="c1">// the preferences object. If that is not truthy, use a hardcoded constant.</code>
        <code class="kd">let</code> <code class="nx">max</code> <code class="o">=</code> <code class="nx">maxWidth</code> <code class="o">||</code> <code class="nx">preferences</code><code class="p">.</code><code class="nx">maxWidth</code> <code class="o">||</code> <code class="mi">500</code><code class="p">;</code></pre>
        
        <p>The problem with this idiomatic use is that zero, the empty string,
        and <code>false</code> are all falsy values that may be perfectly valid in some
        circumstances. In this code example, if <code>maxWidth</code> is zero, that value
        will be ignored. But if we change the <code>||</code> operator to <code>??</code>, we end up
        with an expression where zero is a valid value:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// If maxWidth is defined, use that. Otherwise, look for a value in</code>
        <code class="c1">// the preferences object. If that is not defined, use a hardcoded constant.</code>
        <code class="kd">let</code> <code class="nx">max</code> <code class="o">=</code> <code class="nx">maxWidth</code> <code class="o">??</code> <code class="nx">preferences</code><code class="p">.</code><code class="nx">maxWidth</code> <code class="o">??</code> <code class="mi">500</code><code class="p">;</code></pre>
        
        <p>Here are more examples showing how <code>??</code> works when the first operand
        is falsy. If that operand is falsy but defined, then <code>??</code> returns
        it. It is only when the first operand is “nullish” (i.e., <code>null</code> or
        <code>undefined</code>) that this operator evaluates and returns the second operand:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">options</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">timeout</code><code class="o">:</code> <code class="mi">0</code><code class="p">,</code> <code class="nx">title</code><code class="o">:</code> <code class="s2">""</code><code class="p">,</code> <code class="nx">verbose</code><code class="o">:</code> <code class="kc">false</code><code class="p">,</code> <code class="nx">n</code><code class="o">:</code> <code class="kc">null</code> <code class="p">};</code>
        <code class="nx">options</code><code class="p">.</code><code class="nx">timeout</code> <code class="o">??</code> <code class="mi">1000</code>     <code class="c1">// =&gt; 0: as defined in the object</code>
        <code class="nx">options</code><code class="p">.</code><code class="nx">title</code> <code class="o">??</code> <code class="s2">"Untitled"</code> <code class="c1">// =&gt; "": as defined in the object</code>
        <code class="nx">options</code><code class="p">.</code><code class="nx">verbose</code> <code class="o">??</code> <code class="kc">true</code>     <code class="c1">// =&gt; false: as defined in the object</code>
        <code class="nx">options</code><code class="p">.</code><code class="nx">quiet</code> <code class="o">??</code> <code class="kc">false</code>      <code class="c1">// =&gt; false: property is not defined</code>
        <code class="nx">options</code><code class="p">.</code><code class="nx">n</code> <code class="o">??</code> <code class="mi">10</code>             <code class="c1">// =&gt; 10: property is null</code></pre>
        
        <p>Note that the <code>timeout</code>, <code>title</code>, and <code>verbose</code> expressions here
        would have different values if we used <code>||</code> instead of <code>??</code>.</p>
        
        <p>The <code>??</code> operator is similar to the <code>&amp;&amp;</code> and <code>||</code> operators but does
        not have higher precedence or lower precedence than they do. If you use
        it in an expression with either of those operators, you must use
        explicit parentheses to specify which operation you want to perform
        first:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="p">(</code><code class="nx">a</code> <code class="o">??</code> <code class="nx">b</code><code class="p">)</code> <code class="o">||</code> <code class="nx">c</code>   <code class="c1">// ?? first, then ||</code>
        <code class="nx">a</code> <code class="o">??</code> <code class="p">(</code><code class="nx">b</code> <code class="o">||</code> <code class="nx">c</code><code class="p">)</code>   <code class="c1">// || first, then ??</code>
        <code class="nx">a</code> <code class="o">??</code> <code class="nx">b</code> <code class="o">||</code> <code class="nx">c</code>     <code class="c1">// SyntaxError: parentheses are required</code></pre>
        
        <p>The <code>??</code> operator is defined by<a data-type="indexterm" data-primary="ES2020" data-secondary="?? operator" id="idm46198556507080"></a> ES2020, and as of early 2020, is
        newly supported by current or beta versions of all major
        browsers. This<a data-type="indexterm" data-primary="nullish coalescing operator (??)" id="idm46198556506136"></a> operator is formally called the “nullish coalescing”
        operator, but I avoid that term because this operator selects one of
        its operands but does not “coalesce” them in any way that I can see.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.13.3 The typeof Operator"><div class="sect2" id="typeof">
        <h2>4.13.3 The typeof Operator</h2>
        
        <p><code>typeof</code> is<a data-type="indexterm" data-primary="operators" data-secondary="miscellaneous operators" data-tertiary="typeof operator" id="idm46198556503064"></a><a data-type="indexterm" data-primary="typeof operator" id="idm46198556552696"></a> a unary operator that is placed before its single operand,
        which can be of any type. Its value is a string that specifies the type
        of the operand. <a data-type="xref" href="#typeoftable">Table&nbsp;4-3</a> specifies the value of the <code>typeof</code>
        operator for any JavaScript value.</p>
        <table id="typeoftable">
        <caption><span class="label">Table 4-3. </span>Values returned by the typeof operator</caption>
        <thead>
        <tr>
        <th><code>x</code></th>
        <th><code>typeof x</code></th>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td><p><code>undefined</code></p></td>
        <td><p><code>"undefined"</code></p></td>
        </tr>
        <tr>
        <td><p><code>null</code></p></td>
        <td><p><code>"object"</code></p></td>
        </tr>
        <tr>
        <td><p><code>true</code> or <code>false</code></p></td>
        <td><p><code>"boolean"</code></p></td>
        </tr>
        <tr>
        <td><p>any number or <code>NaN</code></p></td>
        <td><p><code>"number"</code></p></td>
        </tr>
        <tr>
        <td><p>any BigInt</p></td>
        <td><p><code>"bigint"</code></p></td>
        </tr>
        <tr>
        <td><p>any string</p></td>
        <td><p><code>"string"</code></p></td>
        </tr>
        <tr>
        <td><p>any symbol</p></td>
        <td><p><code>"symbol"</code></p></td>
        </tr>
        <tr>
        <td><p>any function</p></td>
        <td><p><code>"function"</code></p></td>
        </tr>
        <tr>
        <td><p>any nonfunction object</p></td>
        <td><p><code>"object"</code></p></td>
        </tr>
        </tbody>
        </table>
        
        <p>You might use the <code>typeof</code> operator in an expression like this:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// If the value is a string, wrap it in quotes, otherwise, convert</code>
        <code class="p">(</code><code class="k">typeof</code> <code class="nx">value</code> <code class="o">===</code> <code class="s2">"string"</code><code class="p">)</code> <code class="o">?</code> <code class="s2">"'"</code> <code class="o">+</code> <code class="nx">value</code> <code class="o">+</code> <code class="s2">"'"</code> <code class="o">:</code> <code class="nx">value</code><code class="p">.</code><code class="nx">toString</code><code class="p">()</code></pre>
        
        <p>Note that <code>typeof</code> returns “object” if the operand value is <code>null</code>.
        If you want to distinguish <code>null</code> from objects, you’ll have to
        explicitly test for this special-case value.</p>
        
        <p>Although JavaScript functions are a kind of object, the <code>typeof</code>
        operator considers functions to be sufficiently different that they
        have their own return value.</p>
        
        <p>Because <code>typeof</code> evaluates to “object” for all object and array
        values other than functions, it is useful only to distinguish objects
        from other, primitive types. In order to distinguish one class of
        object from another, you must use other techniques, such as the
        <code>instanceof</code> operator (see <a data-type="xref" href="#instanceof">§4.9.4</a>), the <code>class</code> attribute (see
        <a data-type="xref" href="ch14.html#tostringtag">§14.4.3</a>), or the <code>constructor</code> property (see
        <a data-type="xref" href="ch09.html#constructorproperty">§9.2.2</a> and <a data-type="xref" href="ch14.html#prototypeattr">§14.3</a>).</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.13.4 The delete Operator"><div class="sect2" id="deleteoperator">
        <h2>4.13.4 The delete Operator</h2>
        
        <p><code>delete</code> is<a data-type="indexterm" data-primary="operators" data-secondary="miscellaneous operators" data-tertiary="delete operator" id="idm46198556450648"></a><a data-type="indexterm" data-primary="delete operator" id="idm46198556449368"></a> a unary operator that attempts to delete the object
        property or array element specified as its operand. Like the
        assignment, increment, and decrement operators, <code>delete</code> is typically
        used for its property deletion side effect and not for the value it
        returns. Some examples:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code> <code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">};</code> <code class="c1">// Start with an object</code>
        <code class="k">delete</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>            <code class="c1">// Delete one of its properties</code>
        <code class="s2">"x"</code> <code class="k">in</code> <code class="nx">o</code>               <code class="c1">// =&gt; false: the property does not exist anymore</code>
        
        <code class="kd">let</code> <code class="nx">a</code> <code class="o">=</code> <code class="p">[</code><code class="mi">1</code><code class="p">,</code><code class="mi">2</code><code class="p">,</code><code class="mi">3</code><code class="p">];</code>       <code class="c1">// Start with an array</code>
        <code class="k">delete</code> <code class="nx">a</code><code class="p">[</code><code class="mi">2</code><code class="p">];</code>           <code class="c1">// Delete the last element of the array</code>
        <code class="mi">2</code> <code class="k">in</code> <code class="nx">a</code>                 <code class="c1">// =&gt; false: array element 2 doesn't exist anymore</code>
        <code class="nx">a</code><code class="p">.</code><code class="nx">length</code>               <code class="c1">// =&gt; 3: note that array length doesn't change, though</code></pre>
        
        <p>Note that a deleted property or array element is not merely set to the
        <code>undefined</code> value. When a property is deleted, the property ceases to
        exist. Attempting to read a nonexistent property returns <code>undefined</code>,
        but you can test for the actual existence of a property with the <code>in</code>
        operator (<a data-type="xref" href="#inoperator">§4.9.3</a>). Deleting an array element leaves a “hole”
        in the array and does not change the array’s length. The resulting
        array is <em>sparse</em> (<a data-type="xref" href="ch07.html#sparsearrays">§7.3</a>).</p>
        
        <p><code>delete</code> expects its operand to be an lvalue. If it is not an lvalue,
        the operator takes no action and returns <code>true</code>. Otherwise, <code>delete</code>
        attempts to delete the specified lvalue. <code>delete</code> returns <code>true</code> if it
        successfully deletes the specified lvalue. Not all properties can be
        deleted, however: non-configurable properties
        (<a data-type="xref" href="ch14.html#propertydescriptors">§14.1</a>) are immune from <span class="keep-together">deletion.</span></p>
        
        <p>In<a data-type="indexterm" data-primary="strict mode" data-secondary="delete operator and" id="idm46198556360264"></a><a data-type="indexterm" data-primary="use strict directive" data-secondary="delete operator and" id="idm46198556359256"></a> strict mode, <code>delete</code> raises a SyntaxError if its operand is an
        unqualified identifier such as a variable, function, or function
        parameter: it only works when the operand is a property access
        expression (<a data-type="xref" href="#propertyexprs">§4.4</a>). Strict mode also specifies that
        <code>delete</code> raises a TypeError if asked to delete any non-configurable
        (i.e., nondeleteable) property. Outside of strict mode, no exception
        occurs in these cases, and <code>delete</code> simply returns <code>false</code> to indicate
        that the operand could not be deleted.</p>
        
        <p>Here are some example uses of the <code>delete</code> operator:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">o</code> <code class="o">=</code> <code class="p">{</code><code class="nx">x</code><code class="o">:</code> <code class="mi">1</code><code class="p">,</code> <code class="nx">y</code><code class="o">:</code> <code class="mi">2</code><code class="p">};</code>
        <code class="k">delete</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>   <code class="c1">// Delete one of the object properties; returns true.</code>
        <code class="k">typeof</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>   <code class="c1">// Property does not exist; returns "undefined".</code>
        <code class="k">delete</code> <code class="nx">o</code><code class="p">.</code><code class="nx">x</code><code class="p">;</code>   <code class="c1">// Delete a nonexistent property; returns true.</code>
        <code class="k">delete</code> <code class="mi">1</code><code class="p">;</code>     <code class="c1">// This makes no sense, but it just returns true.</code>
        <code class="c1">// Can't delete a variable; returns false, or SyntaxError in strict mode.</code>
        <code class="k">delete</code> <code class="nx">o</code><code class="p">;</code>
        <code class="c1">// Undeletable property: returns false, or TypeError in strict mode.</code>
        <code class="k">delete</code> <code class="nb">Object</code><code class="p">.</code><code class="nx">prototype</code><code class="p">;</code></pre>
        
        <p>We’ll see the <code>delete</code> operator again in <a data-type="xref" href="ch06.html#deletingproperties">§6.4</a>.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.13.5 The await Operator"><div class="sect2" id="idm46198556452472">
        <h2>4.13.5 The await Operator</h2>
        
        <p><code>await</code> was<a data-type="indexterm" data-primary="operators" data-secondary="miscellaneous operators" data-tertiary="await operator" id="idm46198556271400"></a><a data-type="indexterm" data-primary="await operator" id="idm46198556270120"></a> introduced in ES2017<a data-type="indexterm" data-primary="ES2017, async and await keywords" id="idm46198556269320"></a> as a way to make
        asynchronous programming more natural in JavaScript. You will need to
        read <a data-type="xref" href="ch13.html#async">Chapter&nbsp;13</a> to understand this operator. Briefly, however,
        <code>await</code> expects a Promise object (representing an asynchronous
        computation) as its sole operand, and it makes your program behave as
        if it were waiting for the asynchronous computation to complete (but
        it does this without actually blocking, and it does not prevent other
        asynchronous operations from proceeding at the same time). The value
        of the <code>await</code> operator is the fulfillment value of the Promise
        object. Importantly, <code>await</code> is only legal within functions that have
        been declared asynchronous with the <code>async</code> keyword. Again, see
        <a data-type="xref" href="ch13.html#async">Chapter&nbsp;13</a> for full details.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.13.6 The void Operator"><div class="sect2" id="idm46198556264568">
        <h2>4.13.6 The void Operator</h2>
        
        <p><code>void</code> is<a data-type="indexterm" data-primary="operators" data-secondary="miscellaneous operators" data-tertiary="void operator" id="idm46198556262952"></a><a data-type="indexterm" data-primary="void operator" id="idm46198556261672"></a> a unary operator that appears before its single operand,
        which may be of any type. This operator is unusual and infrequently
        used; it evaluates its operand, then discards the value and returns
        <code>undefined</code>. Since the operand value is discarded, using the <code>void</code>
        operator makes sense only if the operand has side effects.</p>
        
        <p>The <code>void</code> operator is so obscure that it is difficult to come up with a
        practical example of its use. One case would be when you want to
        define a function that returns nothing but also uses the arrow
        function shortcut syntax (see <a data-type="xref" href="ch08.html#arrowfunctions">§8.1.3</a>) where the body of
        the function is a single expression that is evaluated and returned. If
        you are evaluating the expression solely for its side effects and do
        not want to return its value, then the simplest thing is to use curly
        braces around the function body. But, as an alternative, you could
        also use the void operator in this case:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="kd">let</code> <code class="nx">counter</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code>
        <code class="kr">const</code> <code class="nx">increment</code> <code class="o">=</code> <code class="p">()</code> <code class="o">=&gt;</code> <code class="k">void</code> <code class="nx">counter</code><code class="o">++</code><code class="p">;</code>
        <code class="nx">increment</code><code class="p">()</code>   <code class="c1">// =&gt; undefined</code>
        <code class="nx">counter</code>       <code class="c1">// =&gt; 1</code></pre>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="4.13.7 The comma Operator (,)"><div class="sect2" id="commaoperator">
        <h2>4.13.7 The comma Operator (,)</h2>
        
        <p>The<a data-type="indexterm" data-primary="operators" data-secondary="miscellaneous operators" data-tertiary="comma operator (,)" id="idm46198556188424"></a><a data-type="indexterm" data-primary="comma operator (,)" id="idm46198556187144"></a><a data-type="indexterm" data-primary=", (comma operator)" id="idm46198556186472"></a> <code>comma</code> operator is a binary operator whose operands may be of any
        type. It evaluates its left operand, evaluates its right operand, and
        then returns the value of the right operand. Thus, the following line:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">,</code> <code class="nx">j</code><code class="o">=</code><code class="mi">1</code><code class="p">,</code> <code class="nx">k</code><code class="o">=</code><code class="mi">2</code><code class="p">;</code></pre>
        
        <p>evaluates to 2 and is basically equivalent to:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="nx">i</code> <code class="o">=</code> <code class="mi">0</code><code class="p">;</code> <code class="nx">j</code> <code class="o">=</code> <code class="mi">1</code><code class="p">;</code> <code class="nx">k</code> <code class="o">=</code> <code class="mi">2</code><code class="p">;</code></pre>
        
        <p>The lefthand expression is always evaluated, but its value is
        discarded, which means that it only makes sense to use the comma
        operator when the lefthand expression has side effects. The only
        situation in which the comma operator is commonly used is with a <code>for</code>
        loop (<a data-type="xref" href="ch05.html#forloop">§5.4.3</a>) that has multiple loop variables:</p>
        
        <pre data-type="programlisting" data-code-language="js"><code class="c1">// The first comma below is part of the syntax of the let statement</code>
        <code class="c1">// The second comma is the comma operator: it lets us squeeze 2</code>
        <code class="c1">// expressions (i++ and j--) into a statement (the for loop) that expects 1.</code>
        <code class="k">for</code><code class="p">(</code><code class="kd">let</code> <code class="nx">i</code><code class="o">=</code><code class="mi">0</code><code class="p">,</code><code class="nx">j</code><code class="o">=</code><code class="mi">10</code><code class="p">;</code> <code class="nx">i</code> <code class="o">&lt;</code> <code class="nx">j</code><code class="p">;</code> <code class="nx">i</code><code class="o">++</code><code class="p">,</code><code class="nx">j</code><code class="o">--</code><code class="p">)</code> <code class="p">{</code>
            <code class="nx">console</code><code class="p">.</code><code class="nx">log</code><code class="p">(</code><code class="nx">i</code><code class="o">+</code><code class="nx">j</code><code class="p">);</code>
        <code class="p">}</code></pre>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="4.14 Summary"><div class="sect1" id="idm46198556939320">
        <h1>4.14 Summary</h1>
        
        <p>This chapter covers a wide variety of topics, and there is lots of
        reference material here that you may want to reread in the future as
        you continue to learn JavaScript. Some key points to remember,
        however, are these:</p>
        
        <ul>
        <li>
        <p>Expressions are the phrases of a JavaScript program.</p>
        </li>
        <li>
        <p>Any expression can be <em>evaluated</em> to a JavaScript value.</p>
        </li>
        <li>
        <p>Expressions can also have side effects (such as
        variable assignment) in addition to producing a value.</p>
        </li>
        <li>
        <p>Simple expressions such as literals, variable references, and
        property accesses can be combined with operators to produce larger
        expressions.</p>
        </li>
        <li>
        <p>JavaScript defines operators for arithmetic, comparisons, Boolean
        logic, assignment, and bit manipulation, along with some
        miscellaneous operators, including the ternary conditional operator.</p>
        </li>
        <li>
        <p>The JavaScript <code>+</code> operator is used to both add numbers and
        concatenate strings.</p>
        </li>
        <li>
        <p>The logical operators <code>&amp;&amp;</code> and <code>||</code> have special “short-circuiting”
        behavior and sometimes only evaluate one of their arguments. Common
        JavaScript idioms require you to understand the special behavior of
        these operators.</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781491952016/files/epub.css" crossorigin="anonymous"></div></div></section>
</div>

 <!-- https://learning.oreilly.com -->