<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch06"><span epub:type="pagebreak" id="page_99"></span><strong><span class="big">6</span><br>SYMBOLS AND SYMBOL PROPERTIES</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">ECMAScript 6 introduces symbols as a primitive type. (The language already had five primitive types: strings, numbers, Booleans, <span class="literal">null</span>, and <span class="literal">undefined</span>.) Symbols began as a way to create private object members, a feature JavaScript developers wanted for a long time. Before symbols, any property with a string name was easy to access regardless of the obscurity of the name, and the <em>private names</em> feature was meant to let developers create non-string property names. That way, normal techniques for detecting these private names wouldn’t work.</p>
        <p class="indent">The private names proposal eventually evolved into ECMAScript 6 symbols, and this chapter teaches you how to use symbols effectively. Although <span epub:type="pagebreak" id="page_100"></span>symbols do add non-string values for property names, the goal of privacy was dropped. Instead, symbol properties are categorized separately from other object properties.</p>
        <h3 class="h3" id="ch06lev1sec01"><strong>Creating Symbols</strong></h3>
        <p class="noindent">Symbols are unique among JavaScript primitives in that they don’t have a literal form, like <span class="literal">true</span> for Booleans or <span class="literal">42</span> for numbers. You can create a symbol using the global <span class="literal">Symbol</span> function, as in this example:</p>
        <p class="programs">let firstName = Symbol();<br>let person = {};<br><br>person[firstName] = "Nicholas";<br>console.log(person[firstName]);&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"</p>
        <p class="indent">Here, the symbol <span class="literal">firstName</span> is created and used to assign a new property on the <span class="literal">person</span> object. When you use a symbol to assign a property, you must use that symbol each time you want to access the property. Be sure to name the symbol variable appropriately, so you can easily tell what the symbol represents.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Because symbols are primitive values, calling <span class="literal">new Symbol()</span> throws an error. You can create an instance of <span class="literal">Symbol</span> via <span class="literal">new Object(yourSymbol)</span> as well, but it’s unclear when this capability would be useful.</em></p>
        </div>
        <p class="indent">The <span class="literal">Symbol</span> function also accepts a description of the symbol as an optional argument. You cannot use the description to access the property, but I recommend always providing a description to make reading and debugging symbols easier. For example:</p>
        <p class="programs">let firstName = Symbol("first name");<br>let person = {};<br><br>person[firstName] = "Nicholas";<br><br>console.log("first name" in person);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(person[firstName]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"<br>console.log(firstName);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Symbol(first name)"</p>
        <p class="indent">A symbol’s description is stored internally in the <span class="literal">[[Description]]</span> property. This property is read whenever the symbol’s <span class="literal">toString()</span> method is called either explicitly or implicitly. The <span class="literal">firstName</span> symbol’s <span class="literal">toString()</span> method is called implicitly by <span class="literal">console.log()</span> in this example, so the description is printed to the log. It is not otherwise possible to access <span class="literal">[[Description]]</span> directly from code.</p>
        <div class="sidebar">
        <p class="sidebart"><span epub:type="pagebreak" id="page_101"></span><strong>IDENTIFYING SYMBOLS</strong></p>
        <p class="noindent">Because symbols are primitive values, you can use the <span class="literal">typeof</span> operator to determine whether a variable contains a symbol. ECMAScript 6 extends <span class="literal">typeof</span> to return <span class="literal">"symbol"</span> when used on a symbol. For example:</p>
        <p class="programs">let symbol = Symbol("test symbol");<br>console.log(typeof symbol);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "symbol"</p>
        <p class="indent">Although other indirect ways of determining whether a variable is a symbol are available, the <span class="literal">typeof</span> operator is the most accurate and preferred technique.</p>
        </div>
        <h3 class="h3" id="ch06lev1sec02"><strong>Using Symbols</strong></h3>
        <p class="noindent">You can use symbols anywhere you would use a computed property name. You’ve already seen bracket notation used with symbols in this chapter, but you can use symbols in computed object literal property names as well as with <span class="literal">Object.defineProperty()</span> and <span class="literal">Object.defineProperties()</span> calls:</p>
        <p class="programs">let firstName = Symbol("first name");<br><br>// use a computed object literal property<br>let person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;[firstName]: "Nicholas"<br>};<br><br>// make the property read only<br>Object.defineProperty(person, firstName, { writable: false });<br><br>let lastName = Symbol("last name");<br><br>Object.defineProperties(person, {<br>&nbsp;&nbsp;&nbsp;&nbsp;[lastName]: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: "Zakas",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writable: false<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>console.log(person[firstName]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"<br>console.log(person[lastName]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Zakas"</p>
        <p class="indent">This example first uses a computed object literal property to create the <span class="literal">firstName</span> symbol property. The property is created as nonenumerable, which is different from computed properties created using <span epub:type="pagebreak" id="page_102"></span>non-symbol names. The following line then sets the property to be read-only. Later, a read-only <span class="literal">lastName</span> symbol property is created using the <span class="literal">Object.defineProperties()</span> method. A computed object literal property is used once again, but this time it’s part of the second argument to the <span class="literal">Object.defineProperties()</span> call.</p>
        <p class="indent">Although you can use symbols in any place that computed property names are allowed, you’ll need to have a system for sharing these symbols between different pieces of code to use them effectively.</p>
        <h3 class="h3" id="ch06lev1sec03"><strong>Sharing Symbols</strong></h3>
        <p class="noindent">At times, you might want different parts of your code to share symbols. For example, suppose you have two different object types in your application that should use the same symbol property to represent a unique identifier. Keeping track of symbols across files or large codebases can be difficult and error prone. For these reasons, ECMAScript 6 provides a global symbol registry that you can access at any time.</p>
        <p class="indent">When you want to create a symbol to be shared, use the <span class="literal">Symbol.for()</span> method instead of calling the <span class="literal">Symbol()</span> method. The <span class="literal">Symbol.for()</span> method accepts a single parameter, which is a string identifier for the symbol you want to create. That parameter is also used as the symbol’s description, as shown in this example:</p>
        <p class="programs">let uid = Symbol.for("uid");<br>let object = {};<br><br>object[uid] = "12345";<br><br>console.log(object[uid]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "12345"<br>console.log(uid);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Symbol(uid)"</p>
        <p class="indent">The <span class="literal">Symbol.for()</span> method first searches the global symbol registry to see whether a symbol with the key <span class="literal">"uid"</span> exists. If so, the method returns the existing symbol. If no such symbol exists, a new symbol is created and registered to the global symbol registry using the specified key. The new symbol is then returned.</p>
        <p class="indent">Subsequent calls to <span class="literal">Symbol.for()</span> using the same key will return the same symbol, as follows:</p>
        <p class="programs">let uid = Symbol.for("uid");<br>let object = {<br>&nbsp;&nbsp;&nbsp;&nbsp;[uid]: "12345"<br>};<br><br>console.log(object[uid]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "12345"<br>console.log(uid);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Symbol(uid)"<br><br>let uid2 = Symbol.for("uid");<br><br>console.log(uid === uid2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(object[uid2]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "12345"<br>console.log(uid2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Symbol(uid)"</p>
        <p class="indent"><span epub:type="pagebreak" id="page_103"></span>In this example, <span class="literal">uid</span> and <span class="literal">uid2</span> contain the same symbol and can be used interchangeably. The first call to <span class="literal">Symbol.for()</span> creates the symbol, and the second call retrieves the symbol from the global symbol registry.</p>
        <p class="indent">Another unique aspect of shared symbols is that you can retrieve the key associated with a symbol in the global symbol registry by calling the <span class="literal">Symbol.keyFor()</span> method. For example:</p>
        <p class="programs">let uid = Symbol.for("uid");<br>console.log(Symbol.keyFor(uid));&nbsp;&nbsp;&nbsp;&nbsp;// "uid"<br><br>let uid2 = Symbol.for("uid");<br>console.log(Symbol.keyFor(uid2));&nbsp;&nbsp;&nbsp;// "uid"<br><br>let uid3 = Symbol("uid");<br>console.log(Symbol.keyFor(uid3));&nbsp;&nbsp;&nbsp;// undefined</p>
        <p class="indent">Notice that both <span class="literal">uid</span> and <span class="literal">uid2</span> return the <span class="literal">"uid"</span> key. The symbol <span class="literal">uid3</span> doesn’t exist in the global symbol registry, so it has no key associated with it and <span class="literal">Symbol.keyFor()</span> returns <span class="literal">undefined</span>.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The global symbol registry is a shared environment, just like the global scope. That means you can’t make assumptions about what is or is not already present in that environment. Use namespacing of symbol keys to reduce the likelihood of naming collisions when you’re using third-party components. For example, jQuery code might use <span class="literal">"jquery."</span> to prefix all keys for keys like <span class="literal">"jquery.element"</span> or similar keys.</em></p>
        </div>
        <h3 class="h3" id="ch06lev1sec04"><strong>Symbol Coercion</strong></h3>
        <p class="noindent">Type coercion is a significant part of JavaScript, and there’s a lot of flexibility in the language’s capability to coerce one data type into another. However, symbols are quite inflexible when it comes to coercion because other types lack a logical equivalent to a symbol. Specifically, symbols cannot be coerced into strings or numbers to prevent them from being accidentally used as properties that would otherwise be expected to behave as symbols.</p>
        <p class="indent">The examples in this chapter have used <span class="literal">console.log()</span> to indicate the output for symbols, which works because <span class="literal">console.log()</span> calls <span class="literal">String()</span> on symbols to create useful output. You can use <span class="literal">String()</span> directly to get the same result. For instance:</p>
        <p class="programs">let uid = Symbol.for("uid"),<br>&nbsp;&nbsp;&nbsp;&nbsp;desc = String(uid);<br><br>console.log(desc);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Symbol(uid)"</p>
        <p class="indent"><span epub:type="pagebreak" id="page_104"></span>The <span class="literal">String()</span> function calls <span class="literal">uid.toString()</span>, which returns the symbol’s string description. However, if you try to concatenate the symbol directly with a string, an error is thrown:</p>
        <p class="programs">var uid = Symbol.for("uid"),<br>&nbsp;&nbsp;&nbsp;&nbsp;desc = uid + "";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error!</p>
        <p class="indent">Concatenating <span class="literal">uid</span> with an empty string requires that <span class="literal">uid</span> first be coerced into a string. An error is thrown when the coercion is detected, preventing its use in this manner.</p>
        <p class="indent">Similarly, you cannot coerce a symbol to a number. All mathematical operators cause an error when they’re applied to a symbol. For example:</p>
        <p class="programs">var uid = Symbol.for("uid"),<br>&nbsp;&nbsp;&nbsp;&nbsp;sum = uid / 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error!</p>
        <p class="indent">This example attempts to divide the symbol by 1, which causes an error. Errors are thrown regardless of the mathematical operator used (logical operators do not throw an error because all symbols are considered equivalent to <span class="literal">true</span>, just like any other non-empty value in JavaScript).</p>
        <h3 class="h3" id="ch06lev1sec05"><strong>Retrieving Symbol Properties</strong></h3>
        <p class="noindent">The <span class="literal">Object.keys()</span> and <span class="literal">Object.getOwnPropertyNames()</span> methods can retrieve all property names in an object. The former method returns all enumerable property names, and the latter returns all properties regardless of enumerability. However, neither method returns symbol properties to preserve their ECMAScript 5 functionality. Instead, the <span class="literal">Object.getOwnPropertySymbols()</span> method was added in ECMAScript 6 to allow you to retrieve property symbols from an object.</p>
        <p class="indent">The return value of <span class="literal">Object.getOwnPropertySymbols()</span> is an array of own property symbols, as shown here:</p>
        <p class="programs">let uid = Symbol.for("uid");<br>let object = {<br>&nbsp;&nbsp;&nbsp;&nbsp;[uid]: "12345"<br>};<br><br>let symbols = Object.getOwnPropertySymbols(object);<br><br>console.log(symbols.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(symbols[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Symbol(uid)"<br>console.log(object[symbols[0]]);&nbsp;&nbsp;&nbsp;&nbsp;// "12345"</p>
        <p class="indent">In this code, <span class="literal">object</span> has a single symbol property called <span class="literal">uid</span>. The array that <span class="literal">Object.getOwnPropertySymbols()</span> returns is an array containing just that symbol.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_105"></span>All objects start with zero own symbol properties, but objects can inherit symbol properties from their prototypes. ECMAScript 6 predefines several such properties that are implemented using <em>well-known symbols</em>.</p>
        <h3 class="h3" id="ch06lev1sec06"><strong>Exposing Internal Operations with Well-Known Symbols</strong></h3>
        <p class="noindent">A central theme for ECMAScript 5 was exposing and defining some of the “magic” parts of JavaScript, the parts that developers couldn’t emulate at the time. ECMAScript 6 carries on that tradition by exposing even more of the previously internal logic of the language, primarily by using symbol prototype properties to define the basic behavior of certain objects.</p>
        <p class="indent">ECMAScript 6 has predefined symbols called <em>well-known symbols</em> that represent common behaviors in JavaScript that were previously considered internal-only operations. Each well-known symbol is represented by a property on the <span class="literal">Symbol</span> object, such as <span class="literal">Symbol.match</span>.</p>
        <p class="indentb">The well-known symbols are:</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.hasInstance</span></span> A method used by <span class="literal">instanceof</span> to determine an object’s inheritance</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.isConcatSpreadable</span></span> A Boolean value indicating that <span class="literal">Array.prototype.concat()</span> should flatten the collection’s elements if the collection is passed as a parameter to <span class="literal">Array.prototype.concat()</span></p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.iterator</span></span> A method that returns an iterator (covered in <a href="ch08.xhtml#ch08">Chapter 8</a>)</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.match</span></span> A method used by <span class="literal">String.prototype.match()</span> to compare strings</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.replace</span></span> A method used by <span class="literal">String.prototype.replace()</span> to replace substrings</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.search</span></span> A method used by <span class="literal">String.prototype.search()</span> to locate substrings</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.species</span></span> The constructor for making derived classes (covered in <a href="ch09.xhtml#ch09">Chapter 9</a>)</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.split</span></span> A method used by <span class="literal">String.prototype.split()</span> to split up strings</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.toPrimitive</span></span> A method that returns a primitive value representation of an object</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.toStringTag</span></span> A string used by <span class="literal">Object.prototype.toString()</span> to create an object description</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.unscopables</span></span> An object whose properties are the names of object properties that should not be included in a <span class="literal">with</span> statement</p>
        <p class="indentt">Some commonly used well-known symbols are discussed in the following sections; others are discussed throughout the rest of the book to keep them in the correct context.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_106"></span>Overwriting a method defined with a well-known symbol changes an ordinary object to an exotic object because some internal default behavior is changed. There is no practical impact on your code as a result; the way the specification describes the object just changes.</p>
        <h4 class="h4" id="ch06lev2sec01"><em><strong>The Symbol.hasInstance Method</strong></em></h4>
        <p class="noindent">Every function has a <span class="literal">Symbol.hasInstance</span> method that determines whether or not a given object is an instance of that function. The method is defined on <span class="literal">Function.prototype</span> so all functions inherit the default behavior for the <span class="literal">instanceof</span> property. The <span class="literal">Symbol.hasInstance</span> property is defined as nonwritable and nonconfigurable as well as nonenumerable to ensure it doesn’t get overwritten by mistake.</p>
        <p class="indent">The <span class="literal">Symbol.hasInstance</span> method accepts a single argument: the value to check. It returns <span class="literal">true</span> if the value passed is an instance of the function. To understand how <span class="literal">Symbol.hasInstance</span> works, consider the following:</p>
        <p class="programs">obj instanceof Array;</p>
        <p class="indent">This code is equivalent to the following:</p>
        <p class="programs">Array[Symbol.hasInstance](obj);</p>
        <p class="indent">ECMAScript 6 essentially redefined the <span class="literal">instanceof</span> operator as shorthand syntax for this method call. And now that a method call is involved, you can actually change how <span class="literal">instanceof</span> works.</p>
        <p class="indent">For instance, suppose you want to define a function that claims no object as an instance. You can do so by hardcoding the return value of <span class="literal">Symbol.hasInstance</span> to <span class="literal">false</span>, such as:</p>
        <p class="programs">function MyObject() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>Object.defineProperty(MyObject, Symbol.hasInstance, {<br>&nbsp;&nbsp;&nbsp;&nbsp;value: function(v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>let obj = new MyObject();<br><br>console.log(obj instanceof MyObject);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">You must use <span class="literal">Object.defineProperty()</span> to overwrite a nonwritable property, so this example uses that method to overwrite the <span class="literal">Symbol.hasInstance</span> method with a new function. The new function always returns <span class="literal">false</span>, so even though <span class="literal">obj</span> is actually an instance of the <span class="literal">MyObject</span> class, the <span class="literal">instanceof</span> operator returns <span class="literal">false</span> after the <span class="literal">Object.defineProperty()</span> call.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_107"></span>Of course, you can also inspect the value and decide whether or not it should be considered an instance based on any arbitrary condition. For instance, maybe numbers with values between 1 and 100 should be considered instances of a special number type. To achieve that behavior, you might write code like this:</p>
        <p class="programs">function SpecialNumber() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>Object.defineProperty(SpecialNumber, Symbol.hasInstance, {<br>&nbsp;&nbsp;&nbsp;&nbsp;value: function(v) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return (v instanceof Number) &amp;&amp; (v &gt;=1 &amp;&amp; v &lt;= 100);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>var two = new Number(2),<br>&nbsp;&nbsp;&nbsp;&nbsp;zero = new Number(0);<br><br>console.log(two instanceof SpecialNumber);&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(zero instanceof SpecialNumber);&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">This code defines a <span class="literal">Symbol.hasInstance</span> method that returns <span class="literal">true</span> if the value is an instance of <span class="literal">Number</span> and also has a value between 1 and 100. Thus, <span class="literal">SpecialNumber</span> will claim <span class="literal">two</span> as an instance, even though no directly defined relationship exists between the <span class="literal">SpecialNumber</span> function and the <span class="literal">two</span> variable. Note that the left operand to <span class="literal">instanceof</span> must be an object to trigger the <span class="literal">Symbol.hasInstance</span> call, because nonobjects cause <span class="literal">instanceof</span> to simply return <span class="literal">false</span> all the time.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>You can also overwrite the default <span class="literal">Symbol.hasInstance</span> property for all built-in functions, such as the <span class="literal">Date</span> and <span class="literal">Error</span> functions. However, this isn’t recommended because the effects on your code can be unexpected and confusing. It’s best to only overwrite <span class="literal">Symbol.hasInstance</span> on your own functions and only when necessary.</em></p>
        </div>
        <h4 class="h4" id="ch06lev2sec02"><em><strong>The Symbol.isConcatSpreadable Property</strong></em></h4>
        <p class="noindent">JavaScript arrays’ <span class="literal">concat()</span> method is designed to concatenate two arrays together. Here’s how to use that method:</p>
        <p class="programs">let colors1 = [ "red", "green" ],<br>&nbsp;&nbsp;&nbsp;&nbsp;colors2 = colors1.concat([ "blue", "black" ]);<br><br>console.log(colors2.length);&nbsp;&nbsp;&nbsp;&nbsp;// 4<br>console.log(colors2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ["red","green","blue","black"]</p>
        <p class="indent">This code concatenates a new array to the end of <span class="literal">colors1</span> and creates <span class="literal">colors2</span>, a single array with all items from both arrays. However, the <span class="literal">concat()</span> <span epub:type="pagebreak" id="page_108"></span>method can also accept nonarray arguments; in that case, those arguments are simply added to the end of the array. For example:</p>
        <p class="programs">let colors1 = [ "red", "green" ],<br>&nbsp;&nbsp;&nbsp;&nbsp;colors2 = colors1.concat([ "blue", "black" ], "brown");<br><br>console.log(colors2.length);&nbsp;&nbsp;&nbsp;&nbsp;// 5<br>console.log(colors2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ["red","green","blue","black","brown"]</p>
        <p class="indent">Here, the extra argument <span class="literal">"brown"</span> is passed to <span class="literal">concat()</span> and becomes the fifth item in the <span class="literal">colors2</span> array. Why is an array argument treated differently than a string argument? The JavaScript specification states that arrays are automatically split into their individual items and all other types are not. Prior to ECMAScript 6, there was no way to adjust this behavior.</p>
        <p class="indent">The <span class="literal">Symbol.isConcatSpreadable</span> property is a Boolean value, which indicates that an object has a <span class="literal">length</span> property and numeric keys, and that its numeric property values should be added individually to the result of a <span class="literal">concat()</span> call. Unlike other well-known symbols, this symbol property doesn’t appear on any standard objects by default. Instead, the symbol is available as a way to augment how <span class="literal">concat()</span> works on certain types of objects, effectively short-circuiting the default behavior. You can define any type to behave like arrays do in a <span class="literal">concat()</span> call, like this:</p>
        <p class="programs">let collection = {<br>&nbsp;&nbsp;&nbsp;&nbsp;0: "Hello",<br>&nbsp;&nbsp;&nbsp;&nbsp;1: "world",<br>&nbsp;&nbsp;&nbsp;&nbsp;length: 2,<br>&nbsp;&nbsp;&nbsp;&nbsp;[Symbol.isConcatSpreadable]: true<br>};<br><br>let messages = [ "Hi" ].concat(collection);<br><br>console.log(messages.length);&nbsp;&nbsp;&nbsp;&nbsp;// 3<br>console.log(messages);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ["hi","Hello","world"]</p>
        <p class="indent">The <span class="literal">collection</span> object in this example is set up to look like an array: it has a <span class="literal">length</span> property and two numeric keys. The <span class="literal">Symbol.isConcatSpreadable</span> property is set to <span class="literal">true</span> to indicate that the property values should be added as individual items to an array. When <span class="literal">collection</span> is passed to the <span class="literal">concat()</span> method, the resulting array has <span class="literal">"Hello"</span> and <span class="literal">"world"</span> as separate items after the <span class="literal">"hi"</span> element.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>You can also set <span class="literal">Symbol.isConcatSpreadable</span> to <span class="literal">false</span> on derived array classes to prevent items from being separated by <span class="literal">concat()</span> calls. See “<a href="ch09.xhtml#ch09lev1sec09">Inheritance with Derived Classes</a>” on <a href="ch09.xhtml#page_178">page 178</a>.</em></p>
        </div>
        <h4 class="h4" id="ch06lev2sec03"><span epub:type="pagebreak" id="page_109"></span><em><strong>The Symbol.match, Symbol.replace, Symbol.search, and Symbol.split Properties</strong></em></h4>
        <p class="noindentb">Strings and regular expressions have always had a close relationship in JavaScript. In particular, the string type has several methods that accept regular expressions as arguments:</p>
        <p class="hang"><span class="literal"><span class="codestrong">match(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">regex</span></span></span><span class="literal"><span class="codestrong">)</span></span> Determines whether the given string matches a regular expression</p>
        <p class="hang"><span class="literal"><span class="codestrong">replace(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">regex</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">replacement</span></span></span><span class="literal"><span class="codestrong">)</span></span> Replaces regular expression matches with a <span class="literal"><span class="codeitalic">replacement</span></span></p>
        <p class="hang"><span class="literal"><span class="codestrong">search(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">regex</span></span></span><span class="literal"><span class="codestrong">)</span></span> Locates a regular expression match inside the string</p>
        <p class="hang"><span class="literal"><span class="codestrong">split(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">regex</span></span></span><span class="literal"><span class="codestrong">)</span></span> Splits a string into an array on a regular expression match</p>
        <p class="indentt">The way these methods interacted with regular expressions was hidden from developers prior to ECMAScript 6, leaving no way to mimic regular expressions using developer-defined objects. ECMAScript 6 defines four symbols that correspond to these four methods, effectively outsourcing the native behavior to the <span class="literal">RegExp</span> built-in object.</p>
        <p class="indent">The <span class="literal">Symbol.match</span>, <span class="literal">Symbol.replace</span>, <span class="literal">Symbol.search</span>, and <span class="literal">Symbol.split</span> symbols represent methods on the regular expression argument that should be called on the first argument to the <span class="literal">match()</span> method, the <span class="literal">replace()</span> method, the <span class="literal">search()</span> method, and the <span class="literal">split()</span> method, respectively. The four symbol properties are defined on <span class="literal">RegExp.prototype</span> as the default implementation that the string methods should use.</p>
        <p class="indentb">Knowing this, you can create an object to use with the string methods in a way that is similar to regular expressions. To do so, you can use the following symbol functions in code:</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.match</span></span> Accepts a string argument and returns an array of matches, or <span class="literal">null</span> if no match is found</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.replace</span></span> Accepts a string argument and a replacement string, and returns a string</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.search</span></span> Accepts a string argument and returns the numeric index of the match, or -1 if no match is found</p>
        <p class="hang"><span class="literal"><span class="codestrong">Symbol.split</span></span> Accepts a string argument and returns an array containing pieces of the string split on the match</p>
        <p class="indentt">The ability to define these properties on an object allows you to create objects that implement pattern matching without regular expressions and use those objects in methods that expect regular expressions. Here’s an example that shows these symbols in action:</p>
        <p class="programs">// effectively equivalent to /^.{10}$/<br>let hasLengthOf10 = {<br>&nbsp;&nbsp;&nbsp;&nbsp;[Symbol.match]: function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value.length === 10 ? [value.substring(0, 10)] : null;<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br><span epub:type="pagebreak" id="page_110"></span>&nbsp;&nbsp;&nbsp;&nbsp;[Symbol.replace]: function(value, replacement) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value.length === 10 ? replacement + value.substring(10) : value;<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;[Symbol.search]: function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value.length === 10 ? 0 : -1;<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;[Symbol.split]: function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value.length === 10 ? ["", ""] : [value];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let message1 = "Hello world",&nbsp;&nbsp;&nbsp;// 11 characters<br>&nbsp;&nbsp;&nbsp;&nbsp;message2 = "Hello John";&nbsp;&nbsp;&nbsp;&nbsp;// 10 characters<br><br><br>let match1 = message1.match(hasLengthOf10),<br>&nbsp;&nbsp;&nbsp;&nbsp;match2 = message2.match(hasLengthOf10);<br><br>console.log(match1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// null<br>console.log(match2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ["Hello John"]<br><br>let replace1 = message1.replace(hasLengthOf10),<br>&nbsp;&nbsp;&nbsp;&nbsp;replace2 = message2.replace(hasLengthOf10);<br><br>console.log(replace1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello world"<br>console.log(replace2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello John"<br><br>let search1 = message1.search(hasLengthOf10),<br>&nbsp;&nbsp;&nbsp;&nbsp;search2 = message2.search(hasLengthOf10);<br><br>console.log(search1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// -1<br>console.log(search2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0<br><br>let split1 = message1.split(hasLengthOf10),<br>&nbsp;&nbsp;&nbsp;&nbsp;split2 = message2.split(hasLengthOf10);<br><br>console.log(split1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ["Hello world"]<br>console.log(split2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ["", ""]</p>
        <p class="indent">The <span class="literal">hasLengthOf10</span> object is intended to work like a regular expression that matches whenever the string length is exactly 10. Each of the four methods on <span class="literal">hasLengthOf10</span> is implemented using the appropriate symbol, and then the corresponding methods on two strings are called. The first string, <span class="literal">message1</span>, has 11 characters and will not match; the second string, <span class="literal">message2</span>, has 10 characters and will match. Despite not being a regular expression, <span class="literal">hasLengthOf10</span> is passed to each string method and used correctly due to the additional methods.</p>
        <p class="indent">Although this is a simple example, the ability to perform more complex matches than are currently possible with regular expressions opens lots of possibilities for custom pattern matchers.</p>
        <h4 class="h4" id="ch06lev2sec04"><span epub:type="pagebreak" id="page_111"></span><em><strong>The Symbol.toPrimitive Method</strong></em></h4>
        <p class="noindent">JavaScript frequently attempts to convert objects into primitive values implicitly when you apply certain operations. For instance, when you compare a string to an object using the double equals (<span class="literal">==</span>) operator, the object is converted into a primitive value before comparing. Exactly what primitive value should be used was previously an internal operation, but ECMAScript 6 exposes that value (making it changeable) through the <span class="literal">Symbol.toPrimitive</span> method.</p>
        <p class="indent">The <span class="literal">Symbol.toPrimitive</span> method is defined on the prototype of each standard type and prescribes what should happen when the object is converted into a primitive. When a primitive conversion is needed, <span class="literal">Symbol.toPrimitive</span> is called with a single argument, referred to as <span class="literal">hint</span> in the specification. The <span class="literal">hint</span> argument is one of three string values. If <span class="literal">"number"</span> is passed, <span class="literal">Symbol.toPrimitive</span> should return a number. If <span class="literal">"string"</span> is passed, a string should be returned, and if <span class="literal">"default"</span> is passed, the operation has no preference as to the type.</p>
        <p class="indent">For most standard objects, number mode has the following behaviors, which are listed in order by priority:</p>
        <ol>
        <li><p class="noindents">Call the <span class="literal">valueOf()</span> method, and if the result is a primitive value, return it.</p></li>
        <li><p class="noindents">Otherwise, call the <span class="literal">toString()</span> method, and if the result is a primitive value, return it.</p></li>
        <li><p class="noindents">Otherwise, throw an error.</p></li>
        </ol>
        <p class="indent">Similarly, for most standard objects, the behaviors of string mode have the following priority:</p>
        <ol>
        <li><p class="noindents">Call the <span class="literal">toString()</span> method, and if the result is a primitive value, return it.</p></li>
        <li><p class="noindents">Otherwise, call the <span class="literal">valueOf()</span> method, and if the result is a primitive value, return it.</p></li>
        <li><p class="noindents">Otherwise, throw an error.</p></li>
        </ol>
        <p class="indent">In many cases, standard objects treat default mode as equivalent to number mode (except for <span class="literal">Date</span>, which treats default mode as equivalent to string mode). By defining a <span class="literal">Symbol.toPrimitive</span> method, you can override these default coercion behaviors.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Default mode is used only for the <span class="literal">==</span> operator, the <span class="literal">+</span> operator, and when passing a single argument to the <span class="literal">Date</span> constructor. Most operations use string or number mode.</em></p>
        </div>
        <p class="indent">To override the default conversion behaviors, use <span class="literal">Symbol.toPrimitive</span> and assign a function as its value. For example:</p>
        <p class="programs">function Temperature(degrees) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.degrees = degrees;<br>}<br><span epub:type="pagebreak" id="page_112"></span><br>Temperature.prototype[Symbol.toPrimitive] = function(hint) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;switch (hint) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "string":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.degrees + "\u00b0"; // degrees symbol<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "number":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.degrees;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;case "default":<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.degrees + " degrees";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>var freezing = new Temperature(32);<br><br>console.log(freezing + "!");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "32 degrees!"<br>console.log(freezing / 2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 16<br>console.log(String(freezing));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "32<span class="ent">°</span>"</p>
        <p class="indent">This script defines a <span class="literal">Temperature</span> constructor and overrides the default <span class="literal">Symbol.toPrimitive</span> method on the prototype. A different value is returned depending on whether the <span class="literal">hint</span> argument indicates string, number, or default mode (the <span class="literal">hint</span> argument is filled in by the JavaScript engine). In string mode, the <span class="literal">Temperature()</span> function returns the temperature with the Unicode degrees symbol. In number mode, it returns just the numeric value, and in default mode, it appends the word <em>degrees</em> after the number.</p>
        <p class="indent">Each of the log statements triggers a different <span class="literal">hint</span> argument value. The <span class="literal">+</span> operator triggers default mode by setting <span class="literal">hint</span> to <span class="literal">"default"</span>, the <span class="literal">/</span> operator triggers number mode by setting <span class="literal">hint</span> to <span class="literal">"number"</span>, and the <span class="literal">String()</span> function triggers string mode by setting <span class="literal">hint</span> to <span class="literal">"string"</span>. Returning different values for all three modes is possible, but it’s much more common to set the default mode to be the same as string or number mode.</p>
        <h4 class="h4" id="ch06lev2sec05"><em><strong>The Symbol.toStringTag Property</strong></em></h4>
        <p class="noindent">One of the most interesting problems in JavaScript has been the existence of multiple global execution environments. This occurs in web browsers when a page includes an iframe, because the page and the iframe each has its own execution environment. In most cases, this isn’t a problem, because data can be passed back and forth between the environments with little cause for concern. The problem arises when you’re trying to identify what type of object you’re dealing with after the object has been passed between different objects.</p>
        <p class="indent">The canonical example of this issue is passing an array from an iframe into the page containing the iframe or vice versa. In ECMAScript 6 terminology, the iframe and the containing page each represent a different <em>realm</em>, which is an execution environment for JavaScript. Each realm has its own global scope with its own copy of global objects. In whichever realm <span epub:type="pagebreak" id="page_113"></span>the array is created, it is definitely an array. However, when it’s passed to a different realm, an <span class="literal">instanceof Array</span> call returns <span class="literal">false</span> because the array was created with a constructor from a different realm and <span class="literal">Array</span> represents the constructor in the current realm.</p>
        <h5 class="h5" id="ch06lev3sec01"><strong>A Workaround for the Identification Problem</strong></h5>
        <p class="noindent">Faced with the problem of identifying arrays, developers soon found a good way to do so. They discovered that by calling the standard <span class="literal">toString()</span> method on the object, a predictable string was always returned. Thus, many JavaScript libraries began including a function like this:</p>
        <p class="programs">function isArray(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return Object.prototype.toString.call(value) === "[object Array]";<br>}<br><br>console.log(isArray([]));&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">Although this solution might look a bit roundabout, it worked quite well for identifying arrays in all browsers. Using the <span class="literal">toString()</span> method on arrays isn’t helpful for identifying an object, because it returns a string representation of the items the object contains. But using the <span class="literal">toString()</span> method on <span class="literal">Object.prototype</span> had a quirk: it included an internally defined name called <span class="literal">[[Class]]</span> in the returned result. Developers could use this method on an object to retrieve what the JavaScript environment thought the object’s data type was.</p>
        <p class="indent">Developers quickly realized that because there was no way to change this behavior, it was possible to use the same approach to distinguish between native objects and those created by developers. The most important case was the ECMAScript 5 <span class="literal">JSON</span> object.</p>
        <p class="indent">Prior to ECMAScript 5, many developers used Douglas Crockford’s <em>json2.js</em>, which creates a global <span class="literal">JSON</span> object. As browsers started to implement the <span class="literal">JSON</span> global object, figuring out whether the global <span class="literal">JSON</span> was provided by the JavaScript environment or through some other library became necessary. Using the same technique I showed with the <span class="literal">isArray()</span> function, many developers created functions like this:</p>
        <p class="programs">function supportsNativeJSON() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return typeof JSON !== "undefined" &amp;&amp;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.prototype.toString.call(JSON) === "[object JSON]";<br>}</p>
        <p class="indent">The same characteristic of <span class="literal">Object.prototype</span> that allowed developers to identify arrays across iframe boundaries also provided a way to tell if <span class="literal">JSON</span> was the native <span class="literal">JSON</span> object or not. A non-native <span class="literal">JSON</span> object would return <span class="literal">[object Object]</span>, whereas the native version returned <span class="literal">[object JSON]</span> instead. This approach became the de facto standard for identifying native objects.</p>
        <h5 class="h5" id="ch06lev3sec02"><span epub:type="pagebreak" id="page_114"></span><strong>Defining Object String Tags in ECMAScript 6</strong></h5>
        <p class="noindent">ECMAScript 6 redefines the tendency of native objects to reveal their identity using <span class="literal">Object.prototype.toString()</span> through the <span class="literal">Symbol.toStringTag</span> symbol. This symbol represents a property on each object that defines what value should be produced when <span class="literal">Object.prototype.toString.call()</span> is called on it. For an array, the value that function returns is explained by storing <span class="literal">"Array"</span> in the <span class="literal">Symbol.toStringTag</span> property.</p>
        <p class="indent">Likewise, you can define the <span class="literal">Symbol.toStringTag</span> value for your own objects:</p>
        <p class="programs">function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>}<br><br>Person.prototype[Symbol.toStringTag] = "Person";<br><br>var me = new Person("Nicholas");<br><br>console.log(me.toString());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "[object Person]"<br>console.log(Object.prototype.toString.call(me));&nbsp;&nbsp;&nbsp;&nbsp;// "[object Person]"</p>
        <p class="indent">Here, a <span class="literal">Symbol.toStringTag</span> property is defined on <span class="literal">Person.prototype</span> to provide the default behavior for creating a string representation. Because <span class="literal">Person.prototype</span> inherits the <span class="literal">Object.prototype.toString()</span> method, the value returned from <span class="literal">Symbol.toStringTag</span> is also used when calling the <span class="literal">me.toString()</span> method. However, you can still define your own <span class="literal">toString()</span> method that provides a different behavior without affecting the use of the <span class="literal">Object.prototype.toString.call()</span> method. Here’s how that might look:</p>
        <p class="programs">function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>}<br><br>Person.prototype[Symbol.toStringTag] = "Person";<br><br>Person.prototype.toString = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return this.name;<br>};<br><br>var me = new Person("Nicholas");<br><br>console.log(me.toString());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"<br>console.log(Object.prototype.toString.call(me));&nbsp;&nbsp;&nbsp;&nbsp;// "[object Person]"</p>
        <p class="indent">This code defines <span class="literal">Person.prototype.toString()</span> to return the value of the <span class="literal">name</span> property. Because <span class="literal">Person</span> instances no longer inherit the <span class="literal">Object.prototype.toString()</span> method, calling <span class="literal">me.toString()</span> exhibits a different behavior.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>All objects inherit <span class="literal">Symbol.toStringTag</span> from <span class="literal">Object.prototype</span> unless otherwise specified. The string <span class="literal">"Object"</span> is the default property value.</em></p>
        </div>
        <p class="indent"><span epub:type="pagebreak" id="page_115"></span>There is no restriction on which values you can use for <span class="literal">Symbol.toStringTag</span> on developer-defined objects. For example, nothing prevents you from using <span class="literal">"Array"</span> as the value of the <span class="literal">Symbol.toStringTag</span> property, such as:</p>
        <p class="programs">function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>}<br><br>Person.prototype[Symbol.toStringTag] = "Array";<br><br>Person.prototype.toString = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return this.name;<br>};<br><br>var me = new Person("Nicholas");<br><br>console.log(me.toString());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"<br>console.log(Object.prototype.toString.call(me));&nbsp;&nbsp;&nbsp;&nbsp;// "[object Array]"</p>
        <p class="indent">The result of calling <span class="literal">Object.prototype.toString()</span> is <span class="literal">"[object Array]"</span> in this code, which is the same result you’d get from an actual array. This highlights the fact that <span class="literal">Object.prototype.toString()</span> is no longer a completely reliable way of identifying an object’s type.</p>
        <p class="indent">Changing the string tag for native objects is also possible. Just assign to <span class="literal">Symbol.toStringTag</span> on the object’s prototype, like this:</p>
        <p class="programs">Array.prototype[Symbol.toStringTag] = "Magic";<br><br>var values = [];<br><br>console.log(Object.prototype.toString.call(values));&nbsp;&nbsp;&nbsp;&nbsp;// "[object Magic]"</p>
        <p class="indent"><span class="literal">Symbol.toStringTag</span> is overwritten for arrays in this example, meaning the call to <span class="literal">Object.prototype.toString()</span> results in <span class="literal">"[object Magic]"</span> instead of <span class="literal">"[object Array]"</span>. Even though I recommended not changing built-in objects in this way, there’s nothing in the language that forbids you from doing so.</p>
        <h4 class="h4" id="ch06lev2sec06"><em><strong>The Symbol.unscopables Property</strong></em></h4>
        <p class="noindent">The <span class="literal">with</span> statement is one of the most controversial parts of JavaScript. Originally designed to avoid repetitive typing, the <span class="literal">with</span> statement was roundly criticized for making code more difficult to understand, for negative performance implications, and for being error prone. As a result, the <span class="literal">with</span> statement is not allowed in strict mode; that restriction also affects classes and modules, which are strict mode by default and have no opt-out condition.</p>
        <p class="indent">Although future code will undoubtedly not use the <span class="literal">with</span> statement, ECMAScript 6 still supports <span class="literal">with</span> in non-strict mode for backward compatibility and, as such, had to find ways to allow code that does use <span class="literal">with</span> to continue to work properly.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_116"></span>To understand the complexity of this task, consider the following code:</p>
        <p class="programs">var values = [1, 2, 3],<br>&nbsp;&nbsp;&nbsp;&nbsp;colors = ["red", "green", "blue"],<br>&nbsp;&nbsp;&nbsp;&nbsp;color = "black";<br><br>with(colors) {<br>&nbsp;&nbsp;&nbsp;&nbsp;push(color);<br>&nbsp;&nbsp;&nbsp;&nbsp;push(...values);<br>}<br><br>console.log(colors);&nbsp;&nbsp;&nbsp;&nbsp;// ["red", "green", "blue", "black", 1, 2, 3]</p>
        <p class="indent">In this example, the two calls to <span class="literal">push()</span> inside the <span class="literal">with</span> statement are equivalent to <span class="literal">colors.push()</span> because the <span class="literal">with</span> statement added <span class="literal">push</span> as a local binding. The <span class="literal">color</span> reference refers to the variable created outside the <span class="literal">with</span> statement, as does the <span class="literal">values</span> reference.</p>
        <p class="indent">But ECMAScript 6 added a <span class="literal">values</span> method to arrays. (The <span class="literal">values()</span> method is discussed in detail in <a href="ch08.xhtml#ch08">Chapter 8</a>.) As a result, in an ECMAScript 6 environment, the <span class="literal">values</span> reference inside the <span class="literal">with</span> statement should refer not to the local variable <span class="literal">values</span>, but to the array’s <span class="literal">values</span> method, which would break the code. This is why the <span class="literal">Symbol.unscopables</span> symbol exists.</p>
        <p class="indent">The <span class="literal">Symbol.unscopables</span> symbol is used on <span class="literal">Array.prototype</span> to indicate which properties shouldn’t create bindings inside a <span class="literal">with</span> statement. When present, <span class="literal">Symbol.unscopables</span> is an object whose keys are the identifiers to omit from <span class="literal">with</span> statement bindings and whose values are <span class="literal">true</span> to enforce the block. Here’s the default <span class="literal">Symbol.unscopables</span> property for arrays:</p>
        <p class="programs">// built into ECMAScript 6 by default<br>Array.prototype[Symbol.unscopables] = Object.assign(Object.create(null), {<br>&nbsp;&nbsp;&nbsp;&nbsp;copyWithin: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;entries: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;fill: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;find: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;findIndex: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;keys: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;values: true<br>});</p>
        <p class="indent">The <span class="literal">Symbol.unscopables</span> object has a <span class="literal">null</span> prototype, which is created by the <span class="literal">Object.create(null)</span> call, and contains all the new array methods in ECMAScript 6. (These methods are covered in detail in <a href="ch08.xhtml#ch08">Chapter 8</a> and <a href="ch10.xhtml#ch10">Chapter 10</a>.) Bindings for these methods are not created inside a <span class="literal">with</span> statement, allowing old code to continue working without any problem.</p>
        <p class="indent">In general, you shouldn’t need to define <span class="literal">Symbol.unscopables</span> for your objects unless you use the <span class="literal">with</span> statement and are making changes to an existing object in your code base.</p>
        <h3 class="h3" id="ch06lev1sec07"><span epub:type="pagebreak" id="page_117"></span><strong>Summary</strong></h3>
        <p class="noindent">Symbols are a new type of primitive value in JavaScript and are used to create nonenumerable properties that can’t be accessed without referencing the symbol. Although not truly private, these properties are harder to accidentally change or overwrite and are therefore suitable for functionality that needs a level of protection from developers.</p>
        <p class="indent">You can provide descriptions for symbols that allow you to identify symbol values easier. A global symbol registry allows you to use shared symbols in different parts of code by using the same description. Thus, the same symbol can be used for the same reason in multiple places.</p>
        <p class="indent">Methods like <span class="literal">Object.keys()</span> or <span class="literal">Object.getOwnPropertyNames()</span> don’t return symbols, so a new method called <span class="literal">Object.getOwnPropertySymbols()</span> was added in ECMAScript 6 to allow you to retrieve symbol properties. You can still make changes to symbol properties by calling the <span class="literal">Object.defineProperty()</span> and <span class="literal">Object.defineProperties()</span> methods.</p>
        <p class="indent">Well-known symbols define previously internal-only functionality for standard objects and use globally available symbol constants, such as the <span class="literal">Symbol.hasInstance</span> property. These symbols use the prefix <span class="literal">Symbol.</span> in the specification and allow developers to modify standard object behavior in a variety of ways.<span epub:type="pagebreak" id="page_118"></span></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com