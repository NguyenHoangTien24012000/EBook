<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch04"><span epub:type="pagebreak" id="page_67"></span><strong><span class="big">4</span><br>EXPANDED OBJECT FUNCTIONALITY</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">ECMAScript 6 focuses heavily on making objects more useful, which makes sense because nearly every value in JavaScript is some type of object. The number of objects developers use in an average JavaScript program continues to increase as the complexity of JavaScript applications increases. With more objects in a program, it has become necessary to use them more effectively.</p>
        <p class="indent">ECMAScript 6 improves the use of objects in a number of ways, from simple syntax extensions to options for manipulating and interacting with them, and this chapter covers those improvements in detail.</p>
        <h3 class="h3" id="ch04lev1sec01"><span epub:type="pagebreak" id="page_68"></span><strong>Object Categories</strong></h3>
        <p class="noindentb">JavaScript uses different terminology to describe objects in the standard as opposed to those added by execution environments, such as the browser. The ECMAScript 6 specification has clear definitions for each object category. It’s essential to understand this terminology to grasp the language as a whole. The object categories are:</p>
        <p class="hang"><strong>Ordinary objects</strong> Have all the default internal behaviors for objects in JavaScript.</p>
        <p class="hang"><strong>Exotic objects</strong> Have internal behavior that differs from the default in some way.</p>
        <p class="hang"><strong>Standard objects</strong> Defined by ECMAScript 6, such as <span class="literal">Array</span>, <span class="literal">Date</span>, and so on. Standard objects can be ordinary or exotic.</p>
        <p class="hang"><strong>Built-in objects</strong> Present in a JavaScript execution environment when a script begins to execute. All standard objects are built-in objects.</p>
        <p class="indentt">I’ll use these terms throughout the book to explain the various objects that ECMAScript 6 defines.</p>
        <h3 class="h3" id="ch04lev1sec02"><strong>Object Literal Syntax Extensions</strong></h3>
        <p class="noindent">The object literal is one of the most popular patterns in JavaScript. JSON is built on its syntax, and it’s in nearly every JavaScript file on the Internet. The object literal’s popularity is due to its succinct syntax for creating objects that would otherwise take several lines of code to create. Fortunately for developers, ECMAScript 6 makes object literals more powerful and even more succinct by extending the syntax in several ways.</p>
        <h4 class="h4" id="ch04lev2sec01"><em><strong>Property Initializer Shorthand</strong></em></h4>
        <p class="noindent">In ECMAScript 5 and earlier, object literals were simply collections of name-value pairs, meaning that some duplication could occur when property values are initialized. For example:</p>
        <p class="programs">function createPerson(name, age) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;age: age<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>}</p>
        <p class="indent">The <span class="literal">createPerson()</span> function creates an object whose property names are the same as the function parameter names. The result appears to be the duplication of <span class="literal">name</span> and <span class="literal">age</span>, even though one is the name of an object property and the other provides the value of that property. The key <span class="literal">name</span> in the returned object is assigned the value contained in the variable <span class="literal">name</span>, and the key <span class="literal">age</span> in the returned object is assigned the value contained in the variable <span class="literal">age</span>.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_69"></span>In ECMAScript 6, you can eliminate the duplication that exists around property names and local variables by using the <em>property initializer</em> shorthand syntax. When an object property name is the same as the local variable name, you can simply include the name without a colon and value. For example, <span class="literal">createPerson()</span> can be rewritten for ECMAScript 6 as follows:</p>
        <p class="programs">function createPerson(name, age) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;age<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>}</p>
        <p class="indent">When a property in an object literal only has a name, the JavaScript engine looks in the surrounding scope for a variable of the same name. If it finds one, that variable’s value is assigned to the same name on the object literal. In this example, the object literal property <span class="literal">name</span> is assigned the value of the local variable <span class="literal">name</span>.</p>
        <p class="indent">Shorthand property syntax makes object literal initialization even more succinct and helps to eliminate naming errors. Assigning a property with the same name as a local variable is a very common pattern in JavaScript, making this extension a welcome addition.</p>
        <h4 class="h4" id="ch04lev2sec02"><em><strong>Concise Methods</strong></em></h4>
        <p class="noindent">ECMAScript 6 also improves the syntax for assigning methods to object literals. In ECMAScript 5 and earlier, you must specify a name and then the full function definition to add a method to an object, as follows:</p>
        <p class="programs">var person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Nicholas",<br>&nbsp;&nbsp;&nbsp;&nbsp;sayName: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent">In ECMAScript 6, the syntax is made more concise by eliminating the colon and the <span class="literal">function</span> keyword. That means you can rewrite the example like this:</p>
        <p class="programs">var person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Nicholas",<br>&nbsp;&nbsp;&nbsp;&nbsp;sayName() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent">This shorthand syntax, also called <em>concise method</em> syntax, creates a method on the <span class="literal">person</span> object just as the previous example did. The <span class="literal">sayName()</span> property is assigned an anonymous function expression and has all the same characteristics as the ECMAScript 5 <span class="literal">sayName()</span> function. The one <span epub:type="pagebreak" id="page_70"></span>difference is that concise methods can use <span class="literal">super</span> (discussed in “<a href="ch04.xhtml#ch04lev2sec07">Easy Prototype Access with Super References</a>” on <a href="ch04.xhtml#page_77">page 77</a>), whereas the non-concise methods cannot.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The <span class="literal">name</span> property of a method created using concise method shorthand is the name used before the parentheses. In this example, the <span class="literal">name</span> property for <span class="literal">person.sayName()</span> is <span class="literal">"sayName"</span>.</em></p>
        </div>
        <h4 class="h4" id="ch04lev2sec03"><em><strong>Computed Property Names</strong></em></h4>
        <p class="noindent">ECMAScript 5 and earlier could compute property names on object instances when those properties were set with square brackets instead of dot notation. The square brackets allow you to specify property names using variables and string literals that might contain characters that would cause a syntax error if they were used in an identifier. Here’s an example:</p>
        <p class="programs">var person = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;lastName = "last name";<br><br>person["first name"] = "Nicholas";<br>person[lastName] = "Zakas";<br><br>console.log(person["first name"]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"<br>console.log(person[lastName]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Zakas"</p>
        <p class="indent">Because <span class="literal">lastName</span> is assigned a value of <span class="literal">"last name"</span>, both property names in this example use a space, making it impossible to reference them using dot notation. However, bracket notation allows any string value to be used as a property name, so assigning <span class="literal">"first name"</span> to <span class="literal">"Nicholas"</span> and <span class="literal">"last name"</span> to <span class="literal">"Zakas"</span> works.</p>
        <p class="indent">Additionally, you can use string literals directly as property names in object literals, like this:</p>
        <p class="programs">var person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;"first name": "Nicholas"<br>};<br><br>console.log(person["first name"]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"</p>
        <p class="indent">This pattern works for property names that are known ahead of time and can be represented with a string literal. However, if the property name <span class="literal">"first name"</span> were contained in a variable (as in the previous example) or had to be calculated, there would be no way to define that property using an object literal in ECMAScript 5.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_71"></span>In ECMAScript 6, computed property names are part of the object literal syntax, and they use the same square bracket notation that has been used to reference computed property names in object instances. For example:</p>
        <p class="programs">let lastName = "last name";<br><br>let person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;"first name": "Nicholas",<br>&nbsp;&nbsp;&nbsp;&nbsp;[lastName]: "Zakas"<br>};<br><br>console.log(person["first name"]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"<br>console.log(person[lastName]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Zakas"</p>
        <p class="indent">The square brackets inside the object literal indicate that the property name is computed, so its contents are evaluated as a string. That means you can also include expressions, such as the following:</p>
        <p class="programs">var suffix = " name";<br><br>var person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;["first" + suffix]: "Nicholas",<br>&nbsp;&nbsp;&nbsp;&nbsp;["last" + suffix]: "Zakas"<br>};<br><br>console.log(person["first name"]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"<br>console.log(person["last name"]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Zakas"</p>
        <p class="indent">These properties evaluate to <span class="literal">"first name"</span> and <span class="literal">"last name"</span>, and you can use those strings to reference the properties later. Anything you would put inside square brackets while using bracket notation on object instances will also work for computed property names inside object literals.</p>
        <h3 class="h3" id="ch04lev1sec03"><strong>New Methods</strong></h3>
        <p class="noindent">One of the design goals of ECMAScript, beginning with ECMAScript 5, was to avoid both creating new global functions and creating methods on <span class="literal">Object.prototype</span>. Instead, when the developers want to add new methods to the standard, they make those methods available on an appropriate existing object. As a result, the <span class="literal">Object</span> global has received an increasing number of methods when no other objects are more appropriate. ECMAScript 6 introduces a couple of new methods on the <span class="literal">Object</span> global that are designed to make certain tasks easier.</p>
        <h4 class="h4" id="ch04lev2sec04"><span epub:type="pagebreak" id="page_72"></span><em><strong>The Object.is() Method</strong></em></h4>
        <p class="noindent">When you want to compare two values in JavaScript, you’re probably used to using either the equals operator (<span class="literal">==</span>) or the identically equals operator (<span class="literal">===</span>). Many developers prefer the latter to avoid type coercion during comparison. But even the identically equals operator isn’t entirely accurate. For example, the values +0 and -0 are considered equal by <span class="literal">===</span>, even though they’re represented differently in the JavaScript engine. Also, <span class="literal">NaN === NaN</span> returns <span class="literal">false</span>, which necessitates using <span class="literal">isNaN()</span> to detect <span class="literal">NaN</span> properly.</p>
        <p class="indent">ECMAScript 6 introduces the <span class="literal">Object.is()</span> method to remedy the remaining inaccuracies of the identically equals operator. This method accepts two arguments and returns <span class="literal">true</span> if the values are equivalent. Two values are considered equivalent when they’re the same type and have the same value. Here are some examples:</p>
        <p class="programs">console.log(+0 == -0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(+0 === -0);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(Object.is(+0, -0));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>console.log(NaN == NaN);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(NaN === NaN);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(Object.is(NaN, NaN));&nbsp;&nbsp;&nbsp;// true<br><br>console.log(5 == 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(5 == "5");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(5 === 5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(5 === "5");&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(Object.is(5, 5));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(Object.is(5, "5"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">In many cases, <span class="literal">Object.is()</span> works the same as the <span class="literal">===</span> operator. The only differences are that +0 and -0 are considered not equivalent, and <span class="literal">NaN</span> is considered equivalent to <span class="literal">NaN</span>. But there’s no need to stop using equality operators. Choose whether to use <span class="literal">Object.is()</span> instead of <span class="literal">==</span> or <span class="literal">===</span> based on how those special cases affect your code.</p>
        <h4 class="h4" id="ch04lev2sec05"><em><strong>The Object.assign() Method</strong></em></h4>
        <p class="noindent"><em>Mixins</em> are among the most popular patterns for object composition in JavaScript. In a mixin, one object receives properties and methods from another object. Many JavaScript libraries have a mixin method similar to this:</p>
        <p class="programs">function mixin(receiver, supplier) {<br>&nbsp;&nbsp;&nbsp;&nbsp;Object.keys(supplier).forEach(function(key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;receiver[key] = supplier[key];<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return receiver;<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_73"></span>The <span class="literal">mixin()</span> function iterates over the own properties of <span class="literal">supplier</span> and copies them onto <span class="literal">receiver</span> (a shallow copy, where object references are shared when property values are objects). This allows the <span class="literal">receiver</span> to gain new properties without inheritance, as in this code:</p>
        <p class="programs">function EventTarget() { /*...*/ }<br>EventTarget.prototype = {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor: EventTarget,<br>&nbsp;&nbsp;&nbsp;&nbsp;emit: function() { /*...*/ },<br>&nbsp;&nbsp;&nbsp;&nbsp;on: function() { /*...*/ }<br>};<br><br>var myObject = {};<br>mixin(myObject, EventTarget.prototype);<br><br>myObject.emit("somethingChanged");</p>
        <p class="indent">Here, <span class="literal">myObject</span> receives behavior from the <span class="literal">EventTarget.prototype</span> object. This gives <span class="literal">myObject</span> the ability to publish events and subscribe to them using the <span class="literal">emit()</span> and <span class="literal">on()</span> methods, respectively.</p>
        <p class="indent">This mixin pattern became popular enough that ECMAScript 6 added the <span class="literal">Object.assign()</span> method, which behaves the same way, accepting a receiver and any number of suppliers and then returning the receiver. The name change from <span class="literal">mixin()</span> to <span class="literal">assign()</span> reflects the actual operation that occurs. Because the <span class="literal">mixin()</span> function uses the assignment operator (<span class="literal">=</span>), it cannot copy accessor properties to the receiver as accessor properties. The name <span class="literal">Object.assign()</span> was chosen to reflect this distinction.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Similar methods in various libraries might have other names for the same basic functionality; popular alternates include the <span class="literal">extend()</span> and <span class="literal">mix()</span> methods. In addition to the <span class="literal">Object.assign()</span> method, an <span class="literal">Object.mixin()</span> method was briefly added in ECMAScript 6. The primary difference was that <span class="literal">Object.mixin()</span> also copied over accessor properties, but the method was removed due to concerns over the use of <span class="literal">super</span> (discussed in “<a href="ch04.xhtml#ch04lev2sec07">Easy Prototype Access with Super References</a>” on <a href="ch04.xhtml#page_77">page 77</a>).</em></p>
        </div>
        <p class="indent">You can use <span class="literal">Object.assign()</span> anywhere you would have used the <span class="literal">mixin()</span> function. Here’s an example:</p>
        <p class="programs">function EventTarget() { /*...*/ }<br>EventTarget.prototype = {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor: EventTarget,<br>&nbsp;&nbsp;&nbsp;&nbsp;emit: function() { /*...*/ },<br>&nbsp;&nbsp;&nbsp;&nbsp;on: function() { /*...*/ }<br>}<br><br>var myObject = {}<br>Object.assign(myObject, EventTarget.prototype);<br><br>myObject.emit("somethingChanged");</p>
        <p class="indent"><span epub:type="pagebreak" id="page_74"></span>The <span class="literal">Object.assign()</span> method accepts any number of suppliers, and the receiver receives the properties in the order in which the suppliers are specified. That means the second supplier might overwrite a value from the first supplier on the receiver, which is what happens in this code snippet:</p>
        <p class="programs">var receiver = {};<br><br>Object.assign(receiver,<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: "js",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: "file.js"<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;type: "css"<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>);<br><br>console.log(receiver.type);&nbsp;&nbsp;&nbsp;&nbsp;// "css"<br>console.log(receiver.name);&nbsp;&nbsp;&nbsp;&nbsp;// "file.js"</p>
        <p class="indent">The value of <span class="literal">receiver.type</span> is <span class="literal">"css"</span> because the second supplier overwrote the value of the first.</p>
        <p class="indent">The <span class="literal">Object.assign()</span> method isn’t a significant addition to ECMAScript 6, but it does formalize a common function found in many JavaScript libraries.</p>
        <div class="sidebar">
        <p class="sidebart"><strong>WORKING WITH ACCESSOR PROPERTIES</strong></p>
        <p class="noindent">Keep in mind that <span class="literal">Object.assign()</span> doesn’t create accessor properties on the receiver when a supplier has accessor properties. Because <span class="literal">Object.assign()</span> uses the assignment operator, an accessor property on a supplier will become a data property on the receiver. For example:</p>
        <p class="programs">var receiver = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;supplier = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get name() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "file.js"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>Object.assign(receiver, supplier);<br><br>var descriptor = Object.getOwnPropertyDescriptor(receiver, "name");<br><br>console.log(descriptor.value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "file.js"<br>console.log(descriptor.get);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined</p>
        <p class="noindent">In this code, the <span class="literal">supplier</span> has an accessor property called <span class="literal">name</span>. After using the <span class="literal">Object.assign()</span> method, <span class="literal">receiver.name</span> exists as a data property with a value of <span class="literal">"file.js"</span> because <span class="literal">supplier.name</span> returned <span class="literal">"file.js"</span> when <span class="literal">Object.assign()</span> was called.</p>
        </div>
        <h3 class="h3" id="ch04lev1sec04"><span epub:type="pagebreak" id="page_75"></span><strong>Duplicate Object Literal Properties</strong></h3>
        <p class="noindent">ECMAScript 5 strict mode introduced a check for duplicate object literal properties that would throw an error if a duplicate was found. For example, this code was problematic:</p>
        <p class="programs">"use strict";<br><br>var person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Nicholas",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Greg"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// syntax error in ES5 strict mode<br>};</p>
        <p class="indent">When running in ECMAScript 5 strict mode, the second <span class="literal">name</span> property causes a syntax error. But in ECMAScript 6, the duplicate property check was removed. Strict and non-strict mode code no longer check for duplicate properties. Instead, the last property of the given name becomes the property’s actual value, as shown here:</p>
        <p class="programs">"use strict";<br><br>var person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Nicholas",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Greg"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no error in ES6 strict mode<br>};<br><br>console.log(person.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Greg"</p>
        <p class="indent">In this example, the value of <span class="literal">person.name</span> is <span class="literal">"Greg"</span> because that’s the last value assigned to the property.</p>
        <h3 class="h3" id="ch04lev1sec05"><strong>Own Property Enumeration Order</strong></h3>
        <p class="noindent">ECMAScript 5 didn’t define the enumeration order of object properties; the JavaScript engine vendors did. However, ECMAScript 6 strictly defines the order in which own properties must be returned when they’re enumerated. This affects how properties are returned using <span class="literal">Object.getOwnPropertyNames()</span> and <span class="literal">Reflect.ownKeys</span> (covered in <a href="ch12.xhtml#ch12">Chapter 12</a>). It also affects the order in which properties are processed by <span class="literal">Object.assign()</span>.</p>
        <p class="indent">The basic order for own property enumeration is:</p>
        <ol>
        <li><p class="noindents">All numeric keys in ascending order</p></li>
        <li><p class="noindents">All string keys in the order in which they were added to the object</p></li>
        <li><p class="noindents">All symbol keys (covered in <a href="ch06.xhtml#ch06">Chapter 6</a>) in the order in which they were added to the object</p></li>
        </ol>
        <p class="indent">Here’s an example:</p>
        <p class="programs">var obj = {<br>&nbsp;&nbsp;&nbsp;&nbsp;a: 1,<br><span epub:type="pagebreak" id="page_76"></span>&nbsp;&nbsp;&nbsp;&nbsp;0: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;c: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;2: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;b: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;1: 1<br>};<br><br>obj.d = 1;<br><br>console.log(Object.getOwnPropertyNames(obj).join(""));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "012acbd"</p>
        <p class="indent">The <span class="literal">Object.getOwnPropertyNames()</span> method returns the properties in <span class="literal">obj</span> in the order <span class="literal">0</span>, <span class="literal">1</span>, <span class="literal">2</span>, <span class="literal">a</span>, <span class="literal">c</span>, <span class="literal">b</span>, <span class="literal">d</span>. Note that the numeric keys are grouped together and sorted, even though they appear out of order in the object literal. The string keys come after the numeric keys and appear in the order in which they were added to <span class="literal">obj</span>. The keys in the object literal come first, followed by any dynamic keys that were added later (in this case, <span class="literal">d</span>).</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The <span class="literal">for-in</span> loop still has an unspecified enumeration order because not all JavaScript engines implement it the same way. The <span class="literal">Object.keys()</span> method and <span class="literal">JSON.stringify()</span> are both specified to use the same (unspecified) enumeration order as <span class="literal">for-in</span>.</em></p>
        </div>
        <p class="indent">Although enumeration order is a subtle change to how JavaScript works, it’s not uncommon to find programs that rely on a specific enumeration order to work correctly. ECMAScript 6, by defining the enumeration order, ensures that JavaScript code relying on enumeration will work correctly regardless of where it is executed.</p>
        <h3 class="h3" id="ch04lev1sec06"><strong>Enhancements for Prototypes</strong></h3>
        <p class="noindent">Prototypes are the foundation of inheritance in JavaScript, and ECMAScript 6 continues to make prototypes more useful. Early versions of JavaScript severely limited what you could do with prototypes. However, as the language matured and developers became more familiar with how prototypes work, it became clear that developers wanted more control over prototypes and easier ways to work with them. As a result, ECMAScript 6 introduced some improvements to prototypes.</p>
        <h4 class="h4" id="ch04lev2sec06"><em><strong>Changing an Object’s Prototype</strong></em></h4>
        <p class="noindent">Normally, an object’s prototype is specified when the object is created, via either a constructor or the <span class="literal">Object.create()</span> method. The idea that an object’s prototype remains unchanged after instantiation was one of the predominant assumptions in JavaScript programming through ECMAScript 5. ECMAScript 5 did add the <span class="literal">Object.getPrototypeOf()</span> method for retrieving the prototype of any given object, but it still lacked a standard way to change an object’s prototype after instantiation.</p>
        <p class="indent">ECMAScript 6 changes that assumption with the addition of the <span class="literal">Object.setPrototypeOf()</span> method, which allows you to change the prototype <span epub:type="pagebreak" id="page_77"></span>of any given object. The <span class="literal">Object.setPrototypeOf()</span> method accepts two arguments: the object whose prototype should change and the object that should become the first argument’s prototype. For example:</p>
        <p class="programs">let person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Hello";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let dog = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Woof";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>// prototype is person<br>let friend = Object.create(person);<br>console.log(friend.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello"<br>console.log(Object.getPrototypeOf(friend) === person);&nbsp;&nbsp;// true<br><br>// set prototype to dog<br>Object.setPrototypeOf(friend, dog);<br>console.log(friend.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Woof"<br>console.log(Object.getPrototypeOf(friend) === dog);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">This code defines two base objects: <span class="literal">person</span> and <span class="literal">dog</span>. Both objects have a <span class="literal">getGreeting()</span> method that returns a string. The object <span class="literal">friend</span> first inherits from the <span class="literal">person</span> object, meaning that <span class="literal">getGreeting()</span> outputs <span class="literal">"Hello"</span>. When the prototype becomes the <span class="literal">dog</span> object, <span class="literal">person.getGreeting()</span> outputs <span class="literal">"Woof"</span> because the original relationship to <span class="literal">person</span> is broken.</p>
        <p class="indent">The actual value of an object’s prototype is stored in an internal-only property called <span class="literal">[[Prototype]]</span>. The <span class="literal">Object.getPrototypeOf()</span> method returns the value stored in <span class="literal">[[Prototype]]</span> and <span class="literal">Object.setPrototypeOf()</span> changes the value stored in <span class="literal">[[Prototype]]</span>. However, these aren’t the only ways to work with the <span class="literal">[[Prototype]]</span> value.</p>
        <h4 class="h4" id="ch04lev2sec07"><em><strong>Easy Prototype Access with Super References</strong></em></h4>
        <p class="noindent">As previously mentioned, prototypes are very important in JavaScript, and a lot of work went into making them easier to use in ECMAScript 6. Another improvement is the introduction of <span class="literal">super</span> references, which make accessing functionality on an object’s prototype easier. For example, to override a method on an object instance so it also calls the prototype method of the same name, you’d do the following in ECMAScript 5:</p>
        <p class="programs">let person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Hello";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><span epub:type="pagebreak" id="page_78"></span><br>let dog = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Woof";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br><br>let friend = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Object.getPrototypeOf(this).getGreeting.call(this) + ", hi!";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>// set prototype to person<br>Object.setPrototypeOf(friend, person);<br>console.log(friend.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello, hi!"<br>console.log(Object.getPrototypeOf(friend) === person);&nbsp;&nbsp;// true<br><br>// set prototype to dog<br>Object.setPrototypeOf(friend, dog);<br>console.log(friend.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Woof, hi!"<br>console.log(Object.getPrototypeOf(friend) === dog);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">In this example, <span class="literal">getGreeting()</span> on <span class="literal">friend</span> calls the prototype method of the same name. The <span class="literal">Object.getPrototypeOf()</span> method ensures the correct prototype is called, and then an additional string is appended to the output. The additional <span class="literal">.call(this)</span> ensures that the <span class="literal">this</span> value inside the prototype method is set correctly.</p>
        <p class="indent">Remembering to use <span class="literal">Object.getPrototypeOf()</span> and <span class="literal">.call(this)</span> to call a method on the prototype is a bit involved, so ECMAScript 6 introduced <span class="literal">super</span>. At its simplest, <span class="literal">super</span> is a pointer to the current object’s prototype, effectively the <span class="literal">Object.getPrototypeOf(this)</span> value. Knowing that, you can simplify the <span class="literal">getGreeting()</span> method as follows:</p>
        <p class="programs">let friend = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// in the previous example, this is the same as:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// Object.getPrototypeOf(this).getGreeting.call(this)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.getGreeting() + ", hi!";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent">The call to <span class="literal">super.getGreeting()</span> is the same as <span class="literal">Object.getPrototypeOf(this).getGreeting.call(this)</span> in this context. Similarly, you can call any method on an object’s prototype by using a <span class="literal">super</span> reference, as long as it’s inside a concise method. Attempting to use <span class="literal">super</span> outside of concise methods results in a syntax error, as in this example:</p>
        <p class="programs">let friend = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting: function() {<br><span epub:type="pagebreak" id="page_79"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// syntax error<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.getGreeting() + ", hi!";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent">This example uses a named property with a function, and the call to <span class="literal">super.getGreeting()</span> results in a syntax error because <span class="literal">super</span> is invalid in this context.</p>
        <p class="indent">The <span class="literal">super</span> reference is really helpful when you have multiple levels of inheritance, because in that case, <span class="literal">Object.getPrototypeOf()</span> no longer works in all circumstances. For example:</p>
        <p class="programs">let person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Hello";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>// prototype is person<br>let friend = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Object.getPrototypeOf(this).getGreeting.call(this) + ", hi!";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br>Object.setPrototypeOf(friend, person);<br><br><br>// prototype is friend<br>let relative = Object.create(friend);<br><br>console.log(person.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello"<br>console.log(friend.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello, hi!"<br>console.log(relative.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error!</p>
        <p class="indent">When <span class="literal">relative.getGreeting()</span> is called, the call to <span class="literal">Object.getPrototypeOf()</span> results in an error. The reason is that <span class="literal">this</span> is <span class="literal">relative</span>, and the prototype of <span class="literal">relative</span> is the <span class="literal">friend</span> object. When <span class="literal">friend.getGreeting().call()</span> is called with <span class="literal">relative</span> as <span class="literal">this</span>, the process starts over again and continues to call recursively until a stack overflow error occurs.</p>
        <p class="indent">This problem is difficult to solve in ECMAScript 5, but with ECMAScript 6 and <span class="literal">super</span>, it’s easy:</p>
        <p class="programs">let person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Hello";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>// prototype is person<br>let friend = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.getGreeting() + ", hi!";<br><span epub:type="pagebreak" id="page_80"></span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br>Object.setPrototypeOf(friend, person);<br><br>// prototype is friend<br>let relative = Object.create(friend);<br><br>console.log(person.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello"<br>console.log(friend.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello, hi!"<br>console.log(relative.getGreeting());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello, hi!"</p>
        <p class="indent">Because <span class="literal">super</span> references are not dynamic, they always refer to the correct object. In this case, <span class="literal">super.getGreeting()</span> always refers to <span class="literal">person.getGreeting()</span> regardless of how many other objects inherit the method.</p>
        <h3 class="h3" id="ch04lev1sec07"><strong>A Formal Method Definition</strong></h3>
        <p class="noindent">Prior to ECMAScript 6, the concept of a “method” wasn’t formally defined. Methods were just object properties that contained functions instead of data. ECMAScript 6 formally defines a method as a function that has an internal <span class="literal">[[HomeObject]]</span> property containing the object to which the method belongs. Consider the following:</p>
        <p class="programs">let person = {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// method<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Hello";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>// not a method<br>function shareGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return "Hi!";<br>}</p>
        <p class="indent">This code example defines <span class="literal">person</span> with a single method called <span class="literal">getGreeting()</span>. The <span class="literal">[[HomeObject]]</span> for <span class="literal">getGreeting()</span> is <span class="literal">person</span> by virtue of assigning the function directly to an object. However, the <span class="literal">shareGreeting()</span> function has no <span class="literal">[[HomeObject]]</span> specified because it wasn’t assigned to an object when it was created. In most cases, this difference isn’t important, but it becomes very important when using <span class="literal">super</span> references.</p>
        <p class="indent">Any reference to <span class="literal">super</span> uses the <span class="literal">[[HomeObject]]</span> to determine what to do. The first step in the process is to call <span class="literal">Object.getPrototypeOf()</span> on the <span class="literal">[[HomeObject]]</span> to retrieve a reference to the prototype. Next, the prototype is searched for a function with the same name. Then, the <span class="literal">this</span> binding is set and the method is called. Take a look at the following example.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_81"></span>let person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Hello";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>// prototype is person<br>let friend = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getGreeting() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.getGreeting() + ", hi!";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br>Object.setPrototypeOf(friend, person);<br><br>console.log(friend.getGreeting());&nbsp;&nbsp;// "Hello, hi!"</p>
        <p class="indent">Calling <span class="literal">friend.getGreeting()</span> returns a string, which combines the value from <span class="literal">person.getGreeting()</span> with <span class="literal">", hi!"</span>. The <span class="literal">[[HomeObject]]</span> of <span class="literal">friend.getGreeting()</span> is <span class="literal">friend</span>, and the prototype of <span class="literal">friend</span> is <span class="literal">person</span>, so <span class="literal">super.getGreeting()</span> is equivalent to <span class="literal">person.getGreeting.call(this)</span>.</p>
        <h3 class="h3" id="ch04lev1sec08"><strong>Summary</strong></h3>
        <p class="noindent">Objects are the center of JavaScript programming, and ECMAScript 6 makes some helpful changes to objects that make them easier to work with and more flexible.</p>
        <p class="indent">ECMAScript 6 makes several changes to object literals. Shorthand property definitions make assigning properties with the same names as in-scope variables simpler. Computed property names allow you to specify non-literal values as property names, which you’ve been able to do in other areas of the language. Shorthand methods let you type far fewer characters to define methods on object literals by completely omitting the colon and <span class="literal">function</span> keyword. ECMAScript 6 loosens the strict mode check for duplicate object literal property names as well, meaning two properties with the same name can be in a single object literal without throwing an error.</p>
        <p class="indent">The <span class="literal">Object.assign()</span> method makes it easier to change multiple properties on a single object at once and is very useful when you use the mixin pattern. The <span class="literal">Object.is()</span> method performs strict equality on any value, effectively becoming a safer version of <span class="literal">===</span> when you’re working with special JavaScript values.</p>
        <p class="indent">ECMAScript 6 clearly defines enumeration order for own properties. Numeric keys always come first in ascending order followed by string keys in insertion order and symbol keys in insertion order.</p>
        <p class="indent">It’s now possible to modify an object’s prototype after it’s been created thanks to ECMAScript 6’s <span class="literal">Object.setPrototypeOf()</span> method.</p>
        <p class="indent">In addition, you can use the <span class="literal">super</span> keyword to call methods on an object’s prototype. The <span class="literal">this</span> binding inside a method invoked using <span class="literal">super</span> is set up to automatically work with the current value of <span class="literal">this</span>.<span epub:type="pagebreak" id="page_82"></span></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com