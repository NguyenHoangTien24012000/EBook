<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch02"><span epub:type="pagebreak" id="page_13"></span><strong><span class="big">2</span><br>STRINGS AND REGULAR EXPRESSIONS</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">Strings are arguably one of the most important data types in programming. They’re in nearly every higher-level programming language, and being able to work with them effectively is fundamental for developers to create useful programs. By extension, regular expressions are important because of the extra power they give developers to wield on strings. With these facts in mind, the creators of ECMAScript 6 improved strings and regular expressions by adding new capabilities and long-missing functionality. This chapter provides a tour of both types of changes.</p>
        <h3 class="h3" id="ch02lev1sec01"><strong>Better Unicode Support</strong></h3>
        <p class="noindent">Before ECMAScript 6, JavaScript strings assumed each 16-bit sequence, called a <em>code unit</em>, represented a single character. All string properties and methods, like the <span class="literal">length</span> property and the <span class="literal">charAt()</span> method, were based on <span epub:type="pagebreak" id="page_14"></span>these 16-bit code units. Of course, 16 bits used to be enough to contain any character. That’s no longer true thanks to the expanded character set introduced by Unicode.</p>
        <h4 class="h4" id="ch02lev2sec01"><em><strong>UTF-16 Code Points</strong></em></h4>
        <p class="noindent">Limiting character length to 16 bits wasn’t possible for Unicode’s stated goal of providing a globally unique identifier to every character in the world. These globally unique identifiers, called <em>code points</em>, are simply numbers starting at 0. Code points are what you may think of as character codes, where a number represents a character. A character encoding must encode code points into code units that are internally consistent. For UTF-16, code points can consist of many code units.</p>
        <p class="indent">The first 2<sup>16</sup> code points in UTF-16 are represented as single 16-bit code units. This range is called the <em>Basic Multilingual Plane (BMP)</em>. Everything beyond this range is considered to be in one of the <em>supplementary planes</em>, where the code points can no longer be represented in just 16 bits. UTF-16 solves this problem by introducing <em>surrogate pairs</em> in which a single code point is represented by two 16-bit code units. That means any single character in a string can be either one code unit for BMP characters, for a total of 16 bits, or two units for supplementary plane characters, for a total of 32 bits.</p>
        <p class="indent">In ECMAScript 5, all string operations work on 16-bit code units, meaning that you can get unexpected results from UTF-16 encoded strings containing surrogate pairs, as in this example:</p>
        <p class="programs">let text = "<span class="ent">𠮷</span>";<br><br>console.log(text.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(/^.$/.test(text));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(text.charAt(0));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ""<br>console.log(text.charAt(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ""<br>console.log(text.charCodeAt(0));&nbsp;&nbsp;&nbsp;&nbsp;// 55362<br>console.log(text.charCodeAt(1));&nbsp;&nbsp;&nbsp;&nbsp;// 57271</p>
        <p class="indentb">The single Unicode character <span class="literal">"</span><span class="ent">𠮷</span><span class="literal">"</span> is represented using surrogate pairs, and as such, the JavaScript string operations in this example treat the string as having two 16-bit characters. That means:</p>
        <p class="bull">• The <span class="literal">length</span> of <span class="literal">text</span> is 2 when it should be 1.</p>
        <p class="bull">• A regular expression trying to match a single character fails because it thinks there are two characters.</p>
        <p class="bull">• The <span class="literal">charAt()</span> method is unable to return a valid character string because neither set of 16 bits corresponds to a printable character.</p>
        <p class="bull">• The <span class="literal">charCodeAt()</span> method also can’t identify the character properly. It returns the appropriate 16-bit number for each code unit, but that is the closest you could get to the real value of <span class="literal">text</span> in ECMAScript 5.</p>
        <p class="indentt"><span epub:type="pagebreak" id="page_15"></span>But ECMAScript 6 enforces UTF-16 string encoding to address problems like these. Standardizing string operations based on this character encoding means that JavaScript can support functionality designed to work specifically with surrogate pairs. The rest of this section discusses a few key examples of that functionality.</p>
        <h4 class="h4" id="ch02lev2sec02"><em><strong>The codePointAt() Method</strong></em></h4>
        <p class="noindent">One method ECMAScript 6 added to fully support UTF-16 is the <span class="literal">codePointAt()</span> method, which retrieves the Unicode code point that maps to a given position in a string. This method accepts the code unit position rather than the character position and returns an integer value. Compare its results with those of <span class="literal">charCodeAt()</span>:</p>
        <p class="programs">let text = "<span class="ent">𠮷</span>a";<br><br>console.log(text.charCodeAt(0));&nbsp;&nbsp;&nbsp;&nbsp;// 55362<br>console.log(text.charCodeAt(1));&nbsp;&nbsp;&nbsp;&nbsp;// 57271<br>console.log(text.charCodeAt(2));&nbsp;&nbsp;&nbsp;&nbsp;// 97<br><br>console.log(text.codePointAt(0));&nbsp;&nbsp;&nbsp;// 134071<br>console.log(text.codePointAt(1));&nbsp;&nbsp;&nbsp;// 57271<br>console.log(text.codePointAt(2));&nbsp;&nbsp;&nbsp;// 97</p>
        <p class="indent">The <span class="literal">codePointAt()</span> method returns the same value as the <span class="literal">charCodeAt()</span> method unless it operates on non-BMP characters. The first character in <span class="literal">text</span> is non-BMP and is therefore composed of two code units, meaning the <span class="literal">length</span> property is 3 rather than 2. The <span class="literal">charCodeAt()</span> method returns only the first code unit for position 0, but <span class="literal">codePointAt()</span> returns the full code point, even though the code point spans multiple code units. Both methods return the same value for positions 1 (the second code unit of the first character) and 2 (the <span class="literal">"a"</span> character).</p>
        <p class="indent">Calling the <span class="literal">codePointAt()</span> method on a character is the easiest way to determine whether that character is represented by one or two code points. Here’s a function you could write to check:</p>
        <p class="programs">function is32Bit(c) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return c.codePointAt(0) &gt; 0xFFFF;<br>}<br><br>console.log(is32Bit("<span class="ent">𠮷</span>"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(is32Bit("a"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">The upper bound of 16-bit characters is represented in hexadecimal as <span class="literal">FFFF</span>, so any code point greater than that number must be represented by two code units, for a total of 32 bits.</p>
        <h4 class="h4" id="ch02lev2sec03"><span epub:type="pagebreak" id="page_16"></span><em><strong>The String.fromCodePoint() Method</strong></em></h4>
        <p class="noindent">When JavaScript provides a way to do something, it also provides a way to do the reverse. You can use <span class="literal">codePointAt()</span> to retrieve the code point for a character in a string, whereas <span class="literal">String.fromCodePoint()</span> produces a single-character string from a given code point. For example:</p>
        <p class="programs">console.log(String.fromCodePoint(134071));&nbsp;&nbsp;// "<span class="ent">𠮷</span>"</p>
        <p class="indent">Think of <span class="literal">String.fromCodePoint()</span> as a more complete version of the <span class="literal">String.fromCharCode()</span> method. Both give the same result for all characters in the BMP. Only when you pass code points for characters outside of the BMP is there a difference.</p>
        <h4 class="h4" id="ch02lev2sec04"><em><strong>The normalize() Method</strong></em></h4>
        <p class="noindent">Another interesting aspect of Unicode is that different characters can be considered equivalent for sorting or other comparison-based operations. There are two ways to define these relationships. The first relationship, <em>canonical equivalence</em>, means that two sequences of code points are considered interchangeable in all respects. For example, a combination of two characters can be canonically equivalent to one character. The second relationship is <em>compatibility</em>. Two compatible sequences of code points look different but can be used interchangeably in certain situations.</p>
        <p class="indent">Due to these relationships, two strings representing fundamentally the same text can contain different code point sequences. For example, the character “æ” and the two-character string “ae” can be used interchangeably but are strictly not equivalent unless normalized in some way.</p>
        <p class="indentb">ECMAScript 6 supports Unicode normalization forms by giving strings a <span class="literal">normalize()</span> method. This method optionally accepts a single string parameter that indicates that one of the following Unicode normalization forms should be applied:</p>
        <p class="bull">• Normalization Form Canonical Composition (<span class="literal">"NFC"</span>), the default</p>
        <p class="bull">• Normalization Form Canonical Decomposition (<span class="literal">"NFD"</span>)</p>
        <p class="bull">• Normalization Form Compatibility Composition (<span class="literal">"NFKC"</span>)</p>
        <p class="bull">• Normalization Form Compatibility Decomposition (<span class="literal">"NFKD"</span>)</p>
        <p class="indentt">It’s beyond the scope of this book to explain the differences between these four forms. Just keep in mind that when you’re comparing strings, both strings must be normalized to the same form. For example:</p>
        <p class="programs">let normalized = values.map(function(text) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return text.normalize();<br>});<br><br>normalized.sort(function(first, second) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (first &lt; second) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br><span epub:type="pagebreak" id="page_17"></span>&nbsp;&nbsp;&nbsp;&nbsp;} else if (first === second) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});</p>
        <p class="indent">This code converts the strings in the <span class="literal">values</span> array into a normalized form so the array can be sorted appropriately. You can also sort the original array by calling <span class="literal">normalize()</span> as part of the comparator, as follows:</p>
        <p class="programs">values.sort(function(first, second) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let firstNormalized = first.normalize(),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secondNormalized = second.normalize();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (firstNormalized &lt; secondNormalized) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else if (firstNormalized === secondNormalized) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});</p>
        <p class="indent">Once again, the most important aspect to note about this code is that both <span class="literal">first</span> and <span class="literal">second</span> are normalized in the same way. These examples used the default, <span class="literal">NFC</span>, but you can easily specify one of the others, like this:</p>
        <p class="programs">values.sort(function(first, second) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let firstNormalized = first.normalize("NFD"),<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secondNormalized = second.normalize("NFD");<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (firstNormalized &lt; secondNormalized) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else if (firstNormalized === secondNormalized) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 0;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});</p>
        <p class="indent">If you’ve never worried about Unicode normalization before, you probably won’t have much use for this method now. But if you ever work on an internationalized application, you’ll definitely find the <span class="literal">normalize()</span> method helpful.</p>
        <p class="indent">New methods aren’t the only improvements that ECMAScript 6 provides for working with Unicode strings. ECMAScript 6 also introduces the regular expression <span class="literal">u</span> flag and other changes to strings and regular expressions.</p>
        <h4 class="h4" id="ch02lev2sec05"><span epub:type="pagebreak" id="page_18"></span><em><strong>The Regular Expression u Flag</strong></em></h4>
        <p class="noindent">You can accomplish many common string operations through regular expressions. But remember that regular expressions assume 16-bit code units, where each represents a single character. To address this problem, ECMAScript 6 defines a <span class="literal">u</span> flag (which stands for <em>Unicode</em>) for use in regular expressions.</p>
        <h5 class="h5" id="ch02lev3sec01"><strong>The u Flag in Action</strong></h5>
        <p class="noindent">When a regular expression has the <span class="literal">u</span> flag set, it switches modes to work on characters, not code units. That means the regular expression should no longer treat surrogate pairs as separate characters in strings and should behave as expected. For example, consider this code:</p>
        <p class="programs">let text = "<span class="ent">𠮷</span>";<br><br>console.log(text.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(/^.$/.test(text));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(/^.$/u.test(text));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">The regular expression <span class="literal">/^.$/</span> matches any input string with a single character. When it’s used without the <span class="literal">u</span> flag, this regular expression matches on code units, so the Japanese character (which is represented by two code units) doesn’t match the regular expression. When it’s used with the <span class="literal">u</span> flag, the regular expression compares characters instead of code units, so the Japanese character matches.</p>
        <h5 class="h5" id="ch02lev3sec02"><strong>Counting Code Points</strong></h5>
        <p class="noindent">Unfortunately, ECMAScript 6 doesn’t add a method to determine how many code points a string has (the <span class="literal">length</span> property still returns the number of code units in the string), but with the <span class="literal">u</span> flag, you can use regular expressions to figure it out, as follows:</p>
        <p class="programs">function codePointLength(text) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = text.match(/[\s\S]/gu);<br>&nbsp;&nbsp;&nbsp;&nbsp;return result ? result.length : 0;<br>}<br><br>console.log(codePointLength("abc"));&nbsp;&nbsp;&nbsp;&nbsp;// 3<br>console.log(codePointLength("<span class="ent">𠮷</span>bc"));&nbsp;&nbsp;&nbsp;&nbsp;// 3</p>
        <p class="indent">This example calls <span class="literal">match()</span> to check <span class="literal">text</span> for both whitespace and nonwhitespace characters (using <span class="literal">[\s\S]</span> to ensure the pattern matches newlines) using a regular expression that is applied globally with Unicode enabled. The <span class="literal">result</span> contains an array of matches when there’s at least one match, so the array length is the number of code points in the string. In Unicode, the strings <span class="literal">"abc"</span> and <span class="literal">"</span><span class="ent">𠮷</span><span class="literal">bc"</span> have three characters, so the array length is three.</p>
        <div class="note">
        <p class="notet"><span epub:type="pagebreak" id="page_19"></span><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Although this approach works, it’s not very fast, especially when applied to long strings. You can use a string iterator (discussed in <a href="ch08.xhtml#ch08">Chapter 8</a>) as well. In general, try to minimize counting code points whenever possible.</em></p>
        </div>
        <h5 class="h5" id="ch02lev3sec03"><strong>Determining Support for the u Flag</strong></h5>
        <p class="noindent">Because the <span class="literal">u</span> flag is a syntax change, attempting to use it in JavaScript engines that aren’t compatible with ECMAScript 6 throws a syntax error. The safest way to determine if the <span class="literal">u</span> flag is supported is with a function, like this one:</p>
        <p class="programs">function hasRegExpU() {<br>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var pattern = new RegExp(".", "u");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (ex) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent">This function uses the <span class="literal">RegExp</span> constructor to pass in the <span class="literal">u</span> flag as an argument. This syntax is valid even in earlier JavaScript engines, but the constructor will throw an error if <span class="literal">u</span> isn’t supported.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>If your code still needs to work in earlier JavaScript engines, always use the <span class="literal">RegExp</span> constructor when you’re using the <span class="literal">u</span> flag. This will prevent syntax errors and allow you to optionally detect and use the <span class="literal">u</span> flag without aborting execution.</em></p>
        </div>
        <h3 class="h3" id="ch02lev1sec02"><strong>Other String Changes</strong></h3>
        <p class="noindent">JavaScript’s string manipulation abilities and utilities have always lagged behind similar features in other languages. It was only in ECMAScript 5 that a <span class="literal">trim()</span> method was added for strings, for example, and ECMAScript 6 continues extending JavaScript’s capacity to parse strings using new functionality.</p>
        <h4 class="h4" id="ch02lev2sec06"><em><strong>Methods for Identifying Substrings</strong></em></h4>
        <p class="noindentb">Developers have used the <span class="literal">indexOf()</span> method to identify strings inside other strings since JavaScript was first introduced, and they’ve long asked for easier ways to identify substrings. ECMAScript 6 includes the following three methods, which are designed to do just that:</p>
        <p class="bull">• The <span class="literal">includes()</span> method returns <span class="literal">true</span> if the given text is found anywhere within the string. It returns <span class="literal">false</span> if not.</p>
        <p class="bull">• The <span class="literal">startsWith()</span> method returns <span class="literal">true</span> if the given text is found at the beginning of the string. It returns <span class="literal">false</span> if not.</p>
        <p class="bull">• The <span class="literal">endsWith()</span> method returns <span class="literal">true</span> if the given text is found at the end of the string. It returns <span class="literal">false</span> if not.</p>
        <p class="indentt"><span epub:type="pagebreak" id="page_20"></span>Each method accepts two arguments: the text to search for and an optional index from which to start the search. When the second argument is provided, <span class="literal">includes()</span> and <span class="literal">startsWith()</span> start the match from that index, and <span class="literal">endsWith()</span> starts the match from the length of the string minus the second argument; when the second argument is omitted, <span class="literal">includes()</span> and <span class="literal">startsWith()</span> search from the beginning of the string, and <span class="literal">endsWith()</span> starts from the end. In effect, the second argument minimizes the amount of the string being searched. Here are some examples showing these three methods in action:</p>
        <p class="programs">let msg = "Hello world!";<br><br>console.log(msg.startsWith("Hello"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(msg.endsWith("!"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(msg.includes("o"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>console.log(msg.startsWith("o"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(msg.endsWith("world!"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(msg.includes("x"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>console.log(msg.startsWith("o", 4));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(msg.endsWith("o", 8));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(msg.includes("o", 8));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">The first three calls don’t include a second parameter, so they’ll search the entire string if needed. The last three calls check only part of the string. The call to <span class="literal">msg.startsWith("o", 4)</span> starts the match by looking at index 4 of the <span class="literal">msg</span> string, which is the <em>o</em> in <em>Hello</em>. The call to <span class="literal">msg.endsWith("o", 8)</span> starts the match at index 4 as well, because the <span class="literal">8</span> argument is subtracted from the string length (12). The call to <span class="literal">msg.includes("o", 8)</span> starts the match from index 8, which is the <em>r</em> in <em>world</em>.</p>
        <p class="indent">Although these three methods make identifying the existence of substrings easier, each returns only a Boolean value. If you need to find the actual position of one string within another, use the <span class="literal">indexOf()</span> or <span class="literal">lastIndexOf()</span> methods.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The <span class="literal">startsWith()</span>, <span class="literal">endsWith()</span>, and <span class="literal">includes()</span> methods will throw an error if you pass a regular expression instead of a string. In contrast, <span class="literal">indexOf()</span> and <span class="literal">lastIndexOf()</span> convert a regular expression argument into a string and then search for that string.</em></p>
        </div>
        <h4 class="h4" id="ch02lev2sec07"><em><strong>The repeat() Method</strong></em></h4>
        <p class="noindent">ECMAScript 6 also adds a <span class="literal">repeat()</span> method to strings, which accepts the number of times to repeat the string as an argument. It returns a new string containing the original string repeated the specified number of times. For example:</p>
        <p class="programs">console.log("x".repeat(3));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "xxx"<br>console.log("hello".repeat(2));&nbsp;&nbsp;&nbsp;&nbsp;// "hellohello"<br>console.log("abc".repeat(4));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "abcabcabcabc"</p>
        <p class="indent"><span epub:type="pagebreak" id="page_21"></span>This method is primarily a convenience function, and it can be especially useful when manipulating text. It’s particularly useful in code formatting utilities that need to create indentation levels, such as the following:</p>
        <p class="programs">// indent using a specified number of spaces<br>let indent = " ".repeat(4),<br>&nbsp;&nbsp;&nbsp;&nbsp;indentLevel = 0;<br><br>// whenever you increase the indent<br>let newIndent = indent.repeat(++indentLevel);</p>
        <p class="indent">The first <span class="literal">repeat()</span> call creates a string of four spaces, and the <span class="literal">indentLevel</span> variable keeps track of the indent level. Then, you can just call <span class="literal">repeat()</span> with an incremented <span class="literal">indentLevel</span> to change the number of spaces.</p>
        <p class="indent">ECMAScript 6 also makes some useful changes to regular expression functionality that don’t fit into a particular category. The next section highlights a few of these changes.</p>
        <h3 class="h3" id="ch02lev1sec03"><strong>Other Regular Expression Changes</strong></h3>
        <p class="noindent">Regular expressions are an important part of working with strings in JavaScript, and like many parts of the language, they haven’t changed much in recent versions. However, ECMAScript 6 makes several improvements to regular expressions to complement the updates to strings.</p>
        <h4 class="h4" id="ch02lev2sec08"><em><strong>The Regular Expression y Flag</strong></em></h4>
        <p class="noindent">ECMAScript 6 standardized the <span class="literal">y</span> flag after it was implemented in Firefox as a proprietary extension to regular expressions. The <span class="literal">y</span> flag affects a regular expression search’s <span class="literal">sticky</span> property, and it tells the search to start matching characters in a string at the position specified by the regular expression’s <span class="literal">lastIndex</span> property. If there is no match at that location, the regular expression stops matching. The following code shows how this works:</p>
        <p class="programs">let text = "hello1 hello2 hello3",<br>&nbsp;&nbsp;&nbsp;&nbsp;pattern = /hello\d\s?/,<br>&nbsp;&nbsp;&nbsp;&nbsp;result = pattern.exec(text),<br>&nbsp;&nbsp;&nbsp;&nbsp;globalPattern = /hello\d\s?/g,<br>&nbsp;&nbsp;&nbsp;&nbsp;globalResult = globalPattern.exec(text),<br>&nbsp;&nbsp;&nbsp;&nbsp;stickyPattern = /hello\d\s?/y,<br>&nbsp;&nbsp;&nbsp;&nbsp;stickyResult = stickyPattern.exec(text);<br><br>console.log(result[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "hello1 "<br>console.log(globalResult[0]);&nbsp;&nbsp;&nbsp;// "hello1 "<br>console.log(stickyResult[0]);&nbsp;&nbsp;&nbsp;// "hello1 "<br><br>pattern.lastIndex = 1;<br>globalPattern.lastIndex = 1;<br>stickyPattern.lastIndex = 1;<br><span epub:type="pagebreak" id="page_22"></span><br>result = pattern.exec(text);<br>globalResult = globalPattern.exec(text);<br>stickyResult = stickyPattern.exec(text);<br><br>console.log(result[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "hello1 "<br>console.log(globalResult[0]);&nbsp;&nbsp;&nbsp;// "hello2 "<br>console.log(stickyResult[0]);&nbsp;&nbsp;&nbsp;// throws an error!</p>
        <p class="indent">This example has three regular expressions. The expression in <span class="literal">pattern</span> has no flags, the one in <span class="literal">globalPattern</span> uses the <span class="literal">g</span> flag, and the one in <span class="literal">stickyPattern</span> uses the <span class="literal">y</span> flag. In the first trio of <span class="literal">console.log()</span> calls, all three regular expressions should return <span class="literal">"hello1 "</span> with a space at the end.</p>
        <p class="indent">Then, the <span class="literal">lastIndex</span> property is changed to 1 on all three patterns, meaning that the regular expression should start matching from the second character on all of them. The regular expression with no flags completely ignores the change to <span class="literal">lastIndex</span> and still matches <span class="literal">"hello1 "</span> without incident. The regular expression with the <span class="literal">g</span> flag goes on to match <span class="literal">"hello2 "</span> because it’s searching forward from the second character of the string (<span class="literal">"e"</span>). The <span class="literal">sticky</span> regular expression doesn’t match anything beginning at the second character, so <span class="literal">stickyResult</span> is <span class="literal">null</span>.</p>
        <p class="indent">The <span class="literal">y</span> flag saves the index of the next character after the last match in <span class="literal">lastIndex</span> whenever an operation is performed. If an operation results in no match, <span class="literal">lastIndex</span> is set back to 0. The global flag behaves the same way, as demonstrated here:</p>
        <p class="programs">let text = "hello1 hello2 hello3",<br>&nbsp;&nbsp;&nbsp;&nbsp;pattern = /hello\d\s?/,<br>&nbsp;&nbsp;&nbsp;&nbsp;result = pattern.exec(text),<br>&nbsp;&nbsp;&nbsp;&nbsp;globalPattern = /hello\d\s?/g,<br>&nbsp;&nbsp;&nbsp;&nbsp;globalResult = globalPattern.exec(text),<br>&nbsp;&nbsp;&nbsp;&nbsp;stickyPattern = /hello\d\s?/y,<br>&nbsp;&nbsp;&nbsp;&nbsp;stickyResult = stickyPattern.exec(text);<br><br>console.log(result[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "hello1 "<br>console.log(globalResult[0]);&nbsp;&nbsp;&nbsp;// "hello1 "<br>console.log(stickyResult[0]);&nbsp;&nbsp;&nbsp;// "hello1 "<br><br>console.log(pattern.lastIndex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0<br>console.log(globalPattern.lastIndex);&nbsp;&nbsp;&nbsp;// 7<br>console.log(stickyPattern.lastIndex);&nbsp;&nbsp;&nbsp;// 7<br><br>result = pattern.exec(text);<br>globalResult = globalPattern.exec(text);<br>stickyResult = stickyPattern.exec(text);<br><br>console.log(result[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "hello1 "<br>console.log(globalResult[0]);&nbsp;&nbsp;&nbsp;// "hello2 "<br>console.log(stickyResult[0]);&nbsp;&nbsp;&nbsp;// "hello2 "<br><br>console.log(pattern.lastIndex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0<br>console.log(globalPattern.lastIndex);&nbsp;&nbsp;&nbsp;// 14<br>console.log(stickyPattern.lastIndex);&nbsp;&nbsp;&nbsp;// 14</p>
        <p class="indent"><span epub:type="pagebreak" id="page_23"></span>For both the <span class="literal">stickyPattern</span> and <span class="literal">globalPattern</span> variables, the value of <span class="literal">lastIndex</span> changes to 7 after the first call to <span class="literal">exec()</span> and changes to 14 after the second call.</p>
        <p class="indent">You need to keep two more subtle details about the <span class="literal">y</span> flag in mind. Firstly, the <span class="literal">lastIndex</span> property is honored only when you’re calling methods that exist on the regular expression object, like the <span class="literal">exec()</span> and <span class="literal">test()</span> methods. Passing the <span class="literal">y</span> flag to a string method, such as <span class="literal">match()</span>, will not result in the sticky behavior.</p>
        <p class="indent">Secondly, when sticky regular expressions use the <span class="literal">^</span> character to match the start of a string, they only match from the start of the string (or the start of the line in multiline mode). Although <span class="literal">lastIndex</span> is 0, the <span class="literal">^</span> makes a sticky regular expression the same as a non-sticky one. If <span class="literal">lastIndex</span> doesn’t correspond to the beginning of the string in single-line mode or the beginning of a line in multiline mode, the sticky regular expression will never match.</p>
        <p class="indent">As with other regular expression flags, you can detect the presence of <span class="literal">y</span> by using a property. In this case, you’d check the <span class="literal">sticky</span> property, as follows:</p>
        <p class="programs">let pattern = /hello\d/y;<br><br>console.log(pattern.sticky);&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">The <span class="literal">sticky</span> property is set to <span class="literal">true</span> if the <span class="literal">y</span> flag is present and <span class="literal">false</span> if not. The property is read-only based on the presence of the flag and cannot be changed in code.</p>
        <p class="indent">Similar to the <span class="literal">u</span> flag, the <span class="literal">y</span> flag is a syntax change, so it will cause a syntax error in earlier JavaScript engines. You can use the following approach to detect support:</p>
        <p class="programs">function hasRegExpY() {<br>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var pattern = new RegExp(".", "y");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return true;<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (ex) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent">Just like the <span class="literal">u</span> check, this code returns <span class="literal">false</span> if it’s unable to create a regular expression with the <span class="literal">y</span> flag. Also similar to <span class="literal">u</span>, if you need to use <span class="literal">y</span> in code that runs in earlier JavaScript engines, be sure to use the <span class="literal">RegExp</span> constructor when defining those regular expressions to avoid a syntax error.</p>
        <h4 class="h4" id="ch02lev2sec09"><em><strong>Duplicating Regular Expressions</strong></em></h4>
        <p class="noindent">In ECMAScript 5, you can duplicate regular expressions by passing them into the <span class="literal">RegExp</span> constructor, like this:</p>
        <p class="programs">var re1 = /ab/i,<br>&nbsp;&nbsp;&nbsp;&nbsp;re2 = new RegExp(re1);</p>
        <p class="indent"><span epub:type="pagebreak" id="page_24"></span>The <span class="literal">re2</span> variable is just a copy of the <span class="literal">re1</span> variable. But if you provide the second argument to the <span class="literal">RegExp</span> constructor, which specifies the flags for the regular expression, your code won’t work, as in this example:</p>
        <p class="programs">var re1 = /ab/i,<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// throws an error in ES5, okay in ES6<br>&nbsp;&nbsp;&nbsp;&nbsp;re2 = new RegExp(re1, "g");</p>
        <p class="indent">If you execute this code in an ECMAScript 5 environment, you’ll get an error stating that the second argument cannot be used when the first argument is a regular expression. ECMAScript 6 changed this behavior, allowing the second argument, which overrides any flags present on the first argument. For example:</p>
        <p class="programs">let re1 = /ab/i,<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// throws an error in ES5, okay in ES6<br>&nbsp;&nbsp;&nbsp;&nbsp;re2 = new RegExp(re1, "g");<br><br><br>console.log(re1.toString());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "/ab/i"<br>console.log(re2.toString());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "/ab/g"<br><br>console.log(re1.test("ab"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(re2.test("ab"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>console.log(re1.test("AB"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(re2.test("AB"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">In this code, <span class="literal">re1</span> has the <span class="literal">i</span> (case-insensitive) flag, whereas <span class="literal">re2</span> has only the <span class="literal">g</span> (global) flag. The <span class="literal">RegExp</span> constructor duplicated the pattern from <span class="literal">re1</span> and substituted the <span class="literal">g</span> flag for the <span class="literal">i</span> flag. Without the second argument, <span class="literal">re2</span> would have the same flags as <span class="literal">re1</span>.</p>
        <h4 class="h4" id="ch02lev2sec10"><em><strong>The flags Property</strong></em></h4>
        <p class="noindent">In addition to adding a new flag and changing how you can work with flags, ECMAScript 6 added a property associated with them. In ECMAScript 5, you could get the text of a regular expression by using the <span class="literal">source</span> property, but to get the flag string, you’d have to parse the output of the <span class="literal">toString()</span> method, as shown here:</p>
        <p class="programs">function getFlags(re) {<br>&nbsp;&nbsp;&nbsp;&nbsp;var text = re.toString();<br>&nbsp;&nbsp;&nbsp;&nbsp;return text.substring(text.lastIndexOf("/") + 1, text.length);<br>}<br><br>// toString() is "/ab/g"<br>var re = /ab/g;<br><br>console.log(getFlags(re));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "g"</p>
        <p class="indent"><span epub:type="pagebreak" id="page_25"></span>This code converts a regular expression into a string and then returns the characters found after the last <span class="literal">/</span>. Those characters are the flags.</p>
        <p class="indent">ECMAScript 6 makes fetching flags easier by adding a <span class="literal">flags</span> property to pair with the <span class="literal">source</span> property. Both properties are prototype accessor properties with only a getter assigned, making them read-only. The <span class="literal">flags</span> property makes inspecting regular expressions easier for debugging and inheritance purposes.</p>
        <p class="indent">A late addition to ECMAScript 6, the <span class="literal">flags</span> property returns the string representation of any flags applied to a regular expression. For example:</p>
        <p class="programs">let re = /ab/g;<br><br>console.log(re.source);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "ab"<br>console.log(re.flags);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "g"</p>
        <p class="indent">This code fetches all flags on <span class="literal">re</span> and prints them to the console with far fewer lines of code than the <span class="literal">toString()</span> technique can. Using <span class="literal">source</span> and <span class="literal">flags</span> together allows you to extract the pieces of the regular expression that you need without parsing the regular expression string directly.</p>
        <p class="indent">The changes to strings and regular expressions discussed in this chapter so far definitely allow you to do more with them, but ECMAScript 6 improves your power over strings in a more significant way. It introduces a type of literal that makes strings more flexible.</p>
        <h3 class="h3" id="ch02lev1sec04"><strong>Template Literals</strong></h3>
        <p class="noindent">To allow developers to solve more complex problems, ECMAScript 6’s <em>template literals</em> provide syntax for creating domain-specific languages (DSLs) for working with content in a safer way than the solutions available in ECMAScript 5 and earlier versions. A DSL is a programming language designed for a specific, narrow purpose, as opposed to general-purpose languages like JavaScript. The ECMAScript wiki (<em><a href="http://wiki.ecmascript.org/doku.php?id=harmony:quasis/">http://wiki.ecmascript.org/doku.php?id=harmony:quasis/</a></em>) offers the following description on the template literal strawman:</p>
        <p class="bq">This scheme extends ECMAScript syntax with syntactic sugar to allow libraries to provide DSLs that easily produce, query, and manipulate content from other languages that are immune or resistant to injection attacks such as XSS, SQL Injection, etc.</p>
        <p class="indentb">But in reality, template literals are ECMAScript 6’s answer to the following features that JavaScript lacked in ECMAScript 5 and in earlier versions:</p>
        <p class="hang"><strong>Multiline strings</strong> A formal concept of multiline strings</p>
        <p class="hang"><strong>Basic string formatting</strong> The ability to substitute parts of the string for values contained in variables</p>
        <p class="hang"><strong>HTML escaping</strong> The ability to transform a string so it is safe to insert into HTML</p>
        <p class="indentt"><span epub:type="pagebreak" id="page_26"></span>Rather than trying to add more functionality to JavaScript’s already existing strings, template literals represent an entirely new approach to solving these problems.</p>
        <h4 class="h4" id="ch02lev2sec11"><em><strong>Basic Syntax</strong></em></h4>
        <p class="noindent">At their simplest, template literals act like regular strings delimited by backticks (<span class="literal">`</span>) instead of double or single quotes. For example, consider the following:</p>
        <p class="programs">let message = `Hello world!`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello world!"<br>console.log(typeof message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "string"<br>console.log(message.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 12</p>
        <p class="indent">This code demonstrates that the variable <span class="literal">message</span> contains a normal JavaScript string. The template literal syntax is used to create the string value, which is then assigned to the <span class="literal">message</span> variable.</p>
        <p class="indent">If you want to use a backtick in a string, just escape it with a backslash (<span class="literal">\</span>), as in this version of the <span class="literal">message</span> variable:</p>
        <p class="programs">let message = `\`Hello\` world!`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "`Hello` world!"<br>console.log(typeof message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "string"<br>console.log(message.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 14</p>
        <p class="indent">There’s no need to escape either double or single quotes inside template literals.</p>
        <h4 class="h4" id="ch02lev2sec12"><em><strong>Multiline Strings</strong></em></h4>
        <p class="noindent">JavaScript developers have wanted a way to create multiline strings since the first version of the language. But when you’re using double or single quotes, strings must be completely contained on a single line.</p>
        <h5 class="h5" id="ch02lev3sec04"><strong>Pre-ECMAScript 6 Workarounds</strong></h5>
        <p class="noindent">Thanks to a long-standing syntax bug, JavaScript does have a workaround for creating multiline strings. You can create multiline strings by using a backslash (<span class="literal">\</span>) before a newline. Here’s an example:</p>
        <p class="programs">var message = "Multiline \<br>string";<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Multiline string"</p>
        <p class="indent">The <span class="literal">message</span> string has no newlines present when printed to the console because the backslash is treated as a continuation rather than a newline.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_27"></span>To show a newline in output, you’d need to manually include it:</p>
        <p class="programs">var message = "Multiline \n\<br>string";<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Multiline<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;string"</p>
        <p class="indent">This code should print the contents of <span class="literal">message</span> on two separate lines in all major JavaScript engines; however, the behavior is defined as a bug, and many developers recommend avoiding it.</p>
        <p class="indent">Other pre-ECMAScript 6 attempts to create multiline strings usually relied on arrays or string concatenation, such as the following:</p>
        <p class="programs">var message = [<br>&nbsp;&nbsp;&nbsp;&nbsp;"Multiline ",<br>&nbsp;&nbsp;&nbsp;&nbsp;"string"<br>].join("\n");<br><br>let message = "Multiline \n" +<br>&nbsp;&nbsp;&nbsp;&nbsp;"string";</p>
        <p class="indent">All the ways developers worked around JavaScript’s lack of multiline strings weren’t very practical or convenient.</p>
        <h5 class="h5" id="ch02lev3sec05"><strong>Multiline Strings the Easy Way</strong></h5>
        <p class="noindent">ECMAScript 6’s template literals make multiline strings easy because there’s no special syntax. Just include a newline where you want, and it appears in the result, like so:</p>
        <p class="programs">let message = `Multiline<br>string`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Multiline<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;string"<br>console.log(message.length);&nbsp;&nbsp;&nbsp;&nbsp;// 16</p>
        <p class="indent">All whitespace inside the backticks is part of the string, so be careful with indentation. For example:</p>
        <p class="programs">let message = `Multiline<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Multiline<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;string"<br>console.log(message.length);&nbsp;&nbsp;&nbsp;&nbsp;// 31</p>
        <p class="indent">In this code, all whitespace before the second line of the template literal is considered part of the string.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_28"></span>If making the text align with proper indentation is important to you, consider leaving the first line of a multiline template literal empty and then indenting after that, as follows:</p>
        <p class="programs">let html = `<br>&lt;div&gt;<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;h1&gt;Title&lt;/h1&gt;<br>&lt;/div&gt;`.trim();</p>
        <p class="indent">This code begins the template literal on the first line but doesn’t have any text until the second line. The HTML tags are indented to look correct and then the <span class="literal">trim()</span> method is called to remove the initial empty line.</p>
        <p class="indent">If you prefer, you can also use <span class="literal">\n</span> in a template literal to indicate where a newline should be inserted:</p>
        <p class="programs">let message = `Multiline\nstring`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Multiline<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;string"<br>console.log(message.length);&nbsp;&nbsp;&nbsp;&nbsp;// 16</p>
        <h4 class="h4" id="ch02lev2sec13"><em><strong>Making Substitutions</strong></em></h4>
        <p class="noindent">At this point, template literals may look like fancier versions of normal JavaScript strings. The real difference between the two is in template literal <em>substitutions</em>. Substitutions allow you to embed any valid JavaScript expression inside a template literal and output the result as part of the string.</p>
        <p class="indent">Substitutions are delimited by an opening <span class="literal">${</span> and a closing <span class="literal">}</span> that can have any JavaScript expression inside. The simplest substitutions let you embed local variables directly into a resulting string, like this:</p>
        <p class="programs">let name = "Nicholas",<br>&nbsp;&nbsp;&nbsp;&nbsp;message = `Hello, ${name}.`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello, Nicholas."</p>
        <p class="indent">The substitution <span class="literal">${name}</span> accesses the local variable <span class="literal">name</span> and inserts it into the <span class="literal">message</span> string. The <span class="literal">message</span> variable then holds the result of the substitution immediately.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>A template literal can access any variable accessible in the scope in which it is defined. Attempting to use an undeclared variable in a template literal throws an error in strict and non-strict modes.</em></p>
        </div>
        <p class="indent"><span epub:type="pagebreak" id="page_29"></span>Because all substitutions are JavaScript expressions, you can substitute more than just simple variable names. You can easily embed calculations, function calls, and more. For example:</p>
        <p class="programs">let count = 10,<br>&nbsp;&nbsp;&nbsp;&nbsp;price = 0.25,<br>&nbsp;&nbsp;&nbsp;&nbsp;message = `${count} items cost $${(count * price).toFixed(2)}.`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "10 items cost $2.50."</p>
        <p class="indent">This code performs a calculation as part of the template literal. The variables <span class="literal">count</span> and <span class="literal">price</span> are multiplied together to produce a result and then are formatted to two decimal places using <span class="literal">.toFixed()</span>. The dollar sign before the second substitution is output as is because it’s not followed by an opening curly brace.</p>
        <p class="indent">Template literals are also JavaScript expressions, which means you can place a template literal inside another template literal, as in this example:</p>
        <p class="programs">let name = "Nicholas",<br>&nbsp;&nbsp;&nbsp;&nbsp;message = `Hello, ${<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;`my name is ${ name }`<br>&nbsp;&nbsp;&nbsp;&nbsp;}.`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello, my name is Nicholas."</p>
        <p class="indent">This code nests a second template literal inside the first. After the first <span class="literal">${</span> delimiter, another template literal begins. The second <span class="literal">${</span> indicates the beginning of an embedded expression inside the inner template literal. That expression is the variable <span class="literal">name</span>, which is inserted into the result.</p>
        <h4 class="h4" id="ch02lev2sec14"><em><strong>Tagged Templates</strong></em></h4>
        <p class="noindent">You’ve seen how template literals can create multiline strings and insert values into strings without concatenation. But the real power of template literals comes from tagged templates. A <em>template tag</em> performs a transformation on the template literal and returns the final string value. This tag is specified at the start of the template, just before the first <span class="literal">`</span> character, as shown here:</p>
        <p class="programs">let message = tag`Hello world`;</p>
        <p class="indent">In this example, <span class="literal">tag</span> is the template tag to apply to the <span class="literal">`Hello world`</span> template literal.</p>
        <h5 class="h5" id="ch02lev3sec06"><span epub:type="pagebreak" id="page_30"></span><strong>Defining Tags</strong></h5>
        <p class="noindent">A <em>tag</em> is simply a function that is called with the processed template literal data. The tag receives data about the template literal as individual pieces and must combine the pieces to create the result. The first argument is an array containing the literal strings as interpreted by JavaScript. Each subsequent argument is the interpreted value of each substitution.</p>
        <p class="indent">Tag functions are typically defined using rest arguments to make handling the data easier than using individual named arguments, as follows:</p>
        <p class="programs">function tag(literals, ...substitutions) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// return a string<br>}</p>
        <p class="indent">To better understand what gets passed to tags, consider the following:</p>
        <p class="programs">let count = 10,<br>&nbsp;&nbsp;&nbsp;&nbsp;price = 0.25,<br>&nbsp;&nbsp;&nbsp;&nbsp;message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;</p>
        <p class="indentb">If you had a function called <span class="literal">passthru()</span>, that function would receive three arguments when used as a template literal tag. The first argument would be a <span class="literal">literals</span> array, containing the following elements:</p>
        <p class="bull">• The empty string before the first substitution (<span class="literal">""</span>)</p>
        <p class="bull">• The string after the first substitution and before the second (<span class="literal">" items cost $"</span>)</p>
        <p class="bull">• The string after the second substitution (<span class="literal">"."</span>)</p>
        <p class="indentt">The next argument would be 10, which is the interpreted value for the <span class="literal">count</span> variable. This value becomes the first element in a <span class="literal">substitutions</span> array. The third argument would be <span class="literal">"2.50"</span>, which is the interpreted value for <span class="literal">(count * price).toFixed(2)</span> and the second element in the <span class="literal">substitutions</span> array.</p>
        <p class="indent">Note that the first item in <span class="literal">literals</span> is an empty string. This ensures that <span class="literal">literals[0]</span> is always the start of the string, just like <span class="literal">literals[literals.length - 1]</span> is always the end of the string. The number of items in the substitutions array is always one fewer than the number of items in the literals array, which means the expression <span class="literal">substitutions.length === literals.length - 1</span> is always <span class="literal">true</span>.</p>
        <p class="indent">Using this pattern, the <span class="literal">literals</span> and <span class="literal">substitutions</span> arrays can be interwoven to create a resulting string. The first item in <span class="literal">literals</span> comes first, the first item in <span class="literal">substitutions</span> is next, and so on until the string is complete. As an example, you can mimic the default behavior of a template literal by alternating values from these two arrays, as in the following code.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_31"></span>function passthru(literals, ...substitutions) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = "";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// run the loop only for the substitution count<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; substitutions.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result += literals[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result += substitutions[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// add the last literal<br>&nbsp;&nbsp;&nbsp;&nbsp;result += literals[literals.length - 1];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>}<br><br>let count = 10,<br>&nbsp;&nbsp;&nbsp;&nbsp;price = 0.25,<br>&nbsp;&nbsp;&nbsp;&nbsp;message = passthru`${count} items cost $${(count * price).toFixed(2)}.`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "10 items cost $2.50."</p>
        <p class="indent">This example defines a <span class="literal">passthru</span> tag that performs the same transformation as the default template literal behavior. The only trick is to use <span class="literal">substitutions.length</span> for the loop rather than <span class="literal">literals.length</span> to avoid accidentally going past the end of the <span class="literal">substitutions</span> array. This trick works because the relationship between <span class="literal">literals</span> and <span class="literal">substitutions</span> is well-defined in ECMAScript 6.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The values contained in <span class="literal">substitutions</span> are not necessarily strings. If an expression evaluates to a number, as in the previous example, the numeric value is passed in. Determining how such values should output in the result is part of the tag’s job.</em></p>
        </div>
        <h5 class="h5" id="ch02lev3sec07"><strong>Using Raw Values in Template Literals</strong></h5>
        <p class="noindent">Template tags also have access to raw string information, which primarily means access to character escapes before they’re transformed into their character equivalents. The simplest way to work with raw string values is to use the built-in <span class="literal">String.raw()</span> tag. For example:</p>
        <p class="programs">let message1 = `Multiline\nstring`,<br>&nbsp;&nbsp;&nbsp;&nbsp;message2 = String.raw`Multiline\nstring`;<br><br>console.log(message1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Multiline<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//&nbsp;&nbsp;string"<br>console.log(message2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Multiline\\nstring"</p>
        <p class="indent">In this code, the <span class="literal">\n</span> in <span class="literal">message1</span> is interpreted as a newline, and the <span class="literal">\n</span> in <span class="literal">message2</span> is returned in its raw form of <span class="literal">"\\n"</span> (the slash and <span class="literal">n</span> characters). Retrieving the raw string information like this allows for more complex processing when necessary.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_32"></span>The raw string information is also passed into template tags. The first argument in a tag function is an array with an extra property called <span class="literal">raw</span>. The <span class="literal">raw</span> property is an array containing the raw equivalent of each literal value. For example, the value in <span class="literal">literals[0]</span> always has an equivalent <span class="literal">literals.raw[0]</span> that contains the raw string information. Knowing that, you can mimic <span class="literal">String.raw()</span> using the following code:</p>
        <p class="programs">function raw(literals, ...substitutions) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = "";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// run the loop only for the substitution count<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; substitutions.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// use raw values instead<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result += literals.raw[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result += substitutions[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// add the last literal<br>&nbsp;&nbsp;&nbsp;&nbsp;result += literals.raw[literals.length - 1];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>}<br><br>let message = raw`Multiline\nstring`;<br><br>console.log(message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Multiline\\nstring"<br>console.log(message.length);&nbsp;&nbsp;&nbsp;&nbsp;// 17</p>
        <p class="indent">This code uses <span class="literal">literals.raw</span> instead of <span class="literal">literals</span> to output the string result. That means any character escapes, including Unicode code point escapes, will be returned in their raw form. Raw strings are helpful when you want to output a string containing code that includes character escape sequences. For instance, if you want to generate documentation about some code, you might want to output the actual code as it appears.</p>
        <h3 class="h3" id="ch02lev1sec05"><strong>Summary</strong></h3>
        <p class="noindent">Full Unicode support in ECMAScript 6 allows JavaScript to handle UTF-16 characters in logical ways. The ability to transfer between code point and character via <span class="literal">codePointAt()</span> and <span class="literal">String.fromCodePoint()</span> is an important step for string manipulation. The addition of the regular expression <span class="literal">u</span> flag makes it possible to operate on code points instead of 16-bit characters, and the <span class="literal">normalize()</span> method allows for more appropriate string comparisons.</p>
        <p class="indent">ECMAScript 6 also added new methods for working with strings, allowing you to more easily identify a substring regardless of its position in the parent string. More functionality was added to regular expressions as well.</p>
        <p class="indent">Template literals are an important addition to ECMAScript 6 that allows you to create domain-specific languages (DSLs) to make creating <span epub:type="pagebreak" id="page_33"></span>strings easier. The ability to embed variables directly into template literals means that developers have a safer tool than string concatenation for composing long strings with variables.</p>
        <p class="indent">Built-in support for multiline strings also makes template literals a useful upgrade over normal JavaScript strings, which have never had this ability. Although newlines are allowed directly inside the template literal, you can still use <span class="literal">\n</span> and other character escape sequences.</p>
        <p class="indent">Template tags are the most important part of the template literal feature for creating DSLs. Tags are functions that receive the pieces of the template literal as arguments. You can then use that data to return an appropriate string value. The data provided includes literals, their raw equivalents, and any substitution values. These pieces of information can help you determine the correct output for the tag.<span epub:type="pagebreak" id="page_34"></span></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com