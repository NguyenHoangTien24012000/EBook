<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch08"><span epub:type="pagebreak" id="page_137"></span><strong><span class="big">8</span><br>ITERATORS AND GENERATORS</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">Many programming languages have shifted from iterating over data with <span class="literal">for</span> loops, which requires initializing variables to track position in a collection, to using iterator objects that programmatically return the next item in a collection. Iterators make working with collections of data easier, and ECMAScript 6 adds iterators to JavaScript. When coupled with new array methods and new types of collections (such as sets and maps), iterators are essential for efficient data processing and you’ll find them in many parts of the language. The new <span class="literal">for-of</span> loop works with iterators; the spread operator (<span class="literal">...</span>) uses iterators; and even asynchronous programming can use iterators.</p>
        <p class="indent">This chapter covers the many uses of iterators, but before discussing those uses, it’s important to understand the history behind why iterators were added to JavaScript.</p>
        <h3 class="h3" id="ch08lev1sec01"><span epub:type="pagebreak" id="page_138"></span><strong>The Loop Problem</strong></h3>
        <p class="noindent">If you’ve ever programmed in JavaScript, you’ve probably written code that looks like this:</p>
        <p class="programs">var colors = ["red", "green", "blue"];<br><br>for (var i = 0, len = colors.length; i &lt; len; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(colors[i]);<br>}</p>
        <p class="indent">This standard <span class="literal">for</span> loop tracks the index into the <span class="literal">colors</span> array using the <span class="literal">i</span> variable. The value of <span class="literal">i</span> increments each time the loop executes if <span class="literal">i</span> isn’t larger than the length of the array (stored in <span class="literal">len</span>).</p>
        <p class="indent">Although this loop is fairly straightforward, loops grow in complexity when you nest them and need to keep track of multiple variables. Additional complexity can lead to errors, and the boilerplate nature of the <span class="literal">for</span> loop lends itself to more errors because similar code is written in multiple places. Iterators are meant to eliminate the complexity and error-prone nature of loops.</p>
        <h3 class="h3" id="ch08lev1sec02"><strong>What Are Iterators?</strong></h3>
        <p class="noindent"><em>Iterators</em> are objects with a specific interface designed for iteration. All iterator objects have a <span class="literal">next()</span> method that returns a result object. The result object has two properties: <span class="literal">value</span>, which is the next value, and <span class="literal">done</span>, which is a Boolean that’s <span class="literal">true</span> when there are no more values to return. The iterator keeps an internal pointer to a location within a collection of values, and with each call to the <span class="literal">next()</span> method, it returns the next appropriate value.</p>
        <p class="indent">If you call <span class="literal">next()</span> after the last value has been returned, the method returns <span class="literal">done</span> as <span class="literal">true</span> and <span class="literal">value</span> contains the <em>return value</em> for the iterator. That return value is not part of the data set; rather, it’s a final piece of related data or <span class="literal">undefined</span> if no such data exists. An iterator’s return value is similar to a function’s return value in that it’s a final way to pass information to the caller.</p>
        <p class="indent">With this information in mind, creating an iterator using ECMAScript 5 is possible, as shown here:</p>
        <p class="programs">function createIterator(items) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;var i = 0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;next: function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var done = (i &gt;= items.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var value = !done ? items[i++] : undefined;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;done: done,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: value<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>}<br><br>var iterator = createIterator([1, 2, 3]);<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 2, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 3, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"<br><br>// for all further calls<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent"><span epub:type="pagebreak" id="page_139"></span>The <span class="literal">createIterator()</span> function returns an object with a <span class="literal">next()</span> method. Each time the method is called, the next value in the <span class="literal">items</span> array is returned as <span class="literal">value</span>. When <span class="literal">i</span> is 3, <span class="literal">done</span> becomes <span class="literal">true</span> and the ternary conditional operator that sets <span class="literal">value</span> evaluates to <span class="literal">undefined</span>. These two results fulfill the special last case for iterators in ECMAScript 6, where <span class="literal">next()</span> is called on an iterator after the last piece of data has been used.</p>
        <p class="indent">As this example shows, writing iterators that behave according to the rules laid out in ECMAScript 6 is a bit complex. Fortunately, ECMAScript 6 also provides generators, which make creating iterator objects much simpler.</p>
        <h3 class="h3" id="ch08lev1sec03"><strong>What Are Generators?</strong></h3>
        <p class="noindent">A <em>generator</em> is a function that returns an iterator. Generator functions are indicated by an asterisk character (<span class="literal">*</span>) after the <span class="literal">function</span> keyword and use the new <span class="literal">yield</span> keyword. It doesn’t matter if the asterisk is directly next to <span class="literal">function</span> or if some whitespace is between it and the <span class="literal">*</span> character, as in this example:</p>
        <p class="programs">// generator<br>function *createIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 3;<br>}<br><br>// generators are called like regular functions but return an iterator<br>let iterator = createIterator();<br><br>console.log(iterator.next().value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(iterator.next().value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(iterator.next().value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3</p>
        <p class="indent"><span epub:type="pagebreak" id="page_140"></span>The <span class="literal">*</span> before <span class="literal">createIterator()</span> makes this function a generator. The <span class="literal">yield</span> keyword, also new to ECMAScript 6, specifies values the resulting iterator should return when <span class="literal">next()</span> is called and the order in which they should be returned. The iterator generated in this example has three different values to return on successive calls to the <span class="literal">next()</span> method: first 1, then 2, and finally 3. A generator gets called like any other function, as shown when <span class="literal">iterator</span> is created.</p>
        <p class="indent">Perhaps the most interesting aspect of generator functions is that they stop execution after each <span class="literal">yield</span> statement. For instance, after <span class="literal">yield 1</span> executes in this code, the function doesn’t execute anything else until the iterator’s <span class="literal">next()</span> method is called. At that point, <span class="literal">yield 2</span> executes. This ability to stop execution in the middle of a function leads to some interesting uses of generator functions (which I discuss in “<a href="ch08.xhtml#ch08lev1sec07">Advanced Iterator Functionality</a>” on <a href="ch08.xhtml#page_152">page 152</a>).</p>
        <p class="indent">You can use the <span class="literal">yield</span> keyword with any value or expression, so you can write generator functions that add items to iterators without just listing the items one by one. For example, here’s one way you could use <span class="literal">yield</span> inside a <span class="literal">for</span> loop:</p>
        <p class="programs">function *createIterator(items) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; items.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield items[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let iterator = createIterator([1, 2, 3]);<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 2, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 3, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"<br><br>// for all further calls<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent">This example passes an array called <span class="literal">items</span> to the <span class="literal">createIterator()</span> generator function. Inside the function, a <span class="literal">for</span> loop yields the elements from the array into the iterator as the loop progresses. Each time <span class="literal">yield</span> is encountered, the loop stops, and each time <span class="literal">next()</span> is called on <span class="literal">iterator</span>, the loop picks up with the next <span class="literal">yield</span> statement.</p>
        <p class="indent">Generator functions are an important ECMAScript 6 feature, and because they are just functions, you can use them in all the same places. The rest of this section focuses on other useful ways to write generators.</p>
        <div class="sidebar">
        <p class="sidebart"><span epub:type="pagebreak" id="page_141"></span><strong>WHERE YIELD THROWS ERRORS</strong></p>
        <p class="noindent">You can use the <span class="literal">yield</span> keyword only inside generators. Using <span class="literal">yield</span> anywhere else is a syntax error, including in functions that are inside generators, such as:</p>
        <p class="programs">function *createIterator(items) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;items.forEach(function(item) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// syntax error<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield item + 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}</p>
        <p class="indent">Even though <span class="literal">yield</span> is technically inside the <span class="literal">createIterator()</span> function, this code is a syntax error because <span class="literal">yield</span> cannot cross function boundaries. The <span class="literal">yield</span> keyword is similar to <span class="literal">return</span> in that a nested function cannot return a value for its containing function.</p>
        </div>
        <h4 class="h4" id="ch08lev2sec01"><em><strong>Generator Function Expressions</strong></em></h4>
        <p class="noindent">You can use function expressions to create generators by just including an asterisk (<span class="literal">*</span>) between the <span class="literal">function</span> keyword and the opening parenthesis. For example:</p>
        <p class="programs">let createIterator = function *(items) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; items.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield items[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let iterator = createIterator([1, 2, 3]);<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 2, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 3, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"<br><br>// for all further calls<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent">In this code, <span class="literal">createIterator()</span> is a generator function expression instead of a function declaration. The asterisk goes between the <span class="literal">function</span> keyword and the opening parenthesis because the function expression is anonymous. Otherwise, this example is the same as the previous example, which also used a <span class="literal">for</span> loop.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Creating an arrow function that is also a generator is not possible.</em></p>
        </div>
        <h4 class="h4" id="ch08lev2sec02"><span epub:type="pagebreak" id="page_142"></span><em><strong>Generator Object Methods</strong></em></h4>
        <p class="noindent">Because generators are just functions, you can add them to objects, too. For example, you can make a generator in an ECMAScript 5–style object literal with a function expression, like this:</p>
        <p class="programs">let o = {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;createIterator: function *(items) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; items.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield items[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let iterator = o.createIterator([1, 2, 3]);</p>
        <p class="indent">You can also use the ECMAScript 6 method shorthand by prepending the method name with an asterisk (<span class="literal">*</span>), as shown here:</p>
        <p class="programs">let o = {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;*createIterator(items) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0; i &lt; items.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield items[i];<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let iterator = o.createIterator([1, 2, 3]);</p>
        <p class="indent">These examples are functionally equivalent to the example in the previous section; they just use different syntax. In the shorthand version, because the <span class="literal">createIterator()</span> method is defined with no <span class="literal">function</span> keyword, the asterisk is placed immediately before the method name, although you can leave whitespace between the asterisk and the method name.</p>
        <h3 class="h3" id="ch08lev1sec04"><strong>Iterables and for-of Loops</strong></h3>
        <p class="noindent">Closely related to iterators, an <em>iterable</em> is an object with a <span class="literal">Symbol.iterator</span> property. The well-known <span class="literal">Symbol.iterator</span> symbol specifies a function that returns an iterator for the given object. All collection objects (arrays, sets, and maps) and strings are iterables in ECMAScript 6, so they have a default iterator specified. Iterables are designed to be used with a new addition to ECMAScript: the <span class="literal">for-of</span> loop.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>All iterators created by generators are also iterables, because generators assign the</em> <span class="literal"><span class="codeitalic">Symbol.iterator</span></span> <em>property by default.</em></p>
        </div>
        <p class="indent"><span epub:type="pagebreak" id="page_143"></span>At the beginning of this chapter, I mentioned the problem of tracking an index inside a <span class="literal">for</span> loop. Iterators are the first part of the solution to that problem. The <span class="literal">for-of</span> loop is the second part: it removes the need to track an index into a collection entirely, freeing you to focus on working with the contents of the collection.</p>
        <p class="indent">A <span class="literal">for-of</span> loop calls <span class="literal">next()</span> on an iterable each time the loop executes and stores the <span class="literal">value</span> from the result object in a variable. The loop continues this process until the returned object’s <span class="literal">done</span> property is <span class="literal">true</span>. Here’s an example:</p>
        <p class="programs">let values = [1, 2, 3];<br><br>for (let num of values) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(num);<br>}</p>
        <p class="indent">This code outputs the following:</p>
        <p class="programs">1<br>2<br>3</p>
        <p class="indent">This <span class="literal">for-of</span> loop first calls the <span class="literal">Symbol.iterator</span> method on the <span class="literal">values</span> array to retrieve an iterator. (The call to <span class="literal">Symbol.iterator</span> happens behind the scenes in the JavaScript engine.) Then <span class="literal">iterator.next()</span> is called, and the <span class="literal">value</span> property on the iterator’s result object is read into <span class="literal">num</span>. The <span class="literal">num</span> variable is first 1, then 2, and finally 3. When <span class="literal">done</span> on the result object is <span class="literal">true</span>, the loop exits, so <span class="literal">num</span> is never assigned the value of <span class="literal">undefined</span>.</p>
        <p class="indent">If you’re simply iterating over values in an array or collection, it’s a good idea to use a <span class="literal">for-of</span> loop instead of a <span class="literal">for</span> loop. The <span class="literal">for-of</span> loop is generally less error prone because there are fewer conditions to track. Use the traditional <span class="literal">for</span> loop for more complex control conditions.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>WARNING</strong></span></p>
        <p class="notep"><em>The <span class="literal">for-of</span> statement will throw an error when you use it on a non-iterable object, <span class="literal">null</span>, or <span class="literal">undefined</span>.</em></p>
        </div>
        <h4 class="h4" id="ch08lev2sec03"><em><strong>Accessing the Default Iterator</strong></em></h4>
        <p class="noindent">You can use <span class="literal">Symbol.iterator</span> to access the default iterator for an object, like this:</p>
        <p class="programs">let values = [1, 2, 3];<br>let iterator = values[Symbol.iterator]();<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 2, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 3, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent"><span epub:type="pagebreak" id="page_144"></span>This code gets the default iterator for <span class="literal">values</span> and uses that to iterate over the items in the array. This is the same process that happens behind the scenes when you’re using a <span class="literal">for-of</span> loop.</p>
        <p class="indent">Because <span class="literal">Symbol.iterator</span> specifies the default iterator, you can use it to detect whether an object is iterable, as follows:</p>
        <p class="programs">function isIterable(object) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return typeof object[Symbol.iterator] === "function";<br>}<br><br>console.log(isIterable([1, 2, 3]));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(isIterable("Hello"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(isIterable(new Map()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(isIterable(new Set()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(isIterable(new WeakMap()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(isIterable(new WeakSet()));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">The <span class="literal">isIterable()</span> function simply checks whether a default iterator exists on the object and is a function. The <span class="literal">for-of</span> loop does a similar check before executing.</p>
        <p class="indent">So far, the examples in this section have shown ways to use <span class="literal">Symbol.iterator</span> with built-in iterable types, but you can also use the <span class="literal">Symbol.iterator</span> property to create your own iterables.</p>
        <h4 class="h4" id="ch08lev2sec04"><em><strong>Creating Iterables</strong></em></h4>
        <p class="noindent">Developer-defined objects are not iterable by default, but you can make them iterable by creating a <span class="literal">Symbol.iterator</span> property containing a generator. For example:</p>
        <p class="programs">let collection = {<br>&nbsp;&nbsp;&nbsp;&nbsp;items: [],<br>&nbsp;&nbsp;&nbsp;&nbsp;*[Symbol.iterator]() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (let item of this.items) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield item;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>};<br><br>collection.items.push(1);<br>collection.items.push(2);<br>collection.items.push(3);<br><br>for (let x of collection) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(x);<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_145"></span>This code outputs the following:</p>
        <p class="programs">1<br>2<br>3</p>
        <p class="indent">First, the example defines a default iterator for an object called <span class="literal">collection</span>. The default iterator is created by the <span class="literal">Symbol.iterator</span> method, which is a generator (note that the asterisk still comes before the name). The generator then uses a <span class="literal">for-of</span> loop to iterate over the values in <span class="literal">this.items</span> and uses <span class="literal">yield</span> to return each one. Instead of manually iterating to define values for the default iterator of <span class="literal">collection</span> to return, the <span class="literal">collection</span> object relies on the default iterator of <span class="literal">this.items</span> to do the work.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>“<a href="ch08.xhtml#ch08lev2sec11">Delegating Generators</a>” on <a href="ch08.xhtml#page_156">page 156</a> describes a different approach to using the iterator of another object.</em></p>
        </div>
        <p class="indent">Now you’ve seen some uses for the default array iterator, but there are many more iterators built in to ECMAScript 6 to make working with collections of data easy.</p>
        <h3 class="h3" id="ch08lev1sec05"><strong>Built-In Iterators</strong></h3>
        <p class="noindent">Iterators are an important part of ECMAScript 6, and as such, you don’t need to create your own iterators for many built-in types: the language includes them by default. You only need to create iterators when the built-in iterators don’t serve your purpose, which will most frequently be when defining your own objects or classes. Otherwise, you can rely on built-in iterators to do your work. Perhaps the most common iterators you’ll use are those that work on collections.</p>
        <h4 class="h4" id="ch08lev2sec05"><em><strong>Collection Iterators</strong></em></h4>
        <p class="noindentb">ECMAScript 6 has three types of collection objects: arrays, maps, and sets. All three have the following built-in iterators to help you navigate their content:</p>
        <p class="hang"><span class="literal"><span class="codestrong">entries()</span></span> Returns an iterator whose values are key-value pairs</p>
        <p class="hang"><span class="literal"><span class="codestrong">values()</span></span> Returns an iterator whose values are the values of the collection</p>
        <p class="hang"><span class="literal"><span class="codestrong">keys()</span></span> Returns an iterator whose values are the keys contained in the collection</p>
        <p class="indentt">You can retrieve an iterator for a collection by calling one of these methods.</p>
        <h5 class="h5" id="ch08lev3sec01"><span epub:type="pagebreak" id="page_146"></span><strong>The entries() Iterator</strong></h5>
        <p class="noindent">The <span class="literal">entries()</span> iterator returns a two-item array each time <span class="literal">next()</span> is called. The two-item array represents the key and value for each item in the collection. For arrays, the first item is the numeric index; for sets, the first item is also the value (because values double as keys in sets); for maps, the first item is the key.</p>
        <p class="indent">Here are some examples that use the <span class="literal">entries()</span> iterator:</p>
        <p class="programs">let colors = [ "red", "green", "blue" ];<br>let tracking = new Set([1234, 5678, 9012]);<br>let data = new Map();<br><br>data.set("title", "Understanding ECMAScript 6");<br>data.set("format", "ebook");<br><br>for (let entry of colors.entries()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(entry);<br>}<br><br>for (let entry of tracking.entries()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(entry);<br>}<br><br>for (let entry of data.entries()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(entry);<br>}</p>
        <p class="indent">The <span class="literal">console.log()</span> calls produce the following output:</p>
        <p class="programs">[0, "red"]<br>[1, "green"]<br>[2, "blue"]<br>[1234, 1234]<br>[5678, 5678]<br>[9012, 9012]<br>["title", "Understanding ECMAScript 6"]<br>["format", "ebook"]</p>
        <p class="indent">This code uses the <span class="literal">entries()</span> method on each type of collection to retrieve an iterator, and it uses <span class="literal">for-of</span> loops to iterate the items. The console output shows how the keys and values are returned in pairs for each object.</p>
        <h5 class="h5" id="ch08lev3sec02"><strong>The values() Iterator</strong></h5>
        <p class="noindent">The <span class="literal">values()</span> iterator simply returns values as they are stored in the collection. For example:</p>
        <p class="programs">let colors = [ "red", "green", "blue" ];<br>let tracking = new Set([1234, 5678, 9012]);<br>let data = new Map();<br><span epub:type="pagebreak" id="page_147"></span>data.set("title", "Understanding ECMAScript 6");<br>data.set("format", "ebook");<br><br>for (let value of colors.values()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>}<br><br>for (let value of tracking.values()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>}<br><br>for (let value of data.values()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>}</p>
        <p class="indent">This code outputs the following:</p>
        <p class="programs">"red"<br>"green"<br>"blue"<br>1234<br>5678<br>9012<br>"Understanding ECMAScript 6"<br>"ebook"</p>
        <p class="indent">Calling the <span class="literal">values()</span> iterator, as in this example, returns the exact data contained in each collection without any information about that data’s location in the collection.</p>
        <h5 class="h5" id="ch08lev3sec03"><strong>The keys() Iterator</strong></h5>
        <p class="noindent">The <span class="literal">keys()</span> iterator returns each key present in a collection. For arrays, it returns only numeric keys; it never returns other own properties of the array. For sets, the keys are the same as the values, so <span class="literal">keys()</span> and <span class="literal">values()</span> return the same iterator. For maps, the <span class="literal">keys()</span> iterator returns each unique key. Here’s an example that demonstrates all three:</p>
        <p class="programs">let colors = [ "red", "green", "blue" ];<br>let tracking = new Set([1234, 5678, 9012]);<br>let data = new Map();<br><br>data.set("title", "Understanding ECMAScript 6");<br>data.set("format", "ebook");<br><br>for (let key of colors.keys()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(key);<br>}<br><br>for (let key of tracking.keys()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(key);<br>}<br><br>for (let key of data.keys()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(key);<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_148"></span>This example outputs the following:</p>
        <p class="programs">0<br>1<br>2<br>1234<br>5678<br>9012<br>"title"<br>"format"</p>
        <p class="indent">The <span class="literal">keys()</span> iterator fetches each key in <span class="literal">colors</span>, <span class="literal">tracking</span>, and <span class="literal">data</span>, and those keys are printed from inside the three <span class="literal">for-of</span> loops. For the array object, only numeric indexes are printed, which would still happen even if you added named properties to the array. This is different from the way the <span class="literal">for-in</span> loop works with arrays, because the <span class="literal">for-in</span> loop iterates over properties rather than just the numeric indexes.</p>
        <h5 class="h5" id="ch08lev3sec04"><strong>Default Iterators for Collection Types</strong></h5>
        <p class="noindent">Each collection type also has a default iterator that is used by <span class="literal">for-of</span> whenever an iterator isn’t explicitly specified. The <span class="literal">values()</span> method is the default iterator for arrays and sets, whereas the <span class="literal">entries()</span> method is the default iterator for maps. These defaults make using collection objects in <span class="literal">for-of</span> loops a little easier. For instance, consider this example:</p>
        <p class="programs">let colors = [ "red", "green", "blue" ];<br>let tracking = new Set([1234, 5678, 9012]);<br>let data = new Map();<br><br>data.set("title", "Understanding ECMAScript 6");<br>data.set("format", "print");<br><br>// same as using colors.values()<br>for (let value of colors) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>}<br><br>// same as using tracking.values()<br>for (let num of tracking) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(num);<br>}<br><br>// same as using data.entries()<br>for (let entry of data) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(entry);<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_149"></span>No iterator is specified, so the default iterator functions will be used. The default iterators for arrays, sets, and maps are designed to reflect how these objects are initialized, so this code outputs the following:</p>
        <p class="programs">"red"<br>"green"<br>"blue"<br>1234<br>5678<br>9012<br>["title", "Understanding ECMAScript 6"]<br>["format", "print"]</p>
        <p class="indent">Arrays and sets return their values by default, whereas maps return the same array format that can be passed into the <span class="literal">Map</span> constructor. On the other hand, weak sets and weak maps do not have built-in iterators. Managing weak references means there’s no way to know exactly how many values are in these collections, which also means there’s no way to iterate over them.</p>
        <div class="sidebar">
        <p class="sidebart"><strong>DESTRUCTURING AND FOR-OF LOOPS</strong></p>
        <p class="noindent">The behavior of the default constructor for maps is also helpful when you use it in <span class="literal">for-of</span> loops with destructuring, as in this example:</p>
        <p class="programs">let data = new Map();<br><br>data.set("title", "Understanding ECMAScript 6");<br>data.set("format", "ebook");<br><br>// same as using data.entries()<br>for (let [key, value] of data) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(key + "=" + value);<br>}</p>
        <p class="indent">The <span class="literal">for-of</span> loop in this code uses a destructured array to assign <span class="literal">key</span> and <span class="literal">value</span> for each entry in the map. In this way, you can easily work with keys and values at the same time without needing to access a two-item array or going back to the map to fetch either the key or the value. Using a destructured array for maps makes the <span class="literal">for-of</span> loop equally useful for maps as it is for sets and arrays.</p>
        </div>
        <h4 class="h4" id="ch08lev2sec06"><em><strong>String Iterators</strong></em></h4>
        <p class="noindent">JavaScript strings have slowly become more like arrays since ECMAScript 5 was released. For example, ECMAScript 5 formalized bracket notation for accessing characters in strings (that is, using <span class="literal">text[0]</span> to get the first <span epub:type="pagebreak" id="page_150"></span>character, and so on). But bracket notation works on code units rather than characters, so it cannot be used to access double-byte characters correctly, as this example demonstrates:</p>
        <p class="programs">var message = "A <span class="ent">𠮷</span> B";<br><br>for (let i=0; i &lt; message.length; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(message[i]);<br>}</p>
        <p class="indent">This code uses bracket notation and the <span class="literal">length</span> property to iterate over and print a string containing a Unicode character. The output is a bit unexpected:</p>
        <p class="programs">A<br><span class="codeitalic">(blank)</span><br><span class="codeitalic">(blank)</span><br><span class="codeitalic">(blank)</span><br><span class="codeitalic">(blank)</span><br>B</p>
        <p class="indent">Because the double-byte character is treated as two separate code units, four empty lines are between <span class="literal">A</span> and <span class="literal">B</span> in the output.</p>
        <p class="indent">Fortunately, ECMAScript 6 aims to fully support Unicode (see <a href="ch02.xhtml#ch02">Chapter 2</a>), and the default string iterator is an attempt to solve the string iteration problem. As such, the default iterator for strings works on characters rather than code units. Changing the preceding example to use the default string iterator with a <span class="literal">for-of</span> loop results in more appropriate output. Here’s the tweaked code:</p>
        <p class="programs">var message = "A <span class="ent">𠮷</span> B";<br><br>for (let c of message) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(c);<br>}</p>
        <p class="indent">This code outputs the following:</p>
        <p class="programs">A<br><span class="codeitalic">(blank)</span><br><span class="ent">𠮷</span><br><span class="codeitalic">(blank)</span><br>B</p>
        <p class="indent">This result is more in line with what you’d expect when you’re working with characters: the loop successfully prints the Unicode character as well as all the rest.</p>
        <h4 class="h4" id="ch08lev2sec07"><span epub:type="pagebreak" id="page_151"></span><em><strong>NodeList Iterators</strong></em></h4>
        <p class="noindent">The DOM has a <span class="literal">NodeList</span> type that represents a collection of elements in a document. For those who write JavaScript to run in web browsers, understanding the difference between <span class="literal">NodeList</span> objects and arrays has always been a bit difficult. Both <span class="literal">NodeList</span> objects and arrays use the <span class="literal">length</span> property to indicate the number of items, and both use bracket notation to access individual items. Internally, however, a <span class="literal">NodeList</span> and an array behave quite differently, which has led to a lot of confusion.</p>
        <p class="indent">With the addition of default iterators in ECMAScript 6, the DOM definition of <span class="literal">NodeList</span> (included in the HTML specification rather than ECMAScript 6) includes a default iterator that behaves in the same manner as the array default iterator. That means you can use <span class="literal">NodeList</span> in a <span class="literal">for-of</span> loop or any other place that uses an object’s default iterator. For example:</p>
        <p class="programs">var divs = document.getElementsByTagName("div");<br><br>for (let div of divs) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(div.id);<br>}</p>
        <p class="indent">This code calls <span class="literal">getElementsByTagName()</span> to retrieve a <span class="literal">NodeList</span> that represents all of the <span class="literal">&lt;div&gt;</span> elements in the <span class="literal">document</span> object. The <span class="literal">for-of</span> loop then iterates over each element and outputs the element IDs, effectively making the code the same as it would be for a standard array.</p>
        <h3 class="h3" id="ch08lev1sec06"><strong>The Spread Operator and Nonarray Iterables</strong></h3>
        <p class="noindent">Recall from <a href="ch07.xhtml#ch07">Chapter 7</a> that you can use the spread operator (<span class="literal">...</span>) to convert a set into an array. For example:</p>
        <p class="programs">let set = new Set([1, 2, 3, 3, 3, 4, 5]),<br>&nbsp;&nbsp;&nbsp;&nbsp;array = [...set];<br><br>console.log(array);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [1,2,3,4,5]</p>
        <p class="indent">This code uses the spread operator inside an array literal to fill in that array with the values from <span class="literal">set</span>. The spread operator works on all iterables and uses the default iterator to determine which values to include. All values are read from the iterator and inserted into the array in the order in which values where returned from the iterator. This example runs properly because sets are iterables, but the spread operator works equally well on any iterable. Here’s another example:</p>
        <p class="programs">let map = new Map([["name", "Nicholas"], ["age", 25]]),<br>&nbsp;&nbsp;&nbsp;&nbsp;array = [...map];<br><br>console.log(array);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [["name", "Nicholas"], ["age", 25]]</p>
        <p class="indent"><span epub:type="pagebreak" id="page_152"></span>Here, the spread operator converts <span class="literal">map</span> into an array of arrays. Because the default iterator for maps returns key-value pairs, the resulting array looks like the array that was passed during the <span class="literal">new Map()</span> call.</p>
        <p class="indent">You can use the spread operator in an array literal as many times as you want, and you can use it wherever you want to insert multiple items from an iterable. Those items will just appear in order in the new array at the location of the spread operator. For example:</p>
        <p class="programs">let smallNumbers = [1, 2, 3],<br>&nbsp;&nbsp;&nbsp;&nbsp;bigNumbers = [100, 101, 102],<br>&nbsp;&nbsp;&nbsp;&nbsp;allNumbers = [0, ...smallNumbers, ...bigNumbers];<br><br>console.log(allNumbers.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 7<br>console.log(allNumbers);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [0, 1, 2, 3, 100, 101, 102]</p>
        <p class="indent">Here, the spread operator is used to create <span class="literal">allNumbers</span> from the values in <span class="literal">smallNumbers</span> and <span class="literal">bigNumbers</span>. The values are placed in <span class="literal">allNumbers</span> in the same order the arrays are added when <span class="literal">allNumbers</span> is created: 0 is first, followed by the values from <span class="literal">smallNumbers</span>, followed by the values from <span class="literal">bigNumbers</span>. However, the original arrays are unchanged, because their values have just been copied into <span class="literal">allNumbers</span>.</p>
        <p class="indent">Because you can use the spread operator on any iterable, using it is the easiest way to convert an iterable into an array. You can convert strings into arrays of characters (not code units) and <span class="literal">NodeList</span> objects in the browser into arrays of nodes.</p>
        <p class="indent">Now that you understand the basics of how iterators work, including <span class="literal">for-of</span> and the spread operator, it’s time to look at some more complex uses of iterators.</p>
        <h3 class="h3" id="ch08lev1sec07"><strong>Advanced Iterator Functionality</strong></h3>
        <p class="noindent">You can accomplish a lot with the basic functionality of iterators and the convenience of creating them using generators. However, iterators can be used for tasks other than simply iterating over a collection of values. During the development of ECMAScript 6, many unique ideas and patterns emerged that encouraged the creators to add more functionality to the language. Some of those additions are subtle, but when used together, they can accomplish some interesting interactions, as discussed in the following sections.</p>
        <h4 class="h4" id="ch08lev2sec08"><em><strong>Passing Arguments to Iterators</strong></em></h4>
        <p class="noindent">Throughout this chapter, examples have shown iterators passing values out via the <span class="literal">next()</span> method or by using <span class="literal">yield</span> in a generator. But you can also pass arguments to the iterator through the <span class="literal">next()</span> method. When you pass an argument to the <span class="literal">next()</span> method, that argument becomes the value of the <span class="literal">yield</span> <span epub:type="pagebreak" id="page_153"></span>statement inside a generator. This capability is important for more advanced functionality, such as asynchronous programming. Here’s a basic example:</p>
        <p class="programs">function *createIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let first = yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;let second = yield first + 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4 + 2<br>&nbsp;&nbsp;&nbsp;&nbsp;yield second + 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 5 + 3<br>}<br><br>let iterator = createIterator();<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next(4));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 6, done: false }"<br>console.log(iterator.next(5));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 8, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent">The first call to <span class="literal">next()</span> is a special case where any argument passed to it is lost. Because arguments passed to <span class="literal">next()</span> become the values returned by <span class="literal">yield</span>, an argument from the first call to <span class="literal">next()</span> could only replace the first yield statement in the generator function if it could be accessed before that <span class="literal">yield</span> statement. That’s not possible, so there’s no reason to pass an argument the first time <span class="literal">next()</span> is called.</p>
        <p class="indent">On the second call to <span class="literal">next()</span>, the value 4 is passed as the argument. The 4 ends up assigned to the variable <span class="literal">first</span> inside the generator function. In a <span class="literal">yield</span> statement including an assignment, the right side of the expression is evaluated on the first call to <span class="literal">next()</span> and the left side is evaluated on the second call to <span class="literal">next()</span> before the function continues executing. Because the second call to <span class="literal">next()</span> passes in 4, that value is assigned to <span class="literal">first</span> and then execution continues.</p>
        <p class="indent">The second <span class="literal">yield</span> uses the result of the first <span class="literal">yield</span> and adds two, which means it returns a value of 6. When <span class="literal">next()</span> is called a third time, the value 5 is passed as an argument. That value is assigned to the variable <span class="literal">second</span> and then used in the third <span class="literal">yield</span> statement to return 8.</p>
        <p class="indent">It’s a bit easier to think about what’s happening by considering which code is executing each time execution continues inside the generator function. <a href="ch08.xhtml#ch8fig1">Figure 8-1</a> uses shades of gray to show the code being executed before yielding.</p>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/f08-01.jpg" alt="image" width="602" height="146"></div>
        <p class="figcap"><a id="ch8fig1"></a><em>Figure 8-1: Code execution inside a generator</em></p>
        <p class="indent"><span epub:type="pagebreak" id="page_154"></span>Light gray highlights the first call to <span class="literal">next()</span> and all the code executed inside the generator as a result. Medium gray represents the call to <span class="literal">next(4)</span> and the code that is executed with that call. Dark gray represents the call to <span class="literal">next(5)</span> and the code that is executed as a result. The tricky part is how the code on the right side of each expression executes and stops before the left side is executed. This makes debugging complicated generators a bit more involved than debugging regular functions.</p>
        <p class="indent">You’ve seen that <span class="literal">yield</span> can act like <span class="literal">return</span> when a value is passed to the <span class="literal">next()</span> method, but that’s not the only execution trick you can do inside a generator. You can also cause iterators to throw an error.</p>
        <h4 class="h4" id="ch08lev2sec09"><em><strong>Throwing Errors in Iterators</strong></em></h4>
        <p class="noindent">It’s possible to pass not just data into iterators, but also error conditions. Iterators can implement a <span class="literal">throw()</span> method that instructs the iterator to throw an error when it resumes. This is an important capability for asynchronous programming but also for flexibility inside generators, where you want to be able to mimic return values and thrown errors (the two ways of exiting a function). You can pass an error object to <span class="literal">throw()</span> that should be thrown when the iterator continues processing. For example:</p>
        <p class="programs">function *createIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let first = yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;let second = yield first + 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// yield 4 + 2, then throw<br>&nbsp;&nbsp;&nbsp;&nbsp;yield second + 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// never is executed<br>}<br><br>let iterator = createIterator();<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next(4));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 6, done: false }"<br>console.log(iterator.throw(new Error("Boom"))); // error thrown from generator</p>
        <p class="indent">In this example, the first two <span class="literal">yield</span> expressions are evaluated normally, but when <span class="literal">throw()</span> is called, an error is thrown before <span class="literal">let second</span> is evaluated. This effectively halts code execution similar to directly throwing an error. The only difference is the location in which the error is thrown. <a href="ch08.xhtml#ch8fig2">Figure 8-2</a> shows which code is executed at each step.</p>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/f08-02.jpg" alt="image" width="684" height="146"></div>
        <p class="figcap"><a id="ch8fig2"></a><em>Figure 8-2: Throwing an error inside a generator</em></p>
        <p class="indent"><span epub:type="pagebreak" id="page_155"></span>As in <a href="ch08.xhtml#ch8fig1">Figure 8-1</a>, light and medium gray show which <span class="literal">next()</span> and <span class="literal">yield</span> calls happen together. The <span class="literal">throw()</span> call is highlighted in dark gray, and the dark gray star shows approximately when the error is thrown inside the generator. The first two <span class="literal">yield</span> statements are executed, and when <span class="literal">throw()</span> is called, an error is thrown before any other code executes. Knowing this, you can catch such errors inside the generator using a <span class="literal">try-catch</span> block:</p>
        <p class="programs">function *createIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let first = yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;let second;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second = yield first + 2;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// yield 4 + 2, then throw<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (ex) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;second = 6;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// on error, assign a different value<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;yield second + 3;<br>}<br><br>let iterator = createIterator();<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next(4));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 6, done: false }"<br>console.log(iterator.throw(new Error("Boom"))); // "{ value: 9, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent">In this example, a <span class="literal">try-catch</span> block is wrapped around the second <span class="literal">yield</span> statement. Although this <span class="literal">yield</span> executes without error, the error is thrown before any value can be assigned to <span class="literal">second</span>, so the <span class="literal">catch</span> block assigns it a value of 6. Execution then flows to the next <span class="literal">yield</span> and returns 9.</p>
        <p class="indent">Notice that something interesting happened: the <span class="literal">throw()</span> method returned a result object just like the <span class="literal">next()</span> method. Because the error was caught inside the generator, code execution continued to the next <span class="literal">yield</span> and returned the next value, 9.</p>
        <p class="indent">It helps to think of <span class="literal">next()</span> and <span class="literal">throw()</span> as being instructions to the iterator. The <span class="literal">next()</span> method instructs the iterator to continue executing (possibly with a given value), and <span class="literal">throw()</span> instructs the iterator to continue executing by throwing an error. What happens after that point depends on the code inside the generator.</p>
        <p class="indent">The <span class="literal">next()</span> and <span class="literal">throw()</span> methods control execution inside an iterator when you’re using <span class="literal">yield</span>, but you can also use the <span class="literal">return</span> statement. But <span class="literal">return</span> works a bit differently than it does in regular functions, as you’ll see in the next section.</p>
        <h4 class="h4" id="ch08lev2sec10"><em><strong>Generator Return Statements</strong></em></h4>
        <p class="noindent">Because generators are functions, you can use the <span class="literal">return</span> statement to exit early and specify a return value for the last call to the <span class="literal">next()</span> method. In most examples in this chapter, the last call to <span class="literal">next()</span> on an iterator returns <span epub:type="pagebreak" id="page_156"></span><span class="literal">undefined</span>, but you can specify an alternate value by using <span class="literal">return</span> as you would in any other function. In a generator, <span class="literal">return</span> indicates that all processing is done, so the <span class="literal">done</span> property is set to <span class="literal">true</span> and the value, if provided, becomes the <span class="literal">value</span> field. Here’s an example that simply exits early using <span class="literal">return</span>:</p>
        <p class="programs">function *createIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 3;<br>}<br><br>let iterator = createIterator();<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent">In this code, the generator has a <span class="literal">yield</span> statement followed by a <span class="literal">return</span> statement. The <span class="literal">return</span> indicates that no more values are to come, so the rest of the <span class="literal">yield</span> statements will not execute (they are unreachable).</p>
        <p class="indent">You can also specify a return value that will end up in the <span class="literal">value</span> field of the returned object. For example:</p>
        <p class="programs">function *createIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;return 42;<br>}<br><br>let iterator = createIterator();<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 42, done: true }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent">Here, the value 42 is returned in the <span class="literal">value</span> field on the second call to the <span class="literal">next()</span> method (which is the first time that <span class="literal">done</span> is <span class="literal">true</span>). The third call to <span class="literal">next()</span> returns an object whose <span class="literal">value</span> property is once again <span class="literal">undefined</span>. Any value you specify with <span class="literal">return</span> is only available on the returned object one time before the <span class="literal">value</span> field is reset to <span class="literal">undefined</span>.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The spread operator and <span class="literal">for-of</span> ignore any value specified by a <span class="literal">return</span> statement. As soon as they see <span class="literal">done</span> is <span class="literal">true</span>, they stop without reading the <span class="literal">value</span>. However, iterator return values are helpful when delegating generators.</em></p>
        </div>
        <h4 class="h4" id="ch08lev2sec11"><em><strong>Delegating Generators</strong></em></h4>
        <p class="noindent">In some cases, combining the values from two iterators into one is useful. Generators can delegate to other generators using a special form of <span class="literal">yield</span> <span epub:type="pagebreak" id="page_157"></span>with an asterisk (<span class="literal">*</span>). As with generator definitions, where the asterisk appears doesn’t matter, as long as the asterisk falls between the <span class="literal">yield</span> keyword and the generator function name. Here’s an example:</p>
        <p class="programs">function *createNumberIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 2;<br>}<br><br>function *createColorIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;yield "red";<br>&nbsp;&nbsp;&nbsp;&nbsp;yield "green";<br>}<br><br>function *createCombinedIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;yield *createNumberIterator();<br>&nbsp;&nbsp;&nbsp;&nbsp;yield *createColorIterator();<br>&nbsp;&nbsp;&nbsp;&nbsp;yield true;<br>}<br><br>var iterator = createCombinedIterator();<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 2, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: "red", done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: "green", done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: true, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent">In this example, the <span class="literal">createCombinedIterator()</span> generator delegates first to <span class="literal">createNumberIterator()</span> and then to <span class="literal">createColorIterator()</span>. The returned iterator appears, from the outside, to be one consistent iterator that has produced all of the values. Each call to <span class="literal">next()</span> is delegated to the appropriate iterator until the iterators created by <span class="literal">createNumberIterator()</span> and <span class="literal">createColorIterator()</span> are empty. Then the final <span class="literal">yield</span> is executed to return <span class="literal">true</span>.</p>
        <p class="indent">Generator delegation also lets you make further use of generator return values. It’s the easiest way to access such returned values and can be quite useful when performing complex tasks. For example:</p>
        <p class="programs">function *createNumberIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;return 3;<br>}<br><br>function *createRepeatingIterator(count) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i=0; i &lt; count; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield "repeat";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>function *createCombinedIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = yield *createNumberIterator();<br>&nbsp;&nbsp;&nbsp;&nbsp;yield *createRepeatingIterator(result);<br>}<br><br>var iterator = createCombinedIterator();<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 2, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: "repeat", done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: "repeat", done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: "repeat", done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent"><span epub:type="pagebreak" id="page_158"></span>In this example, the <span class="literal">createCombinedIterator()</span> generator delegates to <span class="literal">createNumberIterator()</span> and assigns the return value to <span class="literal">result</span>. Because <span class="literal">createNumberIterator()</span> contains <span class="literal">return 3</span>, the returned value is 3. The <span class="literal">result</span> variable is then passed to <span class="literal">createRepeatingIterator()</span> as an argument indicating how many times to yield the same string (in this case, three times).</p>
        <p class="indent">Notice that the value 3 was never output from any call to the <span class="literal">next()</span> method. Right now, it exists solely inside the <span class="literal">createCombinedIterator()</span> generator. But you can output that value as well by adding another <span class="literal">yield</span> statement, such as:</p>
        <p class="programs">function *createNumberIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;return 3;<br>}<br><br>function *createRepeatingIterator(count) {<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i=0; i &lt; count; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield "repeat";<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>function *createCombinedIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = yield *createNumberIterator();<br>&nbsp;&nbsp;&nbsp;&nbsp;yield result;<br>&nbsp;&nbsp;&nbsp;&nbsp;yield *createRepeatingIterator(result);<br>}<br><br>var iterator = createCombinedIterator();<br><br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 1, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 2, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: 3, done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: "repeat", done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: "repeat", done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: "repeat", done: false }"<br>console.log(iterator.next());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{ value: undefined, done: true }"</p>
        <p class="indent"><span epub:type="pagebreak" id="page_159"></span>In this code, the extra <span class="literal">yield</span> statement explicitly outputs the returned value from the <span class="literal">createNumberIterator()</span> generator.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>You can use <span class="literal">yield *</span> directly on strings (as in <span class="literal">yield * "hello"</span>), and the string’s default iterator will be used.</em></p>
        </div>
        <h3 class="h3" id="ch08lev1sec08"><strong>Asynchronous Task Running</strong></h3>
        <p class="noindent">Much of the excitement around generators is directly related to asynchronous programming. Asynchronous programming in JavaScript is a double-edged sword: simple tasks are easy to do asynchronously, but complex tasks become an adventure in code organization. Because generators allow you to effectively pause code in the middle of execution, they open many possibilities related to asynchronous processing.</p>
        <p class="indent">The traditional way to perform asynchronous operations is to call a function that has a callback. For example, consider reading a file from the disk in Node.js:</p>
        <p class="programs">let fs = require("fs");<br><br>fs.readFile("config.json", function(err, contents) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWith(contents);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Done");<br>});</p>
        <p class="indent">The <span class="literal">fs.readFile()</span> method is called with the filename to read and a callback function. When the operation is finished, the callback function is called. The callback checks whether an error exists, and if not, processes the returned <span class="literal">contents</span>. This works well when you have a small, finite number of asynchronous tasks to complete but gets complicated when you need to nest callbacks or otherwise sequence a series of asynchronous tasks. In those situations, generators and <span class="literal">yield</span> are helpful.</p>
        <h4 class="h4" id="ch08lev2sec12"><em><strong>A Simple Task Runner</strong></em></h4>
        <p class="noindent">Because <span class="literal">yield</span> stops execution and waits for the <span class="literal">next()</span> method to be called before starting again, you can implement asynchronous calls without managing callbacks. To start, you need a function that can call a generator and start the iterator, such as this:</p>
        <p class="programs">function run(taskDef) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// create the iterator, make available elsewhere<br>&nbsp;&nbsp;&nbsp;&nbsp;let task = taskDef();<br><span epub:type="pagebreak" id="page_160"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;// start the task<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = task.next();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// recursive function to keep calling next()<br>&nbsp;&nbsp;&nbsp;&nbsp;function step() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if there's more to do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!result.done) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.next();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// start the process<br>&nbsp;&nbsp;&nbsp;&nbsp;step();<br><br>}</p>
        <p class="indent">The <span class="literal">run()</span> function accepts a task definition (a generator function) as an argument. It calls the generator to create an iterator and stores the iterator in <span class="literal">task</span>. The first call to <span class="literal">next()</span> begins the iterator and the result is stored for later use. The <span class="literal">step()</span> function checks whether <span class="literal">result.done</span> is <span class="literal">false</span> and, if so, calls <span class="literal">next()</span> before recursively calling itself. Each call to <span class="literal">next()</span> stores the return value in <span class="literal">result</span>, which is always overwritten to contain the latest information. The initial call to <span class="literal">step()</span> starts the process of looking at the <span class="literal">result.done</span> variable to see whether there’s more to do.</p>
        <p class="indent">With this implementation of <span class="literal">run()</span>, you can run a generator containing multiple <span class="literal">yield</span> statements, such as:</p>
        <p class="programs">run(function*() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(1);<br>&nbsp;&nbsp;&nbsp;&nbsp;yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(2);<br>&nbsp;&nbsp;&nbsp;&nbsp;yield;<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(3);<br>});</p>
        <p class="indent">This example just outputs three numbers to the console, which simply shows that all calls to <span class="literal">next()</span> are being made. However, just yielding a couple of times isn’t very useful. The next step is to pass values into and out of the iterator.</p>
        <h4 class="h4" id="ch08lev2sec13"><em><strong>Task Running with Data</strong></em></h4>
        <p class="noindent">The easiest way to pass data through the task runner is to pass the value specified by <span class="literal">yield</span> into the next call to the <span class="literal">next()</span> method. To do so, you need only pass <span class="literal">result.value</span>, as in this code:</p>
        <p class="programs">function run(taskDef) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// create the iterator, make available elsewhere<br>&nbsp;&nbsp;&nbsp;&nbsp;let task = taskDef();<br><span epub:type="pagebreak" id="page_161"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;// start the task<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = task.next();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// recursive function to keep calling next()<br>&nbsp;&nbsp;&nbsp;&nbsp;function step() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if there's more to do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!result.done) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.next(result.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// start the process<br>&nbsp;&nbsp;&nbsp;&nbsp;step();<br><br>}</p>
        <p class="indent">Now that <span class="literal">result.value</span> is passed to <span class="literal">next()</span> as an argument, it’s possible to pass data between <span class="literal">yield</span> calls, like this:</p>
        <p class="programs">run(function*() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let value = yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br><br>&nbsp;&nbsp;&nbsp;&nbsp;value = yield value + 3;<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4<br>});</p>
        <p class="indent">This example outputs two values to the console: 1 and 4. The value 1 comes from <span class="literal">yield 1</span>, because the 1 is passed right back into the <span class="literal">value</span> variable. The 4 is calculated by adding 3 to <span class="literal">value</span> and passing that result back to <span class="literal">value</span>. Now that data is flowing between calls to <span class="literal">yield</span>, you just need one small change to allow asynchronous calls.</p>
        <h4 class="h4" id="ch08lev2sec14"><em><strong>An Asynchronous Task Runner</strong></em></h4>
        <p class="noindent">The previous example passed static data back and forth between <span class="literal">yield</span> calls, but waiting for an asynchronous process is slightly different. The task runner needs to know about callbacks and how to use them. Because <span class="literal">yield</span> expressions pass their values into the task runner, any function call must return a value that somehow indicates the call is an asynchronous operation that the task runner should wait for.</p>
        <p class="indent">Here is one way you might signal that a value is an asynchronous operation:</p>
        <p class="programs">function fetchData() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return function(callback) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(null, "Hi!");<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_162"></span>For the purposes of this example, any function meant to be called by the task runner will return a function that executes a callback. The <span class="literal">fetchData()</span> function returns a function that accepts a callback function as an argument. When the returned function is called, it executes the callback function with a single piece of data (the <span class="literal">"Hi!"</span> string). The <span class="literal">callback</span> argument needs to come from the task runner to ensure executing the callback correctly interacts with the underlying iterator. Although the <span class="literal">fetchData()</span> function is synchronous, you can easily extend it to be asynchronous by calling the callback with a slight delay, such as:</p>
        <p class="programs">function fetchData() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return function(callback) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;setTimeout(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback(null, "Hi!");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, 50);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>}</p>
        <p class="indent">This version of <span class="literal">fetchData()</span> introduces a 50 ms delay before calling the callback, demonstrating that this pattern works equally well for synchronous and asynchronous code. You just have to make sure each function that wants to be called using <span class="literal">yield</span> follows the same pattern.</p>
        <p class="indent">With a good understanding of how a function can signal that it’s an asynchronous process, you can modify the task runner to take that fact into account. Anytime <span class="literal">result.value</span> is a function, the task runner will execute it instead of just passing that value to the <span class="literal">next()</span> method. Here’s the updated code:</p>
        <p class="programs">function run(taskDef) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// create the iterator, make available elsewhere<br>&nbsp;&nbsp;&nbsp;&nbsp;let task = taskDef();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// start the task<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = task.next();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// recursive function to keep calling next()<br>&nbsp;&nbsp;&nbsp;&nbsp;function step() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if there's more to do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!result.done) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof result.value === "function") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.value(function(err, data) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.throw(err);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.next(data);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br><span epub:type="pagebreak" id="page_163"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.next(result.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// start the process<br>&nbsp;&nbsp;&nbsp;&nbsp;step();<br><br>}</p>
        <p class="indent">When <span class="literal">result.value</span> is a function (checked with the <span class="literal">===</span> operator), it’s called with a callback function. That callback function follows the Node.js convention of passing any possible error as the first argument (<span class="literal">err</span>) and the result as the second argument. If <span class="literal">err</span> is present, that means an error occurred and <span class="literal">task.throw()</span> is called with the error object instead of <span class="literal">task.next()</span> so an error is thrown at the correct location. If there is no error, <span class="literal">data</span> is passed into <span class="literal">task.next()</span> and the result is stored. Then, <span class="literal">step()</span> is called to continue the process. When <span class="literal">result.value</span> is not a function, it’s directly passed to the <span class="literal">next()</span> method.</p>
        <p class="indent">This new version of the task runner is ready for all asynchronous tasks. To read data from a file in Node.js, you need to create a wrapper around <span class="literal">fs.readFile()</span> that returns a function similar to the <span class="literal">fetchData()</span> function from the beginning of this section. For example:</p>
        <p class="programs">let fs = require("fs");<br><br>function readFile(filename) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return function(callback) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.readFile(filename, callback);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>}</p>
        <p class="indent">The <span class="literal">readFile()</span> method accepts a single argument, the filename, and returns a function that calls a callback. The callback is passed directly to the <span class="literal">fs.readFile()</span> method, which will execute the callback upon completion. You can then run this task using <span class="literal">yield</span> as follows:</p>
        <p class="programs">run(function*() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let contents = yield readFile("config.json");<br>&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWith(contents);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Done");<br>});</p>
        <p class="indent">This example performs the asynchronous <span class="literal">readFile()</span> operation without making any callbacks visible in the main code. Aside from <span class="literal">yield</span>, the code looks the same as synchronous code. As long as the functions performing asynchronous operations all conform to the same interface, you can write logic that reads like synchronous code.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_164"></span>Of course, there are downsides to the pattern used in these examples; namely, you can’t always be sure a function that returns a function is asynchronous. But for now, it’s only important that you understand the theory behind the task running. Another new feature in ECMAScript 6, promises, offers more flexible ways of scheduling asynchronous tasks, and <a href="ch11.xhtml#ch11">Chapter 11</a> covers this topic in more depth.</p>
        <h3 class="h3" id="ch08lev1sec09"><strong>Summary</strong></h3>
        <p class="noindent">Iterators are an important part of ECMAScript 6 and are at the root of several key language elements. On the surface, iterators provide a simple way to return a sequence of values using a simple API. However, there are far more complex ways to use iterators in ECMAScript 6.</p>
        <p class="indent">The <span class="literal">Symbol.iterator</span> symbol is used to define default iterators for objects. Both built-in objects and developer-defined objects can use this symbol to provide a method that returns an iterator. When <span class="literal">Symbol.iterator</span> is provided on an object, the object is considered an iterable.</p>
        <p class="indent">The <span class="literal">for-of</span> loop uses iterables to return a series of values in a loop. Using <span class="literal">for-of</span> is easier than iterating with a traditional <span class="literal">for</span> loop because you no longer need to track values and control when the loop ends. The <span class="literal">for-of</span> loop automatically reads all values from the iterator until there are no more, and then it exits.</p>
        <p class="indent">To make <span class="literal">for-of</span> simpler to use, many values in ECMAScript 6 have default iterators. All the collection types—that is, arrays, maps, and sets—have iterators designed to make their contents easy to access. Strings also have a default iterator, which makes iterating over the characters of the string (rather than the code units) easy.</p>
        <p class="indent">The spread operator works with any iterable and makes converting iterables into arrays easy, too. The conversion works by reading values from an iterator and inserting them individually into an array.</p>
        <p class="indent">A generator is a special function that automatically creates an iterator when called. Generator definitions are indicated by an asterisk (<span class="literal">*</span>) and use of the <span class="literal">yield</span> keyword to indicate which value to return for each successive call to the <span class="literal">next()</span> method.</p>
        <p class="indent">Generator delegation encourages good encapsulation of iterator behavior by letting you reuse existing generators in new generators. You can use an existing generator inside another generator by calling <span class="literal">yield *</span> instead of <span class="literal">yield</span>. This process allows you to create an iterator that returns values from multiple iterators.</p>
        <p class="indent">Perhaps the most interesting and exciting aspect of generators and iterators is the possibility of creating cleaner-looking asynchronous code. Instead of needing to use callbacks everywhere, you can set up code that looks synchronous but in fact uses <span class="literal">yield</span> to wait for asynchronous operations to complete.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com