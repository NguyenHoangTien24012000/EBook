<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch03"><span epub:type="pagebreak" id="page_35"></span><strong><span class="big">3</span><br>FUNCTIONS</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">Functions are an important part of any programming language, and prior to ECMAScript 6, JavaScript functions hadn’t changed much since the language was created. This left a backlog of problems and nuanced behavior that made making mistakes easy and often required more code just to produce very basic behaviors.</p>
        <p class="indent">ECMAScript 6 functions make a big leap forward, taking into account years of complaints and requests from JavaScript developers. The result is a number of incremental improvements that enhance ECMAScript 5 functions and make programming in JavaScript less error prone and more flexible.</p>
        <h3 class="h3" id="ch03lev1sec01"><span epub:type="pagebreak" id="page_36"></span><strong>Functions with Default Parameter Values</strong></h3>
        <p class="noindent">Functions in JavaScript are unique in that they allow any number of parameters to be passed regardless of the number of parameters declared in the function definition. This allows you to define functions that can handle different numbers of parameters, often by just filling in default values when parameters aren’t provided. This section covers how default parameters work in and prior to ECMAScript 6, along with some important information on the <span class="literal">arguments</span> object, using expressions as parameters, and another TDZ.</p>
        <h4 class="h4" id="ch03lev2sec01"><em><strong>Simulating Default Parameter Values in ECMAScript 5</strong></em></h4>
        <p class="noindent">In ECMAScript 5 and earlier, you would likely use the following pattern to create a function with default parameter values:</p>
        <p class="programs">function makeRequest(url, timeout, callback) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;timeout = timeout || 2000;<br>&nbsp;&nbsp;&nbsp;&nbsp;callback = callback || function() {};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// the rest of the function<br><br>}</p>
        <p class="indent">In this example, <span class="literal">timeout</span> and <span class="literal">callback</span> are actually optional because they are given a default value if a parameter isn’t provided. The logical OR operator (<span class="literal">||</span>) always returns the second operand when the first is falsy. Because named function parameters that are not explicitly provided are set to <span class="literal">undefined</span>, the logical OR operator is frequently used to provide default values for missing parameters. However, a flaw exists with this approach in that a valid value for <span class="literal">timeout</span> might actually be 0, but this would replace it with 2000 because 0 is falsy.</p>
        <p class="indent">In that case, a safer alternative is to check the type of the argument using <span class="literal">typeof</span>, as in this example:</p>
        <p class="programs">function makeRequest(url, timeout, callback) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;timeout = (typeof timeout !== "undefined") ? timeout : 2000;<br>&nbsp;&nbsp;&nbsp;&nbsp;callback = (typeof callback !== "undefined") ? callback : function() {};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// the rest of the function<br><br>}</p>
        <p class="indent">Although this approach is safer, it still requires a lot of extra code to execute a very basic operation. This approach represents a common pattern, and popular JavaScript libraries are filled with similar patterns.</p>
        <h4 class="h4" id="ch03lev2sec02"><span epub:type="pagebreak" id="page_37"></span><em><strong>Default Parameter Values in ECMAScript 6</strong></em></h4>
        <p class="noindent">ECMAScript 6 makes it easier to provide default values for parameters by supplying initializations that are used when the parameter isn’t formally passed. For example:</p>
        <p class="programs">function makeRequest(url, timeout = 2000, callback = function() {}) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// the rest of the function<br>}</p>
        <p class="indent">This function expects only the first parameter to always be passed. The other two parameters have default values, which makes the body of the function much smaller because you don’t need to add any code to check for a missing value.</p>
        <p class="indent">When <span class="literal">makeRequest()</span> is called with all three parameters, the defaults are not used. For example:</p>
        <p class="programs">// uses default timeout and callback<br>makeRequest("/foo");<br><br>// uses default callback<br>makeRequest("/foo", 500);<br><br>// doesn't use defaults<br>makeRequest("/foo", 500, function(body) {<br>&nbsp;&nbsp;&nbsp;&nbsp;doSomething(body);<br>});</p>
        <p class="indent">ECMAScript 6 considers <span class="literal">url</span> to be required, which is why <span class="literal">"/foo"</span> is passed in all three calls to <span class="literal">makeRequest()</span>. The two parameters with a default value are considered optional.</p>
        <p class="indent">It’s possible to specify default values for any arguments, including those that appear before arguments without default values in the function declaration. For example, this is fine:</p>
        <p class="programs">function makeRequest(url, timeout = 2000, callback) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// the rest of the function<br><br>}</p>
        <p class="indent">In this case, the default value for <span class="literal">timeout</span> will be used only if there is no second argument passed in or if the second argument is explicitly passed in as <span class="literal">undefined</span>, as in this example:</p>
        <p class="programs">// uses default timeout<br>makeRequest("/foo", undefined, function(body) {<br>&nbsp;&nbsp;&nbsp;&nbsp;doSomething(body);<br>});<br><span epub:type="pagebreak" id="page_38"></span><br>// uses default timeout<br>makeRequest("/foo");<br><br>// doesn't use default timeout<br>makeRequest("/foo", null, function(body) {<br>&nbsp;&nbsp;&nbsp;&nbsp;doSomething(body);<br>});</p>
        <p class="indent">In the case of default parameter values, a value of <span class="literal">null</span> is considered valid, meaning that in the third call to <span class="literal">makeRequest()</span>, the default value for <span class="literal">timeout</span> will not be used.</p>
        <h4 class="h4" id="ch03lev2sec03"><em><strong>How Default Parameter Values Affect the arguments Object</strong></em></h4>
        <p class="noindent">Keep in mind that the <span class="literal">arguments</span> object’s behavior is different when default parameter values are present. In ECMAScript 5 non-strict mode, the <span class="literal">arguments</span> object reflects changes in the named parameters of a function. Here’s some code that illustrates how this works:</p>
        <p class="programs">function mixArgs(first, second) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(first === arguments[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(second === arguments[1]);<br>&nbsp;&nbsp;&nbsp;&nbsp;first = "c";<br>&nbsp;&nbsp;&nbsp;&nbsp;second = "d";<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(first === arguments[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(second === arguments[1]);<br>}<br><br>mixArgs("a", "b");</p>
        <p class="indent">This code outputs the following:</p>
        <p class="programs">true<br>true<br>true<br>true</p>
        <p class="indent">The <span class="literal">arguments</span> object is always updated in non-strict mode to reflect changes in the named parameters. Thus, when <span class="literal">first</span> and <span class="literal">second</span> are assigned new values, <span class="literal">arguments[0]</span> and <span class="literal">arguments[1]</span> are updated accordingly, making all of the <span class="literal">===</span> comparisons resolve to <span class="literal">true</span>.</p>
        <p class="indent">However, ECMAScript 5’s strict mode eliminates this confusing aspect of the <span class="literal">arguments</span> object. In strict mode, the <span class="literal">arguments</span> object does not reflect changes to the named parameters. Here’s the <span class="literal">mixArgs()</span> function again, but in strict mode:</p>
        <p class="programs">function mixArgs(first, second) {<br>&nbsp;&nbsp;&nbsp;&nbsp;"use strict";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(first === arguments[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(second === arguments[1]);<br>&nbsp;&nbsp;&nbsp;&nbsp;first = "c";<br><span epub:type="pagebreak" id="page_39"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;second = "d"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(first === arguments[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(second === arguments[1]);<br>}<br><br>mixArgs("a", "b");</p>
        <p class="indent">The call to <span class="literal">mixArgs()</span> outputs the following:</p>
        <p class="programs">true<br>true<br>false<br>false</p>
        <p class="indent">This time, changing <span class="literal">first</span> and <span class="literal">second</span> doesn’t affect <span class="literal">arguments</span>, so the output behaves as you’d normally expect it to.</p>
        <p class="indent">The <span class="literal">arguments</span> object in a function using ECMAScript 6 default parameter values will always behave in the same manner as ECMAScript 5 strict mode regardless of whether the function is explicitly running in strict mode. The presence of default parameter values triggers the <span class="literal">arguments</span> object to remain detached from the named parameters. This is a subtle but important detail because of how you can use the <span class="literal">arguments</span> object. Consider the following:</p>
        <p class="programs">// not in strict mode<br>function mixArgs(first, second = "b") {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(arguments.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(first === arguments[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(second === arguments[1]);<br>&nbsp;&nbsp;&nbsp;&nbsp;first = "c";<br>&nbsp;&nbsp;&nbsp;&nbsp;second = "d"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(first === arguments[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(second === arguments[1]);<br>}<br><br>mixArgs("a");</p>
        <p class="indent">This code outputs the following:</p>
        <p class="programs">1<br>true<br>false<br>false<br>false</p>
        <p class="indent">In this example, <span class="literal">arguments.length</span> is 1 because only one argument was passed to <span class="literal">mixArgs()</span>. That also means <span class="literal">arguments[1]</span> is <span class="literal">undefined</span>, which is the expected behavior when only one argument is passed to a function. That means <span class="literal">first</span> is equal to <span class="literal">arguments[0]</span> as well. Changing <span class="literal">first</span> and <span class="literal">second</span> has no effect on <span class="literal">arguments</span>. This behavior occurs in non-strict and strict modes, so you can rely on <span class="literal">arguments</span> to always reflect the initial call state.</p>
        <h4 class="h4" id="ch03lev2sec04"><span epub:type="pagebreak" id="page_40"></span><em><strong>Default Parameter Expressions</strong></em></h4>
        <p class="noindent">Perhaps the most interesting feature of default parameter values is that the default value need not be a primitive value. You can, for example, execute a function to retrieve the default parameter value, like this:</p>
        <p class="programs">function getValue() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return 5;<br>}<br><br>function add(first, second = getValue()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return first + second;<br>}<br><br>console.log(add(1, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(add(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 6</p>
        <p class="indent">Here, if the last argument isn’t provided, the function <span class="literal">getValue()</span> is called to retrieve the correct default value. Keep in mind that <span class="literal">getValue()</span> is called only when <span class="literal">add()</span> is called without a second parameter, not when the function declaration is first parsed. That means if <span class="literal">getValue()</span> were written differently, it could potentially return a different value. For instance:</p>
        <p class="programs">let value = 5;<br><br>function getValue() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return value++;<br>}<br><br>function add(first, second = getValue()) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return first + second;<br>}<br><br>console.log(add(1, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(add(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 6<br>console.log(add(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 7</p>
        <p class="indent">In this example, <span class="literal">value</span> begins as 5 and increments each time <span class="literal">getValue()</span> is called. The first call to <span class="literal">add(1)</span> returns 6, and the second call to <span class="literal">add(1)</span> returns 7 because <span class="literal">value</span> was incremented. Because the default value for <span class="literal">second</span> is evaluated only when the function is called, changes to that value can be made at any time.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>WARNING</strong></span></p>
        <p class="notep"><em>Be careful when using function calls as default parameter values. If you forget the parentheses, such as <span class="literal">second = getValue</span> in this example, you are passing a reference to the function rather than the result of the function call.</em></p>
        </div>
        <p class="indent"><span epub:type="pagebreak" id="page_41"></span>This behavior introduces another useful capability. You can use a previous parameter as the default for a later parameter. Here’s an example:</p>
        <p class="programs">function add(first, second = first) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return first + second;<br>}<br><br>console.log(add(1, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(add(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">In this code, the parameter <span class="literal">second</span> is given a default value of <span class="literal">first</span>, meaning that passing in just one argument leaves both arguments with the same value. So <span class="literal">add(1, 1)</span> returns 2 just as <span class="literal">add(1)</span> returns 2. Taking this approach a step further, you can pass <span class="literal">first</span> into a function to get the value for <span class="literal">second</span> as follows:</p>
        <p class="programs">function getValue(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return value + 5;<br>}<br><br>function add(first, second = getValue(first)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return first + second;<br>}<br><br>console.log(add(1, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(add(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 7</p>
        <p class="indent">This example sets <span class="literal">second</span> equal to the value returned by <span class="literal">getValue(first)</span>, so although <span class="literal">add(1, 1)</span> still returns 2, <span class="literal">add(1)</span> returns 7 (1 + 6).</p>
        <p class="indent">The ability to reference parameters from default parameter assignments works only for previous arguments, so earlier arguments don’t have access to later arguments. For example:</p>
        <p class="programs">function add(first = second, second) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return first + second;<br>}<br><br>console.log(add(1, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(add(undefined, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// throws an error</p>
        <p class="indent">The call to <span class="literal">add(undefined, 1)</span> throws an error because <span class="literal">second</span> is defined after <span class="literal">first</span> and is therefore unavailable as a default value. To understand why that happens, it’s important to revisit TDZs.</p>
        <h4 class="h4" id="ch03lev2sec05"><em><strong>Default Parameter TDZ</strong></em></h4>
        <p class="noindent"><a href="ch01.xhtml#ch01">Chapter 1</a> introduced the TDZ as it relates to <span class="literal">let</span> and <span class="literal">const</span>, and default parameter values also have a TDZ where parameters cannot be accessed. Similar to a <span class="literal">let</span> declaration, each parameter creates a new identifier binding <span epub:type="pagebreak" id="page_42"></span>that can’t be referenced before initialization without throwing an error. Parameter initialization happens when the function is called, either by passing a value for the parameter or by using the default parameter value.</p>
        <p class="indent">To explore the default parameter value TDZ, reconsider this example from <a href="ch03.xhtml#page_41">page 41</a>:</p>
        <p class="programs">function getValue(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return value + 5;<br>}<br><br>function add(first, second = getValue(first)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return first + second;<br>}<br><br>console.log(add(1, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(add(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 7</p>
        <p class="indent">The calls to <span class="literal">add(1, 1)</span> and <span class="literal">add(1)</span> effectively execute the following code to create the <span class="literal">first</span> and <span class="literal">second</span> parameter values:</p>
        <p class="programs">// JavaScript representation of call to add(1, 1)<br>let first = 1;<br>let second = 1;<br><br>// JavaScript representation of call to add(1)<br>let first = 1;<br>let second = getValue(first);</p>
        <p class="indent">When the function <span class="literal">add()</span> is first executed, the bindings <span class="literal">first</span> and <span class="literal">second</span> are added to a parameter-specific TDZ (similar to how <span class="literal">let</span> behaves). So although <span class="literal">second</span> can be initialized with the value of <span class="literal">first</span> because <span class="literal">first</span> is always initialized at that time, the reverse is not true. Now, consider this rewritten <span class="literal">add()</span> function:</p>
        <p class="programs">function add(first = second, second) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return first + second;<br>}<br><br>console.log(add(1, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(add(undefined, 1)); // throws an error</p>
        <p class="indent">The calls to <span class="literal">add(1, 1)</span> and <span class="literal">add(undefined, 1)</span> in this example now map to the following code behind the scenes:</p>
        <p class="programs">// JavaScript representation of call to add(1, 1)<br>let first = 1;<br>let second = 1;<br><br>// JavaScript representation of call to add(undefined, 1)<br>let first = second;<br>let second = 1;</p>
        <p class="indent"><span epub:type="pagebreak" id="page_43"></span>In this example, the call to <span class="literal">add(undefined, 1)</span> throws an error because <span class="literal">second</span> hasn’t yet been initialized when <span class="literal">first</span> is initialized. At that point, <span class="literal">second</span> is in the TDZ and therefore any references to <span class="literal">second</span> throw an error. This example mirrors the behavior of <span class="literal">let</span> bindings discussed in <a href="ch01.xhtml#ch01">Chapter 1</a>.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Function parameters have their own scope and their own TDZ that is separate from the function body scope. That means the default value of a parameter cannot access any variables declared inside the function body.</em></p>
        </div>
        <h3 class="h3" id="ch03lev1sec02"><strong>Working with Unnamed Parameters</strong></h3>
        <p class="noindent">So far, the examples in this chapter have only covered parameters that have been named in the function definition. However, JavaScript functions don’t limit the number of parameters that can be passed to the number of named parameters defined. You can always pass fewer or more parameters than formally specified. Default parameter values make it clear when a function can accept fewer parameters, and ECMAScript 6 makes the problem of passing more parameters than defined better as well.</p>
        <h4 class="h4" id="ch03lev2sec06"><em><strong>Unnamed Parameters in ECMAScript 5</strong></em></h4>
        <p class="noindent">Early on, JavaScript provided the <span class="literal">arguments</span> object as a way to inspect all function parameters that are passed without necessarily defining each parameter. Although inspecting <span class="literal">arguments</span> works fine in most cases, this object can be a bit cumbersome to work with. For example, examine this code, which inspects the <span class="literal">arguments</span> object:</p>
        <p class="programs">function pick(object) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = Object.create(null);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// start at the second parameter<br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 1, len = arguments.length; i &lt; len; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[arguments[i]] = object[arguments[i]];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>}<br><br>let book = {<br>&nbsp;&nbsp;&nbsp;&nbsp;title: "Understanding ECMAScript 6",<br>&nbsp;&nbsp;&nbsp;&nbsp;author: "Nicholas C. Zakas",<br>&nbsp;&nbsp;&nbsp;&nbsp;year: 2016<br>};<br><br>let bookData = pick(book, "author", "year");<br><br>console.log(bookData.author);&nbsp;&nbsp;&nbsp;// "Nicholas C. Zakas"<br>console.log(bookData.year);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2016</p>
        <p class="indent"><span epub:type="pagebreak" id="page_44"></span>This function mimics the <span class="literal">pick()</span> method from the <em>Underscore.js</em> library, which returns a copy of a given object with some specified subset of the original object’s properties. This example defines only one argument and expects the first argument to be the object from which to copy properties. Every other argument passed is the name of a property that should be copied on the result.</p>
        <p class="indent">You should note a couple of things about this <span class="literal">pick()</span> function. First, it’s not at all obvious that the function can handle more than one parameter. You could define several more parameters, but you would always fall short of indicating that this function can take any number of parameters. Second, because the first parameter is named and used directly, when you look for the properties to copy, you have to start in the <span class="literal">arguments</span> object at index 1 instead of index 0. Remembering to use the appropriate indices with <span class="literal">arguments</span> isn’t necessarily difficult, but it’s one more detail to keep track of.</p>
        <p class="indent">ECMAScript 6 introduces rest parameters to help with these issues.</p>
        <h4 class="h4" id="ch03lev2sec07"><em><strong>Rest Parameters</strong></em></h4>
        <p class="noindent">A <em>rest</em> parameter is indicated by three dots (<span class="literal">...</span>) preceding a named parameter. That named parameter becomes an <span class="literal">Array</span> containing the rest of the parameters passed to the function, which is where the name <em>rest</em> parameters originates. For example, <span class="literal">pick()</span> can be rewritten using rest parameters, like this:</p>
        <p class="programs">function pick(object, ...keys) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = Object.create(null);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0, len = keys.length; i &lt; len; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[keys[i]] = object[keys[i]];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>}</p>
        <p class="indent">In this version of the function, <span class="literal">keys</span> is a rest parameter that contains all parameters passed after <span class="literal">object</span> (unlike <span class="literal">arguments</span>, which contains all parameters including the first one). That means you can iterate over <span class="literal">keys</span> from beginning to end without worry. As a bonus, you can tell by looking at the function that it’s capable of handling any number of parameters.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Rest parameters don’t affect a function’s <span class="literal">length</span> property, which indicates the number of named parameters for the function. The value of <span class="literal">length</span> for <span class="literal">pick()</span> in this example is 1 because only <span class="literal">object</span> counts toward this value.</em></p>
        </div>
        <h5 class="h5" id="ch03lev3sec01"><span epub:type="pagebreak" id="page_45"></span><strong>Rest Parameter Restrictions</strong></h5>
        <p class="noindent">Rest parameters have two restrictions. The first restriction is that there can be only one rest parameter, and the rest parameter must be last. For example, this code won’t work:</p>
        <p class="programs">// Syntax error: Can't have a named parameter after rest parameters<br>function pick(object, ...keys, last) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = Object.create(null);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;for (let i = 0, len = keys.length; i &lt; len; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result[keys[i]] = object[keys[i]];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>}</p>
        <p class="indent">Here, the parameter <span class="literal">last</span> follows the rest parameter <span class="literal">keys</span>, which would cause a syntax error.</p>
        <p class="indent">The second restriction is that rest parameters cannot be used in an object literal setter. That means this code would also cause a syntax error:</p>
        <p class="programs">let object = {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// Syntax error: Can't use rest param in setter<br>&nbsp;&nbsp;&nbsp;&nbsp;set name(...value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do something<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent">This restriction exists because object literal setters are restricted to a single argument. Rest parameters are, by definition, an infinite number of arguments, so they’re not allowed in this context.</p>
        <h5 class="h5" id="ch03lev3sec02"><strong>How Rest Parameters Affect the arguments Object</strong></h5>
        <p class="noindent">Rest parameters were designed to replace <span class="literal">arguments</span> in JavaScript. Originally, ECMAScript 4 eliminated <span class="literal">arguments</span> and added rest parameters to allow an unlimited number of arguments to be passed to functions. ECMAScript 4 was never standardized, but this idea was retained and reintroduced in ECMAScript 6, despite <span class="literal">arguments</span> not being removed from the language.</p>
        <p class="indent">The <span class="literal">arguments</span> object works together with rest parameters by reflecting the arguments that were passed to the function when called, as illustrated in the following example.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_46"></span>function checkArgs(...args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(args.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(arguments.length);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(args[0], arguments[0]);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(args[1], arguments[1]);<br>}<br><br>checkArgs("a", "b");</p>
        <p class="indent">The call to <span class="literal">checkArgs()</span> outputs the following:</p>
        <p class="programs">2<br>2<br>a a<br>b b</p>
        <p class="indent">The <span class="literal">arguments</span> object always correctly reflects the parameters that were passed into a function regardless of rest parameter usage.</p>
        <h3 class="h3" id="ch03lev1sec03"><strong>Increased Capabilities of the Function Constructor</strong></h3>
        <p class="noindent">The <span class="literal">Function</span> constructor is an infrequently used part of JavaScript that allows you to dynamically create a new function. The arguments to the constructor are the parameters for the function and the function body, all as strings. Here’s an example:</p>
        <p class="programs">var add = new Function("first", "second", "return first + second");<br><br>console.log(add(1, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">ECMAScript 6 augments the capabilities of the <span class="literal">Function</span> constructor to allow default parameters and rest parameters. You need only add an equal sign and a value to the parameter names, as follows:</p>
        <p class="programs">var add = new Function("first", "second = first",<br>&nbsp;&nbsp;&nbsp;&nbsp;"return first + second");<br><br>console.log(add(1, 1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(add(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">In this example, the parameter <span class="literal">second</span> is assigned the value of <span class="literal">first</span> when only one parameter is passed. The syntax is the same as for function declarations that don’t use <span class="literal">Function</span>.</p>
        <p class="indent">For rest parameters, just add the <span class="literal">...</span> before the last parameter, like this:</p>
        <p class="programs">var pickFirst = new Function("...args", "return args[0]");<br><br>console.log(pickFirst(1, 2));&nbsp;&nbsp;&nbsp;// 1</p>
        <p class="indent"><span epub:type="pagebreak" id="page_47"></span>This code creates a function that uses only a single rest parameter and returns the first argument that was passed in. The addition of default and rest parameters ensures that <span class="literal">Function</span> has the same capabilities as the declarative form of creating functions.</p>
        <h3 class="h3" id="ch03lev1sec04"><strong>The Spread Operator</strong></h3>
        <p class="noindent">Closely related to rest parameters is the spread operator. Whereas rest parameters allow you to specify that multiple independent arguments should be combined into an array, the spread operator allows you to specify an array that should be split and passed in as separate arguments to a function. Consider the built-in <span class="literal">Math.max()</span> method, which accepts any number of arguments and returns the one with the highest value. Here’s a simple use case for this method:</p>
        <p class="programs">let value1 = 25,<br>&nbsp;&nbsp;&nbsp;&nbsp;value2 = 50;<br><br>console.log(Math.max(value1, value2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 50</p>
        <p class="indent">When you’re working with just two values, as in this example, <span class="literal">Math.max()</span> is very easy to use. The two values are passed in, and the higher value is returned. But what if you’ve been tracking values in an array, and now you want to find the highest value? The <span class="literal">Math.max()</span> method doesn’t allow you to pass in an array, so in ECMAScript 5 and earlier, you’d be stuck either searching the array manually or using <span class="literal">apply()</span> as follows:</p>
        <p class="programs">let values = [25, 50, 75, 100]<br><br>console.log(Math.max.apply(Math, values));&nbsp;&nbsp;// 100</p>
        <p class="indent">This solution works, but using <span class="literal">apply()</span> in this manner is a bit confusing. It actually seems to obfuscate the true meaning of the code with additional syntax.</p>
        <p class="indent">The ECMAScript 6 spread operator makes this case very simple. Instead of calling <span class="literal">apply()</span>, you can pass the array to <span class="literal">Math.max()</span> directly and prefix it with the same <span class="literal">...</span> pattern you use with rest parameters. The JavaScript engine then splits the array into individual arguments and passes them in, like this:</p>
        <p class="programs">let values = [25, 50, 75, 100]<br><br>// equivalent to<br>// console.log(Math.max(25, 50, 75, 100));<br>console.log(Math.max(...values));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 100</p>
        <p class="indent">Now the call to <span class="literal">Math.max()</span> looks a bit more conventional and avoids the complexity of specifying a <span class="literal">this</span> binding (the first argument to <span class="literal">Math.max.apply()</span> in the previous example) for a simple mathematical operation.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_48"></span>You can mix and match the spread operator with other arguments as well. Suppose you want the smallest number returned from <span class="literal">Math.max()</span> to be 0 (just in case negative numbers sneak into the array). You can pass that argument separately and still use the spread operator for the other arguments, as follows:</p>
        <p class="programs">let values = [-25, -50, -75, -100]<br><br>console.log(Math.max(...values, 0));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0</p>
        <p class="indent">In this example, the last argument passed to <span class="literal">Math.max()</span> is <span class="literal">0</span>, which comes after the other arguments are passed in using the spread operator.</p>
        <p class="indent">The spread operator for argument passing makes using arrays for function arguments much easier. You’ll likely find it to be a suitable replacement for the <span class="literal">apply()</span> method in most circumstances.</p>
        <p class="indent">In addition to the uses you’ve seen for default and rest parameters so far, in ECMAScript 6, you can also apply both parameter types to JavaScript’s <span class="literal">Function</span> constructor.</p>
        <h3 class="h3" id="ch03lev1sec05"><strong>The name Property</strong></h3>
        <p class="noindent">Identifying functions can be challenging in JavaScript given the various ways you can define a function. Additionally, the prevalence of anonymous function expressions makes debugging a bit more difficult, often resulting in stack traces that are hard to read and decipher. For these reasons, ECMAScript 6 adds the <span class="literal">name</span> property to all functions.</p>
        <h4 class="h4" id="ch03lev2sec08"><em><strong>Choosing Appropriate Names</strong></em></h4>
        <p class="noindent">All functions in an ECMAScript 6 program will have an appropriate value for their <span class="literal">name</span> property. To see this in action, look at the following example, which shows a function and function expression, and prints the <span class="literal">name</span> properties for both:</p>
        <p class="programs">function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>var doAnotherThing = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>};<br><br>console.log(doSomething.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "doSomething"<br>console.log(doAnotherThing.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "doAnotherThing"</p>
        <p class="indent">In this code, <span class="literal">doSomething()</span> has a <span class="literal">name</span> property equal to <span class="literal">"doSomething"</span> because it’s a function declaration. The anonymous function expression <span class="literal">doAnotherThing()</span> has a <span class="literal">name</span> of <span class="literal">"doAnotherThing"</span> because that’s the name of the variable to which it is assigned.</p>
        <h4 class="h4" id="ch03lev2sec09"><span epub:type="pagebreak" id="page_49"></span><em><strong>Special Cases of the name Property</strong></em></h4>
        <p class="noindent">Although appropriate names for function declarations and function expressions are easy to find, ECMAScript 6 goes further to ensure that <em>all</em> functions have appropriate names. To illustrate this, consider the following program:</p>
        <p class="programs">var doSomething = function doSomethingElse() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>};<br><br>var person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;get firstName() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return "Nicholas"<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;sayName: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>console.log(doSomething.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "doSomethingElse"<br>console.log(person.sayName.name);&nbsp;&nbsp;&nbsp;// "sayName"<br>console.log(person.firstName.name); // "get firstName"</p>
        <p class="indent">In this example, <span class="literal">doSomething.name</span> is <span class="literal">"doSomethingElse"</span> because the function expression has a name, and that name takes priority over the variable to which the function was assigned. The <span class="literal">name</span> property of <span class="literal">person.sayName()</span> is <span class="literal">"sayName"</span> because the value was interpreted from the object literal. Similarly, <span class="literal">person.firstName</span> is actually a getter function, so its name is <span class="literal">"get firstName"</span> to indicate this difference. Setter functions are prefixed with <span class="literal">"set"</span> as well.</p>
        <p class="indent">There are a couple of other special cases for function names, too. Functions created using <span class="literal">bind()</span> will prefix their names with <span class="literal">"bound"</span> and a space, and functions created using the <span class="literal">Function</span> constructor use the name <span class="literal">"anonymous"</span>, as in this example:</p>
        <p class="programs">var doSomething = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>};<br><br>console.log(doSomething.bind().name);&nbsp;&nbsp;&nbsp;// "bound doSomething"<br><br>console.log((new Function()).name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "anonymous"</p>
        <p class="indent">The <span class="literal">name</span> of a bound function will always be the <span class="literal">name</span> of the function being bound prefixed with the string <span class="literal">"bound "</span> so the bound version of <span class="literal">doSomething()</span> is <span class="literal">"bound doSomething"</span>.</p>
        <p class="indent">Keep in mind that the value of <span class="literal">name</span> for any function does not necessarily refer to a variable of the same name. The <span class="literal">name</span> property is meant to be informative, to help with debugging, so there’s no way to use the value of <span class="literal">name</span> to get a reference to the function.</p>
        <h3 class="h3" id="ch03lev1sec06"><span epub:type="pagebreak" id="page_50"></span><strong>Clarifying the Dual Purpose of Functions</strong></h3>
        <p class="noindent">In ECMAScript 5 and earlier, functions serve the dual purpose of being callable with or without <span class="literal">new</span>. When used with <span class="literal">new</span>, the <span class="literal">this</span> value inside a function is a new object and that new object is returned, as illustrated in this example:</p>
        <p class="programs">function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>}<br><br>var person = new Person("Nicholas");<br>var notAPerson = Person("Nicholas");<br><br>console.log(person);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "[Object object]"<br>console.log(notAPerson);&nbsp;&nbsp;&nbsp;&nbsp;// "undefined"</p>
        <p class="indent">When creating <span class="literal">notAPerson</span>, calling <span class="literal">Person()</span> without <span class="literal">new</span> results in <span class="literal">undefined</span> (and sets a <span class="literal">name</span> property on the global object in non-strict mode). The capitalization of <span class="literal">Person</span> is the only real indicator that the function is meant to be called using <span class="literal">new</span>, as is common in JavaScript programs. This confusion over the dual roles of functions led to some changes in ECMAScript 6.</p>
        <p class="indent">JavaScript has two different internal-only methods for functions: <span class="literal">[[Call]]</span> and <span class="literal">[[Construct]]</span>. When a function is called without <span class="literal">new</span>, the <span class="literal">[[Call]]</span> method is executed, which executes the body of the function as it appears in the code. When a function is called with <span class="literal">new</span>, that’s when the <span class="literal">[[Construct]]</span> method is called. The <span class="literal">[[Construct]]</span> method is responsible for creating a new object, called the instance, and then executing the function body with <span class="literal">this</span> set to the instance. Functions that have a <span class="literal">[[Construct]]</span> method are called <em>constructors</em>.</p>
        <p class="indent">Keep in mind that not all functions have <span class="literal">[[Construct]]</span>, and therefore not all functions can be called with <span class="literal">new</span>. Arrow functions, discussed in “<a href="ch03.xhtml#ch03lev1sec08">Arrow Functions</a>” on <a href="ch03.xhtml#page_54">page 54</a>, do not have a <span class="literal">[[Construct]]</span> method.</p>
        <h4 class="h4" id="ch03lev2sec10"><em><strong>Determining How a Function Was Called in ECMAScript 5</strong></em></h4>
        <p class="noindent">The most popular way to determine whether a function was called with <span class="literal">new</span> (and hence, as a constructor) in ECMAScript 5 is to use <span class="literal">instanceof</span>, for example:</p>
        <p class="programs">function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (this instanceof Person) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;&nbsp;&nbsp;&nbsp;// using new<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("You must use new with Person.")<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var person = new Person("Nicholas");<br>var notAPerson = Person("Nicholas");&nbsp;&nbsp;// throws an error</p>
        <p class="indent"><span epub:type="pagebreak" id="page_51"></span>Here, the <span class="literal">this</span> value is checked to see whether it’s an instance of the constructor, and if it is, execution continues as normal. If <span class="literal">this</span> isn’t an instance of <span class="literal">Person</span>, an error is thrown. This approach works because the <span class="literal">[[Construct]]</span> method creates a new instance of <span class="literal">Person</span> and assigns it to <span class="literal">this</span>. Unfortunately, this approach is not completely reliable because <span class="literal">this</span> can be an instance of <span class="literal">Person</span> without using <span class="literal">new</span>, as in this example:</p>
        <p class="programs">function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (this instanceof Person) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("You must use new with Person.")<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var person = new Person("Nicholas");<br>var notAPerson = Person.call(person, "Michael");&nbsp;&nbsp;&nbsp;&nbsp;// works!</p>
        <p class="indent">The call to <span class="literal">Person.call()</span> passes the <span class="literal">person</span> variable as the first argument, which means <span class="literal">this</span> is set to <span class="literal">person</span> inside the <span class="literal">Person</span> function. To the function, there’s no way to distinguish being called with <span class="literal">Person.call()</span> (or <span class="literal">Person.apply()</span>) with a <span class="literal">Person</span> instance from being called with <span class="literal">new</span>.</p>
        <h4 class="h4" id="ch03lev2sec11"><em><strong>The new.target Metaproperty</strong></em></h4>
        <p class="noindent">To solve the problem of identifying function calls using <span class="literal">new</span>, ECMAScript 6 introduces the <span class="literal">new.target</span> metaproperty. A <em>metaproperty</em> is a property of a nonobject that provides additional information related to its target (such as <span class="literal">new</span>). When a function’s <span class="literal">[[Construct]]</span> method is called, <span class="literal">new.target</span> is filled with the target of the <span class="literal">new</span> operator. That target is typically the constructor of the newly created object instance that will become <span class="literal">this</span> inside the function body. If <span class="literal">[[Call]]</span> is executed, <span class="literal">new.target</span> is <span class="literal">undefined</span>.</p>
        <p class="indent">This new metaproperty allows you to safely detect if a function is called with <span class="literal">new</span> by checking whether <span class="literal">new.target</span> is defined as follows:</p>
        <p class="programs">function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof new.target !== "undefined") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("You must use new with Person.")<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var person = new Person("Nicholas");<br>var notAPerson = Person.call(person, "Michael");&nbsp;&nbsp;&nbsp;&nbsp;// error!</p>
        <p class="indent">By using <span class="literal">new.target</span> instead of <span class="literal">this instanceof Person</span>, the <span class="literal">Person</span> constructor is now correctly throwing an error when used without <span class="literal">new</span>.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_52"></span>You can also check that <span class="literal">new.target</span> was called with a specific constructor. For instance, look at this example:</p>
        <p class="programs">function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof new.target === Person) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("You must use new with Person.")<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>function AnotherPerson(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;Person.call(this, name);<br>}<br><br>var person = new Person("Nicholas");<br>var anotherPerson = new AnotherPerson("Nicholas");&nbsp;&nbsp;// error!</p>
        <p class="indent">In this code, <span class="literal">new.target</span> must be <span class="literal">Person</span> in order to work correctly. When <span class="literal">new AnotherPerson("Nicholas")</span> is called, the subsequent call to <span class="literal">Person.call(this, name)</span> will throw an error because <span class="literal">new.target</span> is <span class="literal">undefined</span> inside of the <span class="literal">Person</span> constructor (it was called without <span class="literal">new</span>).</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>WARNING</strong></span></p>
        <p class="notep"><em>Using <span class="literal">new.target</span> outside a function is a syntax error.</em></p>
        </div>
        <p class="indent">By adding <span class="literal">new.target</span>, ECMAScript 6 helped to clarify some ambiguity concerning function calls. Following along this theme, ECMAScript 6 also addresses another previously ambiguous part of the language: declaring functions inside blocks.</p>
        <h3 class="h3" id="ch03lev1sec07"><strong>Block-Level Functions</strong></h3>
        <p class="noindent">In ECMAScript 3 and earlier, a function declaration occurring inside a block (a <em>block-level function</em>) was technically a syntax error, but all browsers still supported it. Unfortunately, each browser that allowed the syntax behaved in a slightly different way, so it’s considered a best practice to avoid function declarations inside blocks (the best alternative is to use a function expression).</p>
        <p class="indent">In an attempt to rein in this incompatible behavior, ECMAScript 5 strict mode introduced an error whenever a function declaration was used inside a block in this way:</p>
        <p class="programs">"use strict";<br><br>if (true) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// throws a syntax error in ES5, not so in ES6<br>&nbsp;&nbsp;&nbsp;&nbsp;function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_53"></span>In ECMAScript 5, this code throws a syntax error. In ECMAScript 6, the <span class="literal">doSomething()</span> function is considered a block-level declaration and can be accessed and called within the same block in which it was defined. For example:</p>
        <p class="programs">"use strict";<br><br>if (true) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(typeof doSomething);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "function"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;doSomething();<br>}<br><br>console.log(typeof doSomething);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "undefined"</p>
        <p class="indent">Block-level functions are hoisted to the top of the block in which they are defined, so <span class="literal">typeof doSomething</span> returns <span class="literal">"function"</span>, even though it appears before the function declaration in the code. Once the <span class="literal">if</span> block is finished executing, <span class="literal">doSomething()</span> no longer exists.</p>
        <h4 class="h4" id="ch03lev2sec12"><em><strong>Deciding When to Use Block-Level Functions</strong></em></h4>
        <p class="noindent">Block-level functions are similar to <span class="literal">let</span> function expressions in that the function definition is removed once execution flows out of the block in which it’s defined. The key difference is that block-level functions are hoisted to the top of the containing block. Function expressions that use <span class="literal">let</span> are not hoisted, as this example illustrates:</p>
        <p class="programs">"use strict";<br><br>if (true) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(typeof doSomething);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// throws an error<br><br>&nbsp;&nbsp;&nbsp;&nbsp;let doSomething = function () {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;doSomething();<br>}<br><br>console.log(typeof doSomething);</p>
        <p class="indent">Here, code execution stops when <span class="literal">typeof doSomething</span> is executed, because the <span class="literal">let</span> statement hasn’t been executed yet, leaving <span class="literal">doSomething()</span> in the TDZ. Knowing this difference, you can choose whether to use block-level functions or <span class="literal">let</span> expressions based on whether or not you want the hoisting behavior.</p>
        <h4 class="h4" id="ch03lev2sec13"><span epub:type="pagebreak" id="page_54"></span><em><strong>Block-Level Functions in Non-Strict Mode</strong></em></h4>
        <p class="noindent">ECMAScript 6 also allows block-level functions in non-strict mode, but the behavior is slightly different. Instead of hoisting these declarations to the top of the block, they are hoisted all the way to the containing function or global environment. For example:</p>
        <p class="programs">// ECMAScript 6 behavior<br>if (true) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(typeof doSomething);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "function"<br><br>&nbsp;&nbsp;&nbsp;&nbsp;function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;doSomething();<br>}<br><br>console.log(typeof doSomething);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "function"</p>
        <p class="indent">In this example, <span class="literal">doSomething()</span> is hoisted into the global scope so it still exists outside the <span class="literal">if</span> block. ECMAScript 6 standardized this behavior to remove the incompatible browser behaviors that previously existed, so all ECMAScript 6 runtimes should behave in the same way.</p>
        <p class="indent">Allowing block-level functions improves your ability to declare functions in JavaScript, but ECMAScript 6 also introduced a completely new way to declare functions.</p>
        <h3 class="h3" id="ch03lev1sec08"><strong>Arrow Functions</strong></h3>
        <p class="noindentb">One of the most interesting new parts of ECMAScript 6 is the <em>arrow function</em>. Arrow functions are, as the name suggests, functions defined with a new syntax that uses an arrow (<span class="literal">=&gt;</span>). But arrow functions behave differently than traditional JavaScript functions in a number of important ways:</p>
        <p class="hang"><strong>No <span class="literal">this</span>, <span class="literal">super</span>, <span class="literal">arguments</span>, and <span class="literal">new.target</span> bindings</strong> The values of <span class="literal">this</span>, <span class="literal">super</span>, <span class="literal">arguments</span>, and <span class="literal">new.target</span> inside the function are defined by the closest containing non-arrow function. (<span class="literal">super</span> is covered in <a href="ch04.xhtml#ch04">Chapter 4</a>.)</p>
        <p class="hang"><strong>Cannot be called with <span class="literal">new</span></strong> Arrow functions do not have a <span class="literal">[[Construct]]</span> method and therefore cannot be used as constructors. Arrow functions throw an error when used with <span class="literal">new</span>.</p>
        <p class="hang"><strong>No prototype</strong> Because you can’t use <span class="literal">new</span> on an arrow function, there’s no need for a prototype. The <span class="literal">prototype</span> property of an arrow function doesn’t exist.</p>
        <p class="hang"><span epub:type="pagebreak" id="page_55"></span><strong>Can’t change <span class="literal">this</span></strong> The value of <span class="literal">this</span> inside the function can’t be changed. It remains the same throughout the entire life cycle of the function.</p>
        <p class="hang"><strong>No <span class="literal">arguments</span> object</strong> Because arrow functions have no <span class="literal">arguments</span> binding, you must rely on named and rest parameters to access function arguments.</p>
        <p class="hang"><strong>No duplicate named parameters</strong> Arrow functions cannot have duplicate named parameters in strict or non-strict mode, as opposed to non-arrow functions, which cannot have duplicate named parameters only in strict mode.</p>
        <p class="indentt">There are a few reasons for these differences. First and foremost, <span class="literal">this</span> binding is a common source of error in JavaScript. It’s very easy to lose track of the <span class="literal">this</span> value inside a function, which can result in unintended program behavior, and arrow functions eliminate this confusion. Second, by limiting arrow functions to simply executing code with a single <span class="literal">this</span> value, JavaScript engines can more easily optimize these operations, unlike regular functions, which might be used as a constructor or otherwise modified.</p>
        <p class="indent">The remaining differences also focus on reducing errors and ambiguities inside arrow functions. By doing so, JavaScript engines are better able to optimize arrow function execution.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Arrow functions also have a <span class="literal">name</span> property that follows the same rule as other functions.</em></p>
        </div>
        <h4 class="h4" id="ch03lev2sec14"><em><strong>Arrow Function Syntax</strong></em></h4>
        <p class="noindent">The syntax for arrow functions comes in many flavors depending on what you’re trying to accomplish. All variations begin with function arguments, followed by the arrow, followed by the body of the function. The arguments and the body can take different forms depending on usage. For example, the following arrow function takes a single argument and simply returns it:</p>
        <p class="programs">let reflect = value =&gt; value;<br><br>// effectively equivalent to:<br><br>let reflect = function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return value;<br>};</p>
        <p class="indent">When there is only one argument for an arrow function, that one argument can be used directly without any further syntax. The arrow comes next, and the expression to the right of the arrow is evaluated and returned. Even though there is no explicit <span class="literal">return</span> statement, this arrow function will return the first argument that is passed in.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_56"></span>If you are passing in more than one argument, you must include parentheses around those arguments, like this:</p>
        <p class="programs">let sum = (num1, num2) =&gt; num1 + num2;<br><br>// effectively equivalent to:<br><br>let sum = function(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;<br>};</p>
        <p class="indent">The <span class="literal">sum()</span> function simply adds two arguments together and returns the result. The only difference between this arrow function and the <span class="literal">reflect()</span> function is that the arguments are enclosed in parentheses with a comma separating them (like traditional functions).</p>
        <p class="indent">If there are no arguments to the function, you must include an empty set of parentheses in the declaration, as follows:</p>
        <p class="programs">let getName = () =&gt; "Nicholas";<br><br>// effectively equivalent to:<br><br>let getName = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return "Nicholas";<br>};</p>
        <p class="indent">When you want to provide a more traditional function body, perhaps consisting of more than one expression, you need to wrap the function body in curly braces and explicitly define a return value, as in this version of <span class="literal">sum()</span>:</p>
        <p class="programs">let sum = (num1, num2) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;<br>};<br><br>// effectively equivalent to:<br><br>let sum = function(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;<br>};</p>
        <p class="indent">You can more or less treat the inside of the curly braces the same as you would in a traditional function except <span class="literal">arguments</span> is not available.</p>
        <p class="indent">If you want to create a function that does nothing, you need to include curly braces, like this:</p>
        <p class="programs">let doNothing = () =&gt; {};<br><br>// effectively equivalent to:<br><br>let doNothing = function() {};</p>
        <p class="indent"><span epub:type="pagebreak" id="page_57"></span>Curly braces denote the function’s body, which works just fine in the cases you’ve seen so far. But an arrow function that wants to return an object literal outside a function body must wrap the literal in parentheses. For example:</p>
        <p class="programs">let getTempItem = id =&gt; ({ id: id, name: "Temp" });<br><br>// effectively equivalent to:<br><br>let getTempItem = function(id) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;id: id,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: "Temp"<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>};</p>
        <p class="indent">Wrapping the object literal in parentheses signals that the curly braces are an object literal instead of the function body.</p>
        <h4 class="h4" id="ch03lev2sec15"><em><strong>Creating Immediately Invoked Function Expressions</strong></em></h4>
        <p class="noindent">One popular use of functions in JavaScript is creating immediately invoked function expressions (IIFEs). IIFEs allow you to define an anonymous function and call it immediately without saving a reference. This pattern comes in handy when you want to create a scope that is shielded from the rest of a program. For example:</p>
        <p class="programs">let person = function(name) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getName: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>}("Nicholas");<br><br>console.log(person.getName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"</p>
        <p class="indent">In this code, the IIFE creates an object with a <span class="literal">getName()</span> method. The method uses the <span class="literal">name</span> argument as the return value, effectively making <span class="literal">name</span> a private member of the returned object.</p>
        <p class="indent">You can accomplish the same thing using arrow functions, as long as you wrap the arrow function in parentheses:</p>
        <p class="programs">let person = ((name) =&gt; {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;getName: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return name;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><span epub:type="pagebreak" id="page_58"></span>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>})("Nicholas");<br><br>console.log(person.getName());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"</p>
        <p class="indent">Note that the parentheses are only around the arrow function definition, not around <span class="literal">("Nicholas")</span>. This is different from a formal function where the parentheses can be placed outside the passed-in parameters as well as just around the function definition.</p>
        <h4 class="h4" id="ch03lev2sec16"><em><strong>No this Binding</strong></em></h4>
        <p class="noindent">One of the most common areas of error in JavaScript is the binding of <span class="literal">this</span> inside functions. Because the value of <span class="literal">this</span> can change inside a single function depending on the context in which the function is called, it’s possible to mistakenly affect one object when you meant to affect another. Consider the following example:</p>
        <p class="programs">let PageHandler = {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;id: "123456",<br><br>&nbsp;&nbsp;&nbsp;&nbsp;init: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.addEventListener("click", function(event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.doSomething(event.type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// error<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, false);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br><br>&nbsp;&nbsp;&nbsp;&nbsp;doSomething: function(type) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Handling " + type&nbsp;&nbsp;+ " for " + this.id);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent">In this code, the object <span class="literal">PageHandler</span> is designed to handle interactions on the page. The <span class="literal">init()</span> method is called to set up the interactions, and that method in turn assigns an event handler to call <span class="literal">this.doSomething()</span>. However, this code doesn’t work exactly as intended.</p>
        <p class="indent">The call to <span class="literal">this.doSomething()</span> is broken because <span class="literal">this</span> is a reference to the object that was the target of the event (in this case <span class="literal">document</span>) instead of being bound to <span class="literal">PageHandler</span>. If you tried to run this code, you’d get an error when the event handler fires because <span class="literal">this.doSomething()</span> doesn’t exist on the target <span class="literal">document</span> object.</p>
        <p class="indent">You could fix this by binding the value of <span class="literal">this</span> to <span class="literal">PageHandler</span> explicitly using the <span class="literal">bind()</span> method on the function instead, like this:</p>
        <p class="programs">let PageHandler = {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;id: "123456",<br><br>&nbsp;&nbsp;&nbsp;&nbsp;init: function() {<br><span epub:type="pagebreak" id="page_59"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.addEventListener("click", (function(event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.doSomething(event.type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no error<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).bind(this), false);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br><br>&nbsp;&nbsp;&nbsp;&nbsp;doSomething: function(type) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Handling " + type&nbsp;&nbsp;+ " for " + this.id);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent">Now the code works as expected, but it might look a bit strange. By calling <span class="literal">bind(this)</span>, you’re actually creating a new function whose <span class="literal">this</span> is bound to the current <span class="literal">this</span>, which is <span class="literal">PageHandler</span>. To avoid creating an extra function, a better way to fix this code is to use an arrow function.</p>
        <p class="indent">Arrow functions have no <span class="literal">this</span> binding, which means the value of <span class="literal">this</span> inside an arrow function can only be determined by looking up the scope chain. If the arrow function is contained within a non-arrow function, <span class="literal">this</span> will be the same as the containing function; otherwise, <span class="literal">this</span> is undefined. Here’s one way you could write this code using an arrow function:</p>
        <p class="programs">let PageHandler = {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;id: "123456",<br><br>&nbsp;&nbsp;&nbsp;&nbsp;init: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;document.addEventListener("click",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;event =&gt; this.doSomething(event.type), false);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br><br>&nbsp;&nbsp;&nbsp;&nbsp;doSomething: function(type) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Handling " + type&nbsp;&nbsp;+ " for " + this.id);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent">The event handler in this example is an arrow function that calls <span class="literal">this. doSomething()</span>. The value of <span class="literal">this</span> is the same as it is within <span class="literal">init()</span>, so this version of the code works similarly to the one using <span class="literal">bind(this)</span>. Even though the <span class="literal">doSomething()</span> method doesn’t return a value, it’s still the only statement executed in the function body, so there is no need to include curly braces.</p>
        <p class="indent">Arrow functions are designed to be “throwaway” functions, and so cannot be used to define new types; this is evident from the missing <span class="literal">prototype</span> property, which regular functions have. If you try to use the <span class="literal">new</span> operator with an arrow function, you’ll get an error, as in this example:</p>
        <p class="programs">var MyType = () =&gt; {},<br>&nbsp;&nbsp;&nbsp;&nbsp;object = new MyType();&nbsp;&nbsp;// error - you can't use arrow functions with 'new'</p>
        <p class="indent">In this code, the call to <span class="literal">new MyType()</span> fails because <span class="literal">MyType</span> is an arrow function and therefore has no <span class="literal">[[Construct]]</span> behavior. Knowing that arrow functions cannot be used with <span class="literal">new</span> allows JavaScript engines to further optimize their behavior.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_60"></span>Also, because the <span class="literal">this</span> value is determined by the containing function in which the arrow function is defined, you cannot change the value of <span class="literal">this</span> using <span class="literal">call()</span>, <span class="literal">apply()</span>, or <span class="literal">bind()</span>.</p>
        <h4 class="h4" id="ch03lev2sec17"><em><strong>Arrow Functions and Arrays</strong></em></h4>
        <p class="noindent">The concise syntax for arrow functions makes them ideal for use with array processing, too. For example, if you want to sort an array using a custom comparator, you’d typically write something like this:</p>
        <p class="programs">var result = values.sort(function(a, b) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return a - b;<br>});</p>
        <p class="indent">That’s a lot of syntax for a very simple procedure. Compare that to the terser arrow function version:</p>
        <p class="programs">var result = values.sort((a, b) =&gt; a - b);</p>
        <p class="indent">The array methods that accept callback functions, such as <span class="literal">sort()</span>, <span class="literal">map()</span>, and <span class="literal">reduce()</span>, can all benefit from simpler arrow function syntax, which changes seemingly complex processes into simpler code.</p>
        <h4 class="h4" id="ch03lev2sec18"><em><strong>No arguments Binding</strong></em></h4>
        <p class="noindent">Even though arrow functions don’t have their own <span class="literal">arguments</span> object, it’s possible for them to access the <span class="literal">arguments</span> object from a containing function. That <span class="literal">arguments</span> object is then available no matter where the arrow function is executed later on. For example:</p>
        <p class="programs">function createArrowFunctionReturningFirstArg() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return () =&gt; arguments[0];<br>}<br><br>var arrowFunction = createArrowFunctionReturningFirstArg(5);<br><br>console.log(arrowFunction());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 5</p>
        <p class="indent">Inside <span class="literal">createArrowFunctionReturningFirstArg()</span>, the <span class="literal">arguments[0]</span> element is referenced by the created arrow function. That reference contains the first argument passed to the <span class="literal">createArrowFunctionReturningFirstArg()</span> function. When the arrow function is later executed, it returns <span class="literal">5</span>, which was the first argument passed to <span class="literal">createArrowFunctionReturningFirstArg()</span>. Even though the arrow function is no longer in the scope of the function that created it, <span class="literal">arguments</span> remains accessible due to scope chain resolution of the <span class="literal">arguments</span> identifier.</p>
        <h4 class="h4" id="ch03lev2sec19"><span epub:type="pagebreak" id="page_61"></span><em><strong>Identifying Arrow Functions</strong></em></h4>
        <p class="noindent">Despite their different syntax, arrow functions are still functions and are identified as such. Consider the following code:</p>
        <p class="programs">var comparator = (a, b) =&gt; a - b;<br><br>console.log(typeof comparator);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "function"<br>console.log(comparator instanceof Function);&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">The <span class="literal">console.log()</span> output reveals that both <span class="literal">typeof</span> and <span class="literal">instanceof</span> behave the same with arrow functions as they do with other functions.</p>
        <p class="indent">Also like other functions, you can still use <span class="literal">call()</span>, <span class="literal">apply()</span>, and <span class="literal">bind()</span> on arrow functions, although the <span class="literal">this</span> binding of the function will not be affected. Here are some examples:</p>
        <p class="programs">var sum = (num1, num2) =&gt; num1 + num2;<br><br>console.log(sum.call(null, 1, 2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br>console.log(sum.apply(null, [1, 2]));&nbsp;&nbsp;// 3<br><br>var boundSum = sum.bind(null, 1, 2);<br><br>console.log(boundSum());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3</p>
        <p class="indent">The <span class="literal">sum()</span> function is called using <span class="literal">call()</span> and <span class="literal">apply()</span> to pass arguments, as you’d do with any function. The <span class="literal">bind()</span> method creates <span class="literal">boundSum()</span>, which has its two arguments bound to <span class="literal">1</span> and <span class="literal">2</span> so they don’t need to be passed directly.</p>
        <p class="indent">Arrow functions are appropriate to use anywhere you’re currently using an anonymous function expression, such as with callbacks. The next section covers another major ECMAScript 6 development, but this one is all internal and has no new syntax.</p>
        <h3 class="h3" id="ch03lev1sec09"><strong>Tail Call Optimization</strong></h3>
        <p class="noindent">Perhaps the most interesting change to functions in ECMAScript 6 is an engine optimization that changes the tail call system. A <em>tail call</em> is when a function is called as the last statement in another function, like this:</p>
        <p class="programs">function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return doSomethingElse();&nbsp;&nbsp;// tail call<br>}</p>
        <p class="indent">Tail calls as implemented in ECMAScript 5 engines are handled just like any other function call: a new stack frame is created and pushed onto the call stack to represent the function call. That means every previous stack frame is kept in memory, which is problematic when the call stack gets too large.</p>
        <h4 class="h4" id="ch03lev2sec20"><span epub:type="pagebreak" id="page_62"></span><em><strong>How Tail Calls Are Different in ECMAScript 6</strong></em></h4>
        <p class="noindentb">ECMAScript 6 reduces the size of the call stack for certain tail calls in strict mode (non-strict mode tail calls are left untouched). With this optimization, instead of creating a new stack frame for a tail call, the current stack frame is cleared and reused as long as the following conditions are met:</p>
        <p class="bull">• The tail call does not require access to variables in the current stack frame (meaning the function is not a closure).</p>
        <p class="bull">• The function making the tail call has no further work to do after the tail call returns.</p>
        <p class="bull">• The result of the tail call is returned as the function value.</p>
        <p class="indentt">As an example, this code can easily be optimized because it fits all three criteria:</p>
        <p class="programs">"use strict";<br><br>function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// optimized<br>&nbsp;&nbsp;&nbsp;&nbsp;return doSomethingElse();<br>}</p>
        <p class="indent">This function makes a tail call to <span class="literal">doSomethingElse()</span>, returns the result immediately, and doesn’t access any variables in the local scope. One small change, not returning the result, results in an unoptimized function:</p>
        <p class="programs">"use strict";<br><br>function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// not optimized - no return<br>&nbsp;&nbsp;&nbsp;&nbsp;doSomethingElse();<br>}</p>
        <p class="indent">Similarly, if you have a function that performs an operation after returning from the tail call, the function can’t be optimized:</p>
        <p class="programs">"use strict";<br><br>function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// not optimized - must add after returning<br>&nbsp;&nbsp;&nbsp;&nbsp;return 1 + doSomethingElse();<br>}</p>
        <p class="indent">This example adds the result of <span class="literal">doSomethingElse()</span> with 1 before returning the value, and that’s enough to turn off optimization.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_63"></span>Another common way to inadvertently turn off optimization is to store the result of a function call in a variable and then return the result, such as:</p>
        <p class="programs">"use strict";<br><br>function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// not optimized - call isn't in tail position<br>&nbsp;&nbsp;&nbsp;&nbsp;var result = doSomethingElse();<br>&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>}</p>
        <p class="indent">This example cannot be optimized because the value of <span class="literal">doSomethingElse()</span> isn’t immediately returned.</p>
        <p class="indent">Perhaps the hardest situation to avoid is in using closures. Because a closure has access to variables in the containing scope, tail call optimization may be turned off. For example:</p>
        <p class="programs">"use strict";<br><br>function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;var num = 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;func = () =&gt; num;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// not optimized - function is a closure<br>&nbsp;&nbsp;&nbsp;&nbsp;return func();<br>}</p>
        <p class="indent">The closure <span class="literal">func()</span> has access to the local variable <span class="literal">num</span> in this example. Even though the call to <span class="literal">func()</span> immediately returns the result, optimization can’t occur due to referencing the variable <span class="literal">num</span>.</p>
        <h4 class="h4" id="ch03lev2sec21"><em><strong>How to Harness Tail Call Optimization</strong></em></h4>
        <p class="noindent">In practice, tail call optimization happens behind the scenes, so you don’t need to think about it unless you’re trying to optimize a function. The primary use case for tail call optimization is in recursive functions, because that is where the optimization has the greatest effect. Consider this function, which computes factorials:</p>
        <p class="programs">function factorial(n) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (n &lt;= 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// not optimized - must multiply after returning<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return n * factorial(n - 1);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_64"></span>This version of the function cannot be optimized, because multiplication must happen after the recursive call to <span class="literal">factorial()</span>. If <span class="literal">n</span> is a very large number, the call stack size will grow and could potentially cause a stack overflow.</p>
        <p class="indent">To optimize the function, you need to ensure that the multiplication doesn’t happen after the last function call. To do this, you can use a default parameter to move the multiplication operation outside the <span class="literal">return</span> statement. The resulting function carries along the temporary result into the next iteration, creating a function that behaves the same but <em>can</em> be optimized by an ECMAScript 6 engine. Here’s the new code:</p>
        <p class="programs">function factorial(n, p = 1) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (n &lt;= 1) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1 * p;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let result = n * p;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// optimized<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return factorial(n - 1, result);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent">In this rewritten version of <span class="literal">factorial()</span>, a second argument <span class="literal">p</span> is added as a parameter with a default value of 1. The <span class="literal">p</span> parameter holds the previous multiplication result so the next result can be computed without another function call. When <span class="literal">n</span> is greater than 1, the multiplication is done first and then passed in as the second argument to <span class="literal">factorial()</span>. This allows the ECMAScript 6 engine to optimize the recursive call.</p>
        <p class="indent">Think about tail call optimization whenever you’re writing a recursive function, because it can provide a significant performance improvement, especially when applied in a computationally expensive function.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>WARNING</strong></span></p>
        <p class="notep"><em>At the time of this writing, ECMAScript 6 tail call optimization is undergoing review for changes. It’s possible that tail call optimization will eventually require special syntax for increased clarity. The ongoing discussion may result in changes in ECMAScript 8 (ECMAScript 2017).</em></p>
        </div>
        <h3 class="h3" id="ch03lev1sec10"><strong>Summary</strong></h3>
        <p class="noindent">Functions haven’t undergone a huge change in ECMAScript 6 but rather a series of incremental changes that make them easier to work with.</p>
        <p class="indent">Default function parameters allow you to easily specify what value to use when a particular argument isn’t passed. Prior to ECMAScript 6, this would require some extra code inside the function to check for the presence of arguments <em>and</em> assign a different value.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_65"></span>Rest parameters allow you to specify an array into which all remaining parameters should be placed. Using a real array and letting you indicate which parameters to include makes rest parameters a much more flexible solution than <span class="literal">arguments</span>.</p>
        <p class="indent">The spread operator is a companion to rest parameters, allowing you to deconstruct an array into separate parameters when calling a function. Prior to ECMAScript 6, there were only two ways to pass individual parameters contained in an array: by manually specifying each parameter or using <span class="literal">apply()</span>. With the spread operator, you can easily pass an array to any function without worrying about the <span class="literal">this</span> binding of the function.</p>
        <p class="indent">The addition of the <span class="literal">name</span> property should help you more easily identify functions for debugging and evaluation purposes. ECMAScript 6 also formally defines the behavior of block-level functions so they are no longer a syntax error in strict mode.</p>
        <p class="indent">In ECMAScript 6, the behavior of a function is defined by <span class="literal">[[Call]]</span>, normal function execution, and <span class="literal">[[Construct]]</span> when a function is called with <span class="literal">new</span>. The <span class="literal">new.target</span> metaproperty also allows you to determine if a function was called using <span class="literal">new</span> or not.</p>
        <p class="indent">The biggest change to functions in ECMAScript 6 was the addition of arrow functions. Arrow functions are designed to be used in place of anonymous function expressions. Arrow functions have a more concise syntax, lexical <span class="literal">this</span> binding, and no <span class="literal">arguments</span> object. Additionally, arrow functions can’t change their <span class="literal">this</span> binding and therefore can’t be used as constructors.</p>
        <p class="indent">Tail call optimization allows some function calls to be optimized to maintain a smaller call stack, use less memory, and prevent stack overflow errors. This optimization is applied by the engine automatically when it is safe to do so; however, you might decide to rewrite recursive functions to take advantage of this optimization.<span epub:type="pagebreak" id="page_66"></span></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com