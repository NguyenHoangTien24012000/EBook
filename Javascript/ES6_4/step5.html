<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch05"><span epub:type="pagebreak" id="page_83"></span><strong><span class="big">5</span><br>DESTRUCTURING FOR EASIER DATA ACCESS</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">Object and array literals are two of the most frequently used notations in JavaScript, and thanks to the popular JSON data format, they have become a particularly important part of the language. It’s quite common to define objects and arrays, and then systematically pull out relevant pieces of information from those structures. ECMAScript 6 simplifies this task by adding <em>destructuring</em>, which is the process of breaking down a data structure into smaller parts. This chapter shows you how to harness destructuring for objects and arrays.</p>
        <h3 class="h3" id="ch05lev1sec01"><span epub:type="pagebreak" id="page_84"></span><strong>Why Is Destructuring Useful?</strong></h3>
        <p class="noindent">In ECMAScript 5 and earlier, the need to fetch information from objects and arrays could result in a lot of duplicate code to get certain data into local variables.</p>
        <p class="indent">For example:</p>
        <p class="programs">let options = {<br>&nbsp;&nbsp;&nbsp;&nbsp;repeat: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;save: false<br>};<br><br>// extract data from the object<br>let repeat = options.repeat,<br>&nbsp;&nbsp;&nbsp;&nbsp;save = options.save;</p>
        <p class="indent">This code extracts the values of <span class="literal">repeat</span> and <span class="literal">save</span> from the <span class="literal">options</span> object, and stores that data in local variables with the same names. Although this code looks simple, imagine if you had a large number of variables to assign: you would have to assign them all one by one. And if you had to traverse a nested data structure to find the information instead, you might have to dig through the entire structure just to find one piece of data.</p>
        <p class="indent">That’s why ECMAScript 6 adds destructuring for objects <em>and</em> arrays. When you break down a data structure into smaller parts, getting the information you need from it becomes much easier. Many languages implement destructuring with a minimal amount of syntax to make the process simpler to use. The ECMAScript 6 implementation actually uses syntax you’re already familiar with: the syntax for object and array literals.</p>
        <h3 class="h3" id="ch05lev1sec02"><strong>Object Destructuring</strong></h3>
        <p class="noindent">Object destructuring syntax uses an object literal on the left side of an assignment operation. For example:</p>
        <p class="programs">let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "foo"<br>};<br><br>let { type, name } = node;<br><br>console.log(type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Identifier"<br>console.log(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "foo"</p>
        <p class="indent">In this code, the value of <span class="literal">node.type</span> is stored in a variable called <span class="literal">type</span>, and the value of <span class="literal">node.name</span> is stored in a variable called <span class="literal">name</span>. This syntax is the same as the object literal property initializer shorthand introduced in <a href="ch04.xhtml#ch04">Chapter 4</a>. The identifiers <span class="literal">type</span> and <span class="literal">name</span> are both declarations of local variables and the properties to read the value from on the <span class="literal">node</span> object.</p>
        <div class="sidebar">
        <p class="sidebart"><span epub:type="pagebreak" id="page_85"></span><strong>DON’T FORGET THE INITIALIZER</strong></p>
        <p class="noindent">When you’re using destructuring to declare variables using <span class="literal">var</span>, <span class="literal">let</span>, or <span class="literal">const</span>, you must supply an initializer (the value after the equal sign). The following lines of code will all throw syntax errors due to a missing initializer:</p>
        <p class="programs">// syntax error!<br>var { type, name };<br><br>// syntax error!<br>let { type, name };<br><br>// syntax error!<br>const { type, name };</p>
        <p class="indent">Although <span class="literal">const</span> always requires an initializer, even when you’re using nondestructured variables, <span class="literal">var</span> and <span class="literal">let</span> require initializers only when you’re using destructuring.</p>
        </div>
        <h4 class="h4" id="ch05lev2sec01"><em><strong>Destructuring Assignment</strong></em></h4>
        <p class="noindent">The object destructuring examples you’ve seen so far have used variable declarations. However, it’s also possible to use destructuring in assignments. For instance, you might decide to change the values of variables after they’re defined, as follows:</p>
        <p class="programs">let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "foo"<br>},<br>type = "Literal",<br>name = 5;<br><br>// assign different values using destructuring<br>({ type, name } = node);<br><br>console.log(type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Identifier"<br>console.log(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "foo"</p>
        <p class="indent">In this example, <span class="literal">type</span> and <span class="literal">name</span> are initialized with values when declared, and then two variables with the same names are initialized with different values. The next line uses destructuring assignments to change those values by reading from the <span class="literal">node</span> object. Note that you must put parentheses around a destructuring assignment statement. The reason is that an opening curly brace is expected to be a block statement, and a block statement cannot appear on the left side of an assignment. The parentheses signal that the next curly brace is not a block statement and should be interpreted as an expression, allowing the assignment to complete.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_86"></span>A destructuring assignment expression evaluates to the right side of the expression (after the <span class="literal">=</span>). That means you can use a destructuring assignment expression anywhere a value is expected. For instance, consider this example, which passes a value to a function:</p>
        <p class="programs">let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "foo"<br>},<br>type = "Literal",<br>name = 5;<br><br>function outputInfo(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value === node);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>}<br><br>outputInfo({ type, name } = node);<br><br>console.log(type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Identifier"<br>console.log(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "foo"</p>
        <p class="indent">The <span class="literal">outputInfo()</span> function is called with a destructuring assignment expression. The expression evaluates to <span class="literal">node</span> because that is the value of the right side of the expression. The assignments to <span class="literal">type</span> and <span class="literal">name</span> behave normally, and <span class="literal">node</span> is passed to the <span class="literal">outputInfo()</span> function.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>An error is thrown when the right side of the destructuring assignment expression (the expression after <span class="literal">=</span>) evaluates to <span class="literal">null</span> or <span class="literal">undefined</span>. This happens because any attempt to read a property of <span class="literal">null</span> or <span class="literal">undefined</span> results in a runtime error.</em></p>
        </div>
        <h4 class="h4" id="ch05lev2sec02"><em><strong>Default Values</strong></em></h4>
        <p class="noindent">When you use a destructuring assignment statement and you specify a local variable with a property name that doesn’t exist on the object, that local variable is assigned a value of <span class="literal">undefined</span>. For example:</p>
        <p class="programs">let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "foo"<br>};<br><br>let { type, name, value } = node;<br><br>console.log(type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Identifier"<br>console.log(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "foo"<br>console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined</p>
        <p class="indent">This code defines an additional local variable called <span class="literal">value</span> and attempts to assign it a value. However, no corresponding <span class="literal">value</span> property is on the <span class="literal">node</span> object, so the variable is assigned the value of <span class="literal">undefined</span> as expected.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_87"></span>You can optionally define a default value to use when a specified property doesn’t exist. To do so, insert an equal sign (<span class="literal">=</span>) after the property name and specify the default value, like this:</p>
        <p class="programs">let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "foo"<br>};<br><br>let { type, name, value = true } = node;<br><br>console.log(type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Identifier"<br>console.log(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "foo"<br>console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">In this example, the variable <span class="literal">value</span> is given <span class="literal">true</span> as a default value. The default value is only used if the property is missing on <span class="literal">node</span> or has a value of <span class="literal">undefined</span>. Because no <span class="literal">node.value</span> property exists, the variable <span class="literal">value</span> uses the default value. This works similarly to the default parameter values for functions, as discussed in <a href="ch03.xhtml#ch03">Chapter 3</a>.</p>
        <h4 class="h4" id="ch05lev2sec03"><em><strong>Assigning to Different Local Variable Names</strong></em></h4>
        <p class="noindent">Up to this point, each destructuring assignment example has used the object property name as the local variable name; for example, the value of <span class="literal">node.type</span> was stored in a <span class="literal">type</span> variable. That works well when you want to use the same name, but what if you don’t? ECMAScript 6 has an extended syntax that allows you to assign to a local variable with a different name, and that syntax looks like the object literal non-shorthand property initializer syntax. Here’s an example:</p>
        <p class="programs">let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "foo"<br>};<br><br>let { type: localType, name: localName } = node;<br><br>console.log(localType);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Identifier"<br>console.log(localName);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "foo"</p>
        <p class="indent">This code uses destructuring assignments to declare the <span class="literal">localType</span> and <span class="literal">localName</span> variables, which contain the values from the <span class="literal">node.type</span> and <span class="literal">node.name</span> properties, respectively. The syntax <span class="literal">type: localType</span> reads the property named <span class="literal">type</span> and stores its value in the <span class="literal">localType</span> variable. This syntax is effectively the opposite of traditional object literal syntax, where the name is on the left of the colon and the value is on the right. In this case, the name is on the right of the colon and the location of the value to read is on the left.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_88"></span>You can add default values when you’re using a different variable name, as well. The equal sign and default value are still placed after the local variable name. For example:</p>
        <p class="programs">let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier"<br>};<br><br>let { type: localType, name: localName = "bar" } = node;<br><br>console.log(localType);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Identifier"<br>console.log(localName);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "bar"</p>
        <p class="indent">Here, the <span class="literal">localName</span> variable has a default value of <span class="literal">"bar"</span>. The variable is assigned its default value because no <span class="literal">node.name</span> property exists.</p>
        <p class="indent">So far, you’ve learned how to use object destructuring on an object whose properties are primitive values. You can also use object destructuring to retrieve values in nested object structures.</p>
        <h4 class="h4" id="ch05lev2sec04"><em><strong>Nested Object Destructuring</strong></em></h4>
        <p class="noindent">By using syntax similar to that of object literals, you can navigate into a nested object structure to retrieve just the information you want. Here’s an example:</p>
        <p class="programs">let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "foo",<br>&nbsp;&nbsp;&nbsp;&nbsp;loc: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column: 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column: 4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let { loc: { start }} = node;<br><br>console.log(start.line);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(start.column);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1</p>
        <p class="indent">The destructuring pattern in this example uses curly braces to indicate that the pattern should descend into the property named <span class="literal">loc</span> on <span class="literal">node</span> and look for the <span class="literal">start</span> property. Recall from the previous section that a colon in a destructuring pattern means the identifier before the colon is giving a location to inspect, and the right side assigns a value. A curly brace after the colon indicates that the destination is nested another level into the object.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_89"></span>You can go one step further and use a different name for the local variable as well:</p>
        <p class="programs">let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "foo",<br>&nbsp;&nbsp;&nbsp;&nbsp;loc: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column: 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column: 4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>// extract node.loc.start<br>let { loc: { start: localStart }} = node;<br><br>console.log(localStart.line);&nbsp;&nbsp;&nbsp;// 1<br>console.log(localStart.column); // 1</p>
        <p class="indent">In this version of the code, <span class="literal">node.loc.start</span> is stored in a new local variable called <span class="literal">localStart</span>. Destructuring patterns can be nested to an arbitrary level of depth, and all capabilities will be available at each level.</p>
        <p class="indent">Object destructuring is very powerful because it provides you with lots of options, but array destructuring offers some unique capabilities that allow you to extract information from arrays.</p>
        <div class="sidebar">
        <p class="sidebart"><strong>SYNTAX GOTCHA</strong></p>
        <p class="noindent">Be careful when you’re using nested destructuring because you can inadvertently create a statement that has no effect. Empty curly braces are legal in object destructuring; however, they don’t do anything. For example:</p>
        <p class="programs">// no variables declared!<br>let { loc: {} } = node;</p>
        <p class="indent">No bindings are declared in this statement. Due to the curly braces on the right, <span class="literal">loc</span> is used as a location to inspect rather than a binding to create. In such cases, it’s likely that the intent was to use <span class="literal">=</span> to define a default value rather than <span class="literal">:</span> to define a location. It’s possible that this syntax will be made illegal in the future, but for now, this is a gotcha to look out for.</p>
        </div>
        <h3 class="h3" id="ch05lev1sec03"><span epub:type="pagebreak" id="page_90"></span><strong>Array Destructuring</strong></h3>
        <p class="noindent">Array destructuring syntax is very similar to object destructuring: it just uses array literal syntax instead of object literal syntax. The destructuring operates on positions within an array rather than the named properties that are available in objects. For example:</p>
        <p class="programs">let colors = [ "red", "green", "blue" ];<br><br>let [ firstColor, secondColor ] = colors;<br><br>console.log(firstColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"<br>console.log(secondColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "green"</p>
        <p class="indent">Here, array destructuring pulls out the values <span class="literal">"red"</span> and <span class="literal">"green"</span> from the <span class="literal">colors</span> array, and stores them in the <span class="literal">firstColor</span> and <span class="literal">secondColor</span> variables. Those values are chosen because of their position in the array; the actual variable names could be anything. Any items not explicitly mentioned in the destructuring pattern are ignored. Keep in mind that the array isn’t changed in any way.</p>
        <p class="indent">You can also omit items in the destructuring pattern and only provide variable names for the items you’re interested in. If, for example, you just want the third value of an array, you don’t need to supply variable names for the first and second items. Here’s how that works:</p>
        <p class="programs">let colors = [ "red", "green", "blue" ];<br><br>let [ , , thirdColor ] = colors;<br><br>console.log(thirdColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "blue"</p>
        <p class="indent">This code uses a destructuring assignment to retrieve the third item in <span class="literal">colors</span>. The commas preceding <span class="literal">thirdColor</span> in the pattern are placeholders for the array items that come before it. By using this approach, you can easily pick out values from any number of slots in the middle of an array without needing to provide variable names for them.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Similar to object destructuring, you must always provide an initializer when using array destructuring with <span class="literal">var</span>, <span class="literal">let</span>, or <span class="literal">const</span>.</em></p>
        </div>
        <h4 class="h4" id="ch05lev2sec05"><em><strong>Destructuring Assignment</strong></em></h4>
        <p class="noindent">You can use array destructuring in the context of an assignment, but unlike object destructuring, there is no need to wrap the expression in parentheses. Consider the following example.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_91"></span>let colors = [ "red", "green", "blue" ],<br>&nbsp;&nbsp;&nbsp;&nbsp;firstColor = "black",<br>&nbsp;&nbsp;&nbsp;&nbsp;secondColor = "purple";<br><br>[ firstColor, secondColor ] = colors;<br><br>console.log(firstColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"<br>console.log(secondColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "green"</p>
        <p class="indent">The destructured assignment in this code works in a similar manner to the previous array destructuring example. The only difference is that <span class="literal">firstColor</span> and <span class="literal">secondColor</span> have already been defined. Most of the time, what you know now about array destructuring assignment is all you’ll need to know, but there’s a bit more to it that you’ll probably find useful.</p>
        <p class="indent">Array destructuring assignment has a very unique use case that makes it easier to swap the values of two variables. Value swapping is a common operation in sorting algorithms, and the ECMAScript 5 way of swapping variables involves a third, temporary variable, as in this example:</p>
        <p class="programs">// swapping variables in ECMAScript 5<br>let a = 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;b = 2,<br>&nbsp;&nbsp;&nbsp;&nbsp;tmp;<br><br>tmp = a;<br>a = b;<br>b = tmp;<br><br>console.log(a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1</p>
        <p class="indent">The intermediate variable <span class="literal">tmp</span> is necessary to swap the values of <span class="literal">a</span> and <span class="literal">b</span>. However, using array destructuring assignment, there’s no need for that extra variable. Here’s how you can swap variables in ECMAScript 6:</p>
        <p class="programs">// swapping variables in ECMAScript 6<br>let a = 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;b = 2;<br><br>[ a, b ] = [ b, a ];<br><br>console.log(a);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(b);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1</p>
        <p class="indent">The array destructuring assignment in this example looks like a mirror image. The left side of the assignment (before the equal sign) is a destructuring pattern just like those in the other array destructuring examples. The right side is an array literal that is temporarily created for the swap. The <span epub:type="pagebreak" id="page_92"></span>destructuring happens on the temporary array, which has the values of <span class="literal">b</span> and <span class="literal">a</span> copied into its first and second positions. The effect is that the variables have swapped values.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Like object destructuring assignment, an error is thrown when the right side of an array destructured assignment expression evaluates to <span class="literal">null</span> or <span class="literal">undefined</span>.</em></p>
        </div>
        <h4 class="h4" id="ch05lev2sec06"><em><strong>Default Values</strong></em></h4>
        <p class="noindent">Array destructuring assignment allows you to specify a default value for any position in the array, too. The default value is used when the property at the given position either doesn’t exist or has the value <span class="literal">undefined</span>. For example:</p>
        <p class="programs">let colors = [ "red" ];<br><br>let [ firstColor, secondColor = "green" ] = colors;<br><br>console.log(firstColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"<br>console.log(secondColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "green"</p>
        <p class="indent">In this code, the <span class="literal">colors</span> array has only one item, so there is nothing for <span class="literal">secondColor</span> to match. Because there is a default value, <span class="literal">secondColor</span> is set to <span class="literal">"green"</span> instead of <span class="literal">undefined</span>.</p>
        <h4 class="h4" id="ch05lev2sec07"><em><strong>Nested Array Destructuring</strong></em></h4>
        <p class="noindent">You can destructure nested arrays in a manner similar to destructuring nested objects. By inserting another array pattern into the overall pattern, the destructuring will descend into a nested array, like this:</p>
        <p class="programs">let colors = [ "red", [ "green", "lightgreen" ], "blue" ];<br><br>// later<br><br>let [ firstColor, [ secondColor ] ] = colors;<br><br>console.log(firstColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"<br>console.log(secondColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "green"</p>
        <p class="indent">Here, the <span class="literal">secondColor</span> variable refers to the <span class="literal">"green"</span> value inside the <span class="literal">colors</span> array. That item is contained within a second array, so the extra square brackets around <span class="literal">secondColor</span> in the destructuring pattern are necessary. As with objects, you can nest arrays arbitrarily deep.</p>
        <h4 class="h4" id="ch05lev2sec08"><em><strong>Rest Items</strong></em></h4>
        <p class="noindent"><a href="ch03.xhtml#ch03">Chapter 3</a> introduced rest parameters for functions, and array destructuring has a similar concept called <em>rest items</em>. Rest items use the <span class="literal">...</span> syntax to assign the remaining items in an array to a particular variable. Take a look at the following example.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_93"></span>let colors = [ "red", "green", "blue" ];<br><br>let [ firstColor, ...restColors ] = colors;<br><br>console.log(firstColor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"<br>console.log(restColors.length); // 2<br>console.log(restColors[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "green"<br>console.log(restColors[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "blue"</p>
        <p class="indent">The first item in <span class="literal">colors</span> is assigned to <span class="literal">firstColor</span>, and the rest are assigned into a new <span class="literal">restColors</span> array. Therefore, the <span class="literal">restColors</span> array has two items: <span class="literal">"green"</span> and <span class="literal">"blue"</span>. Rest items are useful for extracting certain items from an array and keeping the rest available, but there’s another helpful use.</p>
        <p class="indent">A glaring omission from JavaScript arrays is the ability to easily create a clone. In ECMAScript 5, developers frequently used the <span class="literal">concat()</span> method as an easy way to clone an array. For example:</p>
        <p class="programs">// cloning an array in ECMAScript 5<br>var colors = [ "red", "green", "blue" ];<br>var clonedColors = colors.concat();<br><br>console.log(clonedColors);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "[red,green,blue]"</p>
        <p class="indent">Although the <span class="literal">concat()</span> method is intended to concatenate two arrays, calling it without an argument returns a clone of the array. In ECMAScript 6, you can use rest items to achieve the same task through syntax intended to function that way. It works like this:</p>
        <p class="programs">// cloning an array in ECMAScript 6<br>let colors = [ "red", "green", "blue" ];<br>let [ ...clonedColors ] = colors;<br><br>console.log(clonedColors);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "[red,green,blue]"</p>
        <p class="indent">In this example, rest items are used to copy values from the <span class="literal">colors</span> array into the <span class="literal">clonedColors</span> array. Although it’s a matter of perception as to whether this technique makes the developer’s intent clearer than using the <span class="literal">concat()</span> method, it’s still a useful approach to be aware of.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Rest items must be the last entry in the destructured array and cannot be followed by a comma. Including a comma after rest items is a syntax error.</em></p>
        </div>
        <h3 class="h3" id="ch05lev1sec04"><strong>Mixed Destructuring</strong></h3>
        <p class="noindent">You can use object and array destructuring together to create more complex expressions. By doing so, you’re able to extract just the pieces of information you want from any mixture of objects and arrays. Consider the following example.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_94"></span>let node = {<br>&nbsp;&nbsp;&nbsp;&nbsp;type: "Identifier",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "foo",<br>&nbsp;&nbsp;&nbsp;&nbsp;loc: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column: 1<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;line: 1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;column: 4<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;range: [0, 3]<br>};<br><br>let {<br>&nbsp;&nbsp;&nbsp;&nbsp;loc: { start },<br>&nbsp;&nbsp;&nbsp;&nbsp;range: [ startIndex ]<br>} = node;<br><br>console.log(start.line);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(start.column);&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(startIndex);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0</p>
        <p class="indent">This code extracts <span class="literal">node.loc.start</span> and <span class="literal">node.range[0]</span> into <span class="literal">start</span> and <span class="literal">startIndex</span>, respectively. Keep in mind that <span class="literal">loc:</span> and <span class="literal">range:</span> in the destructured pattern are just locations that correspond to properties in the <span class="literal">node</span> object. There is no part of <span class="literal">node</span> that cannot be extracted using destructuring when you use a mix of object and array destructuring. This approach is particularly useful for pulling values out of JSON configuration structures without navigating the entire structure.</p>
        <h3 class="h3" id="ch05lev1sec05"><strong>Destructured Parameters</strong></h3>
        <p class="noindent">Destructuring has one more particularly helpful use case and that is when passing function arguments. When a JavaScript function takes a large number of optional parameters, one common pattern is to create an <span class="literal">options</span> object whose properties specify the additional parameters, like this:</p>
        <p class="programs">// properties on options represent additional parameters<br>function setCookie(name, value, options) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;options = options || {};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;let secure = options.secure,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path = options.path,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;domain = options.domain,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expires = options.expires;<br><span epub:type="pagebreak" id="page_95"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;// code to set the cookie<br>}<br><br>// third argument maps to options<br>setCookie("type", "js", {<br>&nbsp;&nbsp;&nbsp;&nbsp;secure: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;expires: 60000<br>});</p>
        <p class="indent">Many JavaScript libraries contain <span class="literal">setCookie()</span> functions that look similar to this one. In this function, the <span class="literal">name</span> and <span class="literal">value</span> arguments are required, but <span class="literal">secure</span>, <span class="literal">path</span>, <span class="literal">domain</span>, and <span class="literal">expires</span> are not. And because there is no priority order for the other data, it’s efficient to just have an <span class="literal">options</span> object with named properties rather than list extra named parameters. This approach works, but now you can’t tell what input the function expects just by looking at the function definition: you need to read the function body.</p>
        <p class="indent">Destructured parameters offer an alternative that makes it clearer what arguments a function expects. A destructured parameter uses an object or array destructuring pattern in place of a named parameter. To see this in action, look at this rewritten version of the <span class="literal">setCookie()</span> function from the previous example:</p>
        <p class="programs">function setCookie(name, value, { secure, path, domain, expires }) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// code to set the cookie<br>}<br><br>setCookie("type", "js", {<br>&nbsp;&nbsp;&nbsp;&nbsp;secure: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;expires: 60000<br>});</p>
        <p class="indent">This function behaves similarly to the previous example, but the third argument now uses destructuring to pull out the necessary data. The parameters outside the destructured parameter are clearly expected, and it’s also clear to someone using <span class="literal">setCookie()</span> what options are available in terms of extra arguments. And of course, if the third argument is required, the values it should contain are crystal clear. The destructured parameters also act like regular parameters in that they are set to <span class="literal">undefined</span> if they’re not passed.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Destructured parameters have all the capabilities of destructuring that you’ve learned so far in this chapter. You can use default values, mix object and array patterns, and use variable names that differ from the properties you’re reading from.</em></p>
        </div>
        <h4 class="h4" id="ch05lev2sec09"><em><strong>Destructured Parameters Are Required</strong></em></h4>
        <p class="noindent">One quirk of using destructured parameters is that, by default, an error is thrown when they’re not provided in a function call. For instance, the following call to the <span class="literal">setCookie()</span> function from the previous example throws an error.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_96"></span>// error!<br>setCookie("type", "js");</p>
        <p class="indent">The missing third argument evaluates to <span class="literal">undefined</span> as expected, causing an error because destructured parameters are just a shorthand for destructured declaration. When the <span class="literal">setCookie()</span> function is called, the JavaScript engine actually does this:</p>
        <p class="programs">function setCookie(name, value, options) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;let { secure, path, domain, expires } = options;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// code to set the cookie<br>}</p>
        <p class="indent">Because destructuring throws an error when the right side expression evaluates to <span class="literal">null</span> or <span class="literal">undefined</span>, it also throws an error when the third argument isn’t passed to the <span class="literal">setCookie()</span> function.</p>
        <p class="indent">If you want the destructured parameter to be required, this behavior isn’t all that troubling. But if you want the destructured parameter to be optional, you can work around this behavior by providing a default value for the destructured parameter, like this:</p>
        <p class="programs">function setCookie(name, value, { secure, path, domain, expires } = {}) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}</p>
        <p class="indent">This example provides a new object as the default value for the third parameter. Providing a default value for the destructured parameter means that <span class="literal">secure</span>, <span class="literal">path</span>, <span class="literal">domain</span>, and <span class="literal">expires</span> will all be <span class="literal">undefined</span> if the third argument to <span class="literal">setCookie()</span> isn’t provided, and no error will be thrown.</p>
        <h4 class="h4" id="ch05lev2sec10"><em><strong>Default Values for Destructured Parameters</strong></em></h4>
        <p class="noindent">You can specify destructured default values for destructured parameters just as you would in destructured assignment. Just add the equal sign after the parameter and specify the default value. For example:</p>
        <p class="programs">function setCookie(name, value,<br>&nbsp;&nbsp;&nbsp;&nbsp;{<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;secure = false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;path = "/",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;domain = "example.com",<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;expires = new Date(Date.now() + 360000000)<br>&nbsp;&nbsp;&nbsp;&nbsp;} = {}<br>) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_97"></span>Each property in the destructured parameter has a default value in this code, so you can avoid checking to see if a given property has been included in order to use the correct value. Also, the entire destructured parameter has a default value of an empty object, making the parameter optional. This does make the function declaration look a bit more complicated than usual, but that’s a small price to pay for ensuring each argument has a usable value.</p>
        <h3 class="h3" id="ch05lev1sec06"><strong>Summary</strong></h3>
        <p class="noindent">Destructuring makes working with objects and arrays in JavaScript easier. Using the familiar object literal and array literal syntax, you can dissect data structures to get at the information you’re interested in. Object patterns allow you to extract data from objects, and array patterns let you extract data from arrays.</p>
        <p class="indent">Both object and array destructuring can specify default values for any property or item that is <span class="literal">undefined</span>, and both throw errors when the right side of an assignment evaluates to <span class="literal">null</span> or <span class="literal">undefined</span>. You can also navigate deeply nested data structures with object and array destructuring, descending to any arbitrary depth.</p>
        <p class="indent">Destructuring declarations use <span class="literal">var</span>, <span class="literal">let</span>, or <span class="literal">const</span> to create variables and must always have an initializer. Destructuring assignments are used in place of other assignments and allow you to destructure into object properties and already existing variables.</p>
        <p class="indent">Destructured parameters use the destructuring syntax to make <span class="literal">options</span> objects more transparent when used as function parameters. You can list all the actual data you’re interested in along with other named parameters. Destructured parameters can be array patterns, object patterns, or a mixture, and you can use all the features of destructuring.<span epub:type="pagebreak" id="page_98"></span></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com