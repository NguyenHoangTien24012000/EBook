<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch13"><span epub:type="pagebreak" id="page_283"></span><strong><span class="big">13</span><br>ENCAPSULATING CODE WITH MODULES</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">JavaScript’s “shared everything” approach to loading code is one of the most error-prone and confusing aspects of the language. Other languages use concepts such as packages to define code scope, but before ECMAScript 6, everything defined in every JavaScript file of an application shared one global scope. As web applications became more complex and started using even more JavaScript code, that approach caused problems, such as naming collisions and security concerns. One goal of ECMAScript 6 was to solve the scope problem and bring some order to JavaScript applications. That’s where modules come in.</p>
        <h3 class="h3" id="ch13lev1sec01"><strong>What Are Modules?</strong></h3>
        <p class="noindent">A <em>module</em> is JavaScript code that automatically runs in strict mode with no way to opt out. Contrary to a shared-everything architecture, variables created in the top level of a module aren’t automatically added to the <span epub:type="pagebreak" id="page_284"></span>shared global scope. The variables exist only within the top-level scope of the module, and the module must export any elements, like variables or functions, that should be available to code outside the module. Modules may also import bindings from other modules.</p>
        <p class="indent">Two other module features relate less to scope but are important nonetheless. First, the value of <span class="literal">this</span> in the top level of a module is <span class="literal">undefined</span>. Second, modules also don’t allow HTML-style comments within code, which is a residual feature from JavaScript’s early browser days.</p>
        <p class="indent"><em>Scripts</em>, which include any JavaScript code that isn’t a module, lack these features. The differences between modules and other JavaScript code may seem minor at first glance, but they represent a significant change in how JavaScript code is loaded and evaluated, which I’ll discuss throughout this chapter. The real power of modules is the ability to export and import only bindings you need rather than everything in a file. A good understanding of exporting and importing is fundamental to understanding how modules differ from scripts.</p>
        <h3 class="h3" id="ch13lev1sec02"><strong>Basic Exporting</strong></h3>
        <p class="noindent">You can use the <span class="literal">export</span> keyword to expose parts of published code to other modules. In the simplest case, you can place <span class="literal">export</span> in front of any variable, function, or class declaration to export it from the module, like this:</p>
        <p class="programs">// export data<br>export var color = "red";<br>export let name = "Nicholas";<br>export const magicNumber = 7;<br><br>// export function<br>export function sum(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num1;<br>}<br><br>// export class<br>export class Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>// this function is private to the module<br>function subtract(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 - num2;<br>}<br><br>// define a function...<br>function multiply(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 * num2;<br>}<br><span epub:type="pagebreak" id="page_285"></span><br>// ...and then export it later<br>export multiply;</p>
        <p class="indent">There are a few details to notice in this example. Apart from the <span class="literal">export</span> keyword, every declaration is the same as it would be in a script. Each exported function or class also has a name, because exported function and class declarations require a name. You can’t export anonymous functions or classes using this syntax unless you use the <span class="literal">default</span> keyword (discussed in detail in “<a href="ch13.xhtml#ch13lev1sec05">Default Values in Modules</a>” on <a href="ch13.xhtml#page_289">page 289</a>).</p>
        <p class="indent">Also, consider the <span class="literal">multiply()</span> function, which isn’t exported when it’s defined. That works because you don’t always need to export a declaration: you can also export references. Additionally, notice that this example doesn’t export the <span class="literal">subtract()</span> function. That function won’t be accessible from outside this module because any variables, functions, or classes that are not explicitly exported remain private to the module.</p>
        <h3 class="h3" id="ch13lev1sec03"><strong>Basic Importing</strong></h3>
        <p class="noindent">When you have a module with exports, you can access the functionality in another module by using the <span class="literal">import</span> keyword. The two parts of an <span class="literal">import</span> statement are the identifiers you’re importing and the module from which those identifiers should be imported.</p>
        <p class="indent">This is the statement’s basic form:</p>
        <p class="programs">import { <span class="codeitalic">identifier1</span>, <span class="codeitalic">identifier2</span>} from " <span class="codeitalic">./example.js</span>";</p>
        <p class="indent">The curly braces after <span class="literal">import</span> indicate the bindings to import from a given module. The keyword <span class="literal">from</span> indicates the module from which to import the given binding. The module is specified by a string representing the path to the module (called the <em>module specifier</em>). Browsers use the same path format you might pass to the <span class="literal">&lt;script&gt;</span> element, which means you must include a file extension. Node.js, on the other hand, follows its convention of differentiating between local files and packages based on a filesystem prefix. For instance, <span class="literal">example</span> would be a package and <span class="literal"><span class="codeitalic">./example.js</span></span> would be a local file.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The list of bindings to import looks similar to a destructured object, but it isn’t one.</em></p>
        </div>
        <p class="indent">When you’re importing a binding from a module, the binding acts as though it was defined using <span class="literal">const</span>. As a result, you can’t define another variable with the same name (including importing another binding of the same name), use the identifier before the <span class="literal">import</span> statement, or change binding’s value.</p>
        <h4 class="h4" id="ch13lev2sec01"><span epub:type="pagebreak" id="page_286"></span><em><strong>Importing a Single Binding</strong></em></h4>
        <p class="noindent">Suppose that the example in “<a href="ch13.xhtml#ch13lev1sec02">Basic Exporting</a>” on <a href="ch13.xhtml#page_284">page 284</a> is in a module with the filename <em>example.js</em>. You can import and use bindings from that module in a number of ways. For instance, you can just import one identifier:</p>
        <p class="programs">// import just one<br>import { sum } from "./example.js";<br><br>console.log(sum(1, 2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br><br>sum = 1;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// throws an error</p>
        <p class="indent">Even though <em>example.js</em> exports more than just that one function, this example imports only the <span class="literal">sum()</span> function. If you try to assign a new value to <span class="literal">sum</span>, the result is an error because you can’t reassign imported bindings.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Be sure to include <span class="literal">/</span>, <span class="literal">./</span>, or <span class="literal">../</span> at the beginning of the string representing the file you’re importing for the best compatibility across browsers and Node.js.</em></p>
        </div>
        <h4 class="h4" id="ch13lev2sec02"><em><strong>Importing Multiple Bindings</strong></em></h4>
        <p class="noindent">If you want to import multiple bindings from the example module, you can explicitly list them as follows:</p>
        <p class="programs">// import multiple<br>import { sum, multiply, magicNumber } from "./example.js";<br>console.log(sum(1, magicNumber));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 8<br>console.log(multiply(1, 2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">Here, three bindings are imported from the example module: <span class="literal">sum</span>, <span class="literal">multiply</span>, and <span class="literal">magicNumber</span>. They are then used as though they were locally defined.</p>
        <h4 class="h4" id="ch13lev2sec03"><em><strong>Importing an Entire Module</strong></em></h4>
        <p class="noindent">A special case allows you to import the entire module as a single object. All exports are then available on that object as properties. For example:</p>
        <p class="programs">// import everything<br>import * as example from "./example.js";<br>console.log(example.sum(1,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;example.magicNumber));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 8<br>console.log(example.multiply(1, 2));&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">In this code, all exported bindings in <em>example.js</em> are loaded into an object called <span class="literal">example</span>. The named exports (the <span class="literal">sum()</span> function, the <span class="literal">multiple()</span> function, and <span class="literal">magicNumber</span>) are then accessible as properties on <span class="literal">example</span>. <span epub:type="pagebreak" id="page_287"></span>This import format is called a <em>namespace import</em> because the <span class="literal">example</span> object doesn’t exist inside the <em>example.js</em> file and is instead created to be used as a namespace object for all the exported members of <em>example.js</em>.</p>
        <p class="indent">However, keep in mind that no matter how many times you use a module in <span class="literal">import</span> statements, the module will execute only once. After the code to import the module executes, the instantiated module is kept in memory and reused whenever another <span class="literal">import</span> statement references it. Consider the following:</p>
        <p class="programs">import { sum } from "./example.js";<br>import { multiply } from "./example.js";<br>import { magicNumber } from "./example.js";</p>
        <p class="indent">Even though three <span class="literal">import</span> statements are in this module, <em>example.js</em> will execute only once. If other modules in the same application were to import bindings from <em>example.js</em>, those modules would use the same module instance this code uses.</p>
        <div class="sidebar">
        <p class="sidebart"><strong>MODULE SYNTAX LIMITATIONS</strong></p>
        <p class="noindent">An important limitation of both <span class="literal">export</span> and <span class="literal">import</span> is that they must be used outside other statements and functions. For instance, this code will give a syntax error:</p>
        <p class="programs">if (flag) {<br>&nbsp;&nbsp;&nbsp;&nbsp;export flag;&nbsp;&nbsp;&nbsp;&nbsp;// syntax error<br>}</p>
        <p class="indent">The <span class="literal">export</span> statement is inside an <span class="literal">if</span> statement, which isn’t allowed. Exports cannot be conditional or done dynamically in any way. One reason module syntax exists is to let the JavaScript engine statically determine what will be exported. As such, you can only use <span class="literal">export</span> at the top level of a module.</p>
        <p class="indent">Similarly, you can’t use <span class="literal">import</span> inside a statement; you can only use it at the top-level. That means this code also gives a syntax error:</p>
        <p class="programs">function tryImport() {<br>&nbsp;&nbsp;&nbsp;&nbsp;import flag from "./example.js";&nbsp;&nbsp;// syntax error<br>}</p>
        <p class="indent">You can’t dynamically import bindings for the same reason you can’t dynamically export bindings. The <span class="literal">export</span> and <span class="literal">import</span> keywords are designed to be static so tools like text editors can easily identify what information is available from a module.</p>
        </div>
        <h4 class="h4" id="ch13lev2sec04"><span epub:type="pagebreak" id="page_288"></span><em><strong>A Subtle Quirk of Imported Bindings</strong></em></h4>
        <p class="noindent">ECMAScript 6’s <span class="literal">import</span> statements create read-only bindings to variables, functions, and classes rather than simply referencing the original bindings like normal variables. Even though the module that imports the binding can’t change the binding’s value, the module that exports that identifier can. For example, suppose you want to use this module:</p>
        <p class="programs">export var name = "Nicholas";<br>export function setName(newName) {<br>&nbsp;&nbsp;&nbsp;&nbsp;name = newName;<br>}</p>
        <p class="indent">When you import these two bindings, the <span class="literal">setName()</span> function can change the value of <span class="literal">name</span>:</p>
        <p class="programs">import { name, setName } from "./example.js";<br><br>console.log(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"<br>setName("Greg");<br>console.log(name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Greg"<br><br>name = "Nicholas";&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// throws an error</p>
        <p class="indent">The call to <span class="literal">setName("Greg")</span> goes back into the module from which <span class="literal">setName()</span> was exported and executes there, setting <span class="literal">name</span> to <span class="literal">"Greg"</span> instead. Note that this change is automatically reflected on the imported <span class="literal">name</span> binding. The reason is that <span class="literal">name</span> is the local name for the exported <span class="literal">name</span> identifier. The <span class="literal">name</span> used in this code and the <span class="literal">name</span> used in the module being imported from aren’t the same.</p>
        <h3 class="h3" id="ch13lev1sec04"><strong>Renaming Exports and Imports</strong></h3>
        <p class="noindent">Sometimes, you may not want to use the original name of a variable, function, or class you’ve imported from a module. Fortunately, you can change the name of an export during the export and during the import.</p>
        <p class="indent">In the first case, suppose you have a function that you want to export with a different name. You can use the <span class="literal">as</span> keyword to specify the name that the function should be known as outside of the module:</p>
        <p class="programs">function sum(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;<br>}<br><br>export { sum as add };</p>
        <p class="indent"><span epub:type="pagebreak" id="page_289"></span>Here, the function with the <em>local name</em> <span class="literal">sum()</span> is exported using <span class="literal">add()</span> as its exported name. That means when another module wants to import this function, it will have to use the name <span class="literal">add</span>:</p>
        <p class="programs">import { add } from "./example.js";</p>
        <p class="indent">If the module importing the function wants to use a different name, it can also use <span class="literal">as</span>:</p>
        <p class="programs">import { add as sum } from "./example.js";<br>console.log(typeof add);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "undefined"<br>console.log(sum(1, 2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3</p>
        <p class="indent">This code imports the <span class="literal">add()</span> function using an <em>import name</em> to rename the function <span class="literal">sum()</span> (the local name in this context). Changing the function’s local name on import means there is no identifier named <span class="literal">add()</span> in this module, even though the module imports the <span class="literal">add()</span> function.</p>
        <h3 class="h3" id="ch13lev1sec05"><strong>Default Values in Modules</strong></h3>
        <p class="noindent">The module syntax is optimized for exporting and importing default values from modules, because this pattern was quite common in other module systems, such as CommonJS (another specification for using JavaScript outside the browser). The <em>default value</em> for a module is a single variable, function, or class as specified by the <span class="literal">default</span> keyword, and you can only set one default export per module. Using the <span class="literal">default</span> keyword with multiple exports is a syntax error.</p>
        <h4 class="h4" id="ch13lev2sec05"><em><strong>Exporting Default Values</strong></em></h4>
        <p class="noindent">Here’s a simple example that uses the <span class="literal">default</span> keyword:</p>
        <p class="programs">export default function(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;<br>}</p>
        <p class="indent">This module exports a function as its default value. The <span class="literal">default</span> keyword indicates that this is a default export. The function doesn’t require a name because the module represents the function.</p>
        <p class="indent">You can also specify an identifier as the default export by placing it after <span class="literal">export default</span>, like this:</p>
        <p class="programs">function sum(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;<br>}<br><br>export default sum;</p>
        <p class="indent"><span epub:type="pagebreak" id="page_290"></span>The <span class="literal">sum()</span> function is first defined and later exported as the default value of the module. You might want to use this approach if the default value needs to be calculated.</p>
        <p class="indent">A third way to specify an identifier as the default export is by using the renaming syntax as follows:</p>
        <p class="programs">function sum(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;<br>}<br><br>export { sum as default };</p>
        <p class="indent">The identifier <span class="literal">default</span> has special meaning in a renaming export and indicates a value should be the default for the module. Because <span class="literal">default</span> is a keyword in JavaScript, you can’t use it for a variable, function, or class name; however, you can use it as a property name. So using <span class="literal">default</span> to rename an export is a special case to create consistency with how non-default exports are defined. This syntax is useful if you want to use a single <span class="literal">export</span> statement to specify multiple exports, including the default, simultaneously.</p>
        <h4 class="h4" id="ch13lev2sec06"><em><strong>Importing Default Values</strong></em></h4>
        <p class="noindent">You can import a default value from a module using the following syntax:</p>
        <p class="programs">// import the default<br>import sum from "./example.js";<br><br>console.log(sum(1, 2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3</p>
        <p class="indent">This <span class="literal">import</span> statement imports the default from the module <em>example.js</em>. Note that no curly braces are used, unlike what you’d see in a non-default import. The local name <span class="literal">sum</span> is used to represent whatever default function the module exports. This syntax is the cleanest, and the creators of ECMAScript 6 expect it to be the dominant form of import on the web, allowing you to use an already existing object.</p>
        <p class="indent">For modules that export a default and one or more non-default bindings, you can import all exported bindings using one statement. For instance, suppose you have this module:</p>
        <p class="programs">export let color = "red";<br><br>export default function(num1, num2) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return num1 + num2;<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_291"></span>You can import <span class="literal">color</span> and the default function using the following <span class="literal">import</span> statement:</p>
        <p class="programs">import sum, { color } from "./example.js";<br><br>console.log(sum(1, 2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br>console.log(color);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"</p>
        <p class="indent">The comma separates the default local name from the non-defaults, which are also surrounded by curly braces. Keep in mind that the default must come before the non-defaults in the <span class="literal">import</span> statement.</p>
        <p class="indent">As with exporting defaults, you can import defaults with the renaming syntax, too:</p>
        <p class="programs">import { default as sum, color } from "./example.js";<br><br>console.log(sum(1, 2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br>console.log(color);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"</p>
        <p class="indent">In this code, the default export (<span class="literal">default</span>) is renamed to <span class="literal">sum</span> and the additional <span class="literal">color</span> export is also imported. This example is otherwise equivalent to the preceding example.</p>
        <h3 class="h3" id="ch13lev1sec06"><strong>Re-exporting a Binding</strong></h3>
        <p class="noindent">Eventually, you may want to re-export something that your module has imported. For instance, perhaps you’re creating a library from several small modules. You can re-export an imported value using the patterns already discussed in this chapter, as follows:</p>
        <p class="programs">import { sum } from "./example.js";<br>export { sum }</p>
        <p class="indent">Although that works, a single statement can also do the same task:</p>
        <p class="programs">export { sum } from "./example.js";</p>
        <p class="indent">This form of <span class="literal">export</span> looks into the specified module for the declaration of <span class="literal">sum</span> and then exports it. Of course, you can also export a different name for the same value:</p>
        <p class="programs">export { sum as add } from "./example.js";</p>
        <p class="indent">Here, <span class="literal">sum</span> is imported from <em>example.js</em> and then exported as <span class="literal">add</span>.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_292"></span>If you want to export everything from another module, you can use the <span class="literal">*</span> pattern:</p>
        <p class="programs">export * from "./example.js";</p>
        <p class="indent">By exporting everything, you’re including the default as well as any named exports, which may affect what you can export from your module. For instance, if <em>example.js</em> has a default export, you’d be unable to define a new default export when using this syntax.</p>
        <h3 class="h3" id="ch13lev1sec07"><strong>Importing Without Bindings</strong></h3>
        <p class="noindent">Some modules may not export anything; instead, they might only modify objects in the global scope. Even though top-level variables, functions, and classes inside modules don’t automatically end up in the global scope, that doesn’t mean modules cannot access the global scope. The shared definitions of built-in objects, such as <span class="literal">Array</span> and <span class="literal">Object</span>, are accessible inside a module, and changes to those objects will be reflected in other modules.</p>
        <p class="indent">For instance, if you want to add a <span class="literal">pushAll()</span> method to all arrays, you might define a module like this:</p>
        <p class="programs">// module code without exports or imports<br>Array.prototype.pushAll = function(items) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// items must be an array<br>&nbsp;&nbsp;&nbsp;&nbsp;if (!Array.isArray(items)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("Argument must be an array.");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// use built-in push() and spread operator<br>&nbsp;&nbsp;&nbsp;&nbsp;return this.push(...items);<br>};</p>
        <p class="indent">This is a valid module, even though there are no exports or imports. This code can be used as a module and as a script. Because it doesn’t export anything, you can use a simplified import to execute the module code without importing any bindings:</p>
        <p class="programs">import "./example.js";<br><br>let colors = ["red", "green", "blue"];<br>let items = [];<br><br>items.pushAll(colors);</p>
        <p class="indent">This code imports and executes the module containing the <span class="literal">pushAll()</span> method, so <span class="literal">pushAll()</span> is added to the array prototype. That means <span class="literal">pushAll()</span> is now available for use on all arrays inside this module.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Imports without bindings are most likely to be used to create polyfills and shims.</em></p>
        </div>
        <h3 class="h3" id="ch13lev1sec08"><span epub:type="pagebreak" id="page_293"></span><strong>Loading Modules</strong></h3>
        <p class="noindent">Although ECMAScript 6 defines the syntax for modules, it doesn’t define how to load them. This is part of the complexity of a specification that’s supposed to be agnostic to implementation environments. Rather than trying to create a single specification that would work for all JavaScript environments, ECMAScript 6 specifies only the syntax and abstracts out the loading mechanism to an undefined internal operation called <span class="literal">HostResolveImportedModule</span>. Web browser and Node.js developers are left to decide how to implement <span class="literal">HostResolveImportedModule</span> in a way that makes sense for their respective environments.</p>
        <h4 class="h4" id="ch13lev2sec07"><em><strong>Using Modules in Web Browsers</strong></em></h4>
        <p class="noindentb">Even before ECMAScript 6, web browsers had multiple ways of including JavaScript in a web application. Those script loading options are:</p>
        <p class="bull">• Loading JavaScript code files using the <span class="literal">&lt;script&gt;</span> element with the <span class="literal">src</span> attribute specifying a location from which to load the code</p>
        <p class="bull">• Embedding JavaScript code inline using the <span class="literal">&lt;script&gt;</span> element without the <span class="literal">src</span> attribute</p>
        <p class="bull">• Loading JavaScript code files to execute as workers (such as a web worker or service worker)</p>
        <p class="indentt">To fully support modules, web browsers had to update each of these mechanisms. These details are fully defined in the HTML specification, and I’ll summarize them in the following sections.</p>
        <h5 class="h5" id="ch13lev3sec01"><strong>Using Modules with &lt;script&gt;</strong></h5>
        <p class="noindent">The default behavior of the <span class="literal">&lt;script&gt;</span> element is to load JavaScript files as scripts, not modules. This happens when the <span class="literal">type</span> attribute is missing or when the <span class="literal">type</span> attribute contains a JavaScript content type (such as <span class="literal">"text/javascript"</span>). The <span class="literal">&lt;script&gt;</span> element can then execute inline code or load the file specified in <span class="literal">src</span>. To support modules, the <span class="literal">"module"</span> value was added as a <span class="literal">type</span> option. Setting <span class="literal">type</span> to <span class="literal">"module"</span> tells the browser to load any inline code or code contained in the file specified by <span class="literal">src</span> as a module instead of a script. Here’s a simple example:</p>
        <p class="programs">&lt;!-- load a module JavaScript file --&gt;<br>&lt;script type="module" src="https://learning.oreilly.commodule.js"&gt;&lt;/script&gt;<br><br>&lt;!-- include a module inline --&gt;<br>&lt;script type="module"&gt;<br><br>import { sum } from "./example.js";<br><br>let result = sum(1, 2);<br><br>&lt;/script&gt;</p>
        <p class="indent"><span epub:type="pagebreak" id="page_294"></span>The first <span class="literal">&lt;script&gt;</span> element in this example loads an external module file using the <span class="literal">src</span> attribute. The only difference between this and loading a script is that <span class="literal">"module"</span> is given as the <span class="literal">type</span>. The second <span class="literal">&lt;script&gt;</span> element contains a module that is embedded directly in the web page. The variable <span class="literal">result</span> is not exposed globally because it exists only within the module (as defined by the <span class="literal">&lt;script&gt;</span> element) and is therefore not added to <span class="literal">window</span> as a property.</p>
        <p class="indent">As you can see, including modules in web pages is fairly simple and similar to including scripts. However, there are some differences in how modules are actually loaded.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>You may have noticed that <span class="literal">"module"</span> is not a content type like the <span class="literal">"text/javascript"</span> type. Module JavaScript files are served with the same content type as script JavaScript files, so it’s not possible to differentiate between them solely based on content type. Also, browsers ignore <span class="literal">&lt;script&gt;</span> elements when the <span class="literal">type</span> is unrecognized, so browsers that don’t support modules will automatically ignore the <span class="literal">&lt;script type="module"&gt;</span> line, providing good backward compatibility.</em></p>
        </div>
        <h5 class="h5" id="ch13lev3sec02"><strong>Module Loading Sequence in Web Browsers</strong></h5>
        <p class="noindent">Modules are unique in that, unlike scripts, they may use <span class="literal">import</span> to specify that other files must be loaded to execute correctly. To support that functionality, <span class="literal">&lt;script type="module"&gt;</span> always acts as though the <span class="literal">defer</span> attribute is applied.</p>
        <p class="indent">The <span class="literal">defer</span> attribute is optional for loading script files but is always applied for loading module files. The module file begins downloading as soon as the HTML parser encounters <span class="literal">&lt;script type="module"&gt;</span> with a <span class="literal">src</span> attribute but doesn’t execute until after the document has been completely parsed. Modules are also executed in the order in which they appear in the HTML file. That means the first <span class="literal">&lt;script type="module"&gt;</span> is always guaranteed to execute before the second, even if one module contains inline code instead of specifying <span class="literal">src</span>. For example:</p>
        <p class="programs">&lt;!-- this will execute first --&gt;<br>&lt;script type="module" src="https://learning.oreilly.commodule1.js"&gt;&lt;/script&gt;<br><br>&lt;!-- this will execute second --&gt;<br>&lt;script type="module"&gt;<br>import { sum } from "./example.js";<br><br>let result = sum(1, 2);<br>&lt;/script&gt;<br><br>&lt;!-- this will execute third --&gt;<br>&lt;script type="module" src="https://learning.oreilly.commodule2.js"&gt;&lt;/script&gt;</p>
        <p class="indent">These three <span class="literal">&lt;script&gt;</span> elements execute in the order they are specified, so the <em>module1.js</em> module is guaranteed to execute before the inline module, and the inline module is guaranteed to execute before the <em>module2.js</em> module.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_295"></span>Each module can <span class="literal">import</span> from one or more other modules, which complicates matters. For that reason, modules are parsed completely first to identify all <span class="literal">import</span> statements. Each <span class="literal">import</span> statement then triggers a fetch (either from the network or from the cache), and no module is executed until all <span class="literal">import</span> resources have been loaded and executed.</p>
        <p class="indent">All modules, those explicitly included using <span class="literal">&lt;script type="module"&gt;</span> and those implicitly included using <span class="literal">import</span>, are loaded and executed in order. In this example, the complete loading sequence is as follows:</p>
        <ol>
        <li><p class="noindents">Download and parse <em>module1.js</em>.</p></li>
        <li><p class="noindents">Recursively download and parse <span class="literal">import</span> resources in <em>module1.js</em>.</p></li>
        <li><p class="noindents">Parse the inline module.</p></li>
        <li><p class="noindents">Recursively download and parse <span class="literal">import</span> resources in the inline module.</p></li>
        <li><p class="noindents">Download and parse <em>module2.js</em>.</p></li>
        <li><p class="noindents">Recursively download and parse <span class="literal">import</span> resources in <em>module2.js.</em></p></li>
        </ol>
        <p class="indent">When loading is complete, nothing is executed until after the document has been completely parsed. After document parsing is completed, the following actions happen:</p>
        <ol>
        <li><p class="noindents">Recursively execute <span class="literal">import</span> resources for <em>module1.js</em>.</p></li>
        <li><p class="noindents">Execute <em>module1.js</em>.</p></li>
        <li><p class="noindents">Recursively execute <span class="literal">import</span> resources for the inline module.</p></li>
        <li><p class="noindents">Execute the inline module.</p></li>
        <li><p class="noindents">Recursively execute <span class="literal">import</span> resources for <em>module2.js</em>.</p></li>
        <li><p class="noindents">Execute <em>module2.js</em>.</p></li>
        </ol>
        <p class="indent">Notice that the inline module acts like the other two modules except the code doesn’t have to be downloaded first. Otherwise, the sequence of loading <span class="literal">import</span> resources and executing modules is the same.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The <span class="literal">defer</span> attribute is ignored on <span class="literal">&lt;script type="module"&gt;</span> because it already behaves as though <span class="literal">defer</span> is applied.</em></p>
        </div>
        <h5 class="h5" id="ch13lev3sec03"><strong>Asynchronous Module Loading in Web Browsers</strong></h5>
        <p class="noindent">You may already be familiar with the <span class="literal">async</span> attribute on the <span class="literal">&lt;script&gt;</span> element. When used with scripts, <span class="literal">async</span> causes the script file to be executed as soon as the file is completely downloaded and parsed. However, the order of <span class="literal">async</span> scripts in the document doesn’t affect the order in which the scripts are executed. The scripts are always executed as soon as they finish downloading without waiting for the containing document to finish parsing.</p>
        <p class="indent">The <span class="literal">async</span> attribute can be applied to modules as well. Using <span class="literal">async</span> on <span class="literal">&lt;script type="module"&gt;</span> causes the module to execute in a manner similar to a script. The only difference is that all <span class="literal">import</span> resources for the module are downloaded before the module is executed. That guarantees all resources <span epub:type="pagebreak" id="page_296"></span>the module needs to function will be downloaded before the module executes; you just can’t guarantee <em>when</em> the module will execute. Consider the following code:</p>
        <p class="programs">&lt;!-- no guarantee which one of these will execute first --&gt;<br>&lt;script type="module" async src="https://learning.oreilly.commodule1.js"&gt;&lt;/script&gt;<br>&lt;script type="module" async src="https://learning.oreilly.commodule2.js"&gt;&lt;/script&gt;</p>
        <p class="indent">In this example, two module files are loaded asynchronously. It’s impossible to determine which module will execute first simply by looking at this code. If <em>module1.js</em> finishes downloading first (including all of its <span class="literal">import</span> resources), it will execute first. If <em>module2.js</em> finishes downloading first, it will execute first instead.</p>
        <h5 class="h5" id="ch13lev3sec04"><strong>Loading Modules as Workers</strong></h5>
        <p class="noindent">Workers, such as web workers and service workers, execute JavaScript code outside of the web page context. Creating a new worker involves creating a new instance <span class="literal">Worker</span> (or another class) and passing in the location of the JavaScript file. The default loading mechanism is to load files as scripts, like this:</p>
        <p class="programs">// load script.js as a script<br>let worker = new Worker("script.js");</p>
        <p class="indent">To support loading modules, the developers of the HTML standard added a second argument to these constructors. The second argument is an object with a <span class="literal">type</span> property with a default value of <span class="literal">"script"</span>. You can set <span class="literal">type</span> to <span class="literal">"module"</span> to load module files:</p>
        <p class="programs">// load module.js as a module<br>let worker = new Worker("module.js", { type: "module" });</p>
        <p class="indent">This example loads <em>module.js</em> as a module instead of a script by passing a second argument with <span class="literal">"module"</span> as the <span class="literal">type</span> property’s value. (The <span class="literal">type</span> property is meant to mimic how the <span class="literal">type</span> attribute of <span class="literal">&lt;script&gt;</span> differentiates modules and scripts.) The second argument is supported for all worker types in the browser.</p>
        <p class="indent">Worker modules are generally the same as worker scripts, but there are a couple of exceptions. First, worker scripts can only be loaded from the same origin as the web page in which they’re referenced, but worker modules aren’t quite as limited. Although worker modules have the same default restriction, they can also load files that have appropriate Cross-Origin Resource Sharing (CORS) headers to allow access. Second, although a worker script can use the <span class="literal">self.importScripts()</span> method to load additional scripts into the worker, <span class="literal">self.importScripts()</span> always fails on worker modules because you should use <span class="literal">import</span> instead.</p>
        <h4 class="h4" id="ch13lev2sec08"><span epub:type="pagebreak" id="page_297"></span><em><strong>Browser Module Specifier Resolution</strong></em></h4>
        <p class="noindentb">All examples to this point in the chapter have used a relative path (as in the string <span class="literal">"./example.js"</span>) for the module specifier. Browsers require module specifiers to be in one of the following formats:</p>
        <p class="bull">• Begin with <span class="literal">/</span> to resolve from the root directory</p>
        <p class="bull">• Begin with <span class="literal">./</span> to resolve from the current directory</p>
        <p class="bull">• Begin with <span class="literal">../</span> to resolve from the parent directory</p>
        <p class="bull">• URL format</p>
        <p class="indentt">For example, suppose you have a module file located at <em><a href="https://www.example.com/modules/module.js">https://www.example.com/modules/module.js</a></em> that contains the following code:</p>
        <p class="programs">// imports from https://www.example.com/modules/example1.js<br>import { first } from "./example1.js";<br><br>// imports from https://www.example.com/example2.js<br>import { second } from "../example2.js";<br><br>// imports from https://www.example.com/example3.js<br>import { third } from "/example3.js";<br><br>// imports from https://www2.example.com/example4.js<br>import { fourth } from "https://www2.example.com/example4.js";</p>
        <p class="indent">Each module specifier in this example is valid for use in a browser, including the complete URL in the final line. (You’d just need to be sure <em><a href="http://www2.example.com">www2.example.com</a></em> has properly configured its CORS headers to allow cross-domain loading.) These are the only module specifier formats that browsers can resolve by default, though the not-yet-complete module loader specification will provide ways to resolve other formats.</p>
        <p class="indent">Until then, some normal-looking module specifiers are actually invalid in browsers and will result in an error, such as:</p>
        <p class="programs">// invalid - doesn't begin with /, ./, or ../<br>import { first } from "example.js";<br><br>// invalid - doesn't begin with /, ./, or ../<br>import { second } from "example/index.js";</p>
        <p class="indent">Each of these module specifiers cannot be loaded by a browser. The two module specifiers are in an invalid format (missing the correct beginning characters), even though both will work when used as the value of <span class="literal">src</span> in a <span class="literal">&lt;script&gt;</span> tag. This is an intentional difference in behavior between <span class="literal">&lt;script&gt;</span> and <span class="literal">import</span>.</p>
        <h3 class="h3" id="ch13lev1sec09"><span epub:type="pagebreak" id="page_298"></span><strong>Summary</strong></h3>
        <p class="noindent">ECMAScript 6 adds modules to the language as a way to package and encapsulate functionality. Modules behave differently than scripts in that they don’t modify the global scope with their top-level variables, functions, and classes, and <span class="literal">this</span> is <span class="literal">undefined</span>. To achieve that behavior, modules are loaded using a different mode.</p>
        <p class="indent">You must export any functionality you want to make available to consumers of a module. Variables, functions, and classes can all be exported, and there is also one default export allowed per module. After exporting, another module can import all or some of the exported names. These names act as though they were defined by <span class="literal">let</span> and operate as block bindings that can’t be redeclared in the same module.</p>
        <p class="indent">Modules don’t need to export anything if they’re manipulating something in the global scope. You can actually import from such a module without introducing any bindings into the module scope.</p>
        <p class="indent">Because modules must run in a different mode, browsers introduced <span class="literal">&lt;script type="module"&gt;</span> to signal that the source file or inline code should be executed as a module. Module files loaded with <span class="literal">&lt;script type="module"&gt;</span> are loaded as though the <span class="literal">defer</span> attribute is applied to them. Modules are also executed in the order in which they appear in the containing document after the document is fully parsed.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com