<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch11"><span epub:type="pagebreak" id="page_213"></span><strong><span class="big">11</span><br>PROMISES AND ASYNCHRONOUS PROGRAMMING</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">One of the most powerful aspects of JavaScript is how easily it handles asynchronous programming. As a language created for the web, JavaScript needed to be able to respond to asynchronous user interactions, such as clicks and key presses, from the beginning. Node.js made asynchronous programming in JavaScript more popular by using callbacks as an alternative to events. But as more programs started using asynchronous programming, events and callbacks weren’t powerful enough to support everything developers wanted to do. <em>Promises</em> are the solution to this problem.</p>
        <p class="indent">Promises are another option for asynchronous programming, and they work like futures and deferreds do in other languages. Like events and callbacks, a promise specifies some code to be executed later, but promises <span epub:type="pagebreak" id="page_214"></span>also explicitly indicate whether the code succeeded or failed. You can chain promises together based on success or failure in ways that make your code easier to understand and debug.</p>
        <p class="indent">This chapter shows you how promises work. However, for a complete understanding, it’s important to understand some of the basic concepts upon which promises are built.</p>
        <h3 class="h3" id="ch11lev1sec01"><strong>Asynchronous Programming Background</strong></h3>
        <p class="noindent">JavaScript engines are built on the concept of a single-threaded event loop. <em>Single-threaded</em> means that only one piece of code is executed at a time. Contrast this with languages like Java or C++, where threads can allow multiple different pieces of code to execute at the same time. Maintaining and protecting state when multiple pieces of code can access and change that state is a difficult problem and a frequent source of bugs in thread-based software.</p>
        <p class="indent">JavaScript engines can execute only one piece of code at a time, so they need to keep track of code that is meant to run. That code is kept in a <em>job queue</em>. Whenever a piece of code is ready to be executed, it is added to the job queue. When the JavaScript engine is finished executing code, the event loop executes the next job in the queue. The <em>event loop</em> is a process inside the JavaScript engine that monitors code execution and manages the job queue. Keep in mind that as a queue, job execution runs from the first job in the queue to the last.</p>
        <h4 class="h4" id="ch11lev2sec01"><em><strong>The Event Model</strong></em></h4>
        <p class="noindent">When a user clicks a button or presses a key on the keyboard, an event like <span class="literal">onclick</span> is triggered. That event might respond to the interaction by adding a new job to the back of the job queue. This is JavaScript’s most basic form of asynchronous programming. The event handler code doesn’t execute until the event fires, and when it does execute, it has the appropriate context. For example:</p>
        <p class="programs">let button = document.getElementById("my-btn");<br>button.onclick = function(event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Clicked");<br>};</p>
        <p class="indent">In this code, <span class="literal">console.log("Clicked")</span> will not be executed until <span class="literal">button</span> is clicked. When <span class="literal">button</span> is clicked, the function assigned to <span class="literal">onclick</span> is added to the back of the job queue and will be executed when all other jobs ahead of it are complete.</p>
        <p class="indent">Events work well for simple interactions, but chaining multiple separate asynchronous calls together is more complicated because you must keep track of the event target (<span class="literal">button</span> in this example) for each event. Additionally, you need to ensure that all appropriate event handlers are <span epub:type="pagebreak" id="page_215"></span>added before the first time an event occurs. For instance, if <span class="literal">button</span> is clicked before <span class="literal">onclick</span> is assigned, nothing will happen. So although events are useful for responding to user interactions and similar infrequent functionality, they aren’t very flexible for more complex needs.</p>
        <h4 class="h4" id="ch11lev2sec02"><em><strong>The Callback Pattern</strong></em></h4>
        <p class="noindent">Node.js advanced the asynchronous programming model by popularizing callbacks. The callback pattern is similar to the event model because the asynchronous code doesn’t execute until a later point in time. It’s different because the function to call is passed in as an argument, as shown here:</p>
        <p class="programs">readFile("example.txt", function(err, contents) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(contents);<br>});<br><br>console.log("Hi!");</p>
        <p class="indent">This example uses the traditional Node.js <em>error-first</em> callback style. The <span class="literal">readFile()</span> function is intended to read from a file on disk (specified as the first argument) and then execute the callback (the second argument) when complete. If there’s an error, the <span class="literal">err</span> argument of the callback is an error object; otherwise, the <span class="literal">contents</span> argument contains the file contents as a string.</p>
        <p class="indent">Using the callback pattern, <span class="literal">readFile()</span> begins executing immediately and pauses when it starts reading from the disk. That means <span class="literal">console.log("Hi!")</span> is output immediately after <span class="literal">readFile()</span> is called, before <span class="literal">console.log(contents)</span> prints anything. When <span class="literal">readFile()</span> finishes, it adds a new job to the end of the job queue with the callback function and its arguments. That job executes upon completion of all other jobs ahead of it.</p>
        <p class="indent">The callback pattern is more flexible than events because chaining multiple calls together is easier with callbacks. Here’s an example:</p>
        <p class="programs">readFile("example.txt", function(err, contents) {<br>&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;writeFile("example.txt", function(err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("File was written!");<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>});</p>
        <p class="indent"><span epub:type="pagebreak" id="page_216"></span>In this code, a successful call to <span class="literal">readFile()</span> results in another asynchronous call, this time to the <span class="literal">writeFile()</span> function. Note that the same basic pattern of checking <span class="literal">err</span> is present in both functions. When <span class="literal">readFile()</span> is complete, it adds a job to the job queue that calls the <span class="literal">writeFile()</span> function if there are no errors. Then, <span class="literal">writeFile()</span> adds a job to the job queue when it finishes.</p>
        <p class="indent">This pattern works fairly well, but you can quickly find yourself in <em>callback hell</em>. Callback hell occurs when you nest too many callbacks, like this:</p>
        <p class="programs">method1(function(err, result) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;method2(function(err, result) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method3(function(err, result) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method4(function(err, result) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw err;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;method5(result);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>});</p>
        <p class="indent">Nesting multiple method calls, as this example does, creates a tangled web of code that is difficult to understand and debug. Callbacks also present problems when you want to implement more complex functionality. What if you want two asynchronous operations to run in parallel and notify you when they’re both complete? What if you want to start two asynchronous operations at the same time but only take the result of the first one to complete? In these cases, you’d need to track multiple callbacks and cleanup operations, and promises greatly improve such situations.</p>
        <h3 class="h3" id="ch11lev1sec02"><span epub:type="pagebreak" id="page_217"></span><strong>Promise Basics</strong></h3>
        <p class="noindent">A promise is a placeholder for the result of an asynchronous operation. Instead of subscribing to an event or passing a callback to a function, the function can return a promise, as shown here:</p>
        <p class="programs">// readFile promises to complete at some point in the future<br>let promise = readFile("example.txt");</p>
        <p class="indent">In this code, <span class="literal">readFile()</span> doesn’t start reading the file immediately: that will happen later. Instead, the function returns a promise object representing the asynchronous read operation so you can work with it in the future. Exactly when you’ll be able to work with that result depends entirely on how the promise’s life cycle concludes.</p>
        <h4 class="h4" id="ch11lev2sec03"><em><strong>The Promise Life Cycle</strong></em></h4>
        <p class="noindentb">Each promise goes through a short life cycle starting in the <em>pending</em> state, which indicates that the asynchronous operation hasn’t completed yet. A pending promise is considered <em>unsettled</em>. The promise in the previous example is in the pending state as soon as the <span class="literal">readFile()</span> function returns it. Once the asynchronous operation completes, the promise is considered <em>settled</em> and enters one of two possible states:</p>
        <p class="hang"><strong>Fulfilled</strong> The promise’s asynchronous operation has completed successfully.</p>
        <p class="hang"><strong>Rejected</strong> The promise’s asynchronous operation didn’t complete successfully due to either an error or some other cause.</p>
        <p class="indentt">An internal <span class="literal">[[PromiseState]]</span> property is set to <span class="literal">"pending"</span>, <span class="literal">"fulfilled"</span>, or <span class="literal">"rejected"</span> to reflect the promise’s state. This property isn’t exposed on promise objects, so you can’t determine which state the promise is in programmatically. But you can take a specific action when a promise changes state by using the <span class="literal">then()</span> method.</p>
        <p class="indent">The <span class="literal">then()</span> method is present on all promises and takes two arguments. The first argument is a function to call when the promise is fulfilled. Any additional data related to the asynchronous operation is passed to this fulfillment function. The second argument is a function to call when the promise is rejected. Similar to the fulfillment function, the rejection function is passed any additional data related to the rejection.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Any object that implements the <span class="literal">then()</span> method as described in the preceding paragraph is called a</em> thenable. <em>All promises are thenables, but all thenables are not promises.</em></p>
        </div>
        <p class="indent"><span epub:type="pagebreak" id="page_218"></span>Both arguments to <span class="literal">then()</span> are optional, so you can listen for any combination of fulfillment and rejection. For example, consider this set of <span class="literal">then()</span> calls:</p>
        <p class="programs">let promise = readFile("example.txt");<br><br>promise.then(function(contents) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// fulfillment<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(contents);<br>}, function(err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// rejection<br>&nbsp;&nbsp;&nbsp;&nbsp;console.error(err.message);<br>});<br><br>promise.then(function(contents) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// fulfillment<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(contents);<br>});<br><br>promise.then(null, function(err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// rejection<br>&nbsp;&nbsp;&nbsp;&nbsp;console.error(err.message);<br>});</p>
        <p class="indent">All three <span class="literal">then()</span> calls operate on the same promise. The first call listens for fulfillment and rejection. The second only listens for fulfillment; errors won’t be reported. The third just listens for rejection and doesn’t report success.</p>
        <p class="indent">Promises also have a <span class="literal">catch()</span> method that behaves the same as <span class="literal">then()</span> when only a rejection handler is passed. For example, the following <span class="literal">catch()</span> and <span class="literal">then()</span> calls are functionally equivalent:</p>
        <p class="programs">promise.catch(function(err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// rejection<br>&nbsp;&nbsp;&nbsp;&nbsp;console.error(err.message);<br>});<br><br>// is the same as:<br><br>promise.then(null, function(err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// rejection<br>&nbsp;&nbsp;&nbsp;&nbsp;console.error(err.message);<br>});</p>
        <p class="indent">The <span class="literal">then()</span> and <span class="literal">catch()</span> methods are intended to be used in combination to properly handle the result of asynchronous operations. This system is better than using events and callbacks because it clearly indicates whether the operation succeeded or failed completely. (Events tend not to fire when there’s an error, and in callbacks you must always remember to check the error argument.) Just know that if you don’t attach a rejection handler to a promise, all failures will happen silently. Always attach a rejection handler, even if the handler just logs the failure.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_219"></span>A fulfillment or rejection handler will still be executed even if it is added to the job queue after the promise is already settled. This allows you to add new fulfillment and rejection handlers at any time and guarantee that they will be called. For example:</p>
        <p class="programs">let promise = readFile("example.txt");<br><br>// original fulfillment handler<br>promise.then(function(contents) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(contents);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// now add another<br>&nbsp;&nbsp;&nbsp;&nbsp;promise.then(function(contents) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(contents);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>});</p>
        <p class="indent">In this code, the fulfillment handler adds another fulfillment handler to the same promise. The promise is already fulfilled at this point, so the new fulfillment handler is added to the job queue and called when all other preceding jobs on the queue are complete. Rejection handlers work the same way.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Each call to <span class="literal">then()</span> or <span class="literal">catch()</span> creates a new job to be executed when the promise is resolved. But these jobs end up in a separate job queue that is reserved strictly for promises. The precise details of this second job queue aren’t important for understanding how to use promises as long as you understand how job queues work in general.</em></p>
        </div>
        <h4 class="h4" id="ch11lev2sec04"><em><strong>Creating Unsettled Promises</strong></em></h4>
        <p class="noindent">New promises are created using the <span class="literal">Promise</span> constructor. This constructor accepts a single argument: a function called the <em>executor</em>, which contains the code to initialize the promise. The executor is passed two functions named <span class="literal">resolve()</span> and <span class="literal">reject()</span> as arguments. The <span class="literal">resolve()</span> function is called when the executor has finished successfully to signal that the promise is ready to be resolved, whereas the <span class="literal">reject()</span> function indicates that the executor has failed.</p>
        <p class="indent">Here’s an example that uses a promise in Node.js to implement the <span class="literal">readFile()</span> function you saw earlier in this chapter:</p>
        <p class="programs">// Node.js example<br><br>let fs = require("fs");<br><br>function readFile(filename) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise(function(resolve, reject) {<br><span epub:type="pagebreak" id="page_220"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// trigger the asynchronous operation<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.readFile(filename, { encoding: "utf8" }, function(err, contents) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// check for errors<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(err);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the read succeeded<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(contents);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}<br><br>let promise = readFile("example.txt");<br><br>// listen for both fulfillment and rejection<br>promise.then(function(contents) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// fulfillment<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(contents);<br>}, function(err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// rejection<br>&nbsp;&nbsp;&nbsp;&nbsp;console.error(err.message);<br>});</p>
        <p class="indent">In this example, the native Node.js <span class="literal">fs.readFile()</span> asynchronous call is wrapped in a promise. The executor either passes the error object to the <span class="literal">reject()</span> function or passes the file contents to the <span class="literal">resolve()</span> function.</p>
        <p class="indent">Keep in mind that the executor runs immediately when <span class="literal">readFile()</span> is called. When either <span class="literal">resolve()</span> or <span class="literal">reject()</span> is called inside the executor, a job is added to the job queue to resolve the promise. This is called <em>job scheduling</em>, and if you’ve ever used the <span class="literal">setTimeout()</span> or <span class="literal">setInterval()</span> functions, you’re already familiar with it. In job scheduling, you add a new job to the job queue to say, “Don’t execute this right now, but execute it later.” For instance, the <span class="literal">setTimeout()</span> function lets you specify a delay before a job is added to the queue:</p>
        <p class="programs">// add this function to the job queue after 500 ms have passed<br>setTimeout(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Timeout");<br>}, 500)<br><br>console.log("Hi!");</p>
        <p class="indent">This code schedules a job to be added to the job queue after 500 ms. The two <span class="literal">console.log()</span> calls produce the following output:</p>
        <p class="programs">Hi!<br>Timeout</p>
        <p class="indent"><span epub:type="pagebreak" id="page_221"></span>Thanks to the 500 ms delay, the output that the function passed to <span class="literal">setTimeout()</span> was shown after the output from the <span class="literal">console.log("Hi!")</span> call.</p>
        <p class="indent">Promises work similarly. The promise executor executes immediately, before anything that appears after it in the source code. For instance:</p>
        <p class="programs">let promise = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Promise");<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve();<br>});<br><br>console.log("Hi!");</p>
        <p class="indent">The output for this code is:</p>
        <p class="programs">Promise<br>Hi!</p>
        <p class="indent">Calling <span class="literal">resolve()</span> triggers an asynchronous operation. Functions passed to <span class="literal">then()</span> and <span class="literal">catch()</span> are executed asynchronously, because these are also added to the job queue. Here’s an example:</p>
        <p class="programs">let promise = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Promise");<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve();<br>});<br><br>promise.then(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Resolved.");<br>});<br><br>console.log("Hi!");</p>
        <p class="indent">The output for this example is:</p>
        <p class="programs">Promise<br>Hi!<br>Resolved</p>
        <p class="indent">Note that even though the call to <span class="literal">then()</span> appears before the line <span class="literal">console.log("Hi!")</span>, it doesn’t actually execute until later (unlike the executor). The reason is that fulfillment and rejection handlers are always added to the end of the job queue after the executor has completed.</p>
        <h4 class="h4" id="ch11lev2sec05"><em><strong>Creating Settled Promises</strong></em></h4>
        <p class="noindent">The <span class="literal">Promise</span> constructor is the best way to create unsettled promises due to the dynamic nature of what the promise executor does. But if you want a promise to represent just a single known value, it doesn’t make sense to schedule a job that simply passes a value to the <span class="literal">resolve()</span> function. Instead, you can use either of two methods that create settled promises given a specific value.</p>
        <h5 class="h5" id="ch11lev3sec01"><span epub:type="pagebreak" id="page_222"></span><strong>Using Promise.resolve()</strong></h5>
        <p class="noindent">The <span class="literal">Promise.resolve()</span> method accepts a single argument and returns a promise in the fulfilled state. That means no job scheduling occurs, and you need to add one or more fulfillment handlers to the promise to retrieve the value. For example:</p>
        <p class="programs">let promise = Promise.resolve(42);<br><br>promise.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>});</p>
        <p class="indent">This code creates a fulfilled promise so the fulfillment handler receives 42 as <span class="literal">value</span>. If a rejection handler were added to this promise, the rejection handler would never be called because the promise will never be in the rejected state.</p>
        <h5 class="h5" id="ch11lev3sec02"><strong>Using Promise.reject()</strong></h5>
        <p class="noindent">You can also create rejected promises by using the <span class="literal">Promise.reject()</span> method. This works like <span class="literal">Promise.resolve()</span> except the created promise is in the rejected state, as follows:</p>
        <p class="programs">let promise = Promise.reject(42);<br><br>promise.catch(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>});</p>
        <p class="indent">Any additional rejection handlers added to this promise would be called but not fulfillment handlers.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>If you pass a promise to either the <span class="literal">Promise.resolve()</span> or <span class="literal">Promise.reject()</span> method, the promise is returned without modification.</em></p>
        </div>
        <h5 class="h5" id="ch11lev3sec03"><strong>Non-Promise Thenables</strong></h5>
        <p class="noindent">Both <span class="literal">Promise.resolve()</span> and <span class="literal">Promise.reject()</span> also accept non-promise thenables as arguments. When passed a non-promise thenable, these methods create a new promise that is called after the <span class="literal">then()</span> function.</p>
        <p class="indent">A non-promise thenable is created when an object has a <span class="literal">then()</span> method that accepts a <span class="literal">resolve</span> and a <span class="literal">reject</span> argument, like this:</p>
        <p class="programs">let thenable = {<br>&nbsp;&nbsp;&nbsp;&nbsp;then: function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};</p>
        <p class="indent"><span epub:type="pagebreak" id="page_223"></span>The <span class="literal">thenable</span> object in this example has no characteristics associated with a promise other than the <span class="literal">then()</span> method. You can call <span class="literal">Promise.resolve()</span> to convert <span class="literal">thenable</span> into a fulfilled promise:</p>
        <p class="programs">let thenable = {<br>&nbsp;&nbsp;&nbsp;&nbsp;then: function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let p1 = Promise.resolve(thenable);<br>p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>});</p>
        <p class="indent">In this example, <span class="literal">Promise.resolve()</span> calls <span class="literal">thenable.then()</span> so a promise state can be determined. The promise state for <span class="literal">thenable</span> is fulfilled because <span class="literal">resolve(42)</span> is called inside the <span class="literal">then()</span> method. A new promise called <span class="literal">p1</span> is created in the fulfilled state with the value passed from <span class="literal">thenable</span> (that is, 42), and the fulfillment handler for <span class="literal">p1</span> receives 42 as the value.</p>
        <p class="indent">You can use the same process with <span class="literal">Promise.resolve()</span> to create a rejected promise from a thenable:</p>
        <p class="programs">let thenable = {<br>&nbsp;&nbsp;&nbsp;&nbsp;then: function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(42);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let p1 = Promise.resolve(thenable);<br>p1.catch(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>});</p>
        <p class="indent">This example is similar to the previous example, except <span class="literal">thenable</span> is rejected. When <span class="literal">thenable.then()</span> executes, a new promise is created in the rejected state with a value of 42. That value is then passed to the rejection handler for <span class="literal">p1</span>.</p>
        <p class="indent"><span class="literal">Promise.resolve()</span> and <span class="literal">Promise.reject()</span> work like this to allow you to easily work with non-promise thenables. Many libraries used thenables prior to promises being introduced in ECMAScript 6, so the ability to convert thenables into formal promises is important for backward compatibility with previously existing libraries. When you’re unsure whether an object is a promise, passing the object through <span class="literal">Promise.resolve()</span> or <span class="literal">Promise.reject()</span> (depending on your anticipated result) is the best way to find out because promises just pass through unchanged.</p>
        <h4 class="h4" id="ch11lev2sec06"><span epub:type="pagebreak" id="page_224"></span><em><strong>Executor Errors</strong></em></h4>
        <p class="noindent">If an error is thrown inside an executor, the promise’s rejection handler is called. For example:</p>
        <p class="programs">let promise = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Explosion!");<br>});<br><br>promise.catch(function(error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(error.message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Explosion!"<br>});</p>
        <p class="indent">In this code, the executor intentionally throws an error. An implicit <span class="literal">try-catch</span> is inside every executor so that the error is caught and then passed to the rejection handler. The previous example is equivalent to this:</p>
        <p class="programs">let promise = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;try {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Explosion!");<br>&nbsp;&nbsp;&nbsp;&nbsp;} catch (ex) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(ex);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>promise.catch(function(error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(error.message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Explosion!"<br>});</p>
        <p class="indent">The executor catches any thrown errors to simplify this common use case, but an error thrown in the executor is only reported when a rejection handler is present. Otherwise, the error is suppressed. This became a problem for developers early on when using promises, and JavaScript environments address it by providing hooks for catching rejected promises.</p>
        <h3 class="h3" id="ch11lev1sec03"><strong>Global Promise Rejection Handling</strong></h3>
        <p class="noindent">One of the most controversial aspects of promises is the silent failure that occurs when a promise is rejected without a rejection handler. Some consider this the biggest flaw in the specification because it’s the only part of the JavaScript language that doesn’t make errors apparent.</p>
        <p class="indent">Determining whether a promise rejection was handled isn’t straightforward due to the nature of promises. For instance, consider this example:</p>
        <p class="programs">let rejected = Promise.reject(42);<br><br>// at this point, rejected is unhandled<br><span epub:type="pagebreak" id="page_225"></span>// some time later...<br>rejected.catch(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// now rejected has been handled<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>});</p>
        <p class="indent">You can call <span class="literal">then()</span> or <span class="literal">catch()</span> at any point and have them work correctly regardless of whether the promise is settled or not, making it difficult to know precisely when a promise will be handled. In this case, the promise is rejected immediately but isn’t handled until later.</p>
        <p class="indent">Although it’s possible that a future version of ECMAScript will address this problem, both Node.js and browsers have implemented changes to address this developer pain point. They aren’t part of the ECMAScript 6 specification but are valuable tools when you’re using promises.</p>
        <h4 class="h4" id="ch11lev2sec07"><em><strong>Node.js Rejection Handling</strong></em></h4>
        <p class="noindentb">Node.js emits two events on the <span class="literal">process</span> object that are related to promise rejection handling:</p>
        <p class="hang"><span class="literal"><span class="codestrong">unhandledRejection</span></span> Emitted when a promise is rejected and no rejection handler is called within one turn of the event loop</p>
        <p class="hang"><span class="literal"><span class="codestrong">rejectionHandled</span></span> Emitted when a promise is rejected and a rejection handler is called after one turn of the event loop</p>
        <p class="indentt">These events are designed to work together to help identify promises that are rejected and not handled.</p>
        <p class="indent">The <span class="literal">unhandledRejection</span> event handler is passed the rejection reason (frequently an error object) and the promise that was rejected as arguments. The following code shows <span class="literal">unhandledRejection</span> in action:</p>
        <p class="programs">let rejected;<br><br>process.on("unhandledRejection", function(reason, promise) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(reason.message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Explosion!"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(rejected === promise);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>});<br><br>rejected = Promise.reject(new Error("Explosion!"));</p>
        <p class="indent">This example creates a rejected promise with an error object and listens for the <span class="literal">unhandledRejection</span> event. The event handler receives the error object as the first argument and the promise as the second.</p>
        <p class="indent">The <span class="literal">rejectionHandled</span> event handler has only one argument, which is the promise that was rejected. For example:</p>
        <p class="programs">let rejected;<br><br>process.on("rejectionHandled", function(promise) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(rejected === promise);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>});<br><span epub:type="pagebreak" id="page_226"></span><br>rejected = Promise.reject(new Error("Explosion!"));<br><br>// wait to add the rejection handler<br>setTimeout(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;rejected.catch(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(value.message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Explosion!"<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}, 1000);</p>
        <p class="indent">Here, the <span class="literal">rejectionHandled</span> event is emitted when the rejection handler is finally called. If the rejection handler were attached directly to <span class="literal">rejected</span> after <span class="literal">rejected</span> is created, the event wouldn’t be emitted. The rejection handler would instead be called during the same turn of the event loop where <span class="literal">rejected</span> was created, which isn’t useful.</p>
        <p class="indent">To properly track potentially unhandled rejections, use the events <span class="literal">rejectionHandled</span> and <span class="literal">unhandledRejection</span> to store a list of potentially unhandled rejections. Then wait some period of time to inspect the list. For example, look at this simple unhandled rejection tracker:</p>
        <p class="programs">let possiblyUnhandledRejections = new Map();<br><br>// when a rejection is unhandled, add it to the map<br>process.on("unhandledRejection", function(reason, promise) {<br>&nbsp;&nbsp;&nbsp;&nbsp;possiblyUnhandledRejections.set(promise, reason);<br>});<br><br>process.on("rejectionHandled", function(promise) {<br>&nbsp;&nbsp;&nbsp;&nbsp;possiblyUnhandledRejections.delete(promise);<br>});<br><br>setInterval(function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;possiblyUnhandledRejections.forEach(function(reason, promise) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(reason.message ? reason.message : reason);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do something to handle these rejections<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handleRejection(promise, reason);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;possiblyUnhandledRejections.clear();<br><br>}, 60000);</p>
        <p class="indent">This code uses a map to store promises and their rejection reasons. Each promise is a key, and the promise’s reason is the associated value. Each time <span class="literal">unhandledRejection</span> is emitted, the promise and its rejection reason are added to the map. Each time <span class="literal">rejectionHandled</span> is emitted, the handled promise is removed from the map. As a result, <span class="literal">possiblyUnhandledRejections</span> grows and shrinks as events are called. The <span class="literal">setInterval()</span> call periodically checks the list of possible unhandled rejections and outputs the information to the console (in reality, you’ll probably want to do something else <span epub:type="pagebreak" id="page_227"></span>to log or otherwise handle the rejection). A map is used in this example instead of a weak map because you need to inspect the map periodically to see which promises are present, and that’s not possible with a weak map.</p>
        <p class="indent">Although this example is specific to Node.js, browsers have implemented a similar mechanism for notifying developers about unhandled rejections.</p>
        <h4 class="h4" id="ch11lev2sec08"><em><strong>Browser Rejection Handling</strong></em></h4>
        <p class="noindentb">Browsers also emit two events to help identify unhandled rejections. These events are emitted by the <span class="literal">window</span> object and are effectively the same as their Node.js equivalents:</p>
        <p class="hang"><span class="literal"><span class="codestrong">unhandledrejection</span></span> Emitted when a promise is rejected and no rejection handler is called within one turn of the event loop</p>
        <p class="hang"><span class="literal"><span class="codestrong">rejectionhandled</span></span> Emitted when a promise is rejected and a rejection handler is called after one turn of the event loop</p>
        <p class="indenttb">Although the Node.js implementation passes individual parameters to the event handler, the event handler for these browser events receives an event object with the following properties:</p>
        <p class="hang"><span class="literal"><span class="codestrong">type</span></span> The name of the event (<span class="literal">"unhandledrejection"</span> or <span class="literal">"rejectionhandled"</span>)</p>
        <p class="hang"><span class="literal"><span class="codestrong">promise</span></span> The promise object that was rejected</p>
        <p class="hang"><span class="literal"><span class="codestrong">reason</span></span> The rejection value from the promise</p>
        <p class="indentt">The other difference in the browser implementation is that the rejection value (<span class="literal">reason</span>) is available for both events. For example:</p>
        <p class="programs">let rejected;<br><br>window.onunhandledrejection = function(event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(event.type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "unhandledrejection"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(event.reason.message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Explosion!"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(rejected === event.promise);&nbsp;&nbsp;&nbsp;&nbsp;// true<br>});<br><br>window.onrejectionhandled = function(event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(event.type);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "rejectionhandled"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(event.reason.message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Explosion!"<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(rejected === event.promise);&nbsp;&nbsp;&nbsp;&nbsp;// true<br>});<br><br>rejected = Promise.reject(new Error("Explosion!"));</p>
        <p class="indent">This code assigns both event handlers using the DOM Level 0 notation of <span class="literal">onunhandledrejection</span> and <span class="literal">onrejectionhandled</span>. (You can also use <span class="literal">addEventListener("unhandledrejection")</span> and <span class="literal">addEventListener("rejectionhandled")</span> if you prefer.) Each event handler receives an event object containing information about the rejected promise. The <span class="literal">type</span>, <span class="literal">promise</span>, and <span class="literal">reason</span> properties are all available in both event handlers.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_228"></span>The code to keep track of unhandled rejections in the browser is very similar to the code for Node.js, too:</p>
        <p class="programs">let possiblyUnhandledRejections = new Map();<br><br>// when a rejection is unhandled, add it to the map<br>window.onunhandledrejection = function(event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;possiblyUnhandledRejections.set(event.promise, event.reason);<br>};<br><br>window.onrejectionhandled = function(event) {<br>&nbsp;&nbsp;&nbsp;&nbsp;possiblyUnhandledRejections.delete(event.promise);<br>};<br><br>setInterval(function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;possiblyUnhandledRejections.forEach(function(reason, promise) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(reason.message ? reason.message : reason);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// do something to handle these rejections<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;handleRejection(promise, reason);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;possiblyUnhandledRejections.clear();<br><br>}, 60000);</p>
        <p class="indent">This implementation is almost exactly the same as the Node.js implementation. It uses the same approach of storing promises and their rejection values in a map and then inspecting them later. The only real difference is where the information is retrieved from in the event handlers.</p>
        <p class="indent">Handling promise rejections can be tricky, but you’ve just begun to see how powerful promises can really be. It’s time to take the next step and chain several promises together.</p>
        <h3 class="h3" id="ch11lev1sec04"><strong>Chaining Promises</strong></h3>
        <p class="noindent">At this point, promises may seem like little more than an incremental improvement over using some combination of a callback and the <span class="literal">setTimeout()</span> function, but there is much more to promises than meets the eye. Specifically, a number of ways are available to chain promises together to accomplish more complex asynchronous behavior.</p>
        <p class="indent">Each call to <span class="literal">then()</span> or <span class="literal">catch()</span> actually creates and returns another promise. This second promise is resolved only when the first has been fulfilled or rejected. Consider this example:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><span epub:type="pagebreak" id="page_229"></span><br>p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>}).then(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Finished");<br>});</p>
        <p class="indent">This code outputs the following:</p>
        <p class="programs">42<br>Finished</p>
        <p class="indent">The call to <span class="literal">p1.then()</span> returns a second promise on which <span class="literal">then()</span> is called. The second <span class="literal">then()</span> fulfillment handler is only called after the first promise has been resolved. If you unchain this example, it looks like this:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>let p2 = p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>})<br><br>p2.then(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Finished");<br>});</p>
        <p class="indent">In this unchained version of the code, the result of <span class="literal">p1.then()</span> is stored in <span class="literal">p2</span>, and then <span class="literal">p2.then()</span> is called to add the final fulfillment handler. As you might have guessed, the call to <span class="literal">p2.then()</span> also returns a promise, but this example just doesn’t use that promise.</p>
        <h4 class="h4" id="ch11lev2sec09"><em><strong>Catching Errors</strong></em></h4>
        <p class="noindent">Promise chaining allows you to catch errors that may occur in a fulfillment or rejection handler from a previous promise. For example:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Boom!");<br>}).catch(function(error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(error.message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Boom!"<br>});</p>
        <p class="indent">In this code, the fulfillment handler for <span class="literal">p1</span> throws an error. The chained call to the <span class="literal">catch()</span> method, which is on a second promise, is able <span epub:type="pagebreak" id="page_230"></span>to receive that error through its rejection handler. The same is true if a rejection handler throws an error:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Explosion!");<br>});<br><br>p1.catch(function(error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(error.message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Explosion!"<br>&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Boom!");<br>}).catch(function(error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(error.message);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Boom!"<br>});</p>
        <p class="indent">Here, the executor throws an error and triggers the <span class="literal">p1</span> promise’s rejection handler. That handler then throws another error that is caught by the second promise’s rejection handler. The chained promise calls are aware of errors in other promises in the chain.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Always have a rejection handler at the end of a promise chain to ensure that you can properly handle any errors that may occur.</em></p>
        </div>
        <h4 class="h4" id="ch11lev2sec10"><em><strong>Returning Values in Promise Chains</strong></em></h4>
        <p class="noindent">Another important aspect of promise chains is the ability to pass data from one promise to the next. I’ve shown how a value passed to the <span class="literal">resolve()</span> handler inside an executor is passed to the fulfillment handler for that promise, but you can continue passing data along a chain by specifying a return value from the fulfillment handler. For example:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "42"<br>&nbsp;&nbsp;&nbsp;&nbsp;return value + 1;<br>}).then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "43"<br>});</p>
        <p class="indent">The fulfillment handler for <span class="literal">p1</span> returns <span class="literal">value + 1</span> when executed. Because <span class="literal">value</span> is 42 (from the executor), the fulfillment handler returns 43. That value is then passed to the fulfillment handler of the second promise, which outputs it to the console.</p>
        <p class="indent">You could do the same thing with the rejection handler. When a rejection handler is called, it may return a value. If it does, that value is used to fulfill the next promise in the chain, as in the next example.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_231"></span>let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;reject(42);<br>});<br><br>p1.catch(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// first fulfillment handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "42"<br>&nbsp;&nbsp;&nbsp;&nbsp;return value + 1;<br>}).then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// second fulfillment handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "43"<br>});</p>
        <p class="indent">Here, the executor calls <span class="literal">reject()</span> with 42. That value is passed into the rejection handler for the promise, where <span class="literal">value + 1</span> is returned. Even though this return value is coming from a rejection handler, it is still used in the fulfillment handler of the next promise in the chain. The failure of one promise can allow the recovery of the entire chain if necessary.</p>
        <h4 class="h4" id="ch11lev2sec11"><em><strong>Returning Promises in Promise Chains</strong></em></h4>
        <p class="noindent">Returning primitive values from fulfillment and rejection handlers allows for the passing of data between promises, but what if you return an object? If the object is a promise, there’s an extra step that’s taken to determine how to proceed. Consider the following example:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>let p2 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(43);<br>});<br><br>p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// first fulfillment handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>&nbsp;&nbsp;&nbsp;&nbsp;return p2;<br>}).then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// second fulfillment handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 43<br>});</p>
        <p class="indent">In this code, <span class="literal">p1</span> schedules a job that resolves to 42. The fulfillment handler for <span class="literal">p1</span> returns <span class="literal">p2</span>, a promise already in the resolved state. The second fulfillment handler is called because <span class="literal">p2</span> has been fulfilled. If <span class="literal">p2</span> were rejected, a rejection handler (if present) would be called instead of the second fulfillment handler.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_232"></span>The important thing to recognize about this pattern is that the second fulfillment handler is not added to <span class="literal">p2</span> but rather to a third promise. The second fulfillment handler is therefore attached to that third promise, making the previous example equivalent to this:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>let p2 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(43);<br>});<br><br>let p3 = p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// first fulfillment handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>&nbsp;&nbsp;&nbsp;&nbsp;return p2;<br>});<br><br>p3.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// second fulfillment handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 43<br>});</p>
        <p class="indent">Here, it’s clear that the second fulfillment handler is attached to <span class="literal">p3</span> rather than <span class="literal">p2</span>. This is a subtle but important distinction, because the second fulfillment handler will not be called if <span class="literal">p2</span> is rejected. For instance:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>let p2 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;reject(43);<br>});<br><br>p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// first fulfillment handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>&nbsp;&nbsp;&nbsp;&nbsp;return p2;<br>}).then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// second fulfillment handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// never called<br>});</p>
        <p class="indent">In this example, the second fulfillment handler is never called because <span class="literal">p2</span> is rejected. However, you could attach a rejection handler instead:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><span epub:type="pagebreak" id="page_233"></span><br>let p2 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;reject(43);<br>});<br><br>p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// first fulfillment handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>&nbsp;&nbsp;&nbsp;&nbsp;return p2;<br>}).catch(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// rejection handler<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 43<br>});</p>
        <p class="indent">Now the rejection handler is called as a result of <span class="literal">p2</span> being rejected. The rejected value 43 from <span class="literal">p2</span> is passed into that rejection handler.</p>
        <p class="indent">Returning thenables from fulfillment or rejection handlers doesn’t change when the promise executors are executed. The first defined promise will run its executor first, then the second promise executor will run, and so on. Returning thenables simply allows you to define additional responses to the promise results. You defer the execution of fulfillment handlers by creating a new promise within a fulfillment handler. For example:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>p1.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// create a new promise<br>&nbsp;&nbsp;&nbsp;&nbsp;let p2 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(43);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return p2<br>}).then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 43<br>});</p>
        <p class="indent">In this example, a new promise is created within the fulfillment handler for <span class="literal">p1</span>. That means the second fulfillment handler won’t execute until after <span class="literal">p2</span> is fulfilled. This pattern is useful when you want to wait until a previous promise has been settled before triggering another promise.</p>
        <h3 class="h3" id="ch11lev1sec05"><strong>Responding to Multiple Promises</strong></h3>
        <p class="noindent">Each example in this chapter so far has dealt with responding to one promise at a time. But sometimes you’ll want to monitor the progress of multiple promises to determine the next action. ECMAScript 6 provides two methods that monitor multiple promises: <span class="literal">Promise.all()</span> and <span class="literal">Promise.race()</span>.</p>
        <h4 class="h4" id="ch11lev2sec12"><span epub:type="pagebreak" id="page_234"></span><em><strong>The Promise.all() Method</strong></em></h4>
        <p class="noindent">The <span class="literal">Promise.all()</span> method accepts a single argument, which is an iterable (such as an array) of promises to monitor, and returns a promise that is resolved only when every promise in the iterable is resolved. The returned promise is fulfilled when every promise in the iterable is fulfilled, as in this example:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>let p2 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(43);<br>});<br><br>let p3 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(44);<br>});<br><br>let p4 = Promise.all([p1, p2, p3]);<br><br>p4.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(Array.isArray(value));&nbsp;&nbsp;// true<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 43<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value[2]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 44<br>});</p>
        <p class="indent">Each promise here resolves with a number. The call to <span class="literal">Promise.all()</span> creates promise <span class="literal">p4</span>, which is ultimately fulfilled when promises <span class="literal">p1</span>, <span class="literal">p2</span>, and <span class="literal">p3</span> are fulfilled. The result passed to the fulfillment handler for <span class="literal">p4</span> is an array containing each resolved value: 42, 43, and 44. The values are stored in the order in which the promises resolved, so you can match promise results to the promises that resolved to them.</p>
        <p class="indent">If any promise passed to <span class="literal">Promise.all()</span> is rejected, the returned promise is immediately rejected without waiting for the other promises to complete:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>let p2 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;reject(43);<br>});<br><br>let p3 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(44);<br>});<br><br>let p4 = Promise.all([p1, p2, p3]);<br><span epub:type="pagebreak" id="page_235"></span><br>p4.catch(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(Array.isArray(value))&nbsp;&nbsp;// false<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 43<br>});</p>
        <p class="indent">In this example, <span class="literal">p2</span> is rejected with a value of 43. The rejection handler for <span class="literal">p4</span> is called immediately without waiting for <span class="literal">p1</span> or <span class="literal">p3</span> to finish executing. (They do finish executing; <span class="literal">p4</span> just doesn’t wait.)</p>
        <p class="indent">The rejection handler always receives a single value rather than an array, and the value is the rejection value from the promise that was rejected. In this case, the rejection handler is passed 43 to reflect the rejection from <span class="literal">p2</span>.</p>
        <h4 class="h4" id="ch11lev2sec13"><em><strong>The Promise.race() Method</strong></em></h4>
        <p class="noindent">The <span class="literal">Promise.race()</span> method provides a slightly different take on monitoring multiple promises. This method also accepts an iterable of promises to monitor and returns a promise, but the returned promise is settled as soon as the first promise is settled. Instead of waiting for all promises to be fulfilled, like the <span class="literal">Promise.all()</span> method, the <span class="literal">Promise.race()</span> method returns an appropriate promise as soon as any promise in the array is fulfilled. For example:</p>
        <p class="programs">let p1 = Promise.resolve(42);<br><br>let p2 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(43);<br>});<br><br>let p3 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(44);<br>});<br><br>let p4 = Promise.race([p1, p2, p3]);<br><br>p4.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>});</p>
        <p class="indent">In this code, <span class="literal">p1</span> is created as a fulfilled promise while the others schedule jobs. The fulfillment handler for <span class="literal">p4</span> is then called with the value of 42 and ignores the other promises. The promises passed to <span class="literal">Promise.race()</span> are truly in a race to see which is settled first. If the first promise to settle is fulfilled, the returned promise is fulfilled; if the first promise to settle is rejected, the returned promise is rejected. Here’s an example with a rejection:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>let p2 = Promise.reject(43);<br><span epub:type="pagebreak" id="page_236"></span><br>let p3 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(44);<br>});<br><br>let p4 = Promise.race([p1, p2, p3]);<br><br>p4.catch(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 43<br>});</p>
        <p class="indent">Here, <span class="literal">p4</span> is rejected because <span class="literal">p2</span> is already in the rejected state when <span class="literal">Promise.race()</span> is called. Even though <span class="literal">p1</span> and <span class="literal">p3</span> are fulfilled, those results are ignored because they occur after <span class="literal">p2</span> is rejected.</p>
        <h3 class="h3" id="ch11lev1sec06"><strong>Inheriting from Promises</strong></h3>
        <p class="noindent">Just like other built-in types, you can use a promise as the base for a derived class. This allows you to define your own variation of promises to extend what built-in promises can do. For instance, suppose you want to create a promise that can use methods named <span class="literal">success()</span> and <span class="literal">failure()</span> in addition to the usual <span class="literal">then()</span> and <span class="literal">catch()</span> methods. You could create that promise type as follows:</p>
        <p class="programs">class MyPromise extends Promise {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// use default constructor<br><br>&nbsp;&nbsp;&nbsp;&nbsp;success(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.then(resolve, reject);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;failure(reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.catch(reject);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>}<br><br>let promise = new MyPromise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>promise.success(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>}).failure(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>});</p>
        <p class="indent">In this example, <span class="literal">MyPromise</span> is derived from <span class="literal">Promise</span> and has two additional methods. The <span class="literal">success()</span> method mimics <span class="literal">resolve()</span> and <span class="literal">failure()</span> mimics the <span class="literal">reject()</span> method.</p>
        <p class="indent">Each added method uses <span class="literal">this</span> to call the method it mimics. The derived promise functions the same as a built-in promise except now you can call <span class="literal">success()</span> and <span class="literal">failure()</span> if you want.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_237"></span>Because static methods are inherited, the <span class="literal">MyPromise.resolve()</span> method, the <span class="literal">MyPromise.reject()</span> method, the <span class="literal">MyPromise.race()</span> method, and the <span class="literal">MyPromise.all()</span> method are also present on derived promises. The last two methods behave the same as the built-in methods, but the first two are slightly different.</p>
        <p class="indent">Both <span class="literal">MyPromise.resolve()</span> and <span class="literal">MyPromise.reject()</span> will return an instance of <span class="literal">MyPromise</span> regardless of the value passed because those methods use the <span class="literal">Symbol.species</span> property (see <a href="ch09.xhtml#page_185">page 185</a>) to determine the type of promise to return. If a built-in promise is passed to either method, the promise will be resolved or rejected, and the method will return a new <span class="literal">MyPromise</span> so you can assign fulfillment and rejection handlers. For example:</p>
        <p class="programs">let p1 = new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;resolve(42);<br>});<br><br>let p2 = MyPromise.resolve(p1);<br>p2.success(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br>});<br><br>console.log(p2 instanceof MyPromise);&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">Here, <span class="literal">p1</span> is a built-in promise that is passed to the <span class="literal">MyPromise.resolve()</span> method. The result, <span class="literal">p2</span>, is an instance of <span class="literal">MyPromise</span> where the resolved value from <span class="literal">p1</span> is passed into the fulfillment handler.</p>
        <p class="indent">If an instance of <span class="literal">MyPromise</span> is passed to the <span class="literal">MyPromise.resolve()</span> or <span class="literal">MyPromise.reject()</span> methods, it will just be returned directly without being resolved. In all other ways, these two methods behave like <span class="literal">Promise.resolve()</span> and <span class="literal">Promise.reject()</span>.</p>
        <h3 class="h3" id="ch11lev1sec07"><strong>Promise-Based Asynchronous Task Running</strong></h3>
        <p class="noindent">In <a href="ch08.xhtml#ch08">Chapter 8</a>, I introduced generators and showed you how to use them for asynchronous task running, like this:</p>
        <p class="programs">let fs = require("fs");<br><br>function run(taskDef) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// create the iterator, make available elsewhere<br>&nbsp;&nbsp;&nbsp;&nbsp;let task = taskDef();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// start the task<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = task.next();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// recursive function to keep calling next()<br>&nbsp;&nbsp;&nbsp;&nbsp;function step() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if there's more to do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!result.done) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof result.value === "function") {<br><span epub:type="pagebreak" id="page_238"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.value(function(err, data) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.throw(err);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.next(data);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.next(result.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// start the process<br>&nbsp;&nbsp;&nbsp;&nbsp;step();<br><br>}<br><br>// define a function to use with the task runner<br><br>function readFile(filename) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return function(callback) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.readFile(filename, callback);<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br>}<br><br>// run a task<br><br>run(function*() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let contents = yield readFile("config.json");<br>&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWith(contents);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Done");<br>});</p>
        <p class="indent">This implementation results in some pain points. First, wrapping every function in a function that returns a function is a bit confusing (even this sentence is confusing). Second, there is no way to distinguish between a function return value intended as a callback for the task runner and a return value that isn’t a callback.</p>
        <p class="indent">You can greatly simplify and generalize this process by ensuring that each asynchronous operation returns a promise. Here’s one way you could simplify that task runner by using promises as a common interface for all asynchronous code:</p>
        <p class="programs">let fs = require("fs");<br><br>function run(taskDef) {<br><span epub:type="pagebreak" id="page_239"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;// create the iterator<br>&nbsp;&nbsp;&nbsp;&nbsp;let task = taskDef();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// start the task<br>&nbsp;&nbsp;&nbsp;&nbsp;let result = task.next();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// recursive function to iterate through<br>&nbsp;&nbsp;&nbsp;&nbsp;(function step() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// if there's more to do<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!result.done) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// resolve to a promise to make it easy<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let promise = Promise.resolve(result.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;promise.then(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.next(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}).catch(function(error) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result = task.throw(error);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;step();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}());<br>}<br><br>// define a function to use with the task runner<br><br>function readFile(filename) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return new Promise(function(resolve, reject) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fs.readFile(filename, function(err, contents) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (err) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reject(err);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resolve(contents);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}<br><br>// run a task<br><br>run(function*() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let contents = yield readFile("config.json");<br>&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWith(contents);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Done");<br>});</p>
        <p class="indent">In this version of the code, a generic <span class="literal">run()</span> function executes a generator to create an iterator. It calls <span class="literal">task.next()</span> to start the task and recursively calls <span class="literal">step()</span> until the iterator is complete.</p>
        <p class="indent">Inside the <span class="literal">step()</span> function, if there’s more work to do, then <span class="literal">result.done</span> is <span class="literal">false</span>. At that point, <span class="literal">result.value</span> should be a promise, but <span class="literal">Promise.resolve()</span> is called just in case the function in question didn’t return a promise. <span epub:type="pagebreak" id="page_240"></span>(Remember, <span class="literal">Promise.resolve()</span> just passes through any promise passed in and wraps any non-promise in a promise.) Next, a fulfillment handler is added that retrieves the promise value and passes the value back to the iterator. Then, <span class="literal">result</span> is assigned to the next yield result before the <span class="literal">step()</span> function calls itself.</p>
        <p class="indent">A rejection handler stores any rejection results in an error object. The <span class="literal">task.throw()</span> method passes that error object back into the iterator, and if an error is caught in the task, <span class="literal">result</span> is assigned to the next yield result. Finally, <span class="literal">step()</span> is called inside <span class="literal">catch()</span> to continue.</p>
        <p class="indent">This <span class="literal">run()</span> function can run any generator that uses <span class="literal">yield</span> to achieve asynchronous code without exposing promises (or callbacks) to the developer. In fact, because the return value of the function call is always converted to a promise, the function can even return something other than a promise. That means both synchronous and asynchronous methods work correctly when called using <span class="literal">yield</span>, and you never have to check that the return value is a promise.</p>
        <p class="indent">The only concern is ensuring that asynchronous functions like <span class="literal">readFile()</span> return a promise that correctly identifies its state. For Node.js built-in methods, that means you’ll have to convert those methods to return promises instead of using callbacks.</p>
        <div class="sidebar">
        <p class="sidebart"><strong>FUTURE ASYNCHRONOUS TASK RUNNING</strong></p>
        <p class="noindent">Bringing a simpler syntax to asynchronous task running in JavaScript is under way. For instance, an <span class="literal">await</span> syntax is in progress that would closely mirror the promise-based example in the preceding section. The basic idea is to use a function marked with <span class="literal">async</span> instead of a generator and use <span class="literal">await</span> instead of <span class="literal">yield</span> when calling a function, such as:</p>
        <p class="programs">(async function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;let contents = await readFile("config.json");<br>&nbsp;&nbsp;&nbsp;&nbsp;doSomethingWith(contents);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log("Done");<br>});</p>
        <p class="indent">The <span class="literal">async</span> keyword before <span class="literal">function</span> indicates that the function is meant to run in an asynchronous manner. The <span class="literal">await</span> keyword signals that the function call to <span class="literal">readFile("config.json")</span> should return a promise, and if it doesn’t, the response should be wrapped in a promise. Just like the implementation of <span class="literal">run()</span> in the preceding section, <span class="literal">await</span> will throw an error if the promise is rejected and otherwise return the value from the promise. The end result is that you can write asynchronous code as if it were synchronous without the overhead of managing an iterator-based state machine.</p>
        <p class="indent">The <span class="literal">await</span> syntax is expected to be finalized in ECMAScript 2017 (ECMAScript 8).</p>
        </div>
        <h3 class="h3" id="ch11lev1sec08"><span epub:type="pagebreak" id="page_241"></span><strong>Summary</strong></h3>
        <p class="noindent">Promises are designed to improve asynchronous programming in JavaScript by giving you more control and composability over asynchronous operations than events and callbacks can. Promises schedule jobs to be added to the JavaScript engine’s job queue for future execution, and a second job queue tracks promise fulfillment and rejection handlers to ensure proper execution.</p>
        <p class="indent">Promises have three states: pending, fulfilled, and rejected. A promise starts in a pending state and becomes fulfilled on a successful execution or rejected on a failure. In either case, you can add handlers to indicate when a promise is settled. The <span class="literal">then()</span> method allows you to assign a fulfillment and rejection handler, and the <span class="literal">catch()</span> method allows you to assign only a rejection handler.</p>
        <p class="indent">You can chain promises together in a variety of ways and pass information between them. Each call to <span class="literal">then()</span> creates and returns a new promise that is resolved when the previous one is resolved. Such chains can be used to trigger responses to a series of asynchronous events. You can also use <span class="literal">Promise.race()</span> and <span class="literal">Promise.all()</span> to monitor the progress of multiple promises and respond accordingly.</p>
        <p class="indent">Asynchronous task running is easier when you combine generators and promises, because promises provide a common interface that asynchronous operations can return. You can then use generators and the <span class="literal">yield</span> operator to wait for asynchronous responses and respond appropriately.</p>
        <p class="indent">Most new web APIs are being built on top of promises, and you can expect many more to follow suit in the future.<span epub:type="pagebreak" id="page_242"></span></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com