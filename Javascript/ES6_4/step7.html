<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch07"><span epub:type="pagebreak" id="page_119"></span><strong><span class="big">7</span><br>SETS AND MAPS</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">For most of its history, JavaScript had only one type of collection, which was represented by the <span class="literal">Array</span> type. (Although some developers may argue that all nonarray objects are just collections of key-value pairs, their intended use was originally quite different from arrays.) Arrays in JavaScript are used just like arrays in other languages, but before ECMAScript 6, the lack of other collection options meant arrays were often used as queues and stacks as well. Because arrays use only numeric indexes, developers used nonarray objects whenever a nonnumeric index was necessary. That technique led to custom implementations of sets and maps using nonarray objects.</p>
        <p class="indent">A <em>set</em> is a list of values that cannot contain duplicates. You typically don’t access individual items in a set like you would items in an array; instead, it’s much more common to just check a set to see if a value is present. A <em>map</em> is a collection of keys that correspond to specific values. Each item in <span epub:type="pagebreak" id="page_120"></span>a map stores two pieces of data, and values are retrieved by specifying the key to read from. Maps are frequently used as caches for storing data that is quickly retrieved at a later time. Although ECMAScript 5 didn’t formally have sets and maps, developers worked around this limitation using nonarray objects, too.</p>
        <p class="indent">ECMAScript 6 added sets and maps to JavaScript, and this chapter discusses everything you need to know about these two collection types. First, I’ll discuss the workarounds developers used to implement sets and maps before ECMAScript 6, and why those implementations were problematic. Then I’ll cover how sets and maps work in ECMAScript 6.</p>
        <h3 class="h3" id="ch07lev1sec01"><strong>Sets and Maps in ECMAScript 5</strong></h3>
        <p class="noindent">In ECMAScript 5, developers mimicked sets and maps by using object properties, like this:</p>
        <p class="programs">var set = Object.create(null);<br><br>set.foo = true;<br><br>// checking for existence<br>if (set.foo) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// code to execute<br>}</p>
        <p class="indent">The <span class="literal">set</span> variable in this example is an object with a <span class="literal">null</span> prototype, ensuring no inherited properties are on the object. Using object properties as unique values to be checked is a common approach in ECMAScript 5. When a property is added to the <span class="literal">set</span> object, it is set to <span class="literal">true</span> so conditional statements (such as the <span class="literal">if</span> statement in this example) can easily check whether the value is present.</p>
        <p class="indent">The only real difference between an object used as a set and an object used as a map is the value being stored. For instance, this example uses an object as a map:</p>
        <p class="programs">var map = Object.create(null);<br>map.foo = "bar";<br><br>// retrieving a value<br>var value = map.foo;<br><br>console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "bar"</p>
        <p class="indent">This code stores a string value <span class="literal">"bar"</span> under the key <span class="literal">foo</span>. Unlike sets, maps are mostly used to retrieve information rather than just to check for the key’s existence.</p>
        <h3 class="h3" id="ch07lev1sec02"><span epub:type="pagebreak" id="page_121"></span><strong>Problems with Workarounds</strong></h3>
        <p class="noindent">Using objects as sets and maps works okay in simple situations, but the approach can get more complicated when you run into the limitations of object properties. For example, because all object properties must be strings, you must be certain no two keys evaluate to the same string. Consider the following:</p>
        <p class="programs">var map = Object.create(null);<br>map[5] = "foo";<br><br>console.log(map["5"]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "foo"</p>
        <p class="indent">This example assigns the string value <span class="literal">"foo"</span> to a numeric key of <span class="literal">5</span>. Internally, that numeric value is converted to a string, so <span class="literal">map["5"]</span> and <span class="literal">map[5]</span> actually reference the same property. That internal conversion can cause problems when you want to use numbers and strings as keys. Another problem arises when you use objects as keys, like this:</p>
        <p class="programs">var map = Object.create(null),<br>&nbsp;&nbsp;&nbsp;&nbsp;key1 = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;key2 = {};<br>map[key1] = "foo";<br><br>console.log(map[key2]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "foo"</p>
        <p class="indent">Here, <span class="literal">map[key2]</span> and <span class="literal">map[key1]</span> reference the same value. The objects <span class="literal">key1</span> and <span class="literal">key2</span> are converted to strings because object properties must be strings. Because <span class="literal">"[object Object]"</span> is the default string representation for objects, both <span class="literal">key1</span> and <span class="literal">key2</span> are converted to that string. This can cause errors that may not be obvious because it’s logical to assume that different object keys would, in fact, be different.</p>
        <p class="indent">The conversion to the default string representation makes it difficult to use objects as keys.</p>
        <p class="indent">Maps with a key whose value is falsy present their own particular problem. A falsy value is automatically converted to <span class="literal">false</span> when used in situations in which a Boolean value is required, such as in the condition of an <span class="literal">if</span> statement. This conversion alone isn’t a problem, as long as you’re careful in how you use values. For instance, look at this code:</p>
        <p class="programs">var map = Object.create(null);<br><br>map.count = 1;<br><br>// checking for the existence of "count" or for a nonzero value?<br>if (map.count) {<br>&nbsp;&nbsp;&nbsp;&nbsp;// code to execute<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_122"></span>This example has some ambiguity as to how <span class="literal">map.count</span> should be used. Is the <span class="literal">if</span> statement intended to check for the existence of <span class="literal">map.count</span> or whether the value is nonzero? In this case, the code inside the <span class="literal">if</span> statement will execute because the value 1 is truthy. However, if <span class="literal">map.count</span> is 0 or if <span class="literal">map.count</span> doesn’t exist, the code inside the <span class="literal">if</span> statement would not be executed.</p>
        <p class="indent">These are difficult problems to identify and debug when they occur in large applications, which is a prime reason that ECMAScript 6 adds sets and maps to the language.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>JavaScript has the <span class="literal">in</span> operator that returns <span class="literal">true</span> if a property exists in an object without reading the value of the object. However, the <span class="literal">in</span> operator also searches the prototype of an object, which makes it safe to use only when an object has a <span class="literal">null</span> prototype. Even so, many developers still incorrectly use code like the preceding example rather than using <span class="literal">in</span>.</em></p>
        </div>
        <h3 class="h3" id="ch07lev1sec03"><strong>Sets in ECMAScript 6</strong></h3>
        <p class="noindent">ECMAScript 6 adds a <span class="literal">Set</span> type that is an ordered list of values without duplicates. Sets allow fast access to the data they contain, adding a more efficient manner of tracking discrete values.</p>
        <h4 class="h4" id="ch07lev2sec01"><em><strong>Creating Sets and Adding Items</strong></em></h4>
        <p class="noindent">Sets are created using <span class="literal">new Set()</span>, and items are added to a set by calling the <span class="literal">add()</span> method. You can see how many items are in a set by checking the <span class="literal">size</span> property:</p>
        <p class="programs">let set = new Set();<br>set.add(5);<br>set.add("5");<br><br>console.log(set.size);&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">Sets don’t coerce values to determine whether they’re the same. That means a set can contain the number <span class="literal">5</span> and the string <span class="literal">"5"</span> as two separate items. (Internally, the comparison uses the <span class="literal">Object.is()</span> method discussed in <a href="ch04.xhtml#ch04">Chapter 4</a> to determine if two values are the same.) You can also add multiple objects to the set, and those objects will remain distinct:</p>
        <p class="programs">let set = new Set(),<br>&nbsp;&nbsp;&nbsp;&nbsp;key1 = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;key2 = {};<br><br>set.add(key1);<br>set.add(key2);<br><br>console.log(set.size);&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent"><span epub:type="pagebreak" id="page_123"></span>Because <span class="literal">key1</span> and <span class="literal">key2</span> are not converted to strings, they count as two unique items in the set. If they were converted to strings, they would both be equal to <span class="literal">"[object Object]"</span> instead.</p>
        <p class="indent">If the <span class="literal">add()</span> method is called more than once with the same value, all calls after the first one are effectively ignored:</p>
        <p class="programs">let set = new Set();<br>set.add(5);<br>set.add("5");<br>set.add(5);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// duplicate - this is ignored<br><br>console.log(set.size);&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">When <span class="literal">console.log()</span> outputs the size of <span class="literal">set</span>, it displays <span class="literal">2</span> because the second <span class="literal">5</span> wasn’t added. You can also initialize a set using an array, and the <span class="literal">Set</span> constructor will ensure that only unique values are used. For instance:</p>
        <p class="programs">let set = new Set([1, 2, 3, 4, 5, 5, 5, 5]);<br>console.log(set.size);&nbsp;&nbsp;&nbsp;&nbsp;// 5</p>
        <p class="indent">In this example, an array with duplicate values is used to initialize the set. The number <span class="literal">5</span> only appears once in the set, even though it appears four times in the array. This functionality makes converting existing code or JSON structures to use sets easy.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The <span class="literal">Set</span> constructor actually accepts any iterable object as an argument. Arrays work because they are iterable by default, as are sets and maps. The <span class="literal">Set</span> constructor uses an iterator to extract values from the argument. Iterables and iterators are discussed in detail in <a href="ch08.xhtml#ch08">Chapter 8</a>.</em></p>
        </div>
        <p class="indent">You can test which values are in a set using the <span class="literal">has()</span> method, like this:</p>
        <p class="programs">let set = new Set();<br>set.add(5);<br>set.add("5");<br><br>console.log(set.has(5));&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(set.has(6));&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">Here, <span class="literal">set.has(6)</span> returns <span class="literal">false</span> because the set doesn’t have that value.</p>
        <h4 class="h4" id="ch07lev2sec02"><em><strong>Removing Items</strong></em></h4>
        <p class="noindent">It’s also possible to remove items from a set. You can remove a single item by using the <span class="literal">delete()</span> method, or you can remove all items from the set by calling the <span class="literal">clear()</span> method. This code shows both in action:</p>
        <p class="programs">let set = new Set();<br>set.add(5);<br>set.add("5");<br><br>console.log(set.has(5));&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>set.delete(5);<br><br>console.log(set.has(5));&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(set.size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br><br>set.clear();<br><br>console.log(set.has("5"));&nbsp;&nbsp;// false<br>console.log(set.size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0</p>
        <p class="indent"><span epub:type="pagebreak" id="page_124"></span>After the <span class="literal">delete()</span> call, only <span class="literal">5</span> is gone; after the <span class="literal">clear()</span> method executes, <span class="literal">set</span> is empty.</p>
        <p class="indent">Sets are a very easy mechanism for tracking unique ordered values. However, what if you want to add items to a set and then perform an operation on each item? That’s where the <span class="literal">forEach()</span> method comes in.</p>
        <h4 class="h4" id="ch07lev2sec03"><em><strong>The forEach() Method for Sets</strong></em></h4>
        <p class="noindent">If you’re used to working with arrays, you may already be familiar with the <span class="literal">forEach()</span> method. ECMAScript 5 added <span class="literal">forEach()</span> to arrays to simplify working on each item in an array without setting up a <span class="literal">for</span> loop. The method proved popular among developers, so the same method is available on sets and works the same way.</p>
        <p class="indentb">The <span class="literal">forEach()</span> method is passed a callback function that accepts three arguments:</p>
        <p class="bull">• The value from the next position in the set</p>
        <p class="bull">• The same value as the first argument</p>
        <p class="bull">• The set from which the value is read</p>
        <p class="indentt">The strange difference between the set version of <span class="literal">forEach()</span> and the array version is that the first and second arguments to the callback function are the same value in the set version. Although this might look like a mistake, there’s a good reason for the behavior.</p>
        <p class="indent">The other objects that have <span class="literal">forEach()</span> methods (arrays and maps) pass three arguments to their callback functions. The first two arguments for arrays and maps are the value and the key (the numeric index for arrays).</p>
        <p class="indent">Sets don’t have keys, however. The people behind the ECMAScript 6 standard could have made the callback function in the set version of <span class="literal">forEach()</span> accept two arguments, but that would have made it different from the other two. Instead, they found a way to keep the callback function the same and accept three arguments: each value in a set is considered to be the key and the value. As such, the first and second argument are always the same in <span class="literal">forEach()</span> on sets to keep this functionality consistent with the other <span class="literal">forEach()</span> methods on arrays and maps.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_125"></span>Other than the difference in arguments, using <span class="literal">forEach()</span> is basically the same for a set as it is for an array. The following code shows the method at work:</p>
        <p class="programs">let set = new Set([1, 2]);<br><br>set.forEach(function(value, key, ownerSet) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(key + " " + value);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(ownerSet === set);<br>});</p>
        <p class="indent">This code iterates over each item in the set and outputs the values passed to the <span class="literal">forEach()</span> callback function. Each time the callback function executes, <span class="literal">key</span> and <span class="literal">value</span> are the same, and <span class="literal">ownerSet</span> is always equal to <span class="literal">set</span>. The output is:</p>
        <p class="programs">1 1<br>true<br>2 2<br>true</p>
        <p class="indent">Also the same as arrays, you can pass a <span class="literal">this</span> value as the second argument to <span class="literal">forEach()</span> if you need to use <span class="literal">this</span> in your callback function:</p>
        <p class="programs">let set = new Set([1, 2]);<br><br>let processor = {<br>&nbsp;&nbsp;&nbsp;&nbsp;output(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;process(dataSet) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataSet.forEach(function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.output(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}, this);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>processor.process(set);</p>
        <p class="indent">In this example, the <span class="literal">processor.process()</span> method calls <span class="literal">forEach()</span> on the set and passes <span class="literal">this</span> as the <span class="literal">this</span> value for the callback. That’s necessary so <span class="literal">this.output()</span> will correctly resolve to the <span class="literal">processor.output()</span> method. The <span class="literal">forEach()</span> callback function only uses the first argument, <span class="literal">value</span>, so the others are omitted. You can also use an arrow function to get the same effect without passing the second argument:</p>
        <p class="programs">let set = new Set([1, 2]);<br><br>let processor = {<br>&nbsp;&nbsp;&nbsp;&nbsp;output(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br><span epub:type="pagebreak" id="page_126"></span>&nbsp;&nbsp;&nbsp;&nbsp;process(dataSet) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;dataSet.forEach(value =&gt; this.output(value));<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>processor.process(set);</p>
        <p class="indent">The arrow function in this example reads <span class="literal">this</span> from the containing <span class="literal">process()</span> function, so it will correctly resolve <span class="literal">this.output()</span> to a <span class="literal">processor.output()</span> call.</p>
        <p class="indent">Keep in mind that although sets are great for tracking values and <span class="literal">forEach()</span> lets you work on each item sequentially, you can’t directly access an item by index like you can with an array. If you need to do so, the best option is to convert the set to an array.</p>
        <h4 class="h4" id="ch07lev2sec04"><em><strong>Converting a Set to an Array</strong></em></h4>
        <p class="noindent">Converting an array to a set is easy because you can pass the array to the <span class="literal">Set</span> constructor; converting a set back to an array is also easy if you use the spread operator (<span class="literal">...</span>). <a href="ch03.xhtml#ch03">Chapter 3</a> introduced the spread operator as a way to split items in an array into separate function parameters. The spread operator can convert iterable objects, such as sets, to arrays, too. For example:</p>
        <p class="programs">let set = new Set([1, 2, 3, 3, 3, 4, 5]),<br>&nbsp;&nbsp;&nbsp;&nbsp;array = [...set];<br><br>console.log(array);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [1,2,3,4,5]</p>
        <p class="indent">Here, a set is initially loaded with an array that contains duplicates. The set removes the duplicates, and then the items are placed into a new array using the spread operator. The set still contains the same items (<span class="literal">1</span>, <span class="literal">2</span>, <span class="literal">3</span>, <span class="literal">4</span>, and <span class="literal">5</span>) it received when it was created. They’ve just been copied to a new array.</p>
        <p class="indent">This approach is useful when you already have an array and want to create an array without duplicates, as in this example:</p>
        <p class="programs">function eliminateDuplicates(items) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return [...new Set(items)];<br>}<br><br>let numbers = [1, 2, 3, 3, 3, 4, 5],<br>&nbsp;&nbsp;&nbsp;&nbsp;noDuplicates = eliminateDuplicates(numbers);<br><br>console.log(noDuplicates);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [1,2,3,4,5]</p>
        <p class="indent">In the <span class="literal">eliminateDuplicates()</span> function, the set is just a temporary intermediary used to filter out duplicate values before creating a new array that has no duplicates.</p>
        <h4 class="h4" id="ch07lev2sec05"><span epub:type="pagebreak" id="page_127"></span><em><strong>Weak Sets</strong></em></h4>
        <p class="noindent">The <span class="literal">Set</span> type could be called a <em>strong set</em> because of the way it stores object references. Storing an object in an instance of <span class="literal">Set</span> is effectively the same as storing that object inside a variable. As long as a reference to that <span class="literal">Set</span> instance exists, the object cannot be garbage-collected to free memory. For example:</p>
        <p class="programs">let set = new Set(),<br>&nbsp;&nbsp;&nbsp;&nbsp;key = {};<br><br>set.add(key);<br>console.log(set.size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br><br>// eliminate original reference<br>key = null;<br><br>console.log(set.size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br><br>// get the original reference back<br>key = [...set][0];</p>
        <p class="indent">In this example, setting <span class="literal">key</span> to <span class="literal">null</span> clears one reference of the <span class="literal">key</span> object, but another remains inside <span class="literal">set</span>. You can still retrieve <span class="literal">key</span> by converting the set to an array using the spread operator and accessing the first item. That result works fine for most programs, but sometimes it’s best for references in a set to disappear when all other references disappear. For instance, if your JavaScript code is running in a web page and needs to keep track of DOM elements that might be removed by another script, you don’t want your code holding onto the last reference to a DOM element. (That situation is called a <em>memory leak</em>.)</p>
        <p class="indent">To address such issues, ECMAScript 6 also includes <em>weak sets</em>, which only store weak object references and cannot store primitive values. A <em>weak reference</em> to an object doesn’t prevent garbage collection if it’s the only remaining reference.</p>
        <h5 class="h5" id="ch07lev3sec01"><strong>Creating Weak Sets</strong></h5>
        <p class="noindent">Weak sets are created using the <span class="literal">WeakSet</span> constructor and have an <span class="literal">add()</span> method, a <span class="literal">has()</span> method, and a <span class="literal">delete()</span> method. Here’s an example that uses all three:</p>
        <p class="programs">let set = new WeakSet(),<br>&nbsp;&nbsp;&nbsp;&nbsp;key = {};<br><br>// add the object to the set<br>set.add(key);<br><br>console.log(set.has(key));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>set.delete(key);<br><br>console.log(set.has(key));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent"><span epub:type="pagebreak" id="page_128"></span>Using a weak set is a lot like using a regular set. You can add, remove, and check for references in the weak set. You can also seed a weak set with values by passing an iterable to the constructor:</p>
        <p class="programs">let key1 = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;key2 = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;set = new WeakSet([key1, key2]);<br><br>console.log(set.has(key1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(set.has(key2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">In this example, an array is passed to the <span class="literal">WeakSet</span> constructor. Because this array contains two objects, those objects are added into the weak set. Keep in mind that an error will be thrown if the array contains any nonobject values, because <span class="literal">WeakSet</span> can’t accept primitive values.</p>
        <h5 class="h5" id="ch07lev3sec02"><strong>Key Differences Between Set Types</strong></h5>
        <p class="noindent">The biggest difference between weak sets and regular sets is that the weak reference is held to the object value. Here’s an example that demonstrates this difference:</p>
        <p class="programs">let set = new WeakSet(),<br>&nbsp;&nbsp;&nbsp;&nbsp;key = {};<br><br>// add the object to the set<br>set.add(key);<br><br>console.log(set.has(key));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>// remove the last strong reference to key (also removes from weak set)<br>key = null;</p>
        <p class="indent">After this code executes, the reference to <span class="literal">key</span> in the weak set is no longer accessible. It’s not possible to verify its removal because you would need a reference to that object to pass to the <span class="literal">has()</span> method. This can make testing weak sets a little confusing, but you can trust that the reference has been properly removed by the JavaScript engine.</p>
        <p class="indentb">The preceding examples show that weak sets share some characteristics with regular sets, but there are some key differences:</p>
        <p class="bull">• In a <span class="literal">WeakSet</span> instance, the <span class="literal">add()</span> method, <span class="literal">has()</span> method, and <span class="literal">delete()</span> method all throw an error when passed a nonobject.</p>
        <p class="bull">• Weak sets aren’t iterables and therefore cannot be used in a <span class="literal">for-of</span> loop.</p>
        <p class="bull">• Weak sets don’t expose any iterators (such as the <span class="literal">keys()</span> and <span class="literal">values()</span> methods), so there is no way to programmatically determine the contents of a weak set.</p>
        <p class="bull">• Weak sets don’t have a <span class="literal">forEach()</span> method.</p>
        <p class="bull">• Weak sets don’t have a <span class="literal">size</span> property.</p>
        <p class="indentt"><span epub:type="pagebreak" id="page_129"></span>The seemingly limited functionality of weak sets is necessary to properly handle memory. In general, if you only need to track object references, you should use a weak set instead of a regular set.</p>
        <p class="indent">Sets give you a new way to handle lists of values, but they aren’t useful when you need to associate additional information with those values. That’s why ECMAScript 6 also adds maps.</p>
        <h3 class="h3" id="ch07lev1sec04"><strong>Maps in ECMAScript 6</strong></h3>
        <p class="noindent">The ECMAScript 6 <span class="literal">Map</span> type is an ordered list of key-value pairs, where the key and the value can be any type. Key equivalence is determined by calling the <span class="literal">Object.is()</span> method, so you can have a key of <span class="literal">5</span> and a key of <span class="literal">"5"</span> because they’re different types. This is quite different from using object properties as keys, because object properties always coerce values into strings.</p>
        <p class="indent">You can add items to maps by calling the <span class="literal">set()</span> method and passing it a key and the value to associate with the key. You can later retrieve a value by passing the key to the <span class="literal">get()</span> method. For example:</p>
        <p class="programs">let map = new Map();<br>map.set("title", "Understanding ECMAScript 6");<br>map.set("year", 2016);<br><br>console.log(map.get("title"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Understanding ECMAScript 6"<br>console.log(map.get("year"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2016</p>
        <p class="indent">In this example, two key-value pairs are stored. The <span class="literal">"title"</span> key stores a string, and the <span class="literal">"year"</span> key stores a number. The <span class="literal">get()</span> method is called later to retrieve the values for both keys. If either key didn’t exist in the map, <span class="literal">get()</span> would have returned the special value <span class="literal">undefined</span> instead of a value.</p>
        <p class="indent">You can also use objects as keys, which isn’t possible when you’re using object properties to create a map in the old workaround approach. Here’s an example:</p>
        <p class="programs">let map = new Map(),<br>&nbsp;&nbsp;&nbsp;&nbsp;key1 = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;key2 = {};<br><br>map.set(key1, 5);<br>map.set(key2, 42);<br><br>console.log(map.get(key1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 5<br>console.log(map.get(key2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42</p>
        <p class="indent">This code uses the objects <span class="literal">key1</span> and <span class="literal">key2</span> as keys in the map to store two different values. Because these keys are not coerced into another form, each object is considered unique. This allows you to associate additional data with an object without modifying the object.</p>
        <h4 class="h4" id="ch07lev2sec06"><span epub:type="pagebreak" id="page_130"></span><em><strong>Map Methods</strong></em></h4>
        <p class="noindentb">Maps share several methods with sets, which is intentional and allows you to interact with maps and sets in similar ways. These three methods are available on maps and sets:</p>
        <p class="hang"><span class="literal"><span class="codestrong">has(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">key</span></span></span><span class="literal"><span class="codestrong">)</span></span> Determines if the given key exists in the map</p>
        <p class="hang"><span class="literal"><span class="codestrong">delete(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">key</span></span></span><span class="literal"><span class="codestrong">)</span></span> Removes the key and its associated value from the map</p>
        <p class="hang"><span class="literal"><span class="codestrong">clear()</span></span> Removes all keys and values from the map</p>
        <p class="indentt">Maps also have a <span class="literal">size</span> property that indicates how many key-value pairs it contains. This code uses all three methods and <span class="literal">size</span> in different ways:</p>
        <p class="programs">let map = new Map();<br>map.set("name", "Nicholas");<br>map.set("age", 25);<br><br>console.log(map.size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br><br>console.log(map.has("name"));&nbsp;&nbsp;&nbsp;// true<br>console.log(map.get("name"));&nbsp;&nbsp;&nbsp;// "Nicholas"<br><br>console.log(map.has("age"));&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(map.get("age"));&nbsp;&nbsp;&nbsp;&nbsp;// 25<br><br>map.delete("name");<br>console.log(map.has("name"));&nbsp;&nbsp;&nbsp;// false<br>console.log(map.get("name"));&nbsp;&nbsp;&nbsp;// undefined<br>console.log(map.size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br><br>map.clear();<br>console.log(map.has("name"));&nbsp;&nbsp;&nbsp;// false<br>console.log(map.get("name"));&nbsp;&nbsp;&nbsp;// undefined<br>console.log(map.has("age"));&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(map.get("age"));&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(map.size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0</p>
        <p class="indent">As with sets, the <span class="literal">size</span> property always contains the number of key-value pairs in the map. The <span class="literal">Map</span> instance in this example starts with the <span class="literal">"name"</span> and <span class="literal">"age"</span> keys, so <span class="literal">has()</span> returns <span class="literal">true</span> when passed either key. After the <span class="literal">"name"</span> key is removed by the <span class="literal">delete()</span> method, the <span class="literal">has()</span> method returns <span class="literal">false</span> when passed <span class="literal">"name"</span>, and the <span class="literal">size</span> property indicates one less item. The <span class="literal">clear()</span> method then removes the remaining key, as indicated by <span class="literal">has()</span> returning <span class="literal">false</span> for both keys and <span class="literal">size</span> being 0.</p>
        <p class="indent">The <span class="literal">clear()</span> method is a fast way to remove a lot of data from a map, but there’s also a way to add a lot of data to a map at one time.</p>
        <h4 class="h4" id="ch07lev2sec07"><span epub:type="pagebreak" id="page_131"></span><em><strong>Map Initialization</strong></em></h4>
        <p class="noindent">Also similar to sets, you can initialize a map with data by passing an array to the <span class="literal">Map</span> constructor. Each item in the array must itself be an array where the first item is the key and the second is that key’s corresponding value. Therefore, the entire map is an array of these two-item arrays, for example:</p>
        <p class="programs">let map = new Map([["name", "Nicholas"], ["age", 25]]);<br><br>console.log(map.has("name"));&nbsp;&nbsp;&nbsp;// true<br>console.log(map.get("name"));&nbsp;&nbsp;&nbsp;// "Nicholas"<br>console.log(map.has("age"));&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(map.get("age"));&nbsp;&nbsp;&nbsp;&nbsp;// 25<br>console.log(map.size);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">The keys <span class="literal">"name"</span> and <span class="literal">"age"</span> are added into <span class="literal">map</span> through initialization in the constructor. Although the array of arrays may look a bit strange, it’s necessary to accurately represent keys, because keys can be any data type. Storing the keys in an array is the only way to ensure they aren’t coerced into another data type before being stored in the map.</p>
        <h4 class="h4" id="ch07lev2sec08"><em><strong>The forEach() Method for Maps</strong></em></h4>
        <p class="noindentb">The <span class="literal">forEach()</span> method for maps is similar to <span class="literal">forEach()</span> for sets and arrays in that it accepts a callback function that receives three arguments:</p>
        <p class="bull">• The value from the next position in the map</p>
        <p class="bull">• The key for that value</p>
        <p class="bull">• The map from which the value is read</p>
        <p class="indentt">These callback arguments more closely match the <span class="literal">forEach()</span> behavior in arrays, where the first argument is the value and the second is the key (corresponding to a numeric index in arrays). Here’s an example:</p>
        <p class="programs">let map = new Map([["name", "Nicholas"], ["age", 25]]);<br><br>map.forEach(function(value, key, ownerMap) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(key + " " + value);<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(ownerMap === map);<br>});</p>
        <p class="indent">The <span class="literal">forEach()</span> callback function outputs the information that is passed to it. The <span class="literal">value</span> and <span class="literal">key</span> are output directly, and <span class="literal">ownerMap</span> is compared to <span class="literal">map</span> to show that the values are equivalent. The code outputs the following:</p>
        <p class="programs">name Nicholas<br>true<br>age 25<br>true</p>
        <p class="indent"><span epub:type="pagebreak" id="page_132"></span>The callback passed to <span class="literal">forEach()</span> receives each key-value pair in the order in which the pairs were inserted into the map. This behavior differs slightly from calling <span class="literal">forEach()</span> on arrays, where the callback receives each item in order of numeric index.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>You can also provide a second argument to <span class="literal">forEach()</span> to specify the <span class="literal">this</span> value inside the callback function. A call like that behaves the same as the set version of the <span class="literal">forEach()</span> method.</em></p>
        </div>
        <h4 class="h4" id="ch07lev2sec09"><em><strong>Weak Maps</strong></em></h4>
        <p class="noindent">Weak maps are to maps what weak sets are to sets: they’re a way to store weak object references. In <em>weak maps</em>, every key must be an object (an error is thrown if you try to use a nonobject key), and those object references are held weakly so they don’t interfere with garbage collection. When there are no references to a weak map key outside a weak map, the key-value pair is removed from the weak map. But only weak map keys, not weak map values, are weak references. An object stored as a weak map value will prevent garbage collection, even if all other references are removed.</p>
        <p class="indent">The most useful place to employ weak maps is when you’re creating an object related to a particular DOM element in a web page. For example, some JavaScript libraries for web pages maintain one custom object for every DOM element referenced in the library, and that mapping is stored in a cache of objects internally.</p>
        <p class="indent">The difficult part of this approach is determining when a DOM element no longer exists in the web page so the library can remove its associated object. Otherwise, the library would hold onto the DOM element reference past the reference’s usefulness and cause a memory leak. Tracking the DOM elements with a weak map would still allow the library to associate a custom object with every DOM element, and it could automatically destroy any object in the map when that object’s DOM element no longer exists.</p>
        <h5 class="h5" id="ch07lev3sec03"><strong>Using Weak Maps</strong></h5>
        <p class="noindent">The ECMAScript 6 <span class="literal">WeakMap</span> type is an unordered list of key-value pairs, where a key must be a non-null object and a value can be of any type. The interface for <span class="literal">WeakMap</span> is very similar to that of <span class="literal">Map</span> in that <span class="literal">set()</span> and <span class="literal">get()</span> are used to add and retrieve data, respectively:</p>
        <p class="programs">let map = new WeakMap(),<br>&nbsp;&nbsp;&nbsp;&nbsp;element = document.querySelector(".element");<br><br>map.set(element, "Original");<br><br>let value = map.get(element);<br>console.log(value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Original"<br><br>// remove the element<br>element.parentNode.removeChild(element);<br>element = null;<br><br>// the weak map is empty at this point</p>
        <p class="indent"><span epub:type="pagebreak" id="page_133"></span>In this example, one key-value pair is stored. The <span class="literal">element</span> key is a DOM element used to store a corresponding string value. That value is then retrieved by passing in the DOM element to the <span class="literal">get()</span> method. When the DOM element is later removed from the document and the variable referencing it is set to <span class="literal">null</span>, the data is also removed from the weak map.</p>
        <p class="indent">Similar to weak sets, there is no way to verify that a weak map is empty, because it doesn’t have a <span class="literal">size</span> property. Because there are no remaining references to the key, you can’t retrieve the value by calling the <span class="literal">get()</span> method, either. The weak map has cut off access to the value for that key, and when the garbage collector runs, the memory occupied by the value will be freed.</p>
        <h5 class="h5" id="ch07lev3sec04"><strong>Weak Map Initialization</strong></h5>
        <p class="noindent">To initialize a weak map, pass an array of arrays to the <span class="literal">WeakMap</span> constructor. Just like initializing a regular map, each array inside the containing array should have two items: the first item is the non-null object key, and the second item is the value (any data type). For example:</p>
        <p class="programs">let key1 = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;key2 = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;map = new WeakMap([[key1, "Hello"], [key2, 42]]);<br><br>console.log(map.has(key1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(map.get(key1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello"<br>console.log(map.has(key2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(map.get(key2));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42</p>
        <p class="indent">The objects <span class="literal">key1</span> and <span class="literal">key2</span> are used as keys in the weak map, and the <span class="literal">get()</span> and <span class="literal">has()</span> methods can access them. An error is thrown if the <span class="literal">WeakMap</span> constructor receives a nonobject key in any of the key-value pairs.</p>
        <h5 class="h5" id="ch07lev3sec05"><strong>Weak Map Methods</strong></h5>
        <p class="noindent">Weak maps have only two additional methods available to interact with key-value pairs. A <span class="literal">has()</span> method determines if a given key exists in the map, and a <span class="literal">delete()</span> method removes a specific key-value pair. There is no <span class="literal">clear()</span> method because that would require enumerating keys, and like weak sets, that isn’t possible with weak maps. This example uses the <span class="literal">has()</span> and <span class="literal">delete()</span> methods:</p>
        <p class="programs">let map = new WeakMap(),<br>&nbsp;&nbsp;&nbsp;&nbsp;element = document.querySelector(".element");<br><br>map.set(element, "Original");<br>console.log(map.has(element));&nbsp;&nbsp;// true<br>console.log(map.get(element));&nbsp;&nbsp;// "Original"<br><br>map.delete(element);<br>console.log(map.has(element));&nbsp;&nbsp;// false<br>console.log(map.get(element));&nbsp;&nbsp;// undefined</p>
        <p class="indent"><span epub:type="pagebreak" id="page_134"></span>Here, a DOM element is once again used as the key in a weak map. The <span class="literal">has()</span> method is useful for checking to see if a reference is currently being used as a key in the weak map. Keep in mind that this only works when you have a non-null reference to a key. The key is forcibly removed from the weak map by the <span class="literal">delete()</span> method, at which point <span class="literal">has()</span> returns <span class="literal">false</span> and <span class="literal">get()</span> returns <span class="literal">undefined</span>.</p>
        <h5 class="h5" id="ch07lev3sec06"><strong>Private Object Data</strong></h5>
        <p class="noindent">Although most developers consider the main use case of weak maps to be associating data with DOM elements, there are many other possible uses (and no doubt some that have yet to be discovered). One practical use of weak maps is to store data that is private to object instances. All object properties are public in ECMAScript 6, so you need to use some creativity to make data accessible to objects but not accessible to everything. Consider the following example:</p>
        <p class="programs">function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this._name = name;<br>}<br><br>Person.prototype.getName = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return this._name;<br>};</p>
        <p class="indent">This code uses the common convention of a leading underscore to indicate that a property is considered private and should not be modified outside the object instance. The intent is to use <span class="literal">getName()</span> to read <span class="literal">this._name</span> and not allow the <span class="literal">_name</span> value to change. However, there is nothing standing in the way of someone writing to the <span class="literal">_name</span> property, so it can be overwritten either intentionally or accidentally.</p>
        <p class="indent">In ECMAScript 5, it’s possible to get close to having truly private data by creating an object using a pattern such as this:</p>
        <p class="programs">var Person = (function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;var privateData = {},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;privateId = 0;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Object.defineProperty(this, "_id", { value: privateId++ });<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;privateData[this._id] = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: name<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Person.prototype.getName = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return privateData[this._id].name;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return Person;<br>}());</p>
        <p class="indent"><span epub:type="pagebreak" id="page_135"></span>This example wraps the definition of <span class="literal">Person</span> in an immediately invoked function expression (IIFE) that contains two private variables, <span class="literal">privateData</span> and <span class="literal">privateId</span>. The <span class="literal">privateData</span> object stores private information for each instance, and <span class="literal">privateId</span> generates a unique ID for each instance. When the <span class="literal">Person</span> constructor is called, a nonenumerable, nonconfigurable, and nonwritable <span class="literal">_id</span> property is added.</p>
        <p class="indent">Then, an entry is made into the <span class="literal">privateData</span> object that corresponds to the ID for the object instance; that’s where the <span class="literal">name</span> is stored. Later, in the <span class="literal">getName()</span> function, the name can be retrieved by using <span class="literal">this._id</span> as the key into <span class="literal">privateData</span>. Because <span class="literal">privateData</span> is not accessible outside the IIFE, the actual data is safe, even though <span class="literal">this._id</span> is exposed publicly.</p>
        <p class="indent">The big problem with this approach is that the data in <span class="literal">privateData</span> never disappears because there is no way to know when an object instance is destroyed: the <span class="literal">privateData</span> object will always contain extra data. This problem can be solved by using a weak map instead, as follows:</p>
        <p class="programs">let Person = (function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;let privateData = new WeakMap();<br><br>&nbsp;&nbsp;&nbsp;&nbsp;function Person(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;privateData.set(this, { name: name });<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Person.prototype.getName = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return privateData.get(this).name;<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return Person;<br>}());</p>
        <p class="indent">This version of the <span class="literal">Person</span> example uses a weak map for the private data instead of an object. Because the <span class="literal">Person</span> object instance can be used as a key, there’s no need to keep track of a separate ID. When the <span class="literal">Person</span> constructor is called, a new entry is made into the weak map with a key of <span class="literal">this</span> and a value of an object containing private information. In this case, that value is an object containing only <span class="literal">name</span>. The <span class="literal">getName()</span> function retrieves that private information by passing <span class="literal">this</span> to the <span class="literal">privateData.get()</span> method, which fetches the value object and accesses the <span class="literal">name</span> property. This technique keeps the private information private and destroys that information whenever an object instance associated with it is destroyed.</p>
        <h5 class="h5" id="ch07lev3sec07"><span epub:type="pagebreak" id="page_136"></span><strong>Weak Map Uses and Limitations</strong></h5>
        <p class="noindent">When you’re deciding whether to use a weak map or a regular map, the primary decision to consider is whether you want to use only object keys. Anytime you’ll be using only object keys, a weak map is the best choice. A weak map will allow you to optimize memory usage and avoid memory leaks by ensuring that extra data isn’t retained after it’s no longer accessible.</p>
        <p class="indent">Keep in mind that weak maps give you very little visibility into their contents, so you can’t use the <span class="literal">forEach()</span> method, the <span class="literal">size</span> property, or the <span class="literal">clear()</span> method to manage the items. If you need some inspection capabilities, regular maps are a better choice. Just be sure to keep an eye on memory usage.</p>
        <p class="indent">Of course, if you only want to use nonobject keys, regular maps are your only choice.</p>
        <h3 class="h3" id="ch07lev1sec05"><strong>Summary</strong></h3>
        <p class="noindent">ECMAScript 6 formally introduces sets and maps into JavaScript. Prior to this addition, developers frequently used objects to mimic sets and maps, often running into problems due to the limitations associated with object properties.</p>
        <p class="indent">Sets are unordered lists of unique values. Values are considered unique if they’re not equivalent according to the <span class="literal">Object.is()</span> method. Sets automatically remove duplicate values, so you can use a set to filter an array for duplicates and return the result. Sets aren’t subclasses of arrays, so you cannot randomly access a set’s values. Instead, you can use the <span class="literal">has()</span> method to determine if a value is contained in the set and use the <span class="literal">size</span> property to inspect the number of values in the set. The <span class="literal">Set</span> type also has a <span class="literal">forEach()</span> method to process each set value.</p>
        <p class="indent">Weak sets are special sets that can contain only objects. The objects are stored with weak references, meaning that an item in a weak set will not block garbage collection if that item is the only remaining reference to an object. Weak set contents can’t be inspected due to the complexities of memory management, so it’s best to use weak sets only for tracking objects that need to be grouped together.</p>
        <p class="indent">Maps are unordered key-value pairs where the key can be any data type. Similar to sets, duplicate keys are determined by a call to the <span class="literal">Object.is()</span> method, which means you can have a numeric key <span class="literal">5</span> and a string <span class="literal">"5"</span> as two separate keys. A value of any data type can be associated with a key using the <span class="literal">set()</span> method, and that value can later be retrieved by using the <span class="literal">get()</span> method. Maps also have a <span class="literal">size</span> property and a <span class="literal">forEach()</span> method to allow for easier item access.</p>
        <p class="indent">Weak maps are a special type of map that can only have object keys. As with weak sets, an object key reference is weak and doesn’t prevent garbage collection when it’s the only remaining reference to an object. When a key is garbage-collected, the value associated with the key is also removed from the weak map. This memory management aspect makes weak maps uniquely suited for correlating additional information with objects whose life cycles are managed outside the code accessing them.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com