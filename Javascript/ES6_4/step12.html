<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch12"><span epub:type="pagebreak" id="page_243"></span><strong><span class="big">12</span><br>PROXIES AND THE REFLECTION API</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">ECMAScript 5 and ECMAScript 6 were both developed with demystifying JavaScript functionality in mind. For example, JavaScript environments contained nonenumerable and nonwritable object properties prior to ECMAScript 5, but developers couldn’t define their own nonenumerable or nonwritable properties. ECMAScript 5 included the <span class="literal">Object.defineProperty()</span> method, which allowed developers to do what JavaScript engines could do already.</p>
        <p class="indent">ECMAScript 6 gives developers further access to JavaScript engine capabilities by adding built-in objects. To allow developers to create built-in objects, the language exposes the inner workings of objects through <em>proxies</em>, which are wrappers that can intercept and alter low-level JavaScript engine operations. This chapter starts by describing the problem that proxies are meant to address in detail, and then discusses how you can create and use proxies effectively.</p>
        <h3 class="h3" id="ch12lev1sec01"><span epub:type="pagebreak" id="page_244"></span><strong>The Array Problem</strong></h3>
        <p class="noindent">The JavaScript array object behaves in ways that developers couldn’t mimic in their own objects prior to ECMAScript 6. An array’s <span class="literal">length</span> property is affected when you assign values to specific array items, and you can modify array items by modifying the <span class="literal">length</span> property. For example:</p>
        <p class="programs">let colors = ["red", "green", "blue"];<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br><br>colors[3] = "black";<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4<br>console.log(colors[3]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "black"<br><br>colors.length = 2;<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(colors[3]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(colors[2]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(colors[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "green"</p>
        <p class="indent">The <span class="literal">colors</span> array starts with three items. Assigning <span class="literal">"black"</span> to <span class="literal">colors[3]</span> automatically increments the <span class="literal">length</span> property to 4. Setting the <span class="literal">length</span> property to 2 removes the last two items in the array, leaving only the first two items. Nothing in ECMAScript 5 allows developers to achieve this behavior, but proxies change that.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>This nonstandard behavior of numeric properties and the <span class="literal">length</span> property is why arrays are considered exotic objects in ECMAScript 6.</em></p>
        </div>
        <h3 class="h3" id="ch12lev1sec02"><strong>Introducing Proxies and Reflection</strong></h3>
        <p class="noindent">Calling <span class="literal">new Proxy()</span> creates a proxy to use in place of another object (called the <em>target</em>). The proxy <em>virtualizes</em> the target so the proxy and the target appear to be functionally the same.</p>
        <p class="indent">Proxies allow you to intercept low-level object operations on the target that are otherwise internal to the JavaScript engine. These low-level operations are intercepted using a <em>trap</em>, which is a function that responds to a specific operation.</p>
        <p class="indent">The reflection API, represented by the <span class="literal">Reflect</span> object, is a collection of methods that provide the default behavior for the same low-level operations that proxies can override. There is a <span class="literal">Reflect</span> method for every proxy trap. Those methods have the same name and are passed the same arguments as their respective proxy traps. <a href="ch12.xhtml#ch12tab1">Table 12-1</a> summarizes the proxy trap behavior.</p>
        <p class="tabcap"><span epub:type="pagebreak" id="page_245"></span><a id="ch12tab1"></a><strong>Table 12-1:</strong> Proxy Traps in JavaScript</p>
        <table class="topbot">
        <thead>
        <tr>
        <td style="vertical-align: top;" class="table_th"><p class="table"><strong>Proxy trap</strong></p></td>
        <td style="vertical-align: top;" class="table_th"><p class="table"><strong>Overrides the behavior of</strong></p></td>
        <td style="vertical-align: top;" class="table_th"><p class="table"><strong>Default behavior</strong></p></td>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">get</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">Reading a property value</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Reflect.get()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">set</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table">Writing to a property</p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Reflect.set()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">has</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">The <span class="literal">in</span> operator</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Reflect.has()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">deleteProperty</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table">The <span class="literal">delete</span> operator</p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Reflect.deleteProperty()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">getPrototypeOf</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Object.getPrototypeOf()</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Reflect.getPrototypeOf()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">setPrototypeOf</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Object.setPrototypeOf()</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Reflect.setPrototypeOf()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">isExtensible</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Object.isExtensible()</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Reflect.isExtensible()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">preventExtensions</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Object.preventExtensions()</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Reflect.preventExtensions()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">getOwnPropertyDescriptor</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Object.getOwnPropertyDescriptor()</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Reflect.getOwnPropertyDescriptor()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">defineProperty</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Object.defineProperty()</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Reflect.defineProperty</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">ownKeys</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Object.keys(), Object.getOwnPropertyNames(),</span> and <span class="literal">Object.getOwnPropertySymbols()</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Reflect.ownKeys()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">apply</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table">Calling a function</p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Reflect.apply()</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">construct</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">Calling a function with <span class="literal">new</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Reflect.construct()</span></p></td>
        </tr>
        </tbody>
        </table>
        <p class="indent">Each trap overrides some built-in behavior of JavaScript objects, allowing you to intercept and modify the behavior. If you still need to use the built-in behavior, you can use the corresponding reflection API method. The relationship between proxies and the reflection API becomes clear when you start creating proxies, so it’s best to dive in and look at some examples.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The original ECMAScript 6 specification had an additional trap called <span class="literal">enumerate</span> that was designed to alter how <span class="literal">for-in</span> and <span class="literal">Object.keys()</span> enumerated properties on an object. However, the <span class="literal">enumerate</span> trap was removed in ECMAScript 7 (also called ECMAScript 2016) because difficulties were discovered during implementation. The <span class="literal">enumerate</span> trap no longer exists in any JavaScript environment and is therefore not covered in this chapter.</em></p>
        </div>
        <h3 class="h3" id="ch12lev1sec03"><strong>Creating a Simple Proxy</strong></h3>
        <p class="noindent">When you use the <span class="literal">Proxy</span> constructor to make a proxy, you’ll pass it two arguments: the target and a handler. A <em>handler</em> is an object that defines one or more traps. The proxy uses the default behavior for all operations except when traps are defined for that operation. To create a simple forwarding proxy, you can use a handler with no traps, like this:</p>
        <p class="programs">let target = {};<br><br>let proxy = new Proxy(target, {});<br><br>proxy.name = "proxy";<br><span epub:type="pagebreak" id="page_246"></span><br>console.log(proxy.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br>console.log(target.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br><br>target.name = "target";<br>console.log(proxy.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "target"<br>console.log(target.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "target"</p>
        <p class="indent">In this example, <span class="literal">proxy</span> forwards all operations directly to <span class="literal">target</span>. When <span class="literal">"proxy"</span> is assigned to the <span class="literal">proxy.name</span> property, <span class="literal">name</span> is created on <span class="literal">target</span>. The proxy is not storing this property; it’s simply forwarding the operation to <span class="literal">target</span>. Similarly, the values of <span class="literal">proxy.name</span> and <span class="literal">target.name</span> are the same because they are both references to <span class="literal">target.name</span>. That also means setting <span class="literal">target.name</span> to a new value causes <span class="literal">proxy.name</span> to reflect the same change. Of course, proxies without traps aren’t very interesting, so what happens when you define a trap?</p>
        <h3 class="h3" id="ch12lev1sec04"><strong>Validating Properties Using the set Trap</strong></h3>
        <p class="noindentb">Suppose you want to create an object whose property values must be numbers. That means every new property added to the object must be validated, and an error must be thrown if the value isn’t a number. To accomplish this task, you could define a <span class="literal">set</span> trap that overrides the default behavior of setting a value. The <span class="literal">set</span> trap receives four arguments:</p>
        <p class="hang"><span class="literal"><span class="codestrong">trapTarget</span></span> The object that will receive the property (the proxy’s target)</p>
        <p class="hang"><span class="literal"><span class="codestrong">key</span></span> The property key (string or symbol) to write to</p>
        <p class="hang"><span class="literal"><span class="codestrong">value</span></span> The value being written to the property</p>
        <p class="hang"><span class="literal"><span class="codestrong">receiver</span></span> The object on which the operation took place (usually the proxy)</p>
        <p class="indentt"><span class="literal">Reflect.set()</span> is the <span class="literal">set</span> trap’s corresponding reflection method, and it’s the default behavior for this operation. The <span class="literal">Reflect.set()</span> method accepts the same four arguments as the <span class="literal">set</span> proxy trap, making the method easy to use inside the trap. The trap should return <span class="literal">true</span> if the property was set or <span class="literal">false</span> if not. (The <span class="literal">Reflect.set()</span> method returns the correct value based on whether the operation succeeded.)</p>
        <p class="indent">To validate the values of properties, you would use the <span class="literal">set</span> trap and inspect the <span class="literal">value</span> that is passed in. Here’s an example:</p>
        <p class="programs">let target = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "target"<br>};<br><br>let proxy = new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;set(trapTarget, key, value, receiver) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// ignore existing properties so as not to affect them<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!trapTarget.hasOwnProperty(key)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isNaN(value)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("Property must be a number.");<br><span epub:type="pagebreak" id="page_247"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// add the property<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.set(trapTarget, key, value, receiver);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>// adding a new property<br>proxy.count = 1;<br>console.log(proxy.count);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(target.count);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br><br>// you can assign to name because it exists on target already<br>proxy.name = "proxy";<br>console.log(proxy.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br>console.log(target.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br><br>// throws an error<br>proxy.anotherName = "proxy";</p>
        <p class="indent">This code defines a proxy trap that validates the value of any new property added to <span class="literal">target</span>. When <span class="literal">proxy.count = 1</span> is executed, the <span class="literal">set</span> trap is called. The <span class="literal">trapTarget</span> value is equal to <span class="literal">target</span>, <span class="literal">key</span> is <span class="literal">"count"</span>, <span class="literal">value</span> is 1, and <span class="literal">receiver</span> (not used in this example) is <span class="literal">proxy</span>. There is no existing property named <span class="literal">count</span> in <span class="literal">target</span>, so the proxy validates <span class="literal">value</span> by passing it to <span class="literal">isNaN()</span>. If the result is <span class="literal">NaN</span>, the property value is not numeric and an error is thrown. Because this code sets <span class="literal">count</span> to 1, the proxy calls <span class="literal">Reflect.set()</span> with the same four arguments that were passed to the trap to add the new property.</p>
        <p class="indent">When <span class="literal">proxy.name</span> is assigned a string, the operation completes successfully. Because <span class="literal">target</span> already has a <span class="literal">name</span> property, that property is omitted from the validation check by calling the <span class="literal">trapTarget.hasOwnProperty()</span> method. This ensures that previously existing nonnumeric property values are still supported.</p>
        <p class="indent">However, when <span class="literal">proxy.anotherName</span> is assigned a string, an error is thrown. The <span class="literal">anotherName</span> property doesn’t exist on the target, so its value needs to be validated. During validation, the error is thrown because <span class="literal">"proxy"</span> isn’t a numeric value.</p>
        <p class="indent">The <span class="literal">set</span> proxy trap lets you intercept when properties are being written to, and the <span class="literal">get</span> proxy trap lets you intercept when properties are being read.</p>
        <h3 class="h3" id="ch12lev1sec05"><strong>Object Shape Validation Using the get Trap</strong></h3>
        <p class="noindent">One of the peculiar, and sometimes confusing, aspects of JavaScript is that reading nonexistent properties doesn’t throw an error. Instead, the value <span class="literal">undefined</span> is used for the property value, as in this example:</p>
        <p class="programs">let target = {};<br><br>console.log(target.name);&nbsp;&nbsp;&nbsp;&nbsp;// undefined</p>
        <p class="indent"><span epub:type="pagebreak" id="page_248"></span>In most other languages, attempting to read <span class="literal">target.name</span> throws an error because the property doesn’t exist. But JavaScript just uses <span class="literal">undefined</span> for the value of the <span class="literal">target.name</span> property. If you’ve ever worked on a large code base, you’ve probably seen how this behavior can cause significant problems, especially when there’s a typo in the property name. Proxies help you avoid this problem by having object shape validation.</p>
        <p class="indent">An <em>object shape</em> is the collection of properties and methods available on the object. JavaScript engines use object shapes to optimize code, often creating classes to represent the objects. If you can safely assume an object will always have the same properties and methods it began with (a behavior you can enforce with the <span class="literal">Object.preventExtensions()</span> method, the <span class="literal">Object.seal()</span> method, or the <span class="literal">Object.freeze()</span> method), then throwing an error on attempts to access nonexistent properties can be helpful. Proxies make object shape validation easy.</p>
        <p class="indentb">Because property validation only has to happen when a property is read, you would use the <span class="literal">get</span> trap. The <span class="literal">get</span> trap is called when a property is read, even if that property doesn’t exist on the object, and it takes three arguments:</p>
        <p class="hang"><span class="literal"><span class="codestrong">trapTarget</span></span> The object from which the property is read (the proxy’s target)</p>
        <p class="hang"><span class="literal"><span class="codestrong">key</span></span> The property key (a string or symbol) to read</p>
        <p class="hang"><span class="literal"><span class="codestrong">receiver</span></span> The object on which the operation took place (usually the proxy)</p>
        <p class="indentt">These arguments mirror the <span class="literal">set</span> trap’s arguments but with one noticeable difference. There’s no <span class="literal">value</span> argument because <span class="literal">get</span> traps don’t write values. The <span class="literal">Reflect.get()</span> method accepts the same three arguments as the <span class="literal">get</span> trap and returns the property’s default value.</p>
        <p class="indent">You can use the <span class="literal">get</span> trap and <span class="literal">Reflect.get()</span> to throw an error when a property doesn’t exist on the target, as follows:</p>
        <p class="programs">let proxy = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;get(trapTarget, key, receiver) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!(key in receiver)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("Property " + key + " doesn't exist.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.get(trapTarget, key, receiver);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>// adding a property still works<br>proxy.name = "proxy";<br>console.log(proxy.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br><br>// nonexistent properties throw an error<br>console.log(proxy.nme);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// throws an error</p>
        <p class="indent"><span epub:type="pagebreak" id="page_249"></span>In this example, the <span class="literal">get</span> trap intercepts property read operations. The <span class="literal">in</span> operator determines whether the property already exists on the <span class="literal">receiver</span>. The <span class="literal">receiver</span> is used with <span class="literal">in</span> instead of <span class="literal">trapTarget</span> in case <span class="literal">receiver</span> is a proxy with a <span class="literal">has</span> trap, a type I’ll cover in the next section. Using <span class="literal">trapTarget</span> in this case would sidestep the <span class="literal">has</span> trap and potentially give you the wrong result. An error is thrown if the property doesn’t exist; otherwise, the default behavior is used.</p>
        <p class="indent">This code allows new properties like <span class="literal">proxy.name</span> to be added, written to, and read from without problems. The last line contains a typo: <span class="literal">proxy.nme</span> should probably be <span class="literal">proxy.name</span>. This throws an error because <span class="literal">nme</span> doesn’t exist as a property.</p>
        <h3 class="h3" id="ch12lev1sec06"><strong>Hiding Property Existence Using the has Trap</strong></h3>
        <p class="noindent">The <span class="literal">in</span> operator determines whether a property exists on a given object and returns <span class="literal">true</span> if an own property or a prototype property matches the name or symbol. For example:</p>
        <p class="programs">let target = {<br>&nbsp;&nbsp;&nbsp;&nbsp;value: 42;<br>}<br><br>console.log("value" in target);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log("toString" in target);&nbsp;&nbsp;// true</p>
        <p class="indent">Both <span class="literal">value</span> and <span class="literal">toString</span> exist on <span class="literal">object</span>, so in both cases the <span class="literal">in</span> operator returns <span class="literal">true</span>. The <span class="literal">value</span> property is an own property, whereas <span class="literal">toString</span> is a prototype property (inherited from <span class="literal">Object</span>). Proxies allow you to intercept this operation and return a different value for <span class="literal">in</span> with the <span class="literal">has</span> trap.</p>
        <p class="indentb">The <span class="literal">has</span> trap is called whenever the <span class="literal">in</span> operator is used. When called, two arguments are passed to the <span class="literal">has</span> trap:</p>
        <p class="hang"><span class="literal"><span class="codestrong">trapTarget</span></span> The object the property is read from (the proxy’s target)</p>
        <p class="hang"><span class="literal"><span class="codestrong">key</span></span> The property key (string or symbol) to check</p>
        <p class="indentt">The <span class="literal">Reflect.has()</span> method accepts these same arguments and returns the default response for the <span class="literal">in</span> operator. Using the <span class="literal">has</span> trap and <span class="literal">Reflect.has()</span> allows you to alter the behavior of <span class="literal">in</span> for some properties while reverting to the default behavior for others. For instance, you could hide the <span class="literal">value</span> property from the previous example like this:</p>
        <p class="programs">let target = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "target",<br>&nbsp;&nbsp;&nbsp;&nbsp;value: 42<br>};<br><span epub:type="pagebreak" id="page_250"></span><br>let proxy = new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;has(trapTarget, key) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (key === "value") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.has(trapTarget, key);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>console.log("value" in proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log("name" in proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log("toString" in proxy);&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">The <span class="literal">has</span> trap for <span class="literal">proxy</span> checks whether <span class="literal">key</span> is <span class="literal">"value"</span> and returns <span class="literal">false</span> if so. Otherwise, the default behavior is used via a call to the <span class="literal">Reflect.has()</span> method. As a result, the <span class="literal">in</span> operator returns <span class="literal">false</span> for the <span class="literal">value</span> property, even though <span class="literal">value</span> actually exists on the target. The other properties, <span class="literal">name</span> and <span class="literal">toString</span>, correctly return <span class="literal">true</span> when used with the <span class="literal">in</span> operator.</p>
        <h3 class="h3" id="ch12lev1sec07"><strong>Preventing Property Deletion with the deleteProperty Trap</strong></h3>
        <p class="noindent">The <span class="literal">delete</span> operator removes a property from an object and returns <span class="literal">true</span> when it’s successful and <span class="literal">false</span> when it’s unsuccessful. In strict mode, <span class="literal">delete</span> throws an error when you attempt to delete a nonconfigurable property; in non-strict mode, <span class="literal">delete</span> simply returns <span class="literal">false</span>. Here’s an example:</p>
        <p class="programs">let target = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "target",<br>&nbsp;&nbsp;&nbsp;&nbsp;value: 42<br>};<br><br>Object.defineProperty(target, "name", { configurable: false });<br><br>console.log("value" in target);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>let result1 = delete target.value;<br>console.log(result1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>console.log("value" in target);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>// note: the following line throws an error in strict mode<br>let result2 = delete target.name;<br>console.log(result2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>console.log("name" in target);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">The <span class="literal">value</span> property is deleted using the <span class="literal">delete</span> operator and, as a result, the <span class="literal">in</span> operator returns <span class="literal">false</span> in the third <span class="literal">console.log()</span> call. The nonconfigurable <span class="literal">name</span> property can’t be deleted, so the <span class="literal">delete</span> operator <span epub:type="pagebreak" id="page_251"></span>simply returns <span class="literal">false</span> (if you run this code in strict mode, an error is thrown instead). You can alter this behavior by using the <span class="literal">deleteProperty</span> trap in a proxy.</p>
        <p class="indentb">The <span class="literal">deleteProperty</span> trap is called whenever the <span class="literal">delete</span> operator is used on an object property. The trap is passed two arguments:</p>
        <p class="hang"><span class="literal"><span class="codestrong">trapTarget</span></span> The object from which the property should be deleted (the proxy’s target)</p>
        <p class="hang"><span class="literal"><span class="codestrong">key</span></span> The property key (string or symbol) to delete</p>
        <p class="indentt">The <span class="literal">Reflect.deleteProperty()</span> method provides the default implementation of the <span class="literal">deleteProperty</span> trap and accepts the same two arguments. You can combine <span class="literal">Reflect.deleteProperty()</span> and the <span class="literal">deleteProperty</span> trap to change how the <span class="literal">delete</span> operator behaves. For instance, you could ensure that the <span class="literal">value</span> property can’t be deleted, like so:</p>
        <p class="programs">let target = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "target",<br>&nbsp;&nbsp;&nbsp;&nbsp;value: 42<br>};<br><br>let proxy = new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;deleteProperty(trapTarget, key) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (key === "value") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.deleteProperty(trapTarget, key);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>// attempt to delete proxy.value<br><br>console.log("value" in proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>let result1 = delete proxy.value;<br>console.log(result1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>console.log("value" in proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>// attempt to delete proxy.name<br><br>console.log("name" in proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>let result2 = delete proxy.name;<br>console.log(result2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>console.log("name" in proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">This code is very similar to the <span class="literal">has</span> trap example in that the <span class="literal">deleteProperty</span> trap checks whether the <span class="literal">key</span> is <span class="literal">"value"</span> and returns <span class="literal">false</span> if so. Otherwise, the default behavior is used by calling the <span class="literal">Reflect.deleteProperty()</span> method. <span epub:type="pagebreak" id="page_252"></span>The <span class="literal">value</span> property can’t be deleted through <span class="literal">proxy</span> because the operation is trapped, but the <span class="literal">name</span> property is deleted as expected. This approach is especially useful when you want to protect properties from deletion without throwing an error in strict mode.</p>
        <h3 class="h3" id="ch12lev1sec08"><strong>Prototype Proxy Traps</strong></h3>
        <p class="noindent"><a href="ch04.xhtml#ch04">Chapter 4</a> introduced the <span class="literal">Object.setPrototypeOf()</span> method that ECMAScript 6 added to complement the ECMAScript 5 <span class="literal">Object.getPrototypeOf()</span> method. Proxies allow you to intercept the execution of both methods through the <span class="literal">setPrototypeOf</span> and <span class="literal">getPrototypeOf</span> traps. In both cases, the method on <span class="literal">Object</span> calls the trap of the corresponding name on the proxy, allowing you to alter the methods’ behavior.</p>
        <p class="indentb">Because two traps are associated with prototype proxies, a set of methods is associated with each type of trap. The <span class="literal">setPrototypeOf</span> trap receives these arguments:</p>
        <p class="hang"><span class="literal"><span class="codestrong">trapTarget</span></span> The object for which the prototype should be set (the proxy’s target)</p>
        <p class="hang"><span class="literal"><span class="codestrong">proto</span></span> The object to use as the prototype</p>
        <p class="indentt">These are the same arguments passed to the <span class="literal">Object.setPrototypeOf()</span> and <span class="literal">Reflect.setPrototypeOf()</span> methods. The <span class="literal">getPrototypeOf</span> trap, on the other hand, only receives the <span class="literal">trapTarget</span> argument, which is the argument passed to the <span class="literal">Object.getPrototypeOf()</span> and <span class="literal">Reflect.getPrototypeOf()</span> methods.</p>
        <h4 class="h4" id="ch12lev2sec01"><em><strong>How Prototype Proxy Traps Work</strong></em></h4>
        <p class="noindent">Prototype proxy traps have some restrictions. First, the <span class="literal">getPrototypeOf</span> trap must return an object or <span class="literal">null</span>, and any other return value results in a runtime error. The return value check ensures that <span class="literal">Object.getPrototypeOf()</span> will always return an expected value. Second, the return value of the <span class="literal">setPrototypeOf</span> trap must be <span class="literal">false</span> if the operation doesn’t succeed. When <span class="literal">setPrototypeOf</span> returns <span class="literal">false</span>, <span class="literal">Object.setPrototypeOf()</span> throws an error. If <span class="literal">setPrototypeOf</span> returns any value other than <span class="literal">false</span>, <span class="literal">Object.setPrototypeOf()</span> assumes the operation succeeded.</p>
        <p class="indent">The following example hides the prototype of the proxy by always returning <span class="literal">null</span> and also doesn’t allow the prototype to be changed:</p>
        <p class="programs">let target = {};<br>let proxy = new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;getPrototypeOf(trapTarget) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;setPrototypeOf(trapTarget, proto) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><span epub:type="pagebreak" id="page_253"></span><br>let targetProto = Object.getPrototypeOf(target);<br>let proxyProto = Object.getPrototypeOf(proxy);<br><br>console.log(targetProto === Object.prototype);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(proxyProto === Object.prototype);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(proxyProto);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// null<br><br>// succeeds<br>Object.setPrototypeOf(target, {});<br><br>// throws an error<br>Object.setPrototypeOf(proxy, {});</p>
        <p class="indent">This code emphasizes the difference between the behavior of <span class="literal">target</span> and <span class="literal">proxy</span>. Although <span class="literal">Object.getPrototypeOf()</span> returns a value for <span class="literal">target</span>, it returns <span class="literal">null</span> for <span class="literal">proxy</span> because the <span class="literal">getPrototypeOf</span> trap is called. Similarly, <span class="literal">Object.setPrototypeOf()</span> succeeds when it’s used on <span class="literal">target</span> but throws an error when it’s used on <span class="literal">proxy</span> due to the <span class="literal">setPrototypeOf</span> trap.</p>
        <p class="indent">If you want to use the default behavior for these two traps, you can use the corresponding methods on <span class="literal">Reflect</span>. For instance, the following code implements the default behavior for the <span class="literal">getPrototypeOf</span> and <span class="literal">setPrototypeOf</span> traps:</p>
        <p class="programs">let target = {};<br>let proxy = new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;getPrototypeOf(trapTarget) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.getPrototypeOf(trapTarget);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;setPrototypeOf(trapTarget, proto) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.setPrototypeOf(trapTarget, proto);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>let targetProto = Object.getPrototypeOf(target);<br>let proxyProto = Object.getPrototypeOf(proxy);<br><br>console.log(targetProto === Object.prototype);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(proxyProto === Object.prototype);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>// succeeds<br>Object.setPrototypeOf(target, {});<br><br>// also succeeds<br>Object.setPrototypeOf(proxy, {});</p>
        <p class="indent">In this example, you can use <span class="literal">target</span> and <span class="literal">proxy</span> interchangeably and get the same results, because the <span class="literal">getPrototypeOf</span> and <span class="literal">setPrototypeOf</span> traps are just passing through to use the default implementation. It’s important that this example use the <span class="literal">Reflect.getPrototypeOf()</span> and <span class="literal">Reflect.setPrototypeOf()</span> methods rather than the methods of the same name on <span class="literal">Object</span> due to some important differences.</p>
        <h4 class="h4" id="ch12lev2sec02"><span epub:type="pagebreak" id="page_254"></span><em><strong>Why Two Sets of Methods?</strong></em></h4>
        <p class="noindent">The confusing aspect of <span class="literal">Reflect.getPrototypeOf()</span> and <span class="literal">Reflect.setPrototypeOf()</span> is that they look suspiciously similar to the <span class="literal">Object.getPrototypeOf()</span> and <span class="literal">Object.setPrototypeOf()</span> methods. Although both sets of methods perform similar operations, there are some distinct differences between the two.</p>
        <p class="indent"><span class="literal">Object.getPrototypeOf()</span> and <span class="literal">Object.setPrototypeOf()</span> are higher-level operations that were created for developer use from the start. The <span class="literal">Reflect.getPrototypeOf()</span> and <span class="literal">Reflect.setPrototypeOf()</span> methods are lower-level operations that give developers access to the previously internal-only <span class="literal">[[GetPrototypeOf]]</span> and <span class="literal">[[SetPrototypeOf]]</span> operations. The <span class="literal">Reflect.getPrototypeOf()</span> method is the wrapper for the internal <span class="literal">[[GetPrototypeOf]]</span> operation (with some input validation). The <span class="literal">Reflect.setPrototypeOf()</span> method and <span class="literal">[[SetPrototypeOf]]</span> have the same relationship. The corresponding methods on <span class="literal">Object</span> also call <span class="literal">[[GetPrototypeOf]]</span> and <span class="literal">[[SetPrototypeOf]]</span> but perform a few steps before the call and inspect the return value to determine how to behave.</p>
        <p class="indent">The <span class="literal">Reflect.getPrototypeOf()</span> method throws an error if its argument is not an object, whereas <span class="literal">Object.getPrototypeOf()</span> first coerces the value into an object before performing the operation. If you passed a number into each method, you’d get a different result:</p>
        <p class="programs">let result1 = Object.getPrototypeOf(1);<br>console.log(result1 === Number.prototype);&nbsp;&nbsp;// true<br><br>// throws an error<br>Reflect.getPrototypeOf(1);</p>
        <p class="indent">The <span class="literal">Object.getPrototypeOf()</span> method allows you retrieve a prototype for the number <span class="literal">1</span> because it first coerces the value into a <span class="literal">Number</span> object and then returns <span class="literal">Number.prototype</span>. The <span class="literal">Reflect.getPrototypeOf()</span> method doesn’t coerce the value, and because <span class="literal">1</span> isn’t an object, it throws an error.</p>
        <p class="indent">The <span class="literal">Reflect.setPrototypeOf()</span> method is also different from the <span class="literal">Object.setPrototypeOf()</span> method. Specifically, <span class="literal">Reflect.setPrototypeOf()</span> returns a Boolean value indicating whether the operation was successful. A <span class="literal">true</span> value is returned for success, and <span class="literal">false</span> is returned for failure. If <span class="literal">Object.setPrototypeOf()</span> fails, it throws an error.</p>
        <p class="indent">As the first example in “<a href="ch12.xhtml#ch12lev2sec01">How Prototype Proxy Traps Work</a>” on <a href="ch12.xhtml#page_252">page 252</a> showed, when the <span class="literal">setPrototypeOf</span> proxy trap returns <span class="literal">false</span>, it causes <span class="literal">Object.setPrototypeOf()</span> to throw an error. The <span class="literal">Object.setPrototypeOf()</span> method returns the first argument as its value and therefore isn’t suitable for implementing the default behavior of the <span class="literal">setPrototypeOf</span> proxy trap. The following code demonstrates these differences:</p>
        <p class="programs">let target1 = {};<br>let result1 = Object.setPrototypeOf(target1, {});<br>console.log(result1 === target1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>let target2 = {};<br>let result2 = Reflect.setPrototypeOf(target2, {});<br><span epub:type="pagebreak" id="page_255"></span><br>console.log(result2 === target2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(result2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">In this example, <span class="literal">Object.setPrototypeOf()</span> returns <span class="literal">target1</span> as its value, but <span class="literal">Reflect.setPrototypeOf()</span> returns <span class="literal">true</span>. This subtle difference is very important. You’ll see more seemingly duplicate methods on <span class="literal">Object</span> and <span class="literal">Reflect</span>, but always be sure to use the method on <span class="literal">Reflect</span> inside any proxy traps.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><span class="literal"><span class="codeitalic">Reflect.getPrototypeOf()</span></span><em>/</em><span class="literal"><span class="codeitalic">Object.getPrototypeOf()</span></span> <em>and</em> <span class="literal"><span class="codeitalic">Reflect.setPrototypeOf()</span></span><em>/</em> <span class="literal"><span class="codeitalic">Object.setPrototypeOf()</span></span> <em>will call the</em> <span class="literal"><span class="codeitalic">getPrototypeOf</span></span> <em>and</em> <span class="literal"><span class="codeitalic">setPrototypeOf</span></span> <em>proxy traps, respectively, when they’re used on a proxy.</em></p>
        </div>
        <h3 class="h3" id="ch12lev1sec09"><strong>Object Extensibility Traps</strong></h3>
        <p class="noindent">ECMAScript 5 added object extensibility modification through the <span class="literal">Object.preventExtensions()</span> and <span class="literal">Object.isExtensible()</span> methods, and ECMAScript 6 allows proxies to intercept those method calls to the underlying objects through the <span class="literal">preventExtensions</span> and <span class="literal">isExtensible</span> traps. Both traps receive a single argument called <span class="literal">trapTarget</span> that is the object on which the method was called. The <span class="literal">isExtensible</span> trap must return a Boolean value indicating whether the object is extensible, and the <span class="literal">preventExtensions</span> trap must return a Boolean value indicating whether the operation succeeded.</p>
        <p class="indent">The <span class="literal">Reflect.preventExtensions()</span> and <span class="literal">Reflect.isExtensible()</span> methods implement the default behavior. Both return Boolean values, so you can use them directly in their corresponding traps.</p>
        <h4 class="h4" id="ch12lev2sec03"><em><strong>Two Basic Examples</strong></em></h4>
        <p class="noindent">To see object extensibility traps in action, consider the following code, which implements the default behavior for the <span class="literal">isExtensible</span> and <span class="literal">preventExtensions</span> traps:</p>
        <p class="programs">let target = {};<br>let proxy = new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;isExtensible(trapTarget) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.isExtensible(trapTarget);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;preventExtensions(trapTarget) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.preventExtensions(trapTarget);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br><br>console.log(Object.isExtensible(target));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(Object.isExtensible(proxy));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>Object.preventExtensions(proxy);<br><br>console.log(Object.isExtensible(target));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(Object.isExtensible(proxy));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent"><span epub:type="pagebreak" id="page_256"></span>This example shows that the methods <span class="literal">Object.preventExtensions()</span> and <span class="literal">Object.isExtensible()</span> correctly pass through from <span class="literal">proxy</span> to <span class="literal">target</span>. You can, of course, change the behavior. For example, if you don’t want to allow <span class="literal">Object.preventExtensions()</span> to succeed on your proxy, you could return <span class="literal">false</span> from the <span class="literal">preventExtensions</span> trap:</p>
        <p class="programs">let target = {};<br>let proxy = new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;isExtensible(trapTarget) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.isExtensible(trapTarget);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;preventExtensions(trapTarget) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br><br>console.log(Object.isExtensible(target));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(Object.isExtensible(proxy));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>Object.preventExtensions(proxy);<br><br>console.log(Object.isExtensible(target));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(Object.isExtensible(proxy));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">Here, the call to <span class="literal">Object.preventExtensions(proxy)</span> is effectively ignored because the <span class="literal">preventExtensions</span> trap returns <span class="literal">false</span>. The operation isn’t forwarded to the underlying <span class="literal">target</span>, so <span class="literal">Object.isExtensible()</span> returns <span class="literal">true</span>.</p>
        <h4 class="h4" id="ch12lev2sec04"><em><strong>Duplicate Extensibility Methods</strong></em></h4>
        <p class="noindent">You may have noticed that, once again, there are seemingly duplicate methods on <span class="literal">Object</span> and <span class="literal">Reflect</span>. In this case, they’re more similar than not. The methods <span class="literal">Object.isExtensible()</span> and <span class="literal">Reflect.isExtensible()</span> are similar except when passed a nonobject value. In that case, <span class="literal">Object.isExtensible()</span> always returns <span class="literal">false</span> and <span class="literal">Reflect.isExtensible()</span> throws an error. Here’s an example of that behavior:</p>
        <p class="programs">let result1 = Object.isExtensible(2);<br>console.log(result1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>// throws an error<br>let result2 = Reflect.isExtensible(2);</p>
        <p class="indent">This restriction is similar to the difference between the methods <span class="literal">Object.getPrototypeOf()</span> and <span class="literal">Reflect.getPrototypeOf()</span>, because the method with lower-level functionality has stricter error checks than its higher-level counterpart.</p>
        <p class="indent">The <span class="literal">Object.preventExtensions()</span> and <span class="literal">Reflect.preventExtensions()</span> methods are also very similar. The <span class="literal">Object.preventExtensions()</span> method always returns the value that was passed to it as an argument, even if the value isn’t an <span epub:type="pagebreak" id="page_257"></span>object. The <span class="literal">Reflect.preventExtensions()</span> method, on the other hand, throws an error if the argument isn’t an object; if the argument is an object, <span class="literal">Reflect.preventExtensions()</span> returns <span class="literal">true</span> when the operation succeeds or <span class="literal">false</span> if not. For example:</p>
        <p class="programs">let result1 = Object.preventExtensions(2);<br>console.log(result1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br><br>let target = {};<br>let result2 = Reflect.preventExtensions(target);<br>console.log(result2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>// throws an error<br>let result3 = Reflect.preventExtensions(2);</p>
        <p class="indent">Here, <span class="literal">Object.preventExtensions()</span> passes through the value 2 as its return value, even though 2 isn’t an object. The <span class="literal">Reflect.preventExtensions()</span> method returns <span class="literal">true</span> when an object is passed to it and throws an error when 2 is passed to it.</p>
        <h3 class="h3" id="ch12lev1sec10"><strong>Property Descriptor Traps</strong></h3>
        <p class="noindent">One of the most important features of ECMAScript 5 was the ability to define property attributes using the <span class="literal">Object.defineProperty()</span> method. In earlier versions of JavaScript, there was no way to define an accessor property, make a property read-only, or make a property nonenumerable. All of these are possible with the <span class="literal">Object.defineProperty()</span> method, and you can retrieve those attributes with the <span class="literal">Object.getOwnPropertyDescriptor()</span> method.</p>
        <p class="indentb">Proxies let you intercept calls to the <span class="literal">Object.defineProperty()</span> method and the <span class="literal">Object.getOwnPropertyDescriptor()</span> method using the <span class="literal">defineProperty</span> and <span class="literal">getOwnPropertyDescriptor</span> traps, respectively. The <span class="literal">defineProperty</span> trap receives the following arguments:</p>
        <p class="hang"><span class="literal"><span class="codestrong">trapTarget</span></span> The object on which the property should be defined (the proxy’s target)</p>
        <p class="hang"><span class="literal"><span class="codestrong">key</span></span> The string or symbol for the property</p>
        <p class="hang"><span class="literal"><span class="codestrong">descriptor</span></span> The descriptor object for the property</p>
        <p class="indentt">The <span class="literal">defineProperty</span> trap requires you to return <span class="literal">true</span> if the operation is successful and <span class="literal">false</span> if not. The <span class="literal">getOwnPropertyDescriptor</span> trap receives only <span class="literal">trapTarget</span> and <span class="literal">key</span>, and you are expected to return the descriptor. The corresponding <span class="literal">Reflect.defineProperty()</span> and <span class="literal">Reflect.getOwnPropertyDescriptor()</span> methods accept the same arguments as their proxy trap counterparts. Here’s an example that implements the default behavior for each trap:</p>
        <p class="programs">let proxy = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;defineProperty(trapTarget, key, descriptor) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.defineProperty(trapTarget, key, descriptor);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br><span epub:type="pagebreak" id="page_258"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;getOwnPropertyDescriptor(trapTarget, key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.getOwnPropertyDescriptor(trapTarget, key);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br><br>Object.defineProperty(proxy, "name", {<br>&nbsp;&nbsp;&nbsp;&nbsp;value: "proxy"<br>});<br><br>console.log(proxy.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br><br>let descriptor = Object.getOwnPropertyDescriptor(proxy, "name");<br><br>console.log(descriptor.value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"</p>
        <p class="indent">This code defines a property called <span class="literal">"name"</span> on the proxy using the <span class="literal">Object.defineProperty()</span> method. The property descriptor for that property is then retrieved by the <span class="literal">Object.getOwnPropertyDescriptor()</span> method.</p>
        <h4 class="h4" id="ch12lev2sec05"><em><strong>Blocking Object.defineProperty()</strong></em></h4>
        <p class="noindent">The <span class="literal">defineProperty</span> trap requires you to return a Boolean value to indicate whether the operation was successful. When <span class="literal">true</span> is returned, the <span class="literal">Object.defineProperty()</span> method succeeds as usual; when <span class="literal">false</span> is returned, the <span class="literal">Object.defineProperty()</span> method throws an error. You can use this functionality to restrict the kinds of properties that the <span class="literal">Object.defineProperty()</span> method can define. For instance, if you want to prevent symbol properties from being defined, you could check that the key is a string and return <span class="literal">false</span> if not, like this:</p>
        <p class="programs">let proxy = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;defineProperty(trapTarget, key, descriptor) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof key === "symbol") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.defineProperty(trapTarget, key, descriptor);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br><br>Object.defineProperty(proxy, "name", {<br>&nbsp;&nbsp;&nbsp;&nbsp;value: "proxy"<br>});<br><br>console.log(proxy.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br><br>let nameSymbol = Symbol("name");<br><span epub:type="pagebreak" id="page_259"></span><br>// throws an error<br>Object.defineProperty(proxy, nameSymbol, {<br>&nbsp;&nbsp;&nbsp;&nbsp;value: "proxy"<br>});</p>
        <p class="indent">The <span class="literal">defineProperty</span> proxy trap returns <span class="literal">false</span> when <span class="literal">key</span> is a symbol and otherwise proceeds with the default behavior. When <span class="literal">Object.defineProperty()</span> is called with <span class="literal">"name"</span> as the key, the method succeeds because the key is a string. When <span class="literal">Object.defineProperty()</span> is called with <span class="literal">nameSymbol</span>, it throws an error because the <span class="literal">defineProperty</span> trap returns <span class="literal">false</span>.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>You can also have <span class="literal">Object.defineProperty()</span> silently fail by returning <span class="literal">true</span> and not calling the <span class="literal">Reflect.defineProperty()</span> method. That will suppress the error while not actually defining the property.</em></p>
        </div>
        <h4 class="h4" id="ch12lev2sec06"><em><strong>Descriptor Object Restrictions</strong></em></h4>
        <p class="noindent">To ensure consistent behavior when you’re using the <span class="literal">Object.defineProperty()</span> and <span class="literal">Object.getOwnPropertyDescriptor()</span> methods, descriptor objects passed to the <span class="literal">defineProperty</span> trap are normalized. Objects returned from the <span class="literal">getOwnPropertyDescriptor</span> trap are always validated for the same reason.</p>
        <p class="indent">No matter what object is passed as the third argument to the method <span class="literal">Object.defineProperty()</span>, only the properties <span class="literal">enumerable</span>, <span class="literal">configurable</span>, <span class="literal">value</span>, <span class="literal">writable</span>, <span class="literal">get</span>, and <span class="literal">set</span> will be on the descriptor object passed to the <span class="literal">defineProperty</span> trap. For example:</p>
        <p class="programs">let proxy = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;defineProperty(trapTarget, key, descriptor) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(descriptor.value);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(descriptor.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.defineProperty(trapTarget, key, descriptor);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br><br>Object.defineProperty(proxy, "name", {<br>&nbsp;&nbsp;&nbsp;&nbsp;value: "proxy",<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "custom"<br>});</p>
        <p class="indent">Here, <span class="literal">Object.defineProperty()</span> is called with a nonstandard <span class="literal">name</span> property on the third argument. When the <span class="literal">defineProperty</span> trap is called, the <span class="literal">descriptor</span> object doesn’t have a <span class="literal">name</span> property but does have a <span class="literal">value</span> property. The reason is that <span class="literal">descriptor</span> isn’t a reference to the actual third argument passed to the <span class="literal">Object.defineProperty()</span> method, but rather a new object that contains only the allowable properties. The <span class="literal">Reflect.defineProperty()</span> method also ignores any nonstandard properties on the descriptor.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_260"></span>The <span class="literal">getOwnPropertyDescriptor</span> trap has a slightly different restriction that requires the return value to be <span class="literal">null</span>, <span class="literal">undefined</span>, or an object. If an object is returned, only <span class="literal">enumerable</span>, <span class="literal">configurable</span>, <span class="literal">value</span>, <span class="literal">writable</span>, <span class="literal">get</span>, and <span class="literal">set</span> are allowed as own properties of the object. An error is thrown if you return an object with an own property that isn’t allowed, as this code shows:</p>
        <p class="programs">let proxy = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;getOwnPropertyDescriptor(trapTarget, key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;name: "proxy";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;};<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>// throws an error<br>let descriptor = Object.getOwnPropertyDescriptor(proxy, "name");</p>
        <p class="indent">The property <span class="literal">name</span> isn’t allowable on property descriptors, so when <span class="literal">Object.getOwnPropertyDescriptor()</span> is called, the <span class="literal">getOwnPropertyDescriptor</span> return value triggers an error. This restriction ensures that the value returned by <span class="literal">Object.getOwnPropertyDescriptor()</span> always has a reliable structure regardless of the method’s use on proxies.</p>
        <h4 class="h4" id="ch12lev2sec07"><em><strong>Duplicate Descriptor Methods</strong></em></h4>
        <p class="noindent">Once again, ECMAScript 6 has some confusingly similar methods: the <span class="literal">Object.defineProperty()</span> and <span class="literal">Object.getOwnPropertyDescriptor()</span> methods appear to do the same thing as the <span class="literal">Reflect.defineProperty()</span> and <span class="literal">Reflect.getOwnPropertyDescriptor()</span> methods, respectively. Like other method pairs discussed earlier in this chapter, these four methods have some subtle but important differences.</p>
        <h5 class="h5" id="ch12lev3sec01"><strong>defineProperty() Methods</strong></h5>
        <p class="noindent">The <span class="literal">Object.defineProperty()</span> and <span class="literal">Reflect.defineProperty()</span> methods are the same except for their return values. The <span class="literal">Object.defineProperty()</span> method returns the first argument, whereas <span class="literal">Reflect.defineProperty()</span> returns <span class="literal">true</span> if the operation succeeded and <span class="literal">false</span> if not. For example:</p>
        <p class="programs">let target = {};<br><br>let result1 = Object.defineProperty(target, "name", { value: "target "});<br><br>console.log(target === result1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>let result2 = Reflect.defineProperty(target, "name", { value: "reflect" });<br><br>console.log(result2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent"><span epub:type="pagebreak" id="page_261"></span>When <span class="literal">Object.defineProperty()</span> is called on <span class="literal">target</span>, the return value is <span class="literal">target</span>. When <span class="literal">Reflect.defineProperty()</span> is called on <span class="literal">target</span>, the return value is <span class="literal">true</span>, indicating that the operation succeeded. Because the <span class="literal">defineProperty</span> proxy trap requires a Boolean value to be returned, it’s best to use <span class="literal">Reflect.defineProperty()</span> to implement the default behavior when necessary.</p>
        <h5 class="h5" id="ch12lev3sec02"><strong>getOwnPropertyDescriptor() Methods</strong></h5>
        <p class="noindent">The <span class="literal">Object.getOwnPropertyDescriptor()</span> method coerces its first argument into an object when a primitive value is passed and then continues the operation. On the other hand, the <span class="literal">Reflect.getOwnPropertyDescriptor()</span> method throws an error if the first argument is a primitive value. Here’s an example that shows both:</p>
        <p class="programs">let descriptor1 = Object.getOwnPropertyDescriptor(2, "name");<br>console.log(descriptor1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br><br>// throws an error<br>let descriptor2 = Reflect.getOwnPropertyDescriptor(2, "name");</p>
        <p class="indent">The <span class="literal">Object.getOwnPropertyDescriptor()</span> method returns <span class="literal">undefined</span> because it coerces 2 into an object, and that object has no <span class="literal">name</span> property. This is the method’s standard behavior when a property with the given name isn’t found on an object. However, when <span class="literal">Reflect.getOwnPropertyDescriptor()</span> is called, an error is thrown immediately because that method doesn’t accept primitive values for the first argument.</p>
        <h3 class="h3" id="ch12lev1sec11"><strong>The ownKeys Trap</strong></h3>
        <p class="noindent">The <span class="literal">ownKeys</span> proxy trap intercepts the internal method <span class="literal">[[OwnPropertyKeys]]</span> and allows you to override that behavior by returning an array of values. This array is used in four methods: the <span class="literal">Object.keys()</span> method, the <span class="literal">Object.getOwnPropertyNames()</span> method, the <span class="literal">Object.getOwnPropertySymbols()</span> method, and the <span class="literal">Object.assign()</span> method. (The <span class="literal">Object.assign()</span> method uses the array to determine which properties to copy.)</p>
        <p class="indent">The default behavior for the <span class="literal">ownKeys</span> trap is implemented by the <span class="literal">Reflect.ownKeys()</span> method and returns an array of all own property keys, including strings and symbols. The <span class="literal">Object.getOwnPropertyNames()</span> method and the <span class="literal">Object.keys()</span> method filter symbols out of the array and return the result, whereas <span class="literal">Object.getOwnPropertySymbols()</span> filters the strings out of the array and returns the result. The <span class="literal">Object.assign()</span> method uses the array with both strings and symbols.</p>
        <p class="indent">The <span class="literal">ownKeys</span> trap receives a single argument, the target, and must always return an array or array-like object; otherwise, an error is thrown. You can use the <span class="literal">ownKeys</span> trap to, for example, filter out certain property keys that you don’t want used when the <span class="literal">Object.keys()</span> method, the <span class="literal">Object.getOwnPropertyNames()</span> method, the <span class="literal">Object.getOwnPropertySymbols()</span> <span epub:type="pagebreak" id="page_262"></span>method, or the <span class="literal">Object.assign()</span> method is used. Suppose you don’t want to include any property names that begin with an underscore character—a common notation in JavaScript indicating that a field is private. You can use the <span class="literal">ownKeys</span> trap to filter out those keys as follows:</p>
        <p class="programs">let proxy = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;ownKeys(trapTarget) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.ownKeys(trapTarget).filter(key =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return typeof key !== "string" || key[0] !== "_";<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>let nameSymbol = Symbol("name");<br><br>proxy.name = "proxy";<br>proxy._name = "private";<br>proxy[nameSymbol] = "symbol";<br><br>let names = Object.getOwnPropertyNames(proxy),<br>&nbsp;&nbsp;&nbsp;&nbsp;keys = Object.keys(proxy),<br>&nbsp;&nbsp;&nbsp;&nbsp;symbols = Object.getOwnPropertySymbols(proxy);<br><br>console.log(names.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(names[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br><br>console.log(keys.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(keys[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "proxy"<br><br>console.log(symbols.length);&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(symbols[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Symbol(name)"</p>
        <p class="indent">This example uses an <span class="literal">ownKeys</span> trap that first calls <span class="literal">Reflect.ownKeys()</span> to get the default list of keys for the target. Next, the <span class="literal">filter()</span> method is used to filter out keys that are strings and begin with an underscore character. Then, three properties are added to the <span class="literal">proxy</span> object: <span class="literal">name</span>, <span class="literal">_name</span>, and <span class="literal">nameSymbol</span>. When <span class="literal">Object.getOwnPropertyNames()</span> and <span class="literal">Object.keys()</span> are called on <span class="literal">proxy</span>, only the <span class="literal">name</span> property is returned. Similarly, only <span class="literal">nameSymbol</span> is returned when <span class="literal">Object.getOwnPropertySymbols()</span> is called on <span class="literal">proxy</span>. The <span class="literal">_name</span> property doesn’t appear in either result because it is filtered out.</p>
        <p class="indent">Although the <span class="literal">ownKeys</span> proxy trap allows you to alter the keys returned from a small set of operations, it doesn’t affect more commonly used operations, such as the <span class="literal">for-of</span> loop and the <span class="literal">Object.keys()</span> method. Those can’t be altered using proxies. The <span class="literal">ownKeys</span> trap also affects the <span class="literal">for-in</span> loop, which calls the trap to determine which keys to use inside of the loop.</p>
        <h3 class="h3" id="ch12lev1sec12"><strong>Function Proxies with the apply and construct Traps</strong></h3>
        <p class="noindentb">Of all the proxy traps, only <span class="literal">apply</span> and <span class="literal">construct</span> require the proxy target to be a function. Recall from <a href="ch03.xhtml#ch03">Chapter 3</a> that functions have two internal methods called <span class="literal">[[Call]]</span> and <span class="literal">[[Construct]]</span> that are executed when a function is called <span epub:type="pagebreak" id="page_263"></span>without and with the <span class="literal">new</span> operator, respectively. The <span class="literal">apply</span> and <span class="literal">construct</span> traps correspond to and let you override those internal methods. When a function is called without <span class="literal">new</span>, the <span class="literal">apply</span> trap receives, and <span class="literal">Reflect.apply()</span> expects, the following arguments:</p>
        <p class="hang"><span class="literal"><span class="codestrong">trapTarget</span></span> The function being executed (the proxy’s target)</p>
        <p class="hang"><span class="literal"><span class="codestrong">thisArg</span></span> The value of <span class="literal">this</span> inside the function during the call</p>
        <p class="hang"><span class="literal"><span class="codestrong">argumentsList</span></span> An array of arguments passed to the function</p>
        <p class="indenttb">The <span class="literal">construct</span> trap, which is called when the function is executed using <span class="literal">new</span>, receives the following arguments:</p>
        <p class="hang"><span class="literal"><span class="codestrong">trapTarget</span></span> The function being executed (the proxy’s target)</p>
        <p class="hang"><span class="literal"><span class="codestrong">argumentsList</span></span> An array of arguments passed to the function</p>
        <p class="indentt">The <span class="literal">Reflect.construct()</span> method also accepts these two arguments and has an optional third argument called <span class="literal">newTarget</span>. When given, the <span class="literal">newTarget</span> argument specifies the value of <span class="literal">new.target</span> inside the function.</p>
        <p class="indent">Together, the <span class="literal">apply</span> and <span class="literal">construct</span> traps completely control the behavior of any proxy target function. To mimic the default behavior of a function, you can do this:</p>
        <p class="programs">let target = function() { return 42 },<br>&nbsp;&nbsp;&nbsp;&nbsp;proxy = new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;apply: function(trapTarget, thisArg, argumentList) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.apply(trapTarget, thisArg, argumentList);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;construct: function(trapTarget, argumentList) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.construct(trapTarget, argumentList);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>// a proxy with a function as its target looks like a function<br>console.log(typeof proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "function"<br><br>console.log(proxy());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 42<br><br>var instance = new proxy();<br>console.log(instance instanceof proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(instance instanceof target);&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">Here, you have a function that returns the number 42. The proxy for that function uses the <span class="literal">apply</span> and <span class="literal">construct</span> traps to delegate those behaviors to the <span class="literal">Reflect.apply()</span> and <span class="literal">Reflect.construct()</span> methods, respectively. The end result is that the proxy function works exactly like the target function, including identifying itself as a function when <span class="literal">typeof</span> is used. The proxy is called without <span class="literal">new</span> to return 42 and then is called with <span class="literal">new</span> to create an object called <span class="literal">instance</span>. The <span class="literal">instance</span> object is considered an instance of both <span class="literal">proxy</span> and <span class="literal">target</span> because <span class="literal">instanceof</span> uses the prototype chain to determine this information. Prototype chain lookup is not affected by this proxy, which is why <span class="literal">proxy</span> and <span class="literal">target</span> appear to have the same prototype.</p>
        <h4 class="h4" id="ch12lev2sec08"><span epub:type="pagebreak" id="page_264"></span><em><strong>Validating Function Parameters</strong></em></h4>
        <p class="noindent">The <span class="literal">apply</span> and <span class="literal">construct</span> traps open several possibilities for altering the way a function is executed. For instance, suppose you want to validate that all arguments are of a specific type. You can check the arguments in the <span class="literal">apply</span> trap:</p>
        <p class="programs">// adds together all arguments<br>function sum(...values) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return values.reduce((previous, current) =&gt; previous + current, 0);<br>}<br><br>let sumProxy = new Proxy(sum, {<br>&nbsp;&nbsp;&nbsp;&nbsp;apply: function(trapTarget, thisArg, argumentList) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argumentList.forEach((arg) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof arg !== "number") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("All arguments must be numbers.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.apply(trapTarget, thisArg, argumentList);<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;construct: function(trapTarget, argumentList) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("This function can't be called with new.");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>console.log(sumProxy(1, 2, 3, 4));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 10<br><br>// throws an error<br>console.log(sumProxy(1, "2", 3, 4));<br><br>// also throws an error<br>let result = new sumProxy();</p>
        <p class="indent">This example uses the <span class="literal">apply</span> trap to ensure that all arguments are numbers. The <span class="literal">sum()</span> function adds all the arguments that are passed. If a nonnumber value is passed, the function will still attempt the operation, which can cause unexpected results. By wrapping <span class="literal">sum()</span> inside the <span class="literal">sumProxy()</span> proxy, this code intercepts function calls and ensures that each argument is a number before allowing the call to proceed. To be safe, the code also uses the <span class="literal">construct</span> trap to ensure that the function can’t be called with <span class="literal">new</span>.</p>
        <p class="indent">You can also do the opposite, ensuring that a function must be called with <span class="literal">new</span> and validating its arguments as numbers:</p>
        <p class="programs">function Numbers(...values) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.values = values;<br>}<br><span epub:type="pagebreak" id="page_265"></span><br>let NumbersProxy = new Proxy(Numbers, {<br>&nbsp;&nbsp;&nbsp;&nbsp;apply: function(trapTarget, thisArg, argumentList) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("This function must be called with new.");<br>&nbsp;&nbsp;&nbsp;&nbsp;},<br><br>&nbsp;&nbsp;&nbsp;&nbsp;construct: function(trapTarget, argumentList) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;argumentList.forEach((arg) =&gt; {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof arg !== "number") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("All arguments must be numbers.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.construct(trapTarget, argumentList);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>let instance = new NumbersProxy(1, 2, 3, 4);<br>console.log(instance.values);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [1,2,3,4]<br><br>// throws an error<br>NumbersProxy(1, 2, 3, 4);</p>
        <p class="indent">Here, the <span class="literal">apply</span> trap throws an error, and the <span class="literal">construct</span> trap uses the <span class="literal">Reflect.construct()</span> method to validate input and return a new instance. Of course, you can accomplish the same thing without proxies using <span class="literal">new.target</span> instead.</p>
        <h4 class="h4" id="ch12lev2sec09"><em><strong>Calling Constructors Without new</strong></em></h4>
        <p class="noindent"><a href="ch03.xhtml#ch03">Chapter 3</a> introduced the <span class="literal">new.target</span> metaproperty. To review, <span class="literal">new.target</span> is a reference to the function on which <span class="literal">new</span> is called, meaning that you can determine whether a function was called using <span class="literal">new</span> or not by checking the value of <span class="literal">new.target</span>, like this:</p>
        <p class="programs">function Numbers(...values) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof new.target === "undefined") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("This function must be called with new.");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;this.values = values;<br>}<br><br>let instance = new Numbers(1, 2, 3, 4);<br>console.log(instance.values);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [1,2,3,4]<br><br>// throws an error<br>Numbers(1, 2, 3, 4);</p>
        <p class="indent">This code throws an error when <span class="literal">Numbers()</span> is called without using <span class="literal">new</span>, which is similar to the second example in “<a href="ch12.xhtml#ch12lev2sec08">Validating Function Parameters</a>” on <a href="ch12.xhtml#page_264">page 264</a> but doesn’t use a proxy. Writing code like this is much simpler than using a proxy and is preferable if your only goal is to prevent calling <span epub:type="pagebreak" id="page_266"></span>the function without <span class="literal">new</span>. But sometimes you’re not in control of the function whose behavior needs to be modified. In that case, using a proxy makes sense.</p>
        <p class="indent">Suppose the <span class="literal">Numbers()</span> function is defined in code you can’t modify. You know that the code relies on <span class="literal">new.target</span> and want to avoid that check while still calling the function. The behavior when using <span class="literal">new</span> is already set, so you can just use the <span class="literal">apply</span> trap:</p>
        <p class="programs">function Numbers(...values) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (typeof new.target === "undefined") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("This function must be called with new.");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;this.values = values;<br>}<br><br><br>let NumbersProxy = new Proxy(Numbers, {<br>&nbsp;&nbsp;&nbsp;&nbsp;apply: function(trapTarget, thisArg, argumentsList) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.construct(trapTarget, argumentsList);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br><br>let instance = NumbersProxy(1, 2, 3, 4);<br>console.log(instance.values);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [1,2,3,4]</p>
        <p class="indent">The <span class="literal">NumbersProxy()</span> function allows you to call <span class="literal">Numbers()</span> without using <span class="literal">new</span> and have it behave as if <span class="literal">new</span> were used. To do so, the <span class="literal">apply</span> trap calls <span class="literal">Reflect.construct()</span> with the arguments passed into <span class="literal">apply</span>. The <span class="literal">new.target</span> inside <span class="literal">Numbers()</span> is equal to <span class="literal">Numbers()</span>, so no error is thrown. Although this is a simple example of modifying <span class="literal">new.target</span>, you can also do so more directly.</p>
        <h4 class="h4" id="ch12lev2sec10"><em><strong>Overriding Abstract Base Class Constructors</strong></em></h4>
        <p class="noindent">You can go one step further to modify <span class="literal">new.target</span> by specifying the third argument to <span class="literal">Reflect.construct()</span> as the specific value to assign to <span class="literal">new.target</span>. This technique is useful when a function is checking <span class="literal">new.target</span> against a known value, such as when you’re creating an abstract base class constructor (discussed in <a href="ch09.xhtml#ch09">Chapter 9</a>). In an abstract base class constructor, <span class="literal">new.target</span> is expected to be something other than the class constructor, as in this example:</p>
        <p class="programs">class AbstractNumbers {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(...values) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new.target === AbstractNumbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("This function must be inherited from.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.values = values;<br><span epub:type="pagebreak" id="page_267"></span>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>class Numbers extends AbstractNumbers {}<br><br>let instance = new Numbers(1, 2, 3, 4);<br>console.log(instance.values);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [1,2,3,4]<br><br>// throws an error<br>new AbstractNumbers(1, 2, 3, 4);</p>
        <p class="indent">When <span class="literal">new AbstractNumbers()</span> is called, <span class="literal">new.target</span> is equal to <span class="literal">AbstractNumbers</span> and an error is thrown. Calling <span class="literal">new Numbers()</span> still works because <span class="literal">new.target</span> is equal to <span class="literal">Numbers</span>. You can bypass the constructor restriction by manually assigning <span class="literal">new.target</span> with a proxy:</p>
        <p class="programs">class AbstractNumbers {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(...values) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new.target === AbstractNumbers) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new TypeError("This function must be inherited from.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.values = values;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let AbstractNumbersProxy = new Proxy(AbstractNumbers, {<br>&nbsp;&nbsp;&nbsp;&nbsp;construct: function(trapTarget, argumentList) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.construct(trapTarget, argumentList, function() {});<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br><br>let instance = new AbstractNumbersProxy(1, 2, 3, 4);<br>console.log(instance.values);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// [1,2,3,4]</p>
        <p class="indent">The <span class="literal">AbstractNumbersProxy</span> uses the <span class="literal">construct</span> trap to intercept the call to the <span class="literal">new AbstractNumbersProxy()</span> method. Then, the <span class="literal">Reflect.construct()</span> method is called with arguments from the trap and adds an empty function as the third argument. That empty function is used as the value of <span class="literal">new.target</span> inside the constructor. Because <span class="literal">new.target</span> is not equal to <span class="literal">AbstractNumbers</span>, no error is thrown and the constructor executes completely.</p>
        <h4 class="h4" id="ch12lev2sec11"><em><strong>Callable Class Constructors</strong></em></h4>
        <p class="noindent"><a href="ch09.xhtml#ch09">Chapter 9</a> explained that class constructors must always be called with <span class="literal">new</span> because the internal <span class="literal">[[Call]]</span> method for class constructors is specified to throw an error. But proxies can intercept calls to the <span class="literal">[[Call]]</span> method, meaning you can effectively create callable class constructors by using a <span epub:type="pagebreak" id="page_268"></span>proxy. For instance, if you want a class constructor to work without using <span class="literal">new</span>, you can use the <span class="literal">apply</span> trap to create a new instance. Here’s some sample code to demonstrate:</p>
        <p class="programs">class Person {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let PersonProxy = new Proxy(Person, {<br>&nbsp;&nbsp;&nbsp;&nbsp;apply: function(trapTarget, thisArg, argumentList) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new trapTarget(...argumentList);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br><br>let me = PersonProxy("Nicholas");<br>console.log(me.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"<br>console.log(me instanceof Person);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(me instanceof PersonProxy); // true</p>
        <p class="indent">The <span class="literal">PersonProxy</span> object is a proxy of the <span class="literal">Person</span> class constructor. Class constructors are just functions, so they behave like functions when they’re used in proxies. The <span class="literal">apply</span> trap overrides the default behavior and instead returns a new instance of <span class="literal">trapTarget</span> that’s equal to <span class="literal">Person</span>. (I used <span class="literal">trapTarget</span> in this example to show that you don’t need to manually specify the class.) The <span class="literal">argumentList</span> is passed to <span class="literal">trapTarget</span> using the spread operator to pass each argument separately. Calling <span class="literal">PersonProxy()</span> without using <span class="literal">new</span> returns an instance of <span class="literal">Person</span>; if you attempt to call <span class="literal">Person()</span> without <span class="literal">new</span>, the constructor will still throw an error. Creating callable class constructors is only possible using proxies.</p>
        <h3 class="h3" id="ch12lev1sec13"><strong>Revocable Proxies</strong></h3>
        <p class="noindent">Normally, a proxy can’t be unbound from its target once the proxy has been created. All of the examples to this point in this chapter have used nonrevocable proxies. But there may be situations in which you want to revoke a proxy so it can no longer be used. You’ll find it most helpful to revoke proxies when you want to provide an object through an API for security purposes and maintain the ability to cut off access to some functionality at any point in time.</p>
        <p class="indentb">You can create revocable proxies using the <span class="literal">Proxy.revocable()</span> method, which takes the same arguments as the <span class="literal">Proxy</span> constructor—a target object and the proxy handler. The return value is an object with the following properties:</p>
        <p class="hang"><span class="literal"><span class="codestrong">proxy</span></span> The proxy object that can be revoked</p>
        <p class="hang"><span class="literal"><span class="codestrong">revoke</span></span> The function to call to revoke the proxy</p>
        <p class="indentt"><span epub:type="pagebreak" id="page_269"></span>When the <span class="literal">revoke()</span> function is called, no further operations can be performed through the <span class="literal">proxy</span>. Any attempt to interact with the proxy object in a way that would trigger a proxy trap throws an error. For example:</p>
        <p class="programs">let target = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "target"<br>};<br><br>let { proxy, revoke } = Proxy.revocable(target, {});<br><br>console.log(proxy.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "target"<br><br>revoke();<br><br>// throws an error<br>console.log(proxy.name);</p>
        <p class="indent">This example creates a revocable proxy. It uses destructuring to assign the <span class="literal">proxy</span> and <span class="literal">revoke</span> variables to the properties of the same name on the object returned by the <span class="literal">Proxy.revocable()</span> method. After that, the <span class="literal">proxy</span> object can be used just like a nonrevocable proxy object, so <span class="literal">proxy.name</span> returns <span class="literal">"target"</span> because it passes through to <span class="literal">target.name</span>. However, once the <span class="literal">revoke()</span> function is called, <span class="literal">proxy</span> no longer functions. Attempting to access <span class="literal">proxy.name</span> throws an error, as will any other operation that would trigger a trap on <span class="literal">proxy</span>.</p>
        <h3 class="h3" id="ch12lev1sec14"><strong>Solving the Array Problem</strong></h3>
        <p class="noindent">At the beginning of this chapter, I explained how developers couldn’t mimic the behavior of an array accurately in JavaScript prior to ECMAScript 6. Proxies and the reflection API allow you to create an object that behaves in the same manner as the built-in <span class="literal">Array</span> type when properties are added and removed. To refresh your memory, here’s an example that shows the behavior that proxies help to mimic:</p>
        <p class="programs">let colors = ["red", "green", "blue"];<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br><br>colors[3] = "black";<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4<br>console.log(colors[3]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "black"<br><br>colors.length = 2;<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(colors[3]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(colors[2]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(colors[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "green"</p>
        <p class="indentb"><span epub:type="pagebreak" id="page_270"></span>Notice two particularly important behaviors in this example:</p>
        <p class="bull">• The <span class="literal">length</span> property is increased to 4 when <span class="literal">colors[3]</span> is assigned a value.</p>
        <p class="bull">• The last two items in the array are deleted when the <span class="literal">length</span> property is set to 2.</p>
        <p class="indentt">These two behaviors are the only ones that need to be mimicked to accurately re-create how built-in arrays work. The next few sections describe how to make an object that correctly mimics them.</p>
        <h4 class="h4" id="ch12lev2sec12"><em><strong>Detecting Array Indexes</strong></em></h4>
        <p class="noindent">Keep in mind that assigning a value to an integer property key is a special case for arrays, because they’re treated differently from non-integer keys. The ECMAScript 6 specification gives the following instructions on how to determine whether a property key is an array index:</p>
        <p class="bq">A String property name <span class="literal">P</span> is an array index if and only if <span class="literal">ToString(ToUint32(P))</span> is equal to <span class="literal">P</span> and <span class="literal">ToUint32(P)</span> is not equal to 232-1.</p>
        <p class="indent">This operation can be implemented in JavaScript as follows:</p>
        <p class="programs">function toUint32(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);<br>}<br><br>function isArrayIndex(key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let numericKey = toUint32(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);<br>}</p>
        <p class="indent">The <span class="literal">toUint32()</span> function converts a given value into an unsigned 32-bit integer using an algorithm described in the specification. The <span class="literal">isArrayIndex()</span> function first converts the key into a uint32 and then performs the comparisons to determine whether or not the key is an array index. With these two utility functions available, you can start to implement an object that will mimic a built-in array.</p>
        <h4 class="h4" id="ch12lev2sec13"><em><strong>Increasing length When Adding New Elements</strong></em></h4>
        <p class="noindent">Notice that both array behaviors I described previously rely on the assignment of a property. That means you only need to use the <span class="literal">set</span> proxy trap to accomplish both behaviors. To get started, look at this example, which implements the first of the two behaviors by incrementing the <span class="literal">length</span> property when an array index larger than <span class="literal">length - 1</span> is used:</p>
        <p class="programs">function toUint32(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);<br>}<br><span epub:type="pagebreak" id="page_271"></span><br>function isArrayIndex(key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let numericKey = toUint32(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);<br>}<br><br>function createMyArray(length=0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return new Proxy({ length }, {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set(trapTarget, key, value) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let currentLength = Reflect.get(trapTarget, "length");<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the special case<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isArrayIndex(key)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let numericKey = Number(key);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (numericKey &gt;= currentLength) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflect.set(trapTarget, "length", numericKey + 1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// always do this regardless of key type<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.set(trapTarget, key, value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}<br><br>let colors = createMyArray(3);<br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br><br>colors[0] = "red";<br>colors[1] = "green";<br>colors[2] = "blue";<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br><br>colors[3] = "black";<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4<br>console.log(colors[3]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "black"</p>
        <p class="indent">This code uses the <span class="literal">set</span> proxy trap to intercept the setting of an array index. If the key is an array index, it is converted into a number because keys are always passed as strings. Next, if that numeric value is greater than or equal to the current <span class="literal">length</span> property, the <span class="literal">length</span> property is updated to be one more than the numeric key (setting an item in position 3 means the <span class="literal">length</span> must be 4). Then, the default behavior for setting a property is used via <span class="literal">Reflect.set()</span>, because you want the property to receive the value as specified.</p>
        <p class="indent">The initial custom array is created by calling <span class="literal">createMyArray()</span> with a <span class="literal">length</span> of 3, and the values for those three items are added immediately afterward. The <span class="literal">length</span> property correctly remains at 3 until the value <span class="literal">"black"</span> is assigned to position 3. At that point, <span class="literal">length</span> is set to 4.</p>
        <p class="indent">With the first array behavior working, it’s time to move on to the second behavior.</p>
        <h4 class="h4" id="ch12lev2sec14"><span epub:type="pagebreak" id="page_272"></span><em><strong>Deleting Elements When Reducing length</strong></em></h4>
        <p class="noindent">The first array behavior to mimic is used only when an array index is greater than or equal to the <span class="literal">length</span> property. The second behavior does the opposite and removes array items when the <span class="literal">length</span> property is set to a smaller value than it previously contained. That involves not only changing the <span class="literal">length</span> property but also deleting all items that might otherwise exist. For instance, if an array with a <span class="literal">length</span> of 4 has <span class="literal">length</span> set to 2, the items in positions 2 and 3 are deleted. You can accomplish this inside the <span class="literal">set</span> proxy trap alongside the first behavior. Here’s the previous example again but with an updated <span class="literal">createMyArray</span> method:</p>
        <p class="programs">function toUint32(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);<br>}<br><br>function isArrayIndex(key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let numericKey = toUint32(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);<br>}<br><br>function createMyArray(length=0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return new Proxy({ length }, {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set(trapTarget, key, value) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let currentLength = Reflect.get(trapTarget, "length");<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the special case<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isArrayIndex(key)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let numericKey = Number(key);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (numericKey &gt;= currentLength) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflect.set(trapTarget, "length", numericKey + 1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (key === "length") {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (value &lt; currentLength) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (let index = currentLength - 1; index &gt;= value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index--) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflect.deleteProperty(trapTarget, index);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// always do this regardless of key type<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.set(trapTarget, key, value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}<br><br>let colors = createMyArray(3);<br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br><span epub:type="pagebreak" id="page_273"></span><br>colors[0] = "red";<br>colors[1] = "green";<br>colors[2] = "blue";<br>colors[3] = "black";<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4<br><br>colors.length = 2;<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(colors[3]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(colors[2]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(colors[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "green"<br>console.log(colors[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"</p>
        <p class="indent">The <span class="literal">set</span> proxy trap in this code checks whether <span class="literal">key</span> is <span class="literal">"length"</span> in order to adjust the rest of the object correctly. When that check happens, the current length is first retrieved using <span class="literal">Reflect.get()</span> and compared against the new value. If the new value is less than the current length, a <span class="literal">for</span> loop deletes all properties on the target that should no longer be available. The <span class="literal">for</span> loop goes backward from the current array length (<span class="literal">currentLength</span>) and deletes each property until it reaches the new array length (<span class="literal">value</span>).</p>
        <p class="indent">This example adds four colors to <span class="literal">colors</span> and then sets the <span class="literal">length</span> property to 2. That effectively removes the items in positions 2 and 3, so they now return <span class="literal">undefined</span> when you attempt to access them. The <span class="literal">length</span> property is correctly set to 2, and the items in positions 0 and 1 are still accessible.</p>
        <p class="indent">With both behaviors implemented, you can easily create an object that mimics the behavior of built-in arrays. But doing so with a function isn’t as desirable as creating a class to encapsulate this behavior, so the next step is to implement this functionality as a class.</p>
        <h4 class="h4" id="ch12lev2sec15"><em><strong>Implementing the MyArray Class</strong></em></h4>
        <p class="noindent">The simplest way to create a class that uses a proxy is to define the class as usual and then return a proxy from the constructor. That way, the object returned when a class is instantiated will be the proxy instead of the instance. (The instance is the value of <span class="literal">this</span> inside the constructor.) The instance becomes the target of the proxy, and the proxy is returned as if it were the instance. The instance will be completely private, and you won’t be able to access it directly, although you’ll be able to access it indirectly through the proxy.</p>
        <p class="indent">Here’s a simple example of returning a proxy from a class constructor:</p>
        <p class="programs">class Thing {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Proxy(this, {});<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let myThing = new Thing();<br>console.log(myThing instanceof Thing);&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent"><span epub:type="pagebreak" id="page_274"></span>In this example, the class <span class="literal">Thing</span> returns a proxy from its constructor. The proxy target is <span class="literal">this</span>, and the proxy is returned from the constructor. That means <span class="literal">myThing</span> is actually a proxy, even though it was created by calling the <span class="literal">Thing</span> constructor. Because proxies pass through their behavior to their targets, <span class="literal">myThing</span> is still considered an instance of <span class="literal">Thing</span>, making the proxy completely transparent to anyone using the <span class="literal">Thing</span> class.</p>
        <p class="indent">With the understanding that you can return a proxy from a constructor in mind, creating a custom array class using a proxy is relatively straightforward. The code is mostly the same as the code in “<a href="ch12.xhtml#ch12lev2sec14">Deleting Elements When Reducing <span class="literal">length</span></a>” on <a href="ch12.xhtml#page_272">page 272</a>. You can use the same proxy code, but this time you need to place it inside a class constructor. Here’s the complete example:</p>
        <p class="programs">function toUint32(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return Math.floor(Math.abs(Number(value))) % Math.pow(2, 32);<br>}<br><br>function isArrayIndex(key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let numericKey = toUint32(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;return String(numericKey) == key &amp;&amp; numericKey &lt; (Math.pow(2, 32) - 1);<br>}<br><br>class MyArray {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length=0) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Proxy(this, {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set(trapTarget, key, value) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let currentLength = Reflect.get(trapTarget, "length");<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// the special case<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (isArrayIndex(key)) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let numericKey = Number(key);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (numericKey &gt;= currentLength) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflect.set(trapTarget, "length", numericKey + 1);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (key === "length") {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (value &lt; currentLength) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (let index = currentLength - 1; index &gt;= value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;index--) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Reflect.deleteProperty(trapTarget, index);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><span epub:type="pagebreak" id="page_275"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// always do this regardless of key type<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.set(trapTarget, key, value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br><br>let colors = new MyArray(3);<br>console.log(colors instanceof MyArray);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br><br>colors[0] = "red";<br>colors[1] = "green";<br>colors[2] = "blue";<br>colors[3] = "black";<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4<br><br>colors.length = 2;<br><br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(colors[3]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(colors[2]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(colors[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "green"<br>console.log(colors[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"</p>
        <p class="indent">This code creates a <span class="literal">MyArray</span> class that returns a proxy from its constructor. The <span class="literal">length</span> property is added in the constructor (initialized to either the value that is passed in or to a default value of 0) and then a proxy is created and returned. This makes the <span class="literal">colors</span> variable appear as though it’s just an instance of <span class="literal">MyArray</span> and implements both key array behaviors.</p>
        <p class="indent">Although returning a proxy from a class constructor is easy, it also means that a new proxy is created for every instance. However, there is a way to have all instances share one proxy: you can use the proxy as a prototype.</p>
        <h3 class="h3" id="ch12lev1sec15"><strong>Using a Proxy as a Prototype</strong></h3>
        <p class="noindent">Although you can use proxies as prototypes, doing so is a bit more involved than the previous examples in this chapter. When a proxy is a prototype, the proxy traps are only called when the default operation would normally continue on to the prototype, which limits a proxy’s capabilities as a prototype. Consider the following example.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_276"></span>let target = {};<br>let newTarget = Object.create(new Proxy(target, {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// never called<br>&nbsp;&nbsp;&nbsp;&nbsp;defineProperty(trapTarget, name, descriptor) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// would cause an error if called<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}));<br><br>Object.defineProperty(newTarget, "name", {<br>&nbsp;&nbsp;&nbsp;&nbsp;value: "newTarget"<br>});<br><br>console.log(newTarget.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "newTarget"<br>console.log(newTarget.hasOwnProperty("name"));&nbsp;&nbsp;// true</p>
        <p class="indent">The <span class="literal">newTarget</span> object is created with a proxy as the prototype. Making <span class="literal">target</span> the proxy target effectively makes <span class="literal">target</span> the prototype of <span class="literal">newTarget</span> because the proxy is transparent. Now, proxy traps will only be called if an operation on <span class="literal">newTarget</span> would pass the operation through to happen on <span class="literal">target</span>.</p>
        <p class="indent">The <span class="literal">Object.defineProperty()</span> method is called on <span class="literal">newTarget</span> to create an own property called <span class="literal">name</span>. Defining a property on an object isn’t an operation that normally continues to the object’s prototype, so the <span class="literal">defineProperty</span> trap on the proxy is never called and the <span class="literal">name</span> property is added to <span class="literal">newTarget</span> as an own property.</p>
        <p class="indent">Although proxies are severely limited when they’re used as prototypes, a few traps are still useful. I’ll cover those in the next few sections.</p>
        <h4 class="h4" id="ch12lev2sec16"><em><strong>Using the get Trap on a Prototype</strong></em></h4>
        <p class="noindent">When the internal <span class="literal">[[Get]]</span> method is called to read a property, the operation looks for own properties first. If an own property with the given name isn’t found, the operation continues to the prototype and looks for a property there. The process continues until there are no further prototypes to check.</p>
        <p class="indent">Because of that process, if you set up a <span class="literal">get</span> proxy trap, the trap will be called on a prototype whenever an own property of the given name doesn’t exist. You can use the <span class="literal">get</span> trap to prevent unexpected behavior when accessing properties that you can’t guarantee will exist. Just create an object that throws an error whenever you try to access a property that doesn’t exist:</p>
        <p class="programs">let target = {};<br>let thing = Object.create(new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;get(trapTarget, key, receiver) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new ReferenceError(`${key} doesn't exist`);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}));<br><br>thing.name = "thing";<br><span epub:type="pagebreak" id="page_277"></span>console.log(thing.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "thing"<br><br>// throws an error<br>let unknown = thing.unknown;</p>
        <p class="indent">In this code, the <span class="literal">thing</span> object is created with a proxy as its prototype. The <span class="literal">get</span> trap throws an error when called to indicate that the given key doesn’t exist on the <span class="literal">thing</span> object. When <span class="literal">thing.name</span> is read, the operation never calls the <span class="literal">get</span> trap on the prototype because the property exists on <span class="literal">thing</span>. The <span class="literal">get</span> trap is called only when the <span class="literal">thing.unknown</span> property, which doesn’t exist, is accessed.</p>
        <p class="indent">When the last line executes, <span class="literal">unknown</span> isn’t an own property of <span class="literal">thing</span>, so the operation continues to the prototype. The <span class="literal">get</span> trap then throws an error. This type of behavior can be very useful in JavaScript where unknown properties silently return <span class="literal">undefined</span> instead of throwing an error (which happens in other languages).</p>
        <p class="indent">It’s important to understand that in this example, <span class="literal">trapTarget</span> and <span class="literal">receiver</span> are different objects. When a proxy is used as a prototype, the <span class="literal">trapTarget</span> is the prototype object and the <span class="literal">receiver</span> is the instance object. In this case, that means <span class="literal">trapTarget</span> is equal to <span class="literal">target</span> and <span class="literal">receiver</span> is equal to <span class="literal">thing</span>. That allows you access to the original target of the proxy and the object on which the operation is meant to take place.</p>
        <h4 class="h4" id="ch12lev2sec17"><em><strong>Using the set Trap on a Prototype</strong></em></h4>
        <p class="noindent">The internal <span class="literal">[[Set]]</span> method also checks for own properties and then continues to the prototype if needed. When you assign a value to an object property, the value is assigned to the own property with the same name if it exists. If no own property with the given name exists, the operation continues to the prototype. The tricky part is that even though the assignment operation continues to the prototype, assigning a value to that property will create a property on the instance (not the prototype) by default regardless of whether a property of that name exists on the prototype.</p>
        <p class="indent">To get a better idea of when the <span class="literal">set</span> trap will be called on a prototype and when it won’t, consider the following example, which shows the default behavior:</p>
        <p class="programs">let target = {};<br>let thing = Object.create(new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;set(trapTarget, key, value, receiver) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.set(trapTarget, key, value, receiver);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}));<br><br>console.log(thing.hasOwnProperty("name"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>// triggers the `set` proxy trap<br>thing.name = "thing";<br><br>console.log(thing.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "thing"<br>console.log(thing.hasOwnProperty("name"));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><span epub:type="pagebreak" id="page_278"></span><br>// does not trigger the `set` proxy trap<br>thing.name = "boo";<br><br>console.log(thing.name);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "boo"</p>
        <p class="indent">In this example, <span class="literal">target</span> starts with no own properties. The <span class="literal">thing</span> object has a proxy as its prototype that defines a <span class="literal">set</span> trap to catch the creation of any new properties. When <span class="literal">thing.name</span> is assigned <span class="literal">"thing"</span> as its value, the <span class="literal">set</span> proxy trap is called because <span class="literal">thing</span> doesn’t have an own property called <span class="literal">name</span>. Inside the <span class="literal">set</span> trap, <span class="literal">trapTarget</span> is equal to <span class="literal">target</span> and <span class="literal">receiver</span> is equal to <span class="literal">thing</span>. The operation should ultimately create a new property on <span class="literal">thing</span>, and fortunately, <span class="literal">Reflect.set()</span> implements this default behavior for you if you pass in <span class="literal">receiver</span> as the fourth argument.</p>
        <p class="indent">Once the <span class="literal">name</span> property is created on <span class="literal">thing</span>, setting <span class="literal">thing.name</span> to a different value will no longer call the <span class="literal">set</span> proxy trap. At that point, <span class="literal">name</span> is an own property, so the <span class="literal">[[Set]]</span> operation never continues on to the prototype.</p>
        <h4 class="h4" id="ch12lev2sec18"><em><strong>Using the has Trap on a Prototype</strong></em></h4>
        <p class="noindent">Recall that the <span class="literal">has</span> trap intercepts the use of the <span class="literal">in</span> operator on objects. The <span class="literal">in</span> operator searches first for an object’s own property with the given name. If an own property with that name doesn’t exist, the operation continues to the prototype. If there’s no own property on the prototype, the search continues through the prototype chain until the own property is found or there are no more prototypes to search.</p>
        <p class="indent">The <span class="literal">has</span> trap is therefore only called when the search reaches the proxy object in the prototype chain. When you’re using a proxy as a prototype, the <span class="literal">has</span> trap is only called when there’s no own property of the given name. For example:</p>
        <p class="programs">let target = {};<br>let thing = Object.create(new Proxy(target, {<br>&nbsp;&nbsp;&nbsp;&nbsp;has(trapTarget, key) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Reflect.has(trapTarget, key);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}));<br><br>// triggers the `has` proxy trap<br>console.log("name" in thing);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>thing.name = "thing";<br><br>// does not trigger the `has` proxy trap<br>console.log("name" in thing);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">This code creates a <span class="literal">has</span> proxy trap on the prototype of <span class="literal">thing</span>. The <span class="literal">has</span> trap isn’t passed a <span class="literal">receiver</span> object like the <span class="literal">get</span> and <span class="literal">set</span> traps are, because searching the prototype happens automatically when the <span class="literal">in</span> operator is used. Instead, the <span class="literal">has</span> trap must operate only on <span class="literal">trapTarget</span>, which is equal to <span class="literal">target</span>. The first time the <span class="literal">in</span> operator is used in this example, the <span class="literal">has</span> trap is called because the property <span class="literal">name</span> doesn’t exist as an own property of <span class="literal">thing</span>. <span epub:type="pagebreak" id="page_279"></span>When <span class="literal">thing.name</span> is given a value and the <span class="literal">in</span> operator is used again, the <span class="literal">has</span> trap isn’t called because the operation stops after finding the own property <span class="literal">name</span> on <span class="literal">thing</span>.</p>
        <p class="indent">The prototype examples to this point have focused on objects created using the <span class="literal">Object.create()</span> method. But if you want to create a class that has a proxy as a prototype, the process is a bit more involved.</p>
        <h4 class="h4" id="ch12lev2sec19"><em><strong>Proxies as Prototypes on Classes</strong></em></h4>
        <p class="noindent">Classes cannot be directly modified to use a proxy as a prototype because their <span class="literal">prototype</span> property is nonwritable. However, you can use a bit of misdirection to create a class that has a proxy as its prototype by using inheritance. To start, you need to create an ECMAScript 5–style type definition using a constructor function. You can then overwrite the prototype to be a proxy. Here’s an example:</p>
        <p class="programs">function NoSuchProperty() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>NoSuchProperty.prototype = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;get(trapTarget, key, receiver) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new ReferenceError(`${key} doesn't exist`);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>let thing = new NoSuchProperty();<br><br>// throws an error due to `get` proxy trap<br>let result = thing.name;</p>
        <p class="indent">The <span class="literal">NoSuchProperty</span> function represents the base from which the class will inherit. There are no restrictions on the <span class="literal">prototype</span> property of functions, so you can overwrite it with a proxy. The <span class="literal">get</span> trap is used to throw an error when the property doesn’t exist. The <span class="literal">thing</span> object is created as an instance of <span class="literal">NoSuchProperty</span> and throws an error when the nonexistent <span class="literal">name</span> property is accessed.</p>
        <p class="indent">The next step is to create a class that inherits from <span class="literal">NoSuchProperty</span>. You can simply use the <span class="literal">extends</span> syntax discussed in <a href="ch09.xhtml#ch09">Chapter 9</a> to introduce the proxy into the class’s prototype chain, like this:</p>
        <p class="programs">function NoSuchProperty() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>NoSuchProperty.prototype = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;get(trapTarget, key, receiver) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new ReferenceError(`${key} doesn't exist`);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><span epub:type="pagebreak" id="page_280"></span><br>class Square extends NoSuchProperty {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let shape = new Square(2, 6);<br><br>let area1 = shape.length * shape.width;<br>console.log(area1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 12<br><br>// throws an error because "wdth" doesn't exist<br>let area2 = shape.length * shape.wdth;</p>
        <p class="indent">The <span class="literal">Square</span> class inherits from <span class="literal">NoSuchProperty</span>, so the proxy is in the <span class="literal">Square</span> class’s prototype chain. The <span class="literal">shape</span> object is then created as a new instance of <span class="literal">Square</span> and has two own properties: <span class="literal">length</span> and <span class="literal">width</span>. Reading the values of those properties succeeds because the <span class="literal">get</span> proxy trap is never called. Only when a property that doesn’t exist on <span class="literal">shape</span> is accessed (<span class="literal">shape.wdth</span>, an obvious typo) does the <span class="literal">get</span> proxy trap trigger and throw an error, proving that the proxy is in the prototype chain of <span class="literal">shape</span>. But it might not be obvious that the proxy is not the direct prototype of <span class="literal">shape</span>. In fact, the proxy is a couple of steps up the prototype chain from <span class="literal">shape</span>. You can see this more clearly by slightly altering the preceding example:</p>
        <p class="programs">function NoSuchProperty() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>// store a reference to the proxy that will be the prototype<br>let proxy = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;get(trapTarget, key, receiver) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new ReferenceError(`${key} doesn't exist`);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>NoSuchProperty.prototype = proxy;<br><br>class Square extends NoSuchProperty {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let shape = new Square(2, 6);<br><br>let shapeProto = Object.getPrototypeOf(shape);<br><span epub:type="pagebreak" id="page_281"></span><br>console.log(shapeProto === proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>let secondLevelProto = Object.getPrototypeOf(shapeProto);<br><br>console.log(secondLevelProto === proxy);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">This version of the code stores the proxy in a variable called <span class="literal">proxy</span>, making it easier to identify later. The prototype of <span class="literal">shape</span> is <span class="literal">Shape.prototype</span>, which is not a proxy. But the prototype of <span class="literal">Shape.prototype</span> is the proxy that was inherited from <span class="literal">NoSuchProperty</span>.</p>
        <p class="indent">The inheritance adds another step in the prototype chain, and that matters because operations that might result in calling the <span class="literal">get</span> trap on <span class="literal">proxy</span> need to go through one extra step before doing so. If there’s a property on <span class="literal">Shape.prototype</span>, that will prevent the <span class="literal">get</span> proxy trap from being called, as in this example:</p>
        <p class="programs">function NoSuchProperty() {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>NoSuchProperty.prototype = new Proxy({}, {<br>&nbsp;&nbsp;&nbsp;&nbsp;get(trapTarget, key, receiver) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new ReferenceError(`${key} doesn't exist`);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>class Square extends NoSuchProperty {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;getArea() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.length * this.width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let shape = new Square(2, 6);<br><br>let area1 = shape.length * shape.width;<br>console.log(area1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 12<br><br>let area2 = shape.getArea();<br>console.log(area2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 12<br><br>// throws an error because "wdth" doesn't exist<br>let area3 = shape.length * shape.wdth;</p>
        <p class="indent">Here, the <span class="literal">Square</span> class has a <span class="literal">getArea()</span> method. The <span class="literal">getArea()</span> method is automatically added to <span class="literal">Square.prototype</span>, so when <span class="literal">shape.getArea()</span> is called, the search for the method <span class="literal">getArea()</span> starts on the <span class="literal">shape</span> instance and then <span epub:type="pagebreak" id="page_282"></span>proceeds to its prototype. Because <span class="literal">getArea()</span> is found on the prototype, the search stops and the proxy is never called. That is actually the behavior you want in this situation, because you wouldn’t want to incorrectly throw an error when <span class="literal">getArea()</span> is called.</p>
        <p class="indent">Even though it takes a bit of extra code to create a class with a proxy in its prototype chain, it can be worth the effort if you need such functionality.</p>
        <h3 class="h3" id="ch12lev1sec16"><strong>Summary</strong></h3>
        <p class="noindent">Prior to ECMAScript 6, certain objects (such as arrays) displayed nonstandard behavior that developers couldn’t replicate. Proxies change that. They let you define your own nonstandard behavior for several low-level JavaScript operations, so you can replicate all behaviors of built-in JavaScript objects through proxy traps. These traps are called behind the scenes when various operations take place, like the use of the <span class="literal">in</span> operator.</p>
        <p class="indent">A reflection API was also introduced in ECMAScript 6 to allow developers to implement the default behavior for each proxy trap. Each proxy trap has a corresponding method of the same name on the <span class="literal">Reflect</span> object, which is another ECMAScript 6 addition. Using a combination of proxy traps and reflection API methods, it’s possible to filter some operations to behave differently only in certain conditions while defaulting to the built-in behavior.</p>
        <p class="indent">Revocable proxies are special proxies that can be effectively disabled by using a <span class="literal">revoke()</span> function. The <span class="literal">revoke()</span> function terminates all functionality on the proxy, so any attempt to interact with the proxy’s properties throws an error after <span class="literal">revoke()</span> is called. Revocable proxies are important for application security where third-party developers may need access to certain objects for a specified amount of time.</p>
        <p class="indent">Although using proxies directly is the most powerful use case, you can also use a proxy as the prototype for another object. In that case, you are severely limited in the number of proxy traps you can effectively use. Only the <span class="literal">get</span>, <span class="literal">set</span>, and <span class="literal">has</span> proxy traps will ever be called on a proxy when it’s used as a prototype, resulting in fewer use cases.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com