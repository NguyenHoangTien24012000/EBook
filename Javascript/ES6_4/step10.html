<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch10"><span epub:type="pagebreak" id="page_191"></span><strong><span class="big">10</span><br>IMPROVED ARRAY CAPABILITIES</strong></h2>
        <div class="image"><img src="/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">The array is a foundational JavaScript object. But while other aspects of JavaScript have evolved over time, arrays remained the same until ECMAScript 5 introduced several methods to make them easier to use. ECMAScript 6 continues to improve arrays by adding a lot more functionality, such as new creation methods, several useful convenience methods, and the ability to make typed arrays. This chapter walks you through those changes in detail.</p>
        <h3 class="h3" id="ch10lev1sec01"><strong>Creating Arrays</strong></h3>
        <p class="noindent">Prior to ECMAScript 6, the two primary ways to create arrays were the <span class="literal">Array</span> constructor and array literal syntax. Both approaches required listing array items individually and were otherwise fairly limited. Options for converting an array-like object (that is, an object with numeric indexes and a <span class="literal">length</span> <span epub:type="pagebreak" id="page_192"></span>property) into an array were also limited and often required extra code. To make JavaScript arrays easier to create, ECMAScript 6 has the <span class="literal">Array.of()</span> and <span class="literal">Array.from()</span> methods.</p>
        <h4 class="h4" id="ch10lev2sec01"><em><strong>The Array.of() Method</strong></em></h4>
        <p class="noindent">One reason ECMAScript 6 added new creation methods to JavaScript was to help developers avoid a quirk of creating arrays with the <span class="literal">Array</span> constructor. The <span class="literal">Array</span> constructor actually behaves differently based on the type and number of arguments passed to it. For example:</p>
        <p class="programs">let items = new Array(2);<br>console.log(items.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(items[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br>console.log(items[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br><br>items = new Array("2");<br>console.log(items.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(items[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "2"<br><br>items = new Array(1, 2);<br>console.log(items.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(items[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(items[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br><br>items = new Array(3, "2");<br>console.log(items.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(items[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 3<br>console.log(items[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "2"</p>
        <p class="indent">When the <span class="literal">Array</span> constructor is passed a single numeric value, the array’s <span class="literal">length</span> property is set to that value. If a single nonnumeric value is passed, that value becomes the one and only item in the array. If multiple values are passed (numeric or not), those values become items in the array. This behavior is confusing and risky, because you might not always be aware of the type of data being passed.</p>
        <p class="indent">ECMAScript 6 introduces <span class="literal">Array.of()</span> to solve this problem. The <span class="literal">Array.of()</span> method works similarly to the <span class="literal">Array</span> constructor but has no special case regarding a single numeric value. The <span class="literal">Array.of()</span> method always creates an array containing its arguments regardless of the number of arguments or the argument types. Here are some examples that use the <span class="literal">Array.of()</span> method:</p>
        <p class="programs">let items = Array.of(1, 2);<br>console.log(items.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(items[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(items[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br><br>items = Array.of(2);<br>console.log(items.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(items[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br><span epub:type="pagebreak" id="page_193"></span><br>items = Array.of("2");<br>console.log(items.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(items[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "2"</p>
        <p class="indent">To create an array with the <span class="literal">Array.of()</span> method, just pass it the values you want in your array. This first example creates an array containing two numbers, the second array contains one number, and the last array contains one string. This approach is similar to using an array literal, and you can use an array literal instead of <span class="literal">Array.of()</span> for native arrays most of the time. But if you ever need to pass the <span class="literal">Array</span> constructor into a function, you might want to pass <span class="literal">Array.of()</span> instead to ensure consistent behavior. For example:</p>
        <p class="programs">function createArray(arrayCreator, value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return arrayCreator(value);<br>}<br><br>let items = createArray(Array.of, value);</p>
        <p class="indent">In this code, the <span class="literal">createArray()</span> function accepts an array creator function and a value to insert into the array. You can pass <span class="literal">Array.of()</span> as the first argument to <span class="literal">createArray()</span> to create a new array. It would be dangerous to pass <span class="literal">Array</span> directly if you cannot guarantee that <span class="literal">value</span> won’t be a number.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The <span class="literal">Array.of()</span> method does not use the <span class="literal">Symbol.species</span> property (see <a href="ch09.xhtml#page_185">page 185</a>) to determine the type of return value. Instead, it uses the current constructor (<span class="literal">this</span> inside the <span class="literal">of()</span> method) to determine the correct data type to return.</em></p>
        </div>
        <h4 class="h4" id="ch10lev2sec02"><em><strong>The Array.from() Method</strong></em></h4>
        <p class="noindent">Converting nonarray objects into actual arrays has always been cumbersome in JavaScript. For instance, if you have an <span class="literal">arguments</span> object (which is array-like) and want to use it like an array, you’d need to convert it first. To convert an array-like object to an array in ECMAScript 5, you’d write a function like the one in this example:</p>
        <p class="programs">function makeArray(arrayLike) {<br>&nbsp;&nbsp;&nbsp;&nbsp;var result = [];<br><br>&nbsp;&nbsp;&nbsp;&nbsp;for (var i = 0, len = arrayLike.length; i &lt; len; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.push(arrayLike[i]);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return result;<br>}<br><br>function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;var args = makeArray(arguments);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// use args<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_194"></span>This approach manually creates a <span class="literal">result</span> array and copies each item from <span class="literal">arguments</span> into the new array. Although this approach works, it takes a decent amount of code to perform a relatively simple operation. Eventually, developers discovered they could reduce the amount of code they used by calling the native <span class="literal">slice()</span> method for arrays on array-like objects, like this:</p>
        <p class="programs">function makeArray(arrayLike) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return Array.prototype.slice.call(arrayLike);<br>}<br><br>function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;var args = makeArray(arguments);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// use args<br>}</p>
        <p class="indent">This code is functionally equivalent to the previous example, and it works because it sets the <span class="literal">this</span> value for <span class="literal">slice()</span> to the array-like object. Because <span class="literal">slice()</span> needs only numeric indexes and a <span class="literal">length</span> property to function correctly, any array-like object will work.</p>
        <p class="indent">Even though you don’t have to type as much when using this technique, calling <span class="literal">Array.prototype.slice.call(arrayLike)</span> doesn’t obviously translate to “Convert <span class="literal">arrayLike</span> to an array.” Fortunately, ECMAScript 6 added the <span class="literal">Array.from()</span> method as an obvious, yet clean, way to convert objects into arrays.</p>
        <p class="indent">Given either an iterable or an array-like object as the first argument, the <span class="literal">Array.from()</span> method returns an array. Here’s a simple example:</p>
        <p class="programs">function doSomething() {<br>&nbsp;&nbsp;&nbsp;&nbsp;var args = Array.from(arguments);<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// use args<br>}</p>
        <p class="indent">The <span class="literal">Array.from()</span> call creates a new array based on the items in <span class="literal">arguments</span>. So <span class="literal">args</span> is an instance of <span class="literal">Array</span> that contains the same values in the same positions as <span class="literal">arguments</span>.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>The <span class="literal">Array.from()</span> method also uses <span class="literal">this</span> to determine the type of array to return.</em></p>
        </div>
        <h5 class="h5" id="ch10lev3sec01"><strong>Mapping Conversion</strong></h5>
        <p class="noindent">If you want to take array conversion a step further, you can provide <span class="literal">Array.from()</span> with a mapping function as a second argument. That function operates on each value from the array-like object and converts it to some final form before storing the result at the appropriate index in the final array. Consider the following example.</p>
        <p class="programs"><span epub:type="pagebreak" id="page_195"></span>function translate() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return Array.from(arguments, (value) =&gt; value + 1);<br>}<br><br>let numbers = translate(1, 2, 3);<br><br>console.log(numbers);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2,3,4</p>
        <p class="indent">Here, <span class="literal">Array.from()</span> is passed <span class="literal">(value) =&gt; value + 1</span> as a mapping function, so it adds 1 to each item in the array before storing the item. If the mapping function is on an object, you can also optionally pass a third argument to <span class="literal">Array.from()</span> that represents the <span class="literal">this</span> value for the mapping function:</p>
        <p class="programs">let helper = {<br>&nbsp;&nbsp;&nbsp;&nbsp;diff: 1,<br><br>&nbsp;&nbsp;&nbsp;&nbsp;add(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value + this.diff;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>function translate() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return Array.from(arguments, helper.add, helper);<br>}<br><br>let numbers = translate(1, 2, 3);<br><br>console.log(numbers);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2,3,4</p>
        <p class="indent">This example passes <span class="literal">helper.add()</span> as the mapping function for the conversion. Because <span class="literal">helper.add()</span> uses the <span class="literal">this.diff</span> property, you need to provide the third argument to <span class="literal">Array.from()</span> specifying the value of <span class="literal">this</span>. Thanks to the third argument, <span class="literal">Array.from()</span> can easily convert data without calling <span class="literal">bind()</span> or specifying the <span class="literal">this</span> value in some other way.</p>
        <h5 class="h5" id="ch10lev3sec02"><strong>Use on Iterables</strong></h5>
        <p class="noindent">The <span class="literal">Array.from()</span> method works on array-like objects and iterables. That means the method can convert any object with a <span class="literal">Symbol.iterator</span> property into an array. For example:</p>
        <p class="programs">let numbers = {<br>&nbsp;&nbsp;&nbsp;&nbsp;*[Symbol.iterator]() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield 3;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let numbers2 = Array.from(numbers, (value) =&gt; value + 1);<br><br>console.log(numbers2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2,3,4</p>
        <p class="indent"><span epub:type="pagebreak" id="page_196"></span>Because the <span class="literal">numbers</span> object is an iterable, you can pass <span class="literal">numbers</span> directly to <span class="literal">Array.from()</span> to convert its values into an array. The mapping function adds 1 to each number, so the resulting array contains 2, 3, and 4 instead of 1, 2, and 3.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>If an object is array-like and an iterable, the iterator is used by <span class="literal">Array.from()</span> to determine the values to convert.</em></p>
        </div>
        <h3 class="h3" id="ch10lev1sec02"><strong>New Methods on All Arrays</strong></h3>
        <p class="noindent">Continuing the trend from ECMAScript 5, ECMAScript 6 adds several new methods to arrays. The <span class="literal">find()</span> and <span class="literal">findIndex()</span> methods are meant to aid developers using arrays with any values, whereas <span class="literal">fill()</span> and <span class="literal">copyWithin()</span> are inspired by use cases for <em>typed arrays</em>, a form of array introduced in ECMAScript 6 that uses only numbers.</p>
        <h4 class="h4" id="ch10lev2sec03"><em><strong>The find() and findIndex() Methods</strong></em></h4>
        <p class="noindent">Prior to ECMAScript 5, searching through arrays was cumbersome because there were no built-in methods for doing so. ECMAScript 5 added the <span class="literal">indexOf()</span> and <span class="literal">lastIndexOf()</span> methods, which finally allowed developers to search for specific values inside an array. These two methods were a big improvement, yet they were still fairly limited because you could search for only one value at a time. For example, if you wanted to find the first even number in a series of numbers, you’d need to write your own code to do so. ECMAScript 6 solved that problem by introducing the <span class="literal">find()</span> and <span class="literal">findIndex()</span> methods.</p>
        <p class="indent">Both <span class="literal">find()</span> and <span class="literal">findIndex()</span> accept two arguments: a callback function and an optional value to use for <span class="literal">this</span> inside the callback function. The callback function is passed an array element, the index of that element in the array, and the actual array—the same arguments passed to methods like <span class="literal">map()</span> and <span class="literal">forEach()</span>. The callback should return <span class="literal">true</span> if the given value matches some criteria you define. Both <span class="literal">find()</span> and <span class="literal">findIndex()</span> also stop searching the array the first time the callback function returns <span class="literal">true</span>.</p>
        <p class="indent">The only difference between these methods is that <span class="literal">find()</span> returns the value, whereas <span class="literal">findIndex()</span> returns the index at which the value was found. Here’s an example to demonstrate:</p>
        <p class="programs">let numbers = [25, 30, 35, 40, 45];<br><br>console.log(numbers.find(n =&gt; n &gt; 33));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 35<br>console.log(numbers.findIndex(n =&gt; n &gt; 33));&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">This code calls <span class="literal">find()</span> and <span class="literal">findIndex()</span> to locate the first value in the <span class="literal">numbers</span> array that is greater than 33. The call to <span class="literal">find()</span> returns 35 and <span class="literal">findIndex()</span> returns 2, the location of 35 in the <span class="literal">numbers</span> array.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_197"></span>Both <span class="literal">find()</span> and <span class="literal">findIndex()</span> are useful to find an array element that matches a condition rather than a value. If you only want to find a value, <span class="literal">indexOf()</span> and <span class="literal">lastIndexOf()</span> are better choices.</p>
        <h4 class="h4" id="ch10lev2sec04"><em><strong>The fill() Method</strong></em></h4>
        <p class="noindent">The <span class="literal">fill()</span> method fills one or more array elements with a specific value. When passed a value, <span class="literal">fill()</span> overwrites all the values in an array with that value. For example:</p>
        <p class="programs">let numbers = [1, 2, 3, 4];<br><br>numbers.fill(1);<br><br>console.log(numbers.toString());&nbsp;&nbsp;&nbsp;&nbsp;// 1,1,1,1</p>
        <p class="indent">Here, the call to <span class="literal">numbers.fill(1)</span> changes all elements in <span class="literal">numbers</span> to 1. If you want to change only some of the elements rather than all of them, you can optionally include a start index and an exclusive end index, like this:</p>
        <p class="programs">let numbers = [1, 2, 3, 4];<br><br>numbers.fill(1, 2);<br><br>console.log(numbers.toString());&nbsp;&nbsp;&nbsp;&nbsp;// 1,2,1,1<br><br>numbers.fill(0, 1, 3);<br><br>console.log(numbers.toString());&nbsp;&nbsp;&nbsp;&nbsp;// 1,0,0,1</p>
        <p class="indent">In the <span class="literal">numbers.fill(1, 2)</span> call, the <span class="literal">2</span> argument starts filling elements at index 2. The exclusive end index isn’t specified with a third argument, so <span class="literal">numbers.length</span> is used as the end index, meaning the last two elements in <span class="literal">numbers</span> are filled with 1. The <span class="literal">numbers.fill(0, 1, 3)</span> operation fills array elements at indexes 1 and 2 with 0. Calling <span class="literal">fill()</span> with the second and third arguments allows you to fill multiple array elements at once without overwriting the entire array.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>If either the start or end index is negative, those values are added to the array’s length to determine the final location. For instance, a start location of <span class="literal">-1</span> gives <span class="literal">array.length - 1</span> as the index, where <span class="literal">array</span> is the array on which <span class="literal">fill()</span> is called.</em></p>
        </div>
        <h4 class="h4" id="ch10lev2sec05"><em><strong>The copyWithin() Method</strong></em></h4>
        <p class="noindent">The <span class="literal">copyWithin()</span> method is similar to <span class="literal">fill()</span> in that it changes multiple array elements at the same time. However, instead of specifying a single value to assign to array elements, <span class="literal">copyWithin()</span> lets you copy array element values from the array. To accomplish that, you need to pass two arguments to the <span class="literal">copyWithin()</span> method: the index where the method should start filling values and the index where the values to be copied begin.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_198"></span>For instance, to copy the values from the first two elements in an array to the last two items in the array, you can do the following:</p>
        <p class="programs">let numbers = [1, 2, 3, 4];<br><br>// paste values into array starting at index 2<br>// copy values from array starting at index 0<br>numbers.copyWithin(2, 0);<br><br>console.log(numbers.toString());&nbsp;&nbsp;&nbsp;&nbsp;// 1,2,1,2</p>
        <p class="indent">This code pastes values into <span class="literal">numbers</span> beginning from index 2, so indexes 2 and 3 will be overwritten. Passing <span class="literal">0</span> as the second argument to <span class="literal">copyWithin()</span> starts copying values from index 0 and continues until there are no more elements to copy into.</p>
        <p class="indent">By default, <span class="literal">copyWithin()</span> always copies values up to the end of the array, but you can provide an optional third argument to limit how many elements will be overwritten. That third argument is an exclusive end index at which copying of values stops. Here’s how that looks in code:</p>
        <p class="programs">let numbers = [1, 2, 3, 4];<br><br>// paste values into array starting at index 2<br>// copy values from array starting at index 0<br>// stop copying values when you hit index 1<br>numbers.copyWithin(2, 0, 1);<br><br>console.log(numbers.toString());&nbsp;&nbsp;&nbsp;&nbsp;// 1,2,1,4</p>
        <p class="indent">In this example, only the value in index 0 is copied because the optional end index is set to <span class="literal">1</span>. The last element in the array remains unchanged.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>As with the <span class="literal">fill()</span> method, if you pass a negative number for any argument to the <span class="literal">copyWithin()</span> method, the array’s length is automatically added to that value to determine the index to use.</em></p>
        </div>
        <p class="indent">The use cases for <span class="literal">fill()</span> and <span class="literal">copyWithin()</span> may not be obvious to you at this point. The reason is that these methods originated on typed arrays and were added to regular arrays for consistency. However, as you’ll learn in the next section, if you use typed arrays for manipulating the bits of a number, these methods become a lot more useful.</p>
        <h3 class="h3" id="ch10lev1sec03"><strong>Typed Arrays</strong></h3>
        <p class="noindent">Typed arrays are special-purpose arrays designed to work with numeric types (not all types, as the name might imply). The origin of typed arrays can be traced to WebGL, a port of OpenGL ES 2.0 designed for use in web pages with the <span class="literal">&lt;canvas&gt;</span> element. Typed arrays were created as part of the port to provide fast bitwise arithmetic in JavaScript.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_199"></span>Arithmetic on native JavaScript numbers was too slow for WebGL because the numbers were stored in a 64-bit floating-point format and converted to 32-bit integers as needed. Typed arrays were introduced to circumvent this limitation and provide better performance for arithmetic operations. The concept is that any single number can be treated like an array of bits and thus can use the familiar methods available on JavaScript arrays.</p>
        <p class="indent">ECMAScript 6 adopted typed arrays as a formal part of the language to ensure better compatibility across JavaScript engines and interoperability with JavaScript arrays. Although the ECMAScript 6 version of typed arrays is not the same as the WebGL version, enough similarities exist to make the ECMAScript 6 version an evolution of the WebGL version rather than a different approach.</p>
        <h4 class="h4" id="ch10lev2sec06"><em><strong>Numeric Data Types</strong></em></h4>
        <p class="noindentb">JavaScript numbers are stored in IEEE 754 format, which uses 64 bits to store a floating-point representation of the number. This format represents integers and floats in JavaScript, and the conversion between the two formats happens frequently as numbers change. Typed arrays allow for the storage and manipulation of eight different numeric types:</p>
        <p class="bull">• Signed 8-bit integer (int8)</p>
        <p class="bull">• Unsigned 8-bit integer (uint8)</p>
        <p class="bull">• Signed 16-bit integer (int16)</p>
        <p class="bull">• Unsigned 16-bit integer (uint16)</p>
        <p class="bull">• Signed 32-bit integer (int32)</p>
        <p class="bull">• Unsigned 32-bit integer (uint32)</p>
        <p class="bull">• 32-bit float (float32)</p>
        <p class="bull">• 64-bit float (float64)</p>
        <p class="indentt">If you represent a number that fits in an int8 as a normal JavaScript number, you’ll waste 56 bits. Those bits might better be used to store additional int8 values or any other number that requires less than 56 bits. Using bits more efficiently is one of the use cases typed arrays address.</p>
        <p class="indent">All the operations and objects related to typed arrays are centered on these eight data types. But to use them, you’ll need to create an array buffer to store the data.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>In this book, I refer to the eight data types using the abbreviations I showed in parentheses. Those abbreviations don’t appear in actual JavaScript code; they’re just shorthand for the much longer descriptions.</em></p>
        </div>
        <h4 class="h4" id="ch10lev2sec07"><em><strong>Array Buffers</strong></em></h4>
        <p class="noindent">The foundation for all typed arrays is an <em>array buffer</em>, which is a memory location that can contain a specified number of bytes. Creating an array <span epub:type="pagebreak" id="page_200"></span>buffer is akin to calling <span class="literal">malloc()</span> in C to allocate memory without specifying what the memory block contains. You can create an array buffer by using the <span class="literal">ArrayBuffer</span> constructor as follows:</p>
        <p class="programs">let buffer = new ArrayBuffer(10);&nbsp;&nbsp;// allocate 10 bytes</p>
        <p class="indent">Just pass the number of bytes the array buffer should contain when you call the constructor. This <span class="literal">let</span> statement creates an array buffer 10 bytes long. After an array buffer is created, you can retrieve the number of bytes in it by checking the <span class="literal">byteLength</span> property:</p>
        <p class="programs">let buffer = new ArrayBuffer(10);&nbsp;&nbsp;// allocate 10 bytes<br>console.log(buffer.byteLength);&nbsp;&nbsp;&nbsp;&nbsp;// 10</p>
        <p class="indent">You can also use the <span class="literal">slice()</span> method to create a new array buffer that contains part of an existing array buffer. The <span class="literal">slice()</span> method works like the <span class="literal">slice()</span> method on arrays: you pass it the start index and end index as arguments, and it returns a new <span class="literal">ArrayBuffer</span> instance composed of those elements from the original. For example:</p>
        <p class="programs">let buffer = new ArrayBuffer(10);&nbsp;&nbsp;// allocate 10 bytes<br>let buffer2 = buffer.slice(4, 6);<br>console.log(buffer2.byteLength);&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">In this code, <span class="literal">buffer2</span> is created by extracting the bytes at indexes 4 and 5. Similar to when you call the array version of this method, the second argument to <span class="literal">slice()</span> is exclusive.</p>
        <p class="indent">Of course, creating a storage location isn’t very helpful without being able to write data into that location. To do so, you’ll need to create a view.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>An array buffer always represents the exact number of bytes specified when it was created. You can change the data contained within an array buffer but never the size of the array buffer.</em></p>
        </div>
        <h4 class="h4" id="ch10lev2sec08"><em><strong>Manipulating Array Buffers with Views</strong></em></h4>
        <p class="noindent">Array buffers represent memory locations, and <em>views</em> are the interfaces you’ll use to manipulate that memory. A view operates on an array buffer or a subset of an array buffer’s bytes, reading and writing data in one of the numeric data types. The <span class="literal">DataView</span> type is a generic view on an array buffer that allows you to operate on all eight numeric data types.</p>
        <p class="indent">To use a <span class="literal">DataView</span>, you first create an instance of <span class="literal">ArrayBuffer</span> and use it to create a new <span class="literal">DataView</span>. Here’s an example:</p>
        <p class="programs">let buffer = new ArrayBuffer(10),<br>&nbsp;&nbsp;&nbsp;&nbsp;view = new DataView(buffer);</p>
        <p class="indent"><span epub:type="pagebreak" id="page_201"></span>The <span class="literal">view</span> object in this example has access to all 10 bytes in <span class="literal">buffer</span>. You can also create a view over a portion of a buffer. Just provide a byte offset and, optionally, the number of bytes to include from that offset. When a number of bytes isn’t included, the <span class="literal">DataView</span> will go from the offset to the end of the buffer by default. For example:</p>
        <p class="programs">let buffer = new ArrayBuffer(10),<br>&nbsp;&nbsp;&nbsp;&nbsp;view = new DataView(buffer, 5, 2);&nbsp;&nbsp;&nbsp;&nbsp;// cover bytes 5 and 6</p>
        <p class="indent">Here, <span class="literal">view</span> operates only on the bytes at indexes 5 and 6. This approach allows you to create several views over the same array buffer, which can be useful if you want to use a single memory location for an entire application rather than dynamically allocating space as needed.</p>
        <h5 class="h5" id="ch10lev3sec03"><strong>Retrieving View Information</strong></h5>
        <p class="noindentb">You can retrieve information about a view by fetching the following read-only properties:</p>
        <p class="hang"><span class="literal"><span class="codestrong">buffer</span></span> The array buffer that the view is tied to</p>
        <p class="hang"><span class="literal"><span class="codestrong">byteOffset</span></span> The second argument to the <span class="literal">DataView</span> constructor, if provided (0 by default)</p>
        <p class="hang"><span class="literal"><span class="codestrong">byteLength</span></span> The third argument to the <span class="literal">DataView</span> constructor, if provided (the buffer’s <span class="literal">byteLength</span> by default)</p>
        <p class="indentt">Using these properties, you can inspect exactly where a view is operating, like this:</p>
        <p class="programs">let buffer = new ArrayBuffer(10),<br>&nbsp;&nbsp;&nbsp;&nbsp;view1 = new DataView(buffer),&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// cover all bytes<br>&nbsp;&nbsp;&nbsp;&nbsp;view2 = new DataView(buffer, 5, 2);&nbsp;&nbsp;&nbsp;&nbsp;// cover bytes 5 and 6<br><br>console.log(view1.buffer === buffer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(view2.buffer === buffer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(view1.byteOffset);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0<br>console.log(view2.byteOffset);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 5<br>console.log(view1.byteLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 10<br>console.log(view2.byteLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">This code creates <span class="literal">view1</span>, a view over the entire array buffer, and <span class="literal">view2</span>, which operates on a small section of the array buffer. These views have equivalent <span class="literal">buffer</span> properties because both work on the same array buffer. However, the <span class="literal">byteOffset</span> and <span class="literal">byteLength</span> are different for each view. They reflect the portion of the array buffer where each view operates.</p>
        <p class="indent">Of course, reading information about memory isn’t very useful on its own. You need to write data into and read data out of that memory to get any benefit.</p>
        <h5 class="h5" id="ch10lev3sec04"><span epub:type="pagebreak" id="page_202"></span><strong>Reading and Writing Data</strong></h5>
        <p class="noindentb">For each of JavaScript’s eight numeric data types, the <span class="literal">DataView</span> prototype has a method to write data and a method to read data from an array buffer. The method names all begin with either <em>set</em> or <em>get</em> and are followed by the data type abbreviation. For instance, here’s a list of the read and write methods that can operate on int8 and uint8 values:</p>
        <p class="hang"><span class="literal"><span class="codestrong">getInt8(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">byteOffset</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">littleEndian</span></span></span><span class="literal"><span class="codestrong">)</span></span> Read an int8 starting at <span class="literal"><span class="codeitalic">byteOffset</span></span></p>
        <p class="hang"><span class="literal"><span class="codestrong">setInt8(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">byteOffset</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">value</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">littleEndian</span></span></span><span class="literal"><span class="codestrong">)</span></span> Write an int8 starting at <span class="literal"><span class="codeitalic">byteOffset</span></span></p>
        <p class="hang"><span class="literal"><span class="codestrong">getUint8(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">byteOffset</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">littleEndian</span></span></span><span class="literal"><span class="codestrong">)</span></span> Read a uint8 starting at <span class="literal"><span class="codeitalic">byteOffset</span></span></p>
        <p class="hang"><span class="literal"><span class="codestrong">setUint8(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">byteOffset</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">value</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">littleEndian</span></span></span><span class="literal"><span class="codestrong">)</span></span> Write a uint8 starting at <span class="literal"><span class="codeitalic">byteOffset</span></span></p>
        <p class="indentt">The get methods accept two arguments: the byte offset to read from and an optional Boolean indicating whether the value should be read as little-endian. (<em>Little-endian</em> means the least significant byte is at byte 0 instead of in the last byte.) The set methods accept three arguments: the byte offset to write at, the value to write, and an optional Boolean indicating whether the value should be stored in little-endian format.</p>
        <p class="indentb">Although I’ve only shown the methods you can use with 8-bit values, the same methods exist for operating on 16- and 32-bit values. Just replace the <span class="literal">8</span> in each name with <span class="literal">16</span> or <span class="literal">32</span>. In addition to all those integer methods, <span class="literal">DataView</span> also has the following read and write methods for floating-point numbers:</p>
        <p class="hang"><span class="literal"><span class="codestrong">getFloat32(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">byteOffset</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">littleEndian</span></span></span><span class="literal"><span class="codestrong">)</span></span> Read a float32 starting at <span class="literal"><span class="codeitalic">byteOffset</span></span></p>
        <p class="hang"><span class="literal"><span class="codestrong">setFloat32(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">byteOffset</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">value</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">littleEndian</span></span></span><span class="literal"><span class="codestrong">)</span></span> Write a float32 starting at <span class="literal"><span class="codeitalic">byteOffset</span></span></p>
        <p class="hang"><span class="literal"><span class="codestrong">getFloat64(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">byteOffset</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">littleEndian</span></span></span><span class="literal"><span class="codestrong">)</span></span> Read a float64 starting at <span class="literal"><span class="codeitalic">byteOffset</span></span></p>
        <p class="hang"><span class="literal"><span class="codestrong">setFloat64(</span></span><span class="literal"><span class="codeitalic"><span class="codestrong">byteOffset</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">value</span></span></span><span class="literal"><span class="codestrong">,</span></span> <span class="literal"><span class="codeitalic"><span class="codestrong">littleEndian</span></span></span><span class="literal"><span class="codestrong">)</span></span> Write a float64 starting at <span class="literal"><span class="codeitalic">byteOffset</span></span></p>
        <p class="indentt">The following example shows a set and a get method in action:</p>
        <p class="programs">let buffer = new ArrayBuffer(2),<br>&nbsp;&nbsp;&nbsp;&nbsp;view = new DataView(buffer);<br><br>view.setInt8(0, 5);<br>view.setInt8(1, -1);<br><br>console.log(view.getInt8(0));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 5<br>console.log(view.getInt8(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// -1</p>
        <p class="indent">This code uses a two-byte array buffer to store two int8 values. The first value is set at offset 0, and the second is at offset 1, reflecting that each value spans a full byte (8 bits). Those values are later retrieved from their positions <span epub:type="pagebreak" id="page_203"></span>with the <span class="literal">getInt8()</span> method. Although this example uses int8 values, you can use any of the eight numeric types with their corresponding methods.</p>
        <p class="indent">Views are unique because they allow you to read and write in any format at any point in time regardless of how data was previously stored. For instance, writing two int8 values and reading the buffer with an int16 method works just fine, as in this example:</p>
        <p class="programs">let buffer = new ArrayBuffer(2),<br>&nbsp;&nbsp;&nbsp;&nbsp;view = new DataView(buffer);<br><br>view.setInt8(0, 5);<br>view.setInt8(1, -1);<br><br>console.log(view.getInt16(0));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1535<br>console.log(view.getInt8(0));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 5<br>console.log(view.getInt8(1));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// -1</p>
        <p class="indent">The call to <span class="literal">view.getInt16(0)</span> reads all bytes in the view and interprets those bytes as the number 1535. To understand why this happens, look at <a href="ch10.xhtml#ch10fig1">Figure 10-1</a>, which shows what each <span class="literal">setInt8()</span> line does to the array buffer.</p>
        <div class="image"><img src="/api/v2/epubs/urn:orm:book:9781492017509/files/images/f10-01.jpg" alt="image" width="549" height="149"></div>
        <p class="figcap"><a id="ch10fig1"></a><em>Figure 10-1: The array buffer after two method calls</em></p>
        <p class="indent">The array buffer starts with 16 bits that are all 0. Writing 5 to the first byte with <span class="literal">setInt8()</span> introduces a couple of 1s (in 8-bit representation, 5 is 00000101). Writing –1 to the second byte sets all bits in that byte to 1, which is the two’s complement representation of –1. After the second <span class="literal">setInt8()</span> call, the array buffer contains 16 bits, and <span class="literal">getInt16()</span> reads those bits as a single 16-bit integer, which is 1535 in decimal.</p>
        <p class="indent">The <span class="literal">DataView</span> object is perfect for use cases that mix different data types in this way. However, if you’re only using one specific data type, the type-specific views are a better choice.</p>
        <h5 class="h5" id="ch10lev3sec05"><strong>Typed Arrays Are Views</strong></h5>
        <p class="noindent">ECMAScript 6 typed arrays are actually type-specific views for array buffers. Instead of using a generic <span class="literal">DataView</span> object to operate on an array buffer, you can use objects that enforce specific data types. Eight type-specific views correspond to the eight numeric data types, plus an additional option for uint8 values. <a href="ch10.xhtml#ch10tab1">Table 10-1</a> shows an abbreviated version of the complete list of type-specific views in section 22.2 of the ECMAScript 6 specification.</p>
        <p class="tabcap"><span epub:type="pagebreak" id="page_204"></span><a id="ch10tab1"></a><strong>Table 10-1:</strong> Some Type-Specific Views in ECMAScript 6</p>
        <table class="topbot">
        <thead>
        <tr>
        <td style="vertical-align: top;" class="table_th"><p class="table"><strong>Constructor name</strong></p></td>
        <td style="vertical-align: top;" class="table_th"><p class="table"><strong>Element size (in bytes)</strong></p></td>
        <td style="vertical-align: top;" class="table_th"><p class="table"><strong>Description</strong></p></td>
        <td style="vertical-align: top;" class="table_th"><p class="table"><strong>Equivalent C type</strong></p></td>
        </tr>
        </thead>
        <tbody>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Int8Array</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">1</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">8-bit two’s complement signed integer</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">signed char</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Uint8Array</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table">1</p></td>
        <td style="vertical-align: top;" class="table"><p class="table">8-bit unsigned integer</p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">unsigned char</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Uint8ClampedArray</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">1</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">8-bit unsigned integer (clamped conversion)</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">unsigned char</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Int16Array</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table">2</p></td>
        <td style="vertical-align: top;" class="table"><p class="table">16-bit two’s complement signed integer</p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">short</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Uint16Array</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">2</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">16-bit unsigned integer</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">unsigned short</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Int32Array</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table">4</p></td>
        <td style="vertical-align: top;" class="table"><p class="table">32-bit two’s complement signed integer</p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">int</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Uint32Array</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">4</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">32-bit unsigned integer</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">int</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">Float32Array</span></p></td>
        <td style="vertical-align: top;" class="table"><p class="table">4</p></td>
        <td style="vertical-align: top;" class="table"><p class="table">32-bit IEEE floating point</p></td>
        <td style="vertical-align: top;" class="table"><p class="table"><span class="literal">float</span></p></td>
        </tr>
        <tr>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">Float64Array</span></p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">8</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table">64-bit IEEE floating point</p></td>
        <td style="vertical-align: top;" class="table_1"><p class="table"><span class="literal">double</span></p></td>
        </tr>
        </tbody>
        </table>
        <p class="indent">The Constructor name column lists the typed array constructors, and the other columns describe the data each typed array can contain. A <span class="literal">Uint8ClampedArray</span> is the same as a <span class="literal">Uint8Array</span> unless values in the array buffer are less than 0 or greater than 255. A <span class="literal">Uint8ClampedArray</span> converts values less than 0 to 0 (–1 becomes 0, for instance) and converts values greater than 255 to 255 (so 300 becomes 255).</p>
        <p class="indent">Typed array operations only work on a particular type of data. For example, all operations on <span class="literal">Int8Array</span> use int8 values. The size of an element in a typed array also depends on the type of array. Although an element in an <span class="literal">Int8Array</span> is a single byte long, <span class="literal">Float64Array</span> uses eight bytes per element. Fortunately, the elements are accessed using numeric indexes just like regular arrays, allowing you to avoid the somewhat awkward calls to the set and get methods of <span class="literal">DataView</span>.</p>
        <h5 class="h5" id="ch10lev3sec06"><strong>Creating Type-Specific Views</strong></h5>
        <p class="noindent">Typed array constructors accept multiple types of arguments, so you can create typed arrays in a few ways. First, you can create a new typed array by passing the same arguments <span class="literal">DataView</span> takes (an array buffer, an optional byte offset, and an optional byte length). For example:</p>
        <p class="programs">let buffer = new ArrayBuffer(10),<br>&nbsp;&nbsp;&nbsp;&nbsp;view1 = new Int8Array(buffer),<br>&nbsp;&nbsp;&nbsp;&nbsp;view2 = new Int8Array(buffer, 5, 2);<br><br>console.log(view1.buffer === buffer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(view2.buffer === buffer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(view1.byteOffset);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0<br>console.log(view2.byteOffset);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 5<br>console.log(view1.byteLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 10<br>console.log(view2.byteLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent"><span epub:type="pagebreak" id="page_205"></span>In this code, the two views are <span class="literal">Int8Array</span> instances that use <span class="literal">buffer</span>. Both <span class="literal">view1</span> and <span class="literal">view2</span> have the same <span class="literal">buffer</span>, <span class="literal">byteOffset</span>, and <span class="literal">byteLength</span> properties that exist on <span class="literal">DataView</span> instances. It’s easy to switch to using a typed array wherever you use a <span class="literal">DataView</span> as long as you only work with one numeric type.</p>
        <p class="indent">The second way to create a typed array is to pass a single number to the constructor. That number represents the number of elements (not bytes) to allocate to the array. The constructor will create a new buffer with the correct number of bytes to represent that number of array elements, and you can access the number of elements in the array by using the <span class="literal">length</span> property. Here’s an example:</p>
        <p class="programs">let ints = new Int16Array(2),<br>&nbsp;&nbsp;&nbsp;&nbsp;floats = new Float32Array(5);<br><br>console.log(ints.byteLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4<br>console.log(ints.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br><br>console.log(floats.byteLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 20<br>console.log(floats.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 5</p>
        <p class="indent">The <span class="literal">ints</span> array is created with space for two elements. Each 16-bit integer requires two bytes per value, so the array is allocated four bytes. The <span class="literal">floats</span> array is created to hold five elements, so the number of bytes required is 20 (four bytes per element). In both cases, a new buffer is created and can be accessed using the <span class="literal">buffer</span> property if necessary.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>If no argument is passed to a typed array constructor, the constructor acts as if <span class="literal">0</span> was passed. This creates a typed array that cannot hold data because zero bytes are allocated to the buffer.</em></p>
        </div>
        <p class="indentb">The third way to create a typed array is to pass an object as the only argument to the constructor. The object can be any of the following:</p>
        <p class="hang"><strong>A typed array</strong> Each element is copied into a new element on the new typed array. For example, if you pass an int8 to the <span class="literal">Int16Array</span> constructor, the int8 values would be copied into an int16 array. The new typed array has a different array buffer than the one that was passed in.</p>
        <p class="hang"><strong>An iterable</strong> The object’s iterator is called to retrieve the items to insert into the typed array. The constructor will throw an error if any elements are invalid for the view type.</p>
        <p class="hang"><strong>An array</strong> The elements of the array are copied into a new typed array. The constructor will throw an error if any elements are invalid for the type.</p>
        <p class="hang"><strong>An array-like object</strong> The object behaves the same as an array.</p>
        <p class="indentt"><span epub:type="pagebreak" id="page_206"></span>In each of these cases, a new typed array is created with the data from the source object. This can be especially useful when you want to initialize a typed array with some values, like this:</p>
        <p class="programs">let ints1 = new Int16Array([25, 50]),<br>&nbsp;&nbsp;&nbsp;&nbsp;ints2 = new Int32Array(ints1);<br><br>console.log(ints1.buffer === ints2.buffer);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false<br><br>console.log(ints1.byteLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 4<br>console.log(ints1.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(ints1[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 25<br>console.log(ints1[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 50<br><br>console.log(ints2.byteLength);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 8<br>console.log(ints2.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(ints2[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 25<br>console.log(ints2[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 50</p>
        <p class="indent">This example creates an <span class="literal">Int16Array</span> and initializes it with an array of two values. Then, an <span class="literal">Int32Array</span> is created and passed the <span class="literal">Int16Array</span>. The values 25 and 50 are copied from <span class="literal">ints1</span> into <span class="literal">ints2</span> because the two typed arrays have completely separate buffers. The same numbers are represented in both typed arrays, but <span class="literal">ints2</span> has eight bytes to represent the data and <span class="literal">ints1</span> has only four.</p>
        <div class="sidebar">
        <p class="sidebart"><strong>ELEMENT SIZE</strong></p>
        <p class="noindent">Each typed array is made up of a number of elements, and the element size is the number of bytes each element represents. This value is stored on a <span class="literal">BYTES_PER_ELEMENT</span> property on each constructor and each instance, so you can easily query the element size:</p>
        <p class="programs">console.log(UInt8Array.BYTES_PER_ELEMENT);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(UInt16Array.BYTES_PER_ELEMENT);&nbsp;&nbsp;&nbsp;&nbsp;// 2<br><br>let ints = new Int8Array(5);<br>console.log(ints.BYTES_PER_ELEMENT);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1</p>
        <p class="indent">As this code shows, you can check <span class="literal">BYTES_PER_ELEMENT</span> on the different typed array classes, and you can also check it on instances of those classes.</p>
        </div>
        <h3 class="h3" id="ch10lev1sec04"><span epub:type="pagebreak" id="page_207"></span><strong>Similarities Between Typed and Regular Arrays</strong></h3>
        <p class="noindent">Typed arrays and regular arrays are similar in several ways, and as you’ve seen in this chapter, you can use typed arrays like regular arrays in many situations. For instance, you can check how many elements are in a typed array using the <span class="literal">length</span> property, and you can access a typed array’s elements directly using numeric indexes. For example:</p>
        <p class="programs">let ints = new Int16Array([25, 50]);<br><br>console.log(ints.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(ints[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 25<br>console.log(ints[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 50<br><br>ints[0] = 1;<br>ints[1] = 2;<br><br>console.log(ints[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(ints[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2</p>
        <p class="indent">In this code, a new <span class="literal">Int16Array</span> with two items is created. The items are read from and written to using their numeric indexes, and those values are automatically stored and converted into int16 values as part of the operation. But the similarities don’t end there.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Unlike regular arrays, you cannot change the size of a typed array using the <span class="literal">length</span> property. The <span class="literal">length</span> property is not writable, so any attempt to change it is ignored in non-strict mode and throws an error in strict mode.</em></p>
        </div>
        <h4 class="h4" id="ch10lev2sec09"><em><strong>Common Methods</strong></em></h4>
        <p class="noindent">Typed arrays also include many methods that are functionally equivalent to regular array methods. You can use the following array methods on typed arrays:</p>
        <p class="programsa">copyWithin()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;findIndex()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lastIndexOf()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;slice()<br>entries()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;forEach()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;map()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;some()<br>fill()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;indexOf()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reduce()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort()<br>filter()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;join()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reduceRight()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;values()<br>find()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;keys()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;reverse()</p>
        <p class="indent">Keep in mind that although these methods act like their counterparts on <span class="literal">Array.prototype</span>, they’re not exactly the same. The typed array <span epub:type="pagebreak" id="page_208"></span>methods have additional checks for numeric type safety and, when an array is returned, it is a typed array instead of a regular array (due to <span class="literal">Symbol.species</span>). Here’s a simple example to demonstrate the difference:</p>
        <p class="programs">let ints = new Int16Array([25, 50]),<br>&nbsp;&nbsp;&nbsp;&nbsp;mapped = ints.map(v =&gt; v * 2);<br><br>console.log(mapped.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(mapped[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 50<br>console.log(mapped[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 100<br><br>console.log(mapped instanceof Int16Array);&nbsp;&nbsp;// true</p>
        <p class="indent">This code uses the <span class="literal">map()</span> method to create a new array based on the values in <span class="literal">ints</span>. The mapping function doubles each value in the array and returns a new <span class="literal">Int16Array</span>.</p>
        <h4 class="h4" id="ch10lev2sec10"><em><strong>The Same Iterators</strong></em></h4>
        <p class="noindent">Typed arrays have the same three iterators as regular arrays, too. Those are the <span class="literal">entries()</span> method, the <span class="literal">keys()</span> method, and the <span class="literal">values()</span> method. That means you can use the spread operator and <span class="literal">for-of</span> loops with typed arrays just like you would with regular arrays. For example:</p>
        <p class="programs">let ints = new Int16Array([25, 50]),<br>&nbsp;&nbsp;&nbsp;&nbsp;intsArray = [...ints];<br><br>console.log(intsArray instanceof Array);&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(intsArray[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 25<br>console.log(intsArray[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 50</p>
        <p class="indent">This code creates a new array called <span class="literal">intsArray</span> containing the same data as the typed array <span class="literal">ints</span>. As with other iterables, the spread operator makes converting typed arrays into regular arrays easy.</p>
        <h4 class="h4" id="ch10lev2sec11"><em><strong>The of() and from() Methods</strong></em></h4>
        <p class="noindent">Additionally, all typed arrays have static <span class="literal">of()</span> and <span class="literal">from()</span> methods that work like the <span class="literal">Array.of()</span> and <span class="literal">Array.from()</span> methods. The difference is that the methods on typed arrays return a typed array instead of a regular array. Here are some examples that use these methods to create typed arrays:</p>
        <p class="programs">let ints = Int16Array.of(25, 50),<br>&nbsp;&nbsp;&nbsp;&nbsp;floats = Float32Array.from([1.5, 2.5]);<br><br>console.log(ints instanceof Int16Array);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(floats instanceof Float32Array);&nbsp;&nbsp;&nbsp;&nbsp;// true<br><span epub:type="pagebreak" id="page_209"></span><br>console.log(ints.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(ints[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 25<br>console.log(ints[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 50<br><br>console.log(floats.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(floats[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1.5<br>console.log(floats[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2.5</p>
        <p class="indent">The <span class="literal">of()</span> and <span class="literal">from()</span> methods in this example create an <span class="literal">Int16Array</span> and a <span class="literal">Float32Array</span>, respectively. These methods ensure that typed arrays can be created just as easily as regular arrays.</p>
        <h3 class="h3" id="ch10lev1sec05"><strong>Differences Between Typed and Regular Arrays</strong></h3>
        <p class="noindent">The most importance difference between typed arrays and regular arrays is that typed arrays are not regular arrays. Typed arrays don’t inherit from <span class="literal">Array</span> and <span class="literal">Array.isArray()</span> returns <span class="literal">false</span> when passed a typed array. For example:</p>
        <p class="programs">let ints = new Int16Array([25, 50]);<br><br>console.log(ints instanceof Array);&nbsp;&nbsp;&nbsp;&nbsp;// false<br>console.log(Array.isArray(ints));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">Because the <span class="literal">ints</span> variable is a typed array, it isn’t an instance of <span class="literal">Array</span> and cannot be identified as an array. This distinction is important because although typed arrays and regular arrays are similar, typed arrays behave differently in many ways.</p>
        <h4 class="h4" id="ch10lev2sec12"><em><strong>Behavioral Differences</strong></em></h4>
        <p class="noindent">Regular arrays can grow and shrink as you interact with them, but typed arrays always remain the same size. You cannot assign a value to a nonexistent numeric index in a typed array like you can with regular arrays, because typed arrays ignore the operation. Here’s an example:</p>
        <p class="programs">let ints = new Int16Array([25, 50]);<br><br>console.log(ints.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(ints[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 25<br>console.log(ints[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 50<br><br>ints[2] = 5;<br><br>console.log(ints.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(ints[2]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined</p>
        <p class="indent"><span epub:type="pagebreak" id="page_210"></span>Despite assigning 5 to the numeric index 2 in this example, the <span class="literal">ints</span> array does not grow at all. The <span class="literal">length</span> remains the same, and the value is thrown away.</p>
        <p class="indent">Typed arrays also have checks to ensure that only valid data types are used. Zero is used in place of any invalid values. For example:</p>
        <p class="programs">let ints = new Int16Array(["hi"]);<br><br>console.log(ints.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br>console.log(ints[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0</p>
        <p class="indent">This code attempts to use the string value <span class="literal">"hi"</span> in an <span class="literal">Int16Array</span>. Of course, strings are invalid data types in typed arrays, so the value is inserted as 0 instead. The <span class="literal">length</span> of the array is still 1, and even though the <span class="literal">ints[0]</span> slot exists, it just contains 0.</p>
        <p class="indent">All methods that modify values in a typed array enforce the same restriction. For example, if the function passed to <span class="literal">map()</span> returns an invalid value for the type array, then 0 is used instead:</p>
        <p class="programs">let ints = new Int16Array([25, 50]),<br>&nbsp;&nbsp;&nbsp;&nbsp;mapped = ints.map(v =&gt; "hi");<br><br>console.log(mapped.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 2<br>console.log(mapped[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0<br>console.log(mapped[1]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0<br><br>console.log(mapped instanceof Int16Array);&nbsp;&nbsp;// true<br>console.log(mapped instanceof Array);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">Because the string value <span class="literal">"hi"</span> isn’t a 16-bit integer, it’s replaced with 0 in the resulting array. Thanks to this error correction behavior, typed array methods don’t have to throw errors when invalid data is present, because invalid data will never be in the array.</p>
        <h4 class="h4" id="ch10lev2sec13"><em><strong>Missing Methods</strong></em></h4>
        <p class="noindent">Although typed arrays do have many of the same methods as regular arrays, they also lack several array methods. The following methods are not available on typed arrays:</p>
        <p class="programsa">concat()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shift()<br>pop()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;splice()<br>push()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;unshift()</p>
        <p class="indent">Except for the <span class="literal">concat()</span> method, the methods in this list can change the size of an array. Typed arrays can’t change size, which is why these methods aren’t available for typed arrays. The <span class="literal">concat()</span> method isn’t available because <span epub:type="pagebreak" id="page_211"></span>the result of concatenating two typed arrays (especially if they deal with different data types) would be uncertain, and that would contradict the reason for using typed arrays in the first place.</p>
        <h4 class="h4" id="ch10lev2sec14"><em><strong>Additional Methods</strong></em></h4>
        <p class="noindent">Finally, typed array methods have two methods not present on regular arrays: the <span class="literal">set()</span> and <span class="literal">subarray()</span> methods. These two methods are opposites in that <span class="literal">set()</span> copies another array into an existing typed array, whereas <span class="literal">subarray()</span> extracts part of an existing typed array into a new typed array.</p>
        <p class="indent">The <span class="literal">set()</span> method accepts an array (either typed or regular) and an optional offset at which to insert the data; if you pass nothing, the offset defaults to zero. The data from the array argument is copied into the destination typed array while ensuring only valid data types are used. Here’s an example:</p>
        <p class="programs">let ints = new Int16Array(4);<br><br>ints.set([25, 50]);<br>ints.set([75, 100], 2);<br><br>console.log(ints.toString());&nbsp;&nbsp;// 25,50,75,100</p>
        <p class="indent">This code creates an <span class="literal">Int16Array</span> with four elements. The first call to <span class="literal">set()</span> copies two values to the first and second elements in the array. The second call to <span class="literal">set()</span> uses an offset of 2 to indicate that the values should be placed in the array starting at the third element.</p>
        <p class="indent">The <span class="literal">subarray()</span> method accepts an optional start and end index (the end index is exclusive, as in the <span class="literal">slice()</span> method) and returns a new typed array. You can also omit both arguments to create a clone of the typed array. For example:</p>
        <p class="programs">let ints = new Int16Array([25, 50, 75, 100]),<br>&nbsp;&nbsp;&nbsp;&nbsp;subints1 = ints.subarray(),<br>&nbsp;&nbsp;&nbsp;&nbsp;subints2 = ints.subarray(2),<br>&nbsp;&nbsp;&nbsp;&nbsp;subints3 = ints.subarray(1, 3);<br><br>console.log(subints1.toString());&nbsp;&nbsp;&nbsp;// 25,50,75,100<br>console.log(subints2.toString());&nbsp;&nbsp;&nbsp;// 75,100<br>console.log(subints3.toString());&nbsp;&nbsp;&nbsp;// 50,75</p>
        <p class="indent">Three typed arrays are created from the original <span class="literal">ints</span> array in this example. The <span class="literal">subints1</span> array is a clone of <span class="literal">ints</span> that contains the same information. Because the <span class="literal">subints2</span> array copies data starting from index 2, it only contains the last two elements of the <span class="literal">ints</span> array (75 and 100). The <span class="literal">subints3</span> array contains only the middle two elements of the <span class="literal">ints</span> array, because <span class="literal">subarray()</span> was called with a start and an end index.</p>
        <h3 class="h3" id="ch10lev1sec06"><span epub:type="pagebreak" id="page_212"></span><strong>Summary</strong></h3>
        <p class="noindent">ECMAScript 6 continues the work of ECMAScript 5 by making arrays more useful. New features include two more ways to create arrays: the <span class="literal">Array.of()</span> and <span class="literal">Array.from()</span> methods. The <span class="literal">Array.from()</span> method can also convert iterables and array-like objects into arrays. Both methods are inherited by derived array classes and use the <span class="literal">Symbol.species</span> property to determine what type of value should be returned (other inherited methods also use <span class="literal">Symbol.species</span> when returning an array).</p>
        <p class="indent">Also, several new methods on arrays were introduced. The <span class="literal">fill()</span> and <span class="literal">copyWithin()</span> methods allow you to alter array elements in place. The <span class="literal">find()</span> and <span class="literal">findIndex()</span> methods are useful for finding the first element in an array that matches some criteria. The former returns the first element that fits the criteria, and the latter returns the element’s index.</p>
        <p class="indent">Typed arrays are not technically arrays, because they don’t inherit from <span class="literal">Array</span>, but they do look and behave a lot like arrays. Typed arrays contain one of eight different numeric data types and are built upon <span class="literal">ArrayBuffer</span> objects that represent the underlying bits of a number or series of numbers. Typed arrays are a more efficient way of doing bitwise arithmetic because the values are not converted back and forth between formats, as is the case with the JavaScript number type.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com