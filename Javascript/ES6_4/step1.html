<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch01"><span epub:type="pagebreak" id="page_1"></span><strong><span class="big">1</span><br>BLOCK BINDINGS</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">Traditionally, the way variable declarations work has been one tricky part of programming in JavaScript. In most C-based languages, variables (more formally known as <em>bindings</em>, as a name is bound to a value inside a scope) are created at the spot where the declaration occurs. In JavaScript, however, this is not the case. Where your variables are actually created depends on how you declare them, and ECMAScript 6 offers options to make controlling scope easier. This chapter demonstrates why classic <span class="literal">var</span> declarations can be confusing, introduces block-level bindings in ECMAScript 6, and then offers some best practices for using them.</p>
        <h3 class="h3" id="ch01lev1sec01"><span epub:type="pagebreak" id="page_2"></span><strong>var Declarations and Hoisting</strong></h3>
        <p class="noindent">Variable declarations using <span class="literal">var</span> are treated as if they’re at the top of the function (or in the global scope, if declared outside of a function) regardless of where the actual declaration occurs; this is called <em>hoisting</em>. For a demonstration of what hoisting does, consider the following function definition:</p>
        <p class="programs">function getValue(condition) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (condition) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var value = "blue";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// other code<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// value exists here with a value of undefined<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// value exists here with a value of undefined<br>}</p>
        <p class="indent">If you are unfamiliar with JavaScript, you might expect the variable <span class="literal">value</span> to be created only if <span class="literal">condition</span> evaluates to <span class="literal">true</span>. In fact, the variable <span class="literal">value</span> is created regardless. Behind the scenes, the JavaScript engine changes the <span class="literal">getValue</span> function to look like this:</p>
        <p class="programs">function getValue(condition) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;var value;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (condition) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value = "blue";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// other code<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent">The declaration of <span class="literal">value</span> is hoisted to the top, and the initialization remains in the same spot. That means the variable <span class="literal">value</span> is still accessible from within the <span class="literal">else</span> clause. If accessed from the <span class="literal">else</span> clause, the variable would just have a value of <span class="literal">undefined</span> because it hasn’t been initialized in the <span class="literal">else</span> block.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_3"></span>It often takes new JavaScript developers some time to get used to declaration hoisting, and misunderstanding this unique behavior can end up causing bugs. For this reason, ECMAScript 6 introduces block-level scoping options to give developers more control over a variable’s life cycle.</p>
        <h3 class="h3" id="ch01lev1sec02"><strong>Block-Level Declarations</strong></h3>
        <p class="noindentb">Block-level declarations declare bindings that are inaccessible outside a given block scope. <em>Block scopes</em>, also called <em>lexical scopes</em>, are created in the following places:</p>
        <p class="bull">• Inside a function</p>
        <p class="bull">• Inside a block (indicated by the <span class="literal">{</span> and <span class="literal">}</span> characters)</p>
        <p class="indentt">Block scoping is how many C-based languages work, and the introduction of block-level declarations in ECMAScript 6 is intended to provide that same flexibility (and uniformity) to JavaScript.</p>
        <h4 class="h4" id="ch01lev2sec01"><em><strong>let Declarations</strong></em></h4>
        <p class="noindent">The <span class="literal">let</span> declaration syntax is the same as the syntax for <span class="literal">var</span>. You can basically replace <span class="literal">var</span> with <span class="literal">let</span> to declare a variable but limit the variable’s scope to only the current code block (there are a few other subtle differences, which are discussed in “<a href="ch01.xhtml#ch01lev2sec04">The Temporal Dead Zone</a>” on <a href="ch01.xhtml#page_6">page 6</a>). Because <span class="literal">let</span> declarations are not hoisted to the top of the enclosing block, it’s best to place <span class="literal">let</span> declarations first in the block so they’re available to the entire block. Here’s an example:</p>
        <p class="programs">function getValue(condition) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;if (condition) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;let value = "blue";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// other code<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return value;<br>&nbsp;&nbsp;&nbsp;&nbsp;} else {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// value doesn't exist here<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return null;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// value doesn't exist here<br>}</p>
        <p class="indent">This version of the <span class="literal">getValue</span> function behaves more similarly to how you’d expect it to in other C-based languages. Because the variable <span class="literal">value</span> is declared using <span class="literal">let</span> instead of <span class="literal">var</span>, the declaration isn’t hoisted to the top <span epub:type="pagebreak" id="page_4"></span>of the function definition, and the variable <span class="literal">value</span> is no longer accessible once execution flows out of the <span class="literal">if</span> block. If <span class="literal">condition</span> evaluates to <span class="literal">false</span>, then <span class="literal">value</span> is never declared or initialized.</p>
        <h4 class="h4" id="ch01lev2sec02"><em><strong>No Redeclaration</strong></em></h4>
        <p class="noindent">If an identifier has already been defined in a scope, using the identifier in a <span class="literal">let</span> declaration inside that scope causes an error to be thrown. For example:</p>
        <p class="programs">var count = 30;<br><br>// throws an error<br>let count = 40;</p>
        <p class="indent">In this example, <span class="literal">count</span> is declared twice: once with <span class="literal">var</span> and once with <span class="literal">let</span>. Because <span class="literal">let</span> will not redefine an identifier that already exists in the same scope, the <span class="literal">let</span> declaration will throw an error. Conversely, no error is thrown if a <span class="literal">let</span> declaration creates a new variable with the same name as a variable in its containing scope, as demonstrated in the following code:</p>
        <p class="programs">var count = 30;<br><br>if (condition) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// doesn't throw an error<br>&nbsp;&nbsp;&nbsp;&nbsp;let count = 40;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// more code<br>}</p>
        <p class="indent">This <span class="literal">let</span> declaration doesn’t throw an error because it creates a new variable called <span class="literal">count</span> within the <span class="literal">if</span> statement instead of creating <span class="literal">count</span> in the surrounding block. Inside the <span class="literal">if</span> block, this new variable shadows the global <span class="literal">count</span>, preventing access to it until execution exits the block.</p>
        <h4 class="h4" id="ch01lev2sec03"><em><strong>const Declarations</strong></em></h4>
        <p class="noindent">You can also define bindings in ECMAScript 6 with the <span class="literal">const</span> declaration syntax. Bindings declared using <span class="literal">const</span> are considered <em>constants</em>, meaning their values cannot be changed once set. For this reason, every <span class="literal">const</span> binding must be initialized on declaration, as shown in this example:</p>
        <p class="programs">// valid constant<br>const maxItems = 30;<br><br>// syntax error: missing initialization<br>const name;</p>
        <p class="indent"><span epub:type="pagebreak" id="page_5"></span>The <span class="literal">maxItems</span> binding is initialized, so its <span class="literal">const</span> declaration will work without a problem. However, the <span class="literal">name</span> binding would cause a syntax error if you tried to run the program containing this code because <span class="literal">name</span> is not initialized.</p>
        <h5 class="h5" id="ch01lev3sec01"><strong>Constants vs. let Declarations</strong></h5>
        <p class="noindent">Constants, like <span class="literal">let</span> declarations, are block-level declarations. That means constants are no longer accessible once execution flows out of the block in which they were declared, and declarations are not hoisted, as demonstrated in this example:</p>
        <p class="programs">if (condition) {<br>&nbsp;&nbsp;&nbsp;&nbsp;const maxItems = 5;<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// more code<br>}<br><br>// maxItems isn't accessible here</p>
        <p class="indent">In this code, the constant <span class="literal">maxItems</span> is declared within an <span class="literal">if</span> statement. After the statement finishes executing, <span class="literal">maxItems</span> is not accessible outside that block.</p>
        <p class="indent">In another similarity to <span class="literal">let</span>, a <span class="literal">const</span> declaration throws an error when made with an identifier for an already defined variable in the same scope. It doesn’t matter whether that variable was declared using <span class="literal">var</span> (for global or function scope) or <span class="literal">let</span> (for block scope). For example, consider this code:</p>
        <p class="programs">var message = "Hello!";<br>let age = 25;<br><br>// each of these throws an error<br>const message = "Goodbye!";<br>const age = 30;</p>
        <p class="indent">The two <span class="literal">const</span> declarations would be valid alone, but given the previous <span class="literal">var</span> and <span class="literal">let</span> declarations in this case, they are syntax errors.</p>
        <p class="indent">Despite those similarities, there is one significant difference between <span class="literal">let</span> and <span class="literal">const</span>. Attempting to assign a <span class="literal">const</span> to a previously defined constant will throw an error in both strict and non-strict modes:</p>
        <p class="programs">const maxItems = 5;<br><br>// throws an error<br>maxItems = 6;</p>
        <p class="indent">Much like constants in other languages, the <span class="literal">maxItems</span> variable can’t be assigned a new value later on. However, unlike constants in other languages, the value a constant holds can be modified if it is an object.</p>
        <h5 class="h5" id="ch01lev3sec02"><span epub:type="pagebreak" id="page_6"></span><strong>Object Declarations with const</strong></h5>
        <p class="noindent">A <span class="literal">const</span> declaration prevents modification of the binding, not of the value. That means <span class="literal">const</span> declarations for objects don’t prevent modification of those objects. For example:</p>
        <p class="programs">const person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Nicholas"<br>};<br><br>// works<br>person.name = "Greg";<br><br>// throws an error<br>person = {<br>&nbsp;&nbsp;&nbsp;&nbsp;name: "Greg"<br>};</p>
        <p class="indent">Here, the binding <span class="literal">person</span> is created with an initial value of an object with one property. It’s possible to change <span class="literal">person.name</span> without causing an error because this changes what <span class="literal">person</span> contains but doesn’t change the value that <span class="literal">person</span> is bound to. When this code attempts to assign a value to <span class="literal">person</span> (thus attempting to change the binding), an error will be thrown. This subtlety in how <span class="literal">const</span> works with objects is easy to misunderstand. Just keep in mind that <span class="literal">const</span> prevents modification of the binding, not modification of the bound value.</p>
        <h4 class="h4" id="ch01lev2sec04"><em><strong>The Temporal Dead Zone</strong></em></h4>
        <p class="noindent">A variable declared with either <span class="literal">let</span> or <span class="literal">const</span> cannot be accessed until after the declaration. Attempting to do so results in a reference error, even when using normally safe operations, such as the <span class="literal">typeof</span> operation in this <span class="literal">if</span> statement:</p>
        <p class="programs">if (condition) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(typeof value);&nbsp;&nbsp;// throws an error<br>&nbsp;&nbsp;&nbsp;&nbsp;let value = "blue";<br>}</p>
        <p class="indent">Here, the variable <span class="literal">value</span> is defined and initialized using <span class="literal">let</span>, but that statement is never executed because the previous line throws an error. The issue is that <span class="literal">value</span> exists in what the JavaScript community has dubbed the <em>temporal dead zone (TDZ)</em>. The TDZ is never named explicitly in the ECMAScript specification, but the term is often used to describe why <span class="literal">let</span> and <span class="literal">const</span> bindings are not accessible before their declaration. This section covers some subtleties of declaration placement that the TDZ causes, and although the examples shown use <span class="literal">let</span>, note that the same information applies to <span class="literal">const</span>.</p>
        <p class="indent">When a JavaScript engine looks through an upcoming block and finds a variable declaration, it either hoists the declaration to the top of the function or global scope (for <span class="literal">var</span>) or places the declaration in the TDZ (for <span class="literal">let</span> and <span class="literal">const</span>). Any attempt to access a variable in the TDZ results in a runtime <span epub:type="pagebreak" id="page_7"></span>error. That variable is only removed from the TDZ, and therefore is safe to use, once execution flows to the variable declaration.</p>
        <p class="indent">This is true anytime you attempt to use a variable declared with <span class="literal">let</span> or <span class="literal">const</span> before it’s been defined. As the previous example demonstrated, this even applies to the normally safe <span class="literal">typeof</span> operator. However, you can use <span class="literal">typeof</span> on a variable outside the block where that variable is declared without throwing an error, although it may not produce the results you’re after. Consider this code:</p>
        <p class="programs">console.log(typeof value);&nbsp;&nbsp;&nbsp;&nbsp;// "undefined"<br><br>if (condition) {<br>&nbsp;&nbsp;&nbsp;&nbsp;let value = "blue";<br>}</p>
        <p class="indent">The variable <span class="literal">value</span> isn’t in the TDZ when the <span class="literal">typeof</span> operation executes because it occurs outside the block in which <span class="literal">value</span> is declared. That means there is no <span class="literal">value</span> binding, and <span class="literal">typeof</span> simply returns <span class="literal">"undefined"</span>.</p>
        <p class="indent">The TDZ is just one unique aspect of block bindings. Another unique aspect has to do with their use inside loops.</p>
        <h3 class="h3" id="ch01lev1sec03"><strong>Block Bindings in Loops</strong></h3>
        <p class="noindent">Perhaps one area where developers most want block-level scoping of variables is within <span class="literal">for</span> loops, where the throwaway counter variable is meant to be used only inside the loop. For instance, it’s not uncommon to see code like this in JavaScript:</p>
        <p class="programs">for (var i = 0; i &lt; 10; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;process(items[i]);<br>}<br><br>// i is still accessible here<br>console.log(i);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 10</p>
        <p class="indent">In other languages where block-level scoping is the default, this example should work as intended—only the <span class="literal">for</span> loop should have access to the <span class="literal">i</span> variable. However, in JavaScript, the variable <span class="literal">i</span> is still accessible after the loop is completed because the <span class="literal">var</span> declaration is hoisted. Using <span class="literal">let</span> instead, as in the following code, should produce the intended behavior:</p>
        <p class="programs">for (let i = 0; i &lt; 10; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;process(items[i]);<br>}<br><br>// i is not accessible here - throws an error<br>console.log(i);</p>
        <p class="indent">In this example, the variable <span class="literal">i</span> exists only within the <span class="literal">for</span> loop. When the loop is complete, the variable is no longer accessible elsewhere.</p>
        <h4 class="h4" id="ch01lev2sec05"><span epub:type="pagebreak" id="page_8"></span><em><strong>Functions in Loops</strong></em></h4>
        <p class="noindent">The characteristics of <span class="literal">var</span> have long made creating functions inside loops problematic, because the loop variables are accessible from outside the scope of the loop. Consider the following code:</p>
        <p class="programs">var funcs = [];<br><br>for (var i = 0; i &lt; 10; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;funcs.push(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}<br><br>funcs.forEach(function(func) {<br>&nbsp;&nbsp;&nbsp;&nbsp;func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// outputs the number "10" ten times<br>});</p>
        <p class="indent">You might ordinarily expect this code to print the numbers 0 to 9, but it outputs the number 10 ten times in a row. The reason is that <span class="literal">i</span> is shared across each iteration of the loop, meaning the functions created inside the loop all hold a reference to the same variable. The variable <span class="literal">i</span> has a value of 10 when the loop completes, so when <span class="literal">console.log(i)</span> is called, that value prints each time.</p>
        <p class="indent">To fix this problem, developers use <em>immediately invoked function expressions (IIFEs)</em> inside loops to force a new copy of the variable they want to iterate over to be created, as in this example:</p>
        <p class="programs">var funcs = [];<br><br>for (var i = 0; i &lt; 10; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;funcs.push((function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(value);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}(i)));<br>}<br><br>funcs.forEach(function(func) {<br>&nbsp;&nbsp;&nbsp;&nbsp;func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// outputs 0, then 1, then 2, up to 9<br>});</p>
        <p class="indent">This version uses an IIFE inside the loop. The <span class="literal">i</span> variable is passed to the IIFE, which creates its own copy and stores it as <span class="literal">value</span>. This is the value used by the function for that iteration, so calling each function returns the expected value as the loop counts up from 0 to 9. Fortunately, block-level binding with <span class="literal">let</span> and <span class="literal">const</span> in ECMAScript 6 can simplify this loop for you.</p>
        <h4 class="h4" id="ch01lev2sec06"><span epub:type="pagebreak" id="page_9"></span><em><strong>let Declarations in Loops</strong></em></h4>
        <p class="noindent">A <span class="literal">let</span> declaration simplifies loops by effectively mimicking what the IIFE does in the previous example. On each iteration, the loop creates a new variable and initializes it to the value of the variable with the same name from the previous iteration. That means you can omit the IIFE altogether and get the results you expect, like this:</p>
        <p class="programs">var funcs = [];<br><br>for (let i = 0; i &lt; 10; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;funcs.push(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}<br><br>funcs.forEach(function(func) {<br>&nbsp;&nbsp;&nbsp;&nbsp;func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// outputs 0, then 1, then 2, up to 9<br>})</p>
        <p class="indent">This loop works exactly like the loop that used <span class="literal">var</span> and an IIFE but is arguably cleaner. The <span class="literal">let</span> declaration creates a new variable <span class="literal">i</span> each time through the loop, so each function created inside the loop gets its own copy of <span class="literal">i</span>. Each copy of <span class="literal">i</span> has the value it was assigned at the beginning of the loop iteration in which it was created. The same is true for <span class="literal">for-in</span> and <span class="literal">for-of</span> loops, as shown here:</p>
        <p class="programs">var funcs = [],<br>&nbsp;&nbsp;&nbsp;&nbsp;object = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c: true<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>for (let key in object) {<br>&nbsp;&nbsp;&nbsp;&nbsp;funcs.push(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}<br><br>funcs.forEach(function(func) {<br>&nbsp;&nbsp;&nbsp;&nbsp;func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// outputs "a", then "b", then "c"<br>});</p>
        <p class="indent">In this example, the <span class="literal">for-in</span> loop shows the same behavior as the <span class="literal">for</span> loop. Each time through the loop, a new <span class="literal">key</span> binding is created, so each function has its own copy of the <span class="literal">key</span> variable. The result is that each function outputs a different value. If <span class="literal">var</span> were used to declare <span class="literal">key</span>, all functions would output <span class="literal">"c"</span>.</p>
        <div class="note">
        <p class="notet"><span epub:type="pagebreak" id="page_10"></span><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>It’s important to understand that the behavior of <span class="literal">let</span> declarations in loops is a specially defined behavior in the specification and is not necessarily related to the non-hoisting characteristics of <span class="literal">let</span>. In fact, early implementations of <span class="literal">let</span> did not exhibit this behavior, because it was added later in the process.</em></p>
        </div>
        <h4 class="h4" id="ch01lev2sec07"><em><strong>const Declarations in Loops</strong></em></h4>
        <p class="noindent">The ECMAScript 6 specification doesn’t explicitly disallow <span class="literal">const</span> declarations in loops; however, <span class="literal">const</span> behaves differently based on the type of loop you’re using. For a normal <span class="literal">for</span> loop, you can use <span class="literal">const</span> in the initializer, but the loop will throw a warning if you attempt to change the value. For example:</p>
        <p class="programs">var funcs = [];<br><br>// throws an error after one iteration<br>for (const i = 0; i &lt; 10; i++) {<br>&nbsp;&nbsp;&nbsp;&nbsp;funcs.push(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(i);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}</p>
        <p class="indent">In this code, the <span class="literal">i</span> variable is declared as a constant. The first iteration of the loop, where <span class="literal">i</span> is 0, executes successfully. An error is thrown when <span class="literal">i++</span> executes because it’s attempting to modify a constant. As such, you can only use <span class="literal">const</span> to declare a variable in the loop initializer if you’re not modifying that variable.</p>
        <p class="indent">On the other hand, when used in a <span class="literal">for-in</span> or <span class="literal">for-of</span> loop, a <span class="literal">const</span> variable behaves similarly to a <span class="literal">let</span> variable. Therefore, the following should not cause an error:</p>
        <p class="programs">var funcs = [],<br>&nbsp;&nbsp;&nbsp;&nbsp;object = {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;a: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c: true<br>&nbsp;&nbsp;&nbsp;&nbsp;};<br><br>// doesn't cause an error<br>for (const key in object) {<br>&nbsp;&nbsp;&nbsp;&nbsp;funcs.push(function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(key);<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br>}<br><br>funcs.forEach(function(func) {<br>&nbsp;&nbsp;&nbsp;&nbsp;func();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// outputs "a", then "b", then "c"<br>});</p>
        <p class="indent"><span epub:type="pagebreak" id="page_11"></span>This code functions almost the same as the second example in “<a href="ch01.xhtml#ch01lev2sec06"><span class="literal">let</span> Declarations in Loops</a>” on <a href="ch01.xhtml#page_9">page 9</a>. The only difference is that the value of <span class="literal">key</span> cannot be changed inside the loop. The <span class="literal">for-in</span> and <span class="literal">for-of</span> loops work with <span class="literal">const</span> because the loop initializer creates a new binding on each iteration through the loop rather than attempting to modify the value of an existing binding (as was the case in the <span class="literal">for</span> loop example).</p>
        <h3 class="h3" id="ch01lev1sec04"><strong>Global Block Bindings</strong></h3>
        <p class="noindent">Another way in which <span class="literal">let</span> and <span class="literal">const</span> are different from <span class="literal">var</span> is in their global scope behavior. When <span class="literal">var</span> is used in the global scope, it creates a new global variable, which is a property on the global object (<span class="literal">window</span> in browsers). That means you can accidentally overwrite an existing global using <span class="literal">var</span>, as this code does:</p>
        <p class="programs">// in a browser<br>var RegExp = "Hello!";<br>console.log(window.RegExp);&nbsp;&nbsp;&nbsp;&nbsp;// "Hello!"<br><br>var ncz = "Hi!";<br>console.log(window.ncz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hi!"</p>
        <p class="indent">Even though the <span class="literal">RegExp</span> global is defined on the <span class="literal">window</span> object, it is not safe from being overwritten by a <span class="literal">var</span> declaration. This example declares a new global variable <span class="literal">RegExp</span> that overwrites the original. Similarly, <span class="literal">ncz</span> is defined as a global variable and then defined as a property on <span class="literal">window</span> immediately afterward, which is the way JavaScript has always worked.</p>
        <p class="indent">If you instead use <span class="literal">let</span> or <span class="literal">const</span> in the global scope, a new binding is created in the global scope but no property is added to the global object. That also means you cannot overwrite a global variable using <span class="literal">let</span> or <span class="literal">const</span> declarations; you can only shadow it. Here’s an example:</p>
        <p class="programs">// in a browser<br>let RegExp = "Hello!";<br>console.log(RegExp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hello!"<br>console.log(window.RegExp === RegExp);&nbsp;&nbsp;// false<br><br>const ncz = "Hi!";<br>console.log(ncz);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hi!"<br>console.log("ncz" in window);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">A new <span class="literal">let</span> declaration for <span class="literal">RegExp</span> creates a binding that shadows the global <span class="literal">RegExp</span>. Because <span class="literal">window.RegExp</span> and <span class="literal">RegExp</span> are not the same, there is no disruption to the global scope. Also, the <span class="literal">const</span> declaration for <span class="literal">ncz</span> creates a binding but does not create a property on the global object. This lack of global object modification makes <span class="literal">let</span> and <span class="literal">const</span> much safer to use in the global scope when you don’t want to create properties on the global object.</p>
        <div class="note">
        <p class="notet"><span epub:type="pagebreak" id="page_12"></span><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>You might still want to use <span class="literal">var</span> in the global scope if you have code that should be available from the global object. This is most common in a browser when you want to access code across frames or windows.</em></p>
        </div>
        <h3 class="h3" id="ch01lev1sec05"><strong>Emerging Best Practices for Block Bindings</strong></h3>
        <p class="noindent">While ECMAScript 6 was in development, there was widespread belief you should use <span class="literal">let</span> by default instead of <span class="literal">var</span> for variable declarations. For many JavaScript developers, <span class="literal">let</span> behaves exactly the way they thought <span class="literal">var</span> should have behaved, so the direct replacement made logical sense. In this case, you would use <span class="literal">const</span> for variables that needed modification protection.</p>
        <p class="indent">However, as more developers migrated to ECMAScript 6, an alternate approach gained popularity: use <span class="literal">const</span> by default, and only use <span class="literal">let</span> when you know a variable’s value needs to change. The rationale is that most variables should not change their value after initialization because unexpected value changes are a source of bugs. This idea has a significant amount of traction and is worth exploring in your code as you adopt ECMAScript 6.</p>
        <h3 class="h3" id="ch01lev1sec06"><strong>Summary</strong></h3>
        <p class="noindent">The <span class="literal">let</span> and <span class="literal">const</span> block bindings introduce lexical scoping to JavaScript. These declarations are not hoisted and only exist within the block in which they’re declared. Block bindings offer behavior that is more like other languages and less likely to cause unintentional errors, because variables can now be declared exactly where they’re needed. As a side effect, you cannot access variables before they’re declared, even with safe operators, such as <span class="literal">typeof</span>. Attempting to access a block binding before its declaration results in an error due to the binding’s presence in the TDZ.</p>
        <p class="indent">In many cases, <span class="literal">let</span> and <span class="literal">const</span> behave in a manner similar to <span class="literal">var</span>; however, this is not true in loops. Inside <span class="literal">for-in</span> and <span class="literal">for-of</span> loops, both <span class="literal">let</span> and <span class="literal">const</span> create a new binding with each iteration through the loop. As a result, functions created inside the loop body can access the loop bindings’ current values rather than their values after the loop’s final iteration (the behavior with <span class="literal">var</span>). The same is true for <span class="literal">let</span> declarations in <span class="literal">for</span> loops, whereas attempting to use a <span class="literal">const</span> declaration in a <span class="literal">for</span> loop may result in an error.</p>
        <p class="indent">The current best practice for block bindings is to use <span class="literal">const</span> by default and only use <span class="literal">let</span> when you know a variable’s value needs to change. Doing so ensures a basic level of immutability in code that can help prevent certain types of errors.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com