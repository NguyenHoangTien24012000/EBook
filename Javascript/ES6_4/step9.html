<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content" class="noOutline" tabindex="-1"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch09"><span epub:type="pagebreak" id="page_165"></span><strong><span class="big">9</span><br>INTRODUCING JAVASCRIPT CLASSES</strong></h2>
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492017509/files/images/common-01.jpg" alt="image" width="204" height="203"></div>
        <p class="noindent">Unlike most formal object-oriented programming languages, JavaScript didn’t support classes and classical inheritance as the primary way of defining similar and related objects when it was created. This left many developers confused, and from pre–ECMAScript 1 through ECMAScript 5, many libraries created utilities to make JavaScript look like it supported classes. Although some JavaScript developers feel strongly that the language doesn’t need classes, the number of libraries created specifically for this purpose led to the inclusion of classes in ECMAScript 6.</p>
        <p class="indent">When you’re exploring ECMAScript 6 classes, it’s helpful to understand the underlying mechanisms that classes use, so this chapter starts by discussing how ECMAScript 5 developers achieved class-like behavior. However, as you’ll see, ECMAScript 6 classes aren’t the same as classes in other languages. They have a uniqueness that embraces the dynamic nature of JavaScript.</p>
        <h3 class="h3" id="ch09lev1sec01"><span epub:type="pagebreak" id="page_166"></span><strong>Class-Like Structures in ECMAScript 5</strong></h3>
        <p class="noindent">As mentioned, in ECMAScript 5 and earlier, JavaScript had no classes. The closest equivalent to a class was creating a constructor and then assigning methods to the constructor’s prototype, an approach typically called creating a custom type. For example:</p>
        <p class="programs">function PersonType(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>}<br><br>PersonType.prototype.sayName = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>};<br><br>var person = new PersonType("Nicholas");<br>person.sayName();&nbsp;&nbsp;&nbsp;// outputs "Nicholas"<br><br>console.log(person instanceof PersonType);&nbsp;&nbsp;// true<br>console.log(person instanceof Object);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">In this code, <span class="literal">PersonType</span> is a constructor function that creates a single property called <span class="literal">name</span>. The <span class="literal">sayName()</span> method is assigned to the prototype so the same function is shared by all instances of the <span class="literal">PersonType</span> object. Then, a new instance of <span class="literal">PersonType</span> is created via the <span class="literal">new</span> operator. The resulting <span class="literal">person</span> object is considered an instance of <span class="literal">PersonType</span> and of <span class="literal">Object</span> through prototypal inheritance.</p>
        <p class="indent">This basic pattern underlies many of the class-mimicking JavaScript libraries, and that’s where ECMAScript 6 classes start.</p>
        <h3 class="h3" id="ch09lev1sec02"><strong>Class Declarations</strong></h3>
        <p class="noindent">The simplest class form in ECMAScript 6 is the class declaration, which looks similar to classes in other languages.</p>
        <h4 class="h4" id="ch09lev2sec01"><em><strong>A Basic Class Declaration</strong></em></h4>
        <p class="noindent">Class declarations begin with the <span class="literal">class</span> keyword followed by the name of the class. The rest of the syntax looks similar to concise methods in object literals but doesn’t require commas between the elements of the class. Here’s a simple class declaration:</p>
        <p class="programs">class PersonClass {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of the PersonType constructor<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of PersonType.prototype.sayName<br>&nbsp;&nbsp;&nbsp;&nbsp;sayName() {<br><span epub:type="pagebreak" id="page_167"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let person = new PersonClass("Nicholas");<br>person.sayName();&nbsp;&nbsp;&nbsp;// outputs "Nicholas"<br><br>console.log(person instanceof PersonClass);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(person instanceof Object);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>console.log(typeof PersonClass);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "function"<br>console.log(typeof PersonClass.prototype.sayName);&nbsp;&nbsp;// "function"</p>
        <p class="indent">The class declaration for <span class="literal">PersonClass</span> behaves similarly to <span class="literal">PersonType</span> in the previous example. But instead of defining a function as the constructor, class declarations allow you to define the constructor directly inside the class using the special <span class="literal">constructor</span> method name. Because class methods use the concise syntax, there’s no need to use the <span class="literal">function</span> keyword. All other method names have no special meaning, so you can add as many methods as you want.</p>
        <p class="indent"><em>Own properties</em>, properties that occur on the instance rather than the prototype, can only be created inside a class constructor or method. In this example, <span class="literal">name</span> is an own property. I recommend creating all possible own properties inside the constructor function so a single place in the class is responsible for all of them.</p>
        <p class="indent">Interestingly, class declarations are just syntactic sugar on top of the existing custom type declarations. The <span class="literal">PersonClass</span> declaration actually creates a function that has the behavior of the <span class="literal">constructor</span> method, which is why <span class="literal">typeof PersonClass</span> gives <span class="literal">"function"</span> as the result. The <span class="literal">sayName()</span> method also ends up as a method on <span class="literal">PersonClass.prototype</span> in this example, similar to the relationship between <span class="literal">sayName()</span> and <span class="literal">PersonType.prototype</span> in the previous example. These similarities allow you to mix custom types and classes without worrying too much about which you’re using.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Class prototypes, such as <span class="literal">PersonClass.prototype</span> in the preceding example, are read-only. That means you cannot assign a new value to the prototype like you can with functions.</em></p>
        </div>
        <h4 class="h4" id="ch09lev2sec02"><em><strong>Why Use the Class Syntax?</strong></em></h4>
        <p class="noindentb">Despite the similarities between classes and custom types, you need to keep some important differences in mind:</p>
        <p class="bull">• Class declarations, unlike function declarations, are not hoisted. Class declarations act like <span class="literal">let</span> declarations, so they exist in the temporal dead zone until execution reaches the declaration.</p>
        <p class="bull">• All code inside class declarations runs in strict mode automatically. There’s no way to opt out of strict mode inside classes.</p>
        <p class="bull">• All methods are nonenumerable. This is a significant change from custom types, where you need to use <span class="literal">Object.defineProperty()</span> to make a method nonenumerable.</p>
        <p class="bull"><span epub:type="pagebreak" id="page_168"></span>• All methods lack an internal <span class="literal">[[Construct]]</span> method and will throw an error if you try to call them with <span class="literal">new</span>.</p>
        <p class="bull">• Calling the class constructor without <span class="literal">new</span> throws an error.</p>
        <p class="bull">• Attempting to overwrite the class name within a class method throws an error.</p>
        <p class="indentt">With all of these differences in mind, the <span class="literal">PersonClass</span> declaration in the previous example is directly equivalent to the following code, which doesn’t use the class syntax:</p>
        <p class="programs">// direct equivalent of PersonClass<br>let PersonType2 = (function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;"use strict";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;const PersonType2 = function(name) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// make sure the function was called with new<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof new.target === "undefined") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Constructor must be called with new.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Object.defineProperty(PersonType2.prototype, "sayName", {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// make sure the method wasn't called with new<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof new.target !== "undefined") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Method cannot be called with new.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enumerable: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writable: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configurable: true<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return PersonType2;<br>}());</p>
        <p class="indent">First, notice that there are two <span class="literal">PersonType2</span> declarations: a <span class="literal">let</span> declaration in the outer scope and a <span class="literal">const</span> declaration inside the immediately invoked function expression (IIFE)—this is how class methods are forbidden from overwriting the class name while code outside the class is allowed to do so. The constructor function checks <span class="literal">new.target</span> to ensure that it’s being called with <span class="literal">new</span>; if not, an error is thrown. Next, the <span class="literal">sayName()</span> method is defined as nonenumerable, and the method checks <span class="literal">new.target</span> to ensure that it wasn’t called with <span class="literal">new</span>. The final step returns the constructor function.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_169"></span>This example shows that although it’s possible to do everything classes do without using the new syntax, the class syntax simplifies the functionality significantly.</p>
        <div class="sidebar">
        <p class="sidebart"><strong>CONSTANT CLASS NAMES</strong></p>
        <p class="noindent">The class name is only constant inside the class itself. That means you can overwrite the class name outside the class but not inside a class method. For example:</p>
        <p class="programs">class Foo {<br>&nbsp;&nbsp;&nbsp;constructor() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Foo = "bar";&nbsp;&nbsp;&nbsp;&nbsp;// throws an error when executed...<br>&nbsp;&nbsp;&nbsp;}<br>}<br><br>// but this is okay after the class declaration<br>Foo = "baz";</p>
        <p class="indent">In this code, the <span class="literal">Foo</span> inside the class constructor is a separate binding from the <span class="literal">Foo</span> outside the class. The internal <span class="literal">Foo</span> is defined as if it’s a <span class="literal">const</span> and cannot be overwritten. An error is thrown when the constructor attempts to overwrite <span class="literal">Foo</span> with any value. But because the external <span class="literal">Foo</span> is defined as if it’s a <span class="literal">let</span> declaration, you can overwrite its value at any time.</p>
        </div>
        <h3 class="h3" id="ch09lev1sec03"><strong>Class Expressions</strong></h3>
        <p class="noindent">Classes and functions are similar in that they have two forms: declarations and expressions. Function and class declarations begin with an appropriate keyword (<span class="literal">function</span> or <span class="literal">class</span>, respectively) followed by an identifier. Functions have an expression form that doesn’t require an identifier after <span class="literal">function</span>; similarly, classes have an expression form that doesn’t require an identifier after <span class="literal">class</span>. These <em>class expressions</em> are designed to be used in variable declarations or passed into functions as arguments.</p>
        <h4 class="h4" id="ch09lev2sec03"><em><strong>A Basic Class Expression</strong></em></h4>
        <p class="noindent">Here’s the class expression equivalent of the previous <span class="literal">PersonClass</span> examples, followed by some code that uses it:</p>
        <p class="programs">let PersonClass = class {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of the PersonType constructor<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><span epub:type="pagebreak" id="page_170"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of PersonType.prototype.sayName<br>&nbsp;&nbsp;&nbsp;&nbsp;sayName() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let person = new PersonClass("Nicholas");<br>person.sayName();&nbsp;&nbsp;&nbsp;// outputs "Nicholas"<br><br>console.log(person instanceof PersonClass);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(person instanceof Object);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br><br>console.log(typeof PersonClass);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "function"<br>console.log(typeof PersonClass.prototype.sayName);&nbsp;&nbsp;// "function"</p>
        <p class="indent">As this example demonstrates, class expressions do not require identifiers after <span class="literal">class</span>. Aside from the syntax, class expressions are functionally equivalent to class declarations. In anonymous class expressions, as in the preceding example, <span class="literal">PersonClass.name</span> is an empty string. When you’re using a class declaration, <span class="literal">PersonClass.name</span> would be the <span class="literal">"PersonClass"</span> string.</p>
        <p class="indent">Whether you use class declarations or class expressions is mostly a matter of style. Unlike function declarations and function expressions, class declarations and class expressions are not hoisted, so your choice has little bearing on the code’s runtime behavior. The only significant difference is that anonymous class expressions have a <span class="literal">name</span> property that is an empty string, whereas class declarations always have a <span class="literal">name</span> property equal to the class name (for instance, <span class="literal">PersonClass.name</span> is <span class="literal">"PersonClass"</span> when you’re using a class declaration).</p>
        <h4 class="h4" id="ch09lev2sec04"><em><strong>Named Class Expressions</strong></em></h4>
        <p class="noindent">The previous example used an anonymous class expression, but just like function expressions, you can also name class expressions. To do so, include an identifier after the <span class="literal">class</span> keyword, like this:</p>
        <p class="programs">let PersonClass = class PersonClass2 {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of the PersonType constructor<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of PersonType.prototype.sayName<br>&nbsp;&nbsp;&nbsp;&nbsp;sayName() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>console.log(typeof PersonClass);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "function"<br>console.log(typeof PersonClass2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "undefined"</p>
        <p class="indent"><span epub:type="pagebreak" id="page_171"></span>In this example, the class expression is named <span class="literal">PersonClass2</span>. The <span class="literal">PersonClass2</span> identifier exists only within the class definition so it can be used inside class methods (such as the <span class="literal">sayName()</span> method). Outside the class, <span class="literal">typeof PersonClass2</span> is <span class="literal">"undefined"</span> because no <span class="literal">PersonClass2</span> binding exists there; to understand why, look at an equivalent declaration that doesn’t use classes:</p>
        <p class="programs">// direct equivalent of PersonClass named class expression<br>let PersonClass = (function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;"use strict";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;const PersonClass2 = function(name) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// make sure the function was called with new<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof new.target === "undefined") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Constructor must be called with new.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;Object.defineProperty(PersonClass2.prototype, "sayName", {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// make sure the method wasn't called with new<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof new.target !== "undefined") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Method cannot be called with new.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enumerable: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writable: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configurable: true<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return PersonClass2;<br>}());</p>
        <p class="indent">Creating a named class expression slightly changes what’s happening in the JavaScript engine. For class declarations, the outer binding (defined with <span class="literal">let</span>) has the same name as the inner binding (defined with <span class="literal">const</span>). A named class expression uses its name in the <span class="literal">const</span> definition, so <span class="literal">PersonClass2</span> is defined for use only inside the class.</p>
        <p class="indent">Although named class expressions behave differently from named function expressions, there are still many similarities between the two. Both can be used as values, and that opens several possibilities, which I’ll cover next.</p>
        <h3 class="h3" id="ch09lev1sec04"><span epub:type="pagebreak" id="page_172"></span><strong>Classes as First-Class Citizens</strong></h3>
        <p class="noindent">In programming, a <em>first-class citizen</em> is a value that can be passed into a function, returned from a function, and assigned to a variable. JavaScript functions are first-class citizens (also called <em>first-class functions</em>), and they’re part of what makes JavaScript unique.</p>
        <p class="indent">ECMAScript 6 continues this tradition by making classes first-class citizens as well, allowing you to use classes in many different ways. For example, you can pass them into functions as arguments:</p>
        <p class="programs">function createObject(classDef) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return new classDef();<br>}<br><br>let obj = createObject(class {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;sayHi() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log("Hi!");<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>obj.sayHi();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Hi!"</p>
        <p class="indent">In this example, the <span class="literal">createObject()</span> function is called with an anonymous class expression as an argument, creates an instance of that class with <span class="literal">new</span>, and returns the instance. The variable <span class="literal">obj</span> then stores the returned instance.</p>
        <p class="indent">Another use of class expressions is creating singletons by immediately invoking the class constructor. To do so, you must use <span class="literal">new</span> with a class expression and include parentheses at the end. For example:</p>
        <p class="programs">let person = new class {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;sayName() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>}("Nicholas");<br><br>person.sayName();&nbsp;&nbsp;&nbsp;// "Nicholas"</p>
        <p class="indent">Here, an anonymous class expression is created and then executed immediately. This pattern allows you to use the class syntax for creating singletons without leaving a class reference available for inspection. The parentheses at the end of the class expression indicate that you’re calling a function and also allow you to pass in an argument.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_173"></span>The examples in this chapter so far have focused on classes with methods. But you can also create accessor properties on classes using a syntax similar to object literals.</p>
        <h3 class="h3" id="ch09lev1sec05"><strong>Accessor Properties</strong></h3>
        <p class="noindent">Although you should create own properties inside class constructors, classes allow you to define accessor properties on the prototype. To create a getter, use the keyword <span class="literal">get</span> followed by a space, followed by an identifier; to create a setter, do the same using the keyword <span class="literal">set</span>, as shown here:</p>
        <p class="programs">class CustomHTMLElement {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(element) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.element = element;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;get html() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.element.innerHTML;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;set html(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.element.innerHTML = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var descriptor = Object.getOwnPropertyDescriptor(CustomHTMLElement.prototype, "html");<br>console.log("get" in descriptor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log("set" in descriptor);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(descriptor.enumerable);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">In this code, the <span class="literal">CustomHTMLElement</span> class is made as a wrapper around an existing DOM element. It has a getter and setter for <span class="literal">html</span> that delegates to the <span class="literal">innerHTML</span> method on the element. This accessor property is created on the <span class="literal">CustomHTMLElement.prototype</span> and, just like any other method would be, is created as nonenumerable. The equivalent nonclass representation looks like this:</p>
        <p class="programs">// direct equivalent to previous example<br>let CustomHTMLElement = (function() {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;"use strict";<br><br>&nbsp;&nbsp;&nbsp;&nbsp;const CustomHTMLElement = function(element) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// make sure the function was called with new<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (typeof new.target === "undefined") {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("Constructor must be called with new.");<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.element = element;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><span epub:type="pagebreak" id="page_174"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;Object.defineProperty(CustomHTMLElement.prototype, "html", {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enumerable: false,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configurable: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;get: function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.element.innerHTML;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;},<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;set: function(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.element.innerHTML = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;});<br><br>&nbsp;&nbsp;&nbsp;&nbsp;return CustomHTMLElement;<br>}());</p>
        <p class="indent">As in previous examples, this one shows just how much code you can omit by using a class instead of the nonclass equivalent. The <span class="literal">html</span> accessor property definition alone is almost the size of the equivalent class declaration.</p>
        <h3 class="h3" id="ch09lev1sec06"><strong>Computed Member Names</strong></h3>
        <p class="noindent">Even more similarities exist between object literals and classes. Class methods and accessor properties can also have computed names. Instead of using an identifier, use square brackets around an expression, which is the same syntax you use for object literal computed names. For example:</p>
        <p class="programs">let methodName = "sayName";<br><br>class PersonClass {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;[methodName]() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let me = new PersonClass("Nicholas");<br>me.sayName();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "Nicholas"</p>
        <p class="indent">This version of <span class="literal">PersonClass</span> uses a variable to assign a name to a method inside its definition. The string <span class="literal">"sayName"</span> is assigned to the <span class="literal">methodName</span> variable, and then <span class="literal">methodName</span> is used to declare the method. The <span class="literal">sayName()</span> method is later accessed directly.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_175"></span>Accessor properties can use computed names in the same way, like this:</p>
        <p class="programs">let propertyName = "html";<br><br>class CustomHTMLElement {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(element) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.element = element;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;get [propertyName]() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.element.innerHTML;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;set [propertyName](value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.element.innerHTML = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent">Here, the getter and setter for <span class="literal">html</span> are set using the <span class="literal">propertyName</span> variable. Accessing the property by using <span class="literal">.html</span> only affects the definition.</p>
        <p class="indent">You’ve seen several similarities between classes and object literals, including methods, accessor properties, and computed names. There’s just one more similarity I need to cover, and that is generators.</p>
        <h3 class="h3" id="ch09lev1sec07"><strong>Generator Methods</strong></h3>
        <p class="noindent">Recall from <a href="ch08.xhtml#ch08">Chapter 8</a> that you can define a generator on an object literal by prepending an asterisk (<span class="literal">*</span>) to the method name. The same syntax works for classes as well, allowing any method to be a generator. Here’s an example:</p>
        <p class="programs">class MyClass {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;*createIterator() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield 1;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield 2;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield 3;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>}<br><br>let instance = new MyClass();<br>let iterator = instance.createIterator();</p>
        <p class="indent">This code creates a class called <span class="literal">MyClass</span> with a <span class="literal">createIterator()</span> generator method. The method returns an iterator whose values are hardcoded into the generator. Generator methods are useful when you have an object that represents a collection of values and you want to iterate over those <span epub:type="pagebreak" id="page_176"></span>values easily. Arrays, sets, and maps all have multiple generator methods to account for the different ways developers need to interact with their items.</p>
        <p class="indent">Although generator methods are useful, defining a default iterator for your class is much more helpful if the class represents a collection of values. You can define the default iterator for a class by using <span class="literal">Symbol.iterator</span> to define a generator method:</p>
        <p class="programs">class Collection {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;constructor() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.items = [];<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;*[Symbol.iterator]() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield *this.items.values();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var collection = new Collection();<br>collection.items.push(1);<br>collection.items.push(2);<br>collection.items.push(3);<br><br>for (let x of collection) {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(x);<br>}<br><br>// Output:<br>// 1<br>// 2<br>// 3</p>
        <p class="indent">This example uses a computed name for a generator method that delegates to the <span class="literal">values()</span> iterator of the <span class="literal">this.items</span> array. Any class that manages a collection of values should include a default iterator because some collection-specific operations require collections they operate on to have an iterator. Now you can use any instance of <span class="literal">Collection</span> directly in a <span class="literal">for-of</span> loop or with the spread operator.</p>
        <p class="indent">Adding methods and accessor properties to a class prototype is useful when you want them to show up on object instances. If, on the other hand, you want methods or accessor properties on the class, you’ll need to use static members.</p>
        <h3 class="h3" id="ch09lev1sec08"><strong>Static Members</strong></h3>
        <p class="noindent">Adding methods directly onto constructors to simulate static members is another common pattern in ECMAScript 5 and earlier. For example:</p>
        <p class="programs">function PersonType(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>}<br><span epub:type="pagebreak" id="page_177"></span><br>// static method<br>PersonType.create = function(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;return new PersonType(name);<br>};<br><br>// instance method<br>PersonType.prototype.sayName = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>};<br><br>var person = PersonType.create("Nicholas");</p>
        <p class="indent">In other programming languages, the factory method called <span class="literal">PersonType.create()</span> would be considered a static method, because it doesn’t depend on an instance of <span class="literal">PersonType</span> for its data. ECMAScript 6 classes simplify the creation of static members by using the formal <span class="literal">static</span> annotation before the method or accessor property name. For instance, here’s the class equivalent of the preceding example:</p>
        <p class="programs">class PersonClass {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of the PersonType constructor<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.name = name;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of PersonType.prototype.sayName<br>&nbsp;&nbsp;&nbsp;&nbsp;sayName() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(this.name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of PersonType.create<br>&nbsp;&nbsp;&nbsp;&nbsp;static create(name) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new PersonClass(name);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let person = PersonClass.create("Nicholas");</p>
        <p class="indent">The <span class="literal">PersonClass</span> definition has a single static method called <span class="literal">create()</span>. The method syntax is the same as the syntax used for <span class="literal">sayName()</span> except for the <span class="literal">static</span> keyword. You can use the <span class="literal">static</span> keyword on any method or accessor property definition within a class. The only restriction is that you can’t use <span class="literal">static</span> with the <span class="literal">constructor</span> method definition.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Static members are not accessible from instances. You must always access static members from the class directly.</em></p>
        </div>
        <h3 class="h3" id="ch09lev1sec09"><span epub:type="pagebreak" id="page_178"></span><strong>Inheritance with Derived Classes</strong></h3>
        <p class="noindent">Prior to ECMAScript 6, implementing inheritance with custom types was an extensive process. Proper inheritance required multiple steps. For instance, consider this example:</p>
        <p class="programs">function Rectangle(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>}<br><br>Rectangle.prototype.getArea = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return this.length * this.width;<br>};<br><br>function Square(length) {<br>&nbsp;&nbsp;&nbsp;&nbsp;Rectangle.call(this, length, length);<br>}<br><br>Square.prototype = Object.create(Rectangle.prototype, {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: Square,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enumerable: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writable: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configurable: true<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>var square = new Square(3);<br><br>console.log(square.getArea());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 9<br>console.log(square instanceof Square);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(square instanceof Rectangle);&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent"><span class="literal">Square</span> inherits from <span class="literal">Rectangle</span>, and to do so, it must overwrite <span class="literal">Square.prototype</span> with a new object created from <span class="literal">Rectangle.prototype</span> as well as call the <span class="literal">Rectangle.call()</span> method. These steps often confused JavaScript newcomers and were a source of errors for experienced developers.</p>
        <p class="indent">Classes make inheritance easier to implement by using the familiar <span class="literal">extends</span> keyword to specify the function from which the class should inherit. The prototypes are automatically adjusted, and you can access the base class constructor by calling the <span class="literal">super()</span> method. Here’s the ECMAScript 6 equivalent of the preceding example:</p>
        <p class="programs">class Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><span epub:type="pagebreak" id="page_179"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;getArea() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.length * this.width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>class Square extends Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of Rectangle.call(this, length, length)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(length, length);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var square = new Square(3);<br><br>console.log(square.getArea());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 9<br>console.log(square instanceof Square);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(square instanceof Rectangle);&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">This time, the <span class="literal">Square</span> class inherits from <span class="literal">Rectangle</span> using the <span class="literal">extends</span> keyword. The <span class="literal">Square</span> constructor uses <span class="literal">super()</span> to call the <span class="literal">Rectangle</span> constructor with the specified arguments. Note that unlike the ECMAScript 5 version of the code, the identifier <span class="literal">Rectangle</span> is only used within the class declaration (after <span class="literal">extends</span>).</p>
        <p class="indent">Classes that inherit from other classes are referred to as <em>derived classes</em>. Derived classes require you to use <span class="literal">super()</span> if you specify a constructor; if you don’t, an error will occur. If you choose not to use a constructor, <span class="literal">super()</span> is automatically called for you with all arguments upon creating a new instance of the class. For instance, the following two classes are identical:</p>
        <p class="programs">class Square extends Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;// no constructor<br>}<br><br>// is equivalent to<br><br>class Square extends Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(...args) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(...args);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent">The second class in this example shows the equivalent of the default constructor for all derived classes. All of the arguments are passed, in order, to the base class constructor. In this case, the functionality isn’t quite correct because the <span class="literal">Square</span> constructor needs only one argument, so it’s best to manually define the constructor.</p>
        <div class="sidebar">
        <p class="sidebart"><span epub:type="pagebreak" id="page_180"></span><strong>NOTES ON USING SUPER( )</strong></p>
        <p class="noindentb">Keep the following key points in mind when you’re using <span class="literal">super()</span>:</p>
        <p class="bulla">• You can only use <span class="literal">super()</span> in a derived class constructor. If you try to use it in a nonderived class (a class that doesn’t use <span class="literal">extends</span>) or a function, it will throw an error.</p>
        <p class="bulla">• You must call <span class="literal">super()</span> before accessing <span class="literal">this</span> in the constructor. Because <span class="literal">super()</span> is responsible for initializing <span class="literal">this</span>, attempting to access <span class="literal">this</span> before calling <span class="literal">super()</span> results in an error.</p>
        <p class="bulla">• The only way to avoid calling <span class="literal">super()</span> is to return an object from the class constructor.</p>
        </div>
        <h4 class="h4" id="ch09lev2sec05"><em><strong>Shadowing Class Methods</strong></em></h4>
        <p class="noindent">The methods on derived classes always shadow methods of the same name on the base class. For instance, you can add <span class="literal">getArea()</span> to <span class="literal">Square</span> to redefine that functionality:</p>
        <p class="programs">class Square extends Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(length, length);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// override and shadow Rectangle.prototype.getArea()<br>&nbsp;&nbsp;&nbsp;&nbsp;getArea() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.length * this.length;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent">Because the <span class="literal">getArea()</span> method is defined as part of <span class="literal">Square</span>, the method <span class="literal">Rectangle.prototype.getArea()</span> will no longer be called by any instances of <span class="literal">Square</span>. Of course, you can always decide to call the base class version of the method by using the <span class="literal">super.getArea()</span> method, like this:</p>
        <p class="programs">class Square extends Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(length, length);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;// override, shadow, and call Rectangle.prototype.getArea()<br>&nbsp;&nbsp;&nbsp;&nbsp;getArea() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return super.getArea();<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent"><span epub:type="pagebreak" id="page_181"></span>Using <span class="literal">super</span> in this way works the same as the super references discussed in <a href="ch04.xhtml#ch04">Chapter 4</a> (see “<a href="ch04.xhtml#ch04lev2sec07">Easy Prototype Access with Super References</a>” on <a href="ch04.xhtml#page_77">page 77</a>). The <span class="literal">this</span> value is automatically set correctly so you can make a simple method call.</p>
        <h4 class="h4" id="ch09lev2sec06"><em><strong>Inherited Static Members</strong></em></h4>
        <p class="noindent">If a base class has static members, those static members are also available on the derived class. Inheritance works like that in other languages, but this is a new concept in JavaScript. Here’s an example:</p>
        <p class="programs">class Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;getArea() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.length * this.width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;static create(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new Rectangle(length, width);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>class Square extends Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length) {<br><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// equivalent of Rectangle.call(this, length, length)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(length, length);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var rect = Square.create(3, 4);<br><br>console.log(rect instanceof Rectangle);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(rect.getArea());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 12<br>console.log(rect instanceof Square);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">In this code, a new static <span class="literal">create()</span> method is added to the <span class="literal">Rectangle</span> class. Through inheritance, that method is available as <span class="literal">Square.create()</span> and behaves like the <span class="literal">Rectangle.create()</span> method.</p>
        <h4 class="h4" id="ch09lev2sec07"><em><strong>Derived Classes from Expressions</strong></em></h4>
        <p class="noindent">Perhaps the most powerful aspect of derived classes in ECMAScript 6 is the ability to derive a class from an expression. You can use <span class="literal">extends</span> with any expression as long as the expression resolves to a function with <span class="literal">[[Construct]]</span> and a prototype. For instance:</p>
        <p class="programs">function Rectangle(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br><span epub:type="pagebreak" id="page_182"></span>&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>}<br><br>Rectangle.prototype.getArea = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return this.length * this.width;<br>};<br><br>class Square extends Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(length, length);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var x = new Square(3);<br>console.log(x.getArea());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 9<br>console.log(x instanceof Rectangle);&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent"><span class="literal">Rectangle</span> is defined as an ECMAScript 5–style constructor, and <span class="literal">Square</span> is a class. Because <span class="literal">Rectangle</span> has <span class="literal">[[Construct]]</span> and a prototype, the <span class="literal">Square</span> class can still inherit directly from it.</p>
        <p class="indent">Accepting any type of expression after <span class="literal">extends</span> offers powerful possibilities, such as dynamically determining what to inherit from. For example:</p>
        <p class="programs">function Rectangle(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>}<br><br>Rectangle.prototype.getArea = function() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return this.length * this.width;<br>};<br><br>function getBase() {<br>&nbsp;&nbsp;&nbsp;&nbsp;return Rectangle;<br>}<br><br>class Square extends getBase() {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(length, length);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var x = new Square(3);<br>console.log(x.getArea());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 9<br>console.log(x instanceof Rectangle);&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">The <span class="literal">getBase()</span> function is called directly as part of the class declaration. It returns <span class="literal">Rectangle</span>, making this example functionally equivalent to the previous one. And because you can determine the base class dynamically, it’s <span epub:type="pagebreak" id="page_183"></span>possible to create different inheritance approaches. For instance, you can effectively create mixins, like this:</p>
        <p class="programs">let SerializableMixin = {<br>&nbsp;&nbsp;&nbsp;&nbsp;serialize() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return JSON.stringify(this);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>let AreaMixin = {<br>&nbsp;&nbsp;&nbsp;&nbsp;getArea() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this.length * this.width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>};<br><br>function mixin(...mixins) {<br>&nbsp;&nbsp;&nbsp;&nbsp;var base = function() {};<br>&nbsp;&nbsp;&nbsp;&nbsp;Object.assign(base.prototype, ...mixins);<br>&nbsp;&nbsp;&nbsp;&nbsp;return base;<br>}<br><br>class Square extends mixin(AreaMixin, SerializableMixin) {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var x = new Square(3);<br>console.log(x.getArea());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 9<br>console.log(x.serialize());&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "{"length":3,"width":3}"</p>
        <p class="indent">This example uses mixins instead of classical inheritance. The <span class="literal">mixin()</span> function takes any number of arguments that represent mixin objects. It creates a function called <span class="literal">base</span> and assigns the properties of each mixin object to the prototype. The function is then returned so <span class="literal">Square</span> can use <span class="literal">extends</span>. Keep in mind that because <span class="literal">extends</span> is still used, you’re required to call <span class="literal">super()</span> in the constructor.</p>
        <p class="indent">The instance of <span class="literal">Square</span> has <span class="literal">getArea()</span> from <span class="literal">AreaMixin</span> and <span class="literal">serialize</span> from <span class="literal">SerializableMixin</span>. This is accomplished through prototypal inheritance. The <span class="literal">mixin()</span> function dynamically populates the prototype of a new function with all of the own properties of each mixin. Keep in mind that if multiple mixins have the same property, only the last property added will remain.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>You can use any expression after <span class="literal">extends</span>, but not all expressions result in a valid class. Specifically, using <span class="literal">null</span> or a generator function (covered in <a href="ch08.xhtml#ch08">Chapter 8</a>) after extends will cause errors. In these cases, attempting to create a new instance of the class will throw an error because there is no <span class="literal">[[Construct]]</span> to call.</em></p>
        </div>
        <h4 class="h4" id="ch09lev2sec08"><span epub:type="pagebreak" id="page_184"></span><em><strong>Inheriting from Built-Ins</strong></em></h4>
        <p class="noindent">For almost as long as JavaScript arrays have existed, developers have wanted to create their own special array types through inheritance. In ECMAScript 5 and earlier, this wasn’t possible. Attempting to use classical inheritance didn’t result in functioning code. For example:</p>
        <p class="programs">// built-in array behavior<br>var colors = [];<br>colors[0] = "red";<br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br><br>colors.length = 0;<br>console.log(colors[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined<br><br>// trying to inherit from array in ES5<br><br>function MyArray() {<br>&nbsp;&nbsp;&nbsp;&nbsp;Array.apply(this, arguments);<br>}<br><br>MyArray.prototype = Object.create(Array.prototype, {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor: {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;value: MyArray,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;writable: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;configurable: true,<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;enumerable: true<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>});<br><br>var colors = new MyArray();<br>colors[0] = "red";<br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 0<br><br>colors.length = 0;<br>console.log(colors[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// "red"</p>
        <p class="indent">The <span class="literal">console.log()</span> output at the end of this code shows how using the classical form of JavaScript inheritance on an array results in unexpected behavior. The <span class="literal">length</span> and numeric properties on an instance of <span class="literal">MyArray</span> don’t behave the same way they do for the built-in array because this functionality isn’t covered by either <span class="literal">Array.apply()</span> or assigning the prototype.</p>
        <p class="indent">One goal of ECMAScript 6 classes is to allow inheritance from all built-ins. To accomplish this, the inheritance model of classes is slightly different than the classical inheritance model found in ECMAScript 5 and earlier, in two significant ways.</p>
        <p class="indent">In ECMAScript 5 classical inheritance, the value of <span class="literal">this</span> is first created by the derived type (for example, <span class="literal">MyArray</span>) and then the base type constructor (like the <span class="literal">Array.apply()</span> method) is called. That means <span class="literal">this</span> starts out as an instance of <span class="literal">MyArray</span> and then is decorated with additional properties from <span class="literal">Array</span>.</p>
        <p class="indent"><span epub:type="pagebreak" id="page_185"></span>Conversely, in ECMAScript 6 class-based inheritance, the value of <span class="literal">this</span> is first created by the base (<span class="literal">Array</span>) and then modified by the derived class constructor (<span class="literal">MyArray</span>). The result is that <span class="literal">this</span> starts with all the built-in functionality of the base and correctly receives all functionality related to it.</p>
        <p class="indent">The following example shows a class-based special array in action:</p>
        <p class="programs">class MyArray extends Array {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>var colors = new MyArray();<br>colors[0] = "red";<br>console.log(colors.length);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 1<br><br>colors.length = 0;<br>console.log(colors[0]);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// undefined</p>
        <p class="indent"><span class="literal">MyArray</span> inherits directly from <span class="literal">Array</span> and therefore works like <span class="literal">Array</span>. Interacting with numeric properties updates the <span class="literal">length</span> property, and manipulating the <span class="literal">length</span> property updates the numeric properties. That means you can properly inherit from <span class="literal">Array</span> to create your own derived array classes and inherit from other built-ins as well. With all this added functionality, ECMAScript 6 and derived classes have effectively removed the last special case of inheriting from built-ins, but that case is still worth exploring.</p>
        <h4 class="h4" id="ch09lev2sec09"><em><strong>The Symbol.species Property</strong></em></h4>
        <p class="noindent">A convenient aspect of inheriting from built-ins is that any method that returns an instance of the built-in will automatically return a derived class instance instead. So, if you have a derived class called <span class="literal">MyArray</span> that inherits from <span class="literal">Array</span>, methods such as <span class="literal">slice()</span> return an instance of <span class="literal">MyArray</span>. For example:</p>
        <p class="programs">class MyArray extends Array {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>let items = new MyArray(1, 2, 3, 4),<br>&nbsp;&nbsp;&nbsp;&nbsp;subitems = items.slice(1, 3);<br><br>console.log(items instanceof MyArray);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(subitems instanceof MyArray);&nbsp;&nbsp;// true</p>
        <p class="indent">In this code, the <span class="literal">slice()</span> method returns a <span class="literal">MyArray</span> instance. The <span class="literal">slice()</span> method is inherited from <span class="literal">Array</span> and returns an instance of <span class="literal">Array</span> normally. Behind the scenes, the <span class="literal">Symbol.species</span> property is actually making this change.</p>
        <p class="indentb"><span epub:type="pagebreak" id="page_186"></span>The <span class="literal">Symbol.species</span> well-known symbol is used to define a static accessor property that returns a function. That function is a constructor to use whenever an instance of the class must be created inside an instance method (instead of using the constructor). The following built-in types have <span class="literal">Symbol.species</span> defined:</p>
        <p class="bull">• <span class="literal">Array</span></p>
        <p class="bull">• <span class="literal">ArrayBuffer</span> (discussed in <a href="ch10.xhtml#ch10">Chapter 10</a>)</p>
        <p class="bull">• <span class="literal">Map</span></p>
        <p class="bull">• <span class="literal">Promise</span></p>
        <p class="bull">• <span class="literal">RegExp</span></p>
        <p class="bull">• <span class="literal">Set</span></p>
        <p class="bull">• Typed arrays (discussed in <a href="ch10.xhtml#ch10">Chapter 10</a>)</p>
        <p class="indentt">Each type in the list has a default <span class="literal">Symbol.species</span> property that returns <span class="literal">this</span>, meaning the property will always return the constructor function. If you implemented that functionality on a custom class, the code would look like this:</p>
        <p class="programs">// several built-in types use species similar to this<br>class MyClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;static get [Symbol.species]() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;clone() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new this.constructor[Symbol.species](this.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}</p>
        <p class="indent">In this example, the <span class="literal">Symbol.species</span> well-known symbol is used to assign a static accessor property to <span class="literal">MyClass</span>. Note that there’s a getter without a setter, because changing the species of a class isn’t possible. Any call to <span class="literal">this.constructor[Symbol.species]</span> returns <span class="literal">MyClass</span>. The <span class="literal">clone()</span> method uses that definition to return a new instance rather than directly using <span class="literal">MyClass</span>, which allows derived classes to override that value. For example:</p>
        <p class="programs">class MyClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;static get [Symbol.species]() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return this;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(value) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.value = value;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br><span epub:type="pagebreak" id="page_187"></span><br>&nbsp;&nbsp;&nbsp;&nbsp;clone() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return new this.constructor[Symbol.species](this.value);<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>class MyDerivedClass1 extends MyClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;// empty<br>}<br><br>class MyDerivedClass2 extends MyClass {<br>&nbsp;&nbsp;&nbsp;&nbsp;static get [Symbol.species]() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return MyClass;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let instance1 = new MyDerivedClass1("foo"),<br>&nbsp;&nbsp;&nbsp;&nbsp;clone1 = instance1.clone(),<br>&nbsp;&nbsp;&nbsp;&nbsp;instance2 = new MyDerivedClass2("bar"),<br>&nbsp;&nbsp;&nbsp;&nbsp;clone2 = instance2.clone();<br><br>console.log(clone1 instanceof MyClass);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(clone1 instanceof MyDerivedClass1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(clone2 instanceof MyClass);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(clone2 instanceof MyDerivedClass2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent">Here, <span class="literal">MyDerivedClass1</span> inherits from <span class="literal">MyClass</span> and doesn’t change the <span class="literal">Symbol.species</span> property. When <span class="literal">clone()</span> is called, it returns an instance of <span class="literal">MyDerivedClass1</span> because <span class="literal">this.constructor[Symbol.species]</span> returns <span class="literal">MyDerivedClass1</span>. The <span class="literal">MyDerivedClass2</span> class inherits from <span class="literal">MyClass</span> and overrides <span class="literal">Symbol.species</span> to return <span class="literal">MyClass</span>. When <span class="literal">clone()</span> is called on an instance of <span class="literal">MyDerivedClass2</span>, the return value is an instance of <span class="literal">MyClass</span>. Using <span class="literal">Symbol.species</span>, any derived class can determine what type of value should be returned when a method returns an instance.</p>
        <p class="indent">For instance, <span class="literal">Array</span> uses <span class="literal">Symbol.species</span> to specify the class to use for methods that return an array. In a class derived from <span class="literal">Array</span>, you can determine the type of object returned from the inherited methods, such as:</p>
        <p class="programs">class MyArray extends Array {<br>&nbsp;&nbsp;&nbsp;&nbsp;static get [Symbol.species]() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return Array;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>let items = new MyArray(1, 2, 3, 4),<br>&nbsp;&nbsp;&nbsp;&nbsp;subitems = items.slice(1, 3);<br><br>console.log(items instanceof MyArray);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(subitems instanceof Array);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// true<br>console.log(subitems instanceof MyArray);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// false</p>
        <p class="indent"><span epub:type="pagebreak" id="page_188"></span>This code overrides <span class="literal">Symbol.species</span> on <span class="literal">MyArray</span>, which inherits from <span class="literal">Array</span>. All of the inherited methods that return arrays will now use an instance of <span class="literal">Array</span> instead of <span class="literal">MyArray</span>.</p>
        <p class="indent">In general, you should use the <span class="literal">Symbol.species</span> property whenever you might want to use <span class="literal">this.constructor</span> in a class method. Doing so allows derived classes to override the return type easily. Additionally, if you’re creating derived classes from a class that has <span class="literal">Symbol.species</span> defined, be sure to use that value instead of the constructor.</p>
        <h3 class="h3" id="ch09lev1sec10"><strong>Using new.target in Class Constructors</strong></h3>
        <p class="noindent">In <a href="ch03.xhtml#ch03">Chapter 3</a>, you learned about <span class="literal">new.target</span> and how its value changes depending on how a function is called. You can also use <span class="literal">new.target</span> in class constructors to determine how the class is being invoked. In the simple case, <span class="literal">new.target</span> is equal to the constructor function for the class, as in this example:</p>
        <p class="programs">class Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(new.target === Rectangle);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>// new.target is Rectangle<br>var obj = new Rectangle(3, 4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// outputs true</p>
        <p class="indent">This code shows that <span class="literal">new.target</span> is equivalent to <span class="literal">Rectangle</span> when <span class="literal">new Rectangle(3, 4)</span> is called. Class constructors can’t be called without <span class="literal">new</span>, so the <span class="literal">new.target</span> property is always defined inside class constructors. But the value may not always be the same. Consider this code:</p>
        <p class="programs">class Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;console.log(new.target === Rectangle);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>class Square extends Rectangle {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super(length, length)<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>// new.target is Square<br>var obj = new Square(3);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// outputs false</p>
        <p class="indent"><span epub:type="pagebreak" id="page_189"></span><span class="literal">Square</span> is calling the <span class="literal">Rectangle</span> constructor, so <span class="literal">new.target</span> is equal to <span class="literal">Square</span> when the <span class="literal">Rectangle</span> constructor is called. This is important because it gives each constructor the ability to alter its behavior based on how it’s being called. For instance, you can create an abstract base class (one that can’t be instantiated directly) by using <span class="literal">new.target</span> as follows:</p>
        <p class="programs">// abstract base class<br>class Shape {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor() {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (new.target === Shape) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;throw new Error("This class cannot be instantiated directly.")<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>class Rectangle extends Shape {<br>&nbsp;&nbsp;&nbsp;&nbsp;constructor(length, width) {<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;super();<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.length = length;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.width = width;<br>&nbsp;&nbsp;&nbsp;&nbsp;}<br>}<br><br>var x = new Shape();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// throws an error<br><br>var y = new Rectangle(3, 4);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// no error<br>console.log(y instanceof Shape);&nbsp;&nbsp;&nbsp;&nbsp;// true</p>
        <p class="indent">In this example, the <span class="literal">Shape</span> class constructor throws an error whenever <span class="literal">new.target</span> is <span class="literal">Shape</span>, meaning that <span class="literal">new Shape()</span> always throws an error. However, you can still use <span class="literal">Shape</span> as a base class, which is what <span class="literal">Rectangle</span> does. The <span class="literal">super()</span> call executes the <span class="literal">Shape</span> constructor and <span class="literal">new.target</span> is equal to <span class="literal">Rectangle</span> so the constructor continues without error.</p>
        <div class="note">
        <p class="notet"><span class="notes"><strong>NOTE</strong></span></p>
        <p class="notep"><em>Because classes can’t be called without <span class="literal">new</span>, the <span class="literal">new.target</span> property is never <span class="literal">undefined</span> inside a class constructor.</em></p>
        </div>
        <h3 class="h3" id="ch09lev1sec11"><strong>Summary</strong></h3>
        <p class="noindent">ECMAScript 6 classes make inheritance in JavaScript easier to use, so you don’t need to disregard any existing understanding of inheritance you might have from other languages. ECMAScript 6 classes started as syntactic sugar for the classical inheritance model in ECMAScript 5 but added several features to reduce mistakes.</p>
        <p class="indent">ECMAScript 6 classes work with prototypal inheritance by defining nonstatic methods on the class prototype, whereas static methods end up on the constructor. All methods are nonenumerable, which better matches the behavior of built-in objects whose methods are typically nonenumerable <span epub:type="pagebreak" id="page_190"></span>by default. Additionally, class constructors can’t be called without <span class="literal">new</span>, ensuring that you can’t accidentally call a class as a function.</p>
        <p class="indent">Class-based inheritance allows you to derive a class from another class, function, or expression. This capability means you can call a function to determine the correct base to inherit from, allowing you to use mixins and other different composition patterns to create a new class. Inheritance works in such a way that inheriting from built-in objects like <span class="literal">Array</span> is now possible and works as expected.</p>
        <p class="indent">You can use <span class="literal">new.target</span> in class constructors to behave differently depending on how the class is called. The most common use is to create an abstract base class that throws an error when instantiated directly but still allows inheritance via other classes.</p>
        <p class="indent">Overall, classes are an important addition to JavaScript. They provide a more concise syntax and better functionality for defining custom object types in a safe, consistent manner.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492017509/files/styles/9781593277574.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com