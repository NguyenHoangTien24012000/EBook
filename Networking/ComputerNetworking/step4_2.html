<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch26"><a id="page_679"></a><strong>Chapter 26<br>The Case for Network Automation</strong></h2>
        <div class="sidebar">
        <p class="sb-noindent"><strong>Learning Objectives</strong></p>
        <p class="sb-noindent">After reading this chapter, you should understand:</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The main objectives of network automation</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The basic network management requirements</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The basic purpose and operation of NETCONF</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The basic purpose and operation of RESTCONF</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Some of the languages used in network automation and their attributes</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> On-box automation and network controllers</p>
        </div>
        <p class="noindent">A typical network consists of a collection of distributed nodes, each running an operating system, each configured with protocols and feature sets. Networkwide features—for example a routing protocol—require synced configurations to enable nodes to work together. The number of nodes in addition to the distributed configurations leads to complexity. New nodes or new features increase the complexities of the system, and increased complexity increases the opportunity of failure, increases operational cost, and retards the network’s ability to change. These monetary and nonmonetary costs often restrict network engineers from adopting new features, using the network to solve business problems, or understanding network failures.</p>
        <p class="indent">Network automation can lead to better deployment, operation, and troubleshooting of the network. It can reduce the complexity of network deployment, configurations, <a id="page_680"></a>and operations; increase agility, or the ability of the operator to reshape the network to new requirements more quickly; and reduce cost and risk by removing the human element and using automation tools to interact with individual network devices.</p>
        <div class="sidebar1">
        <p class="title1"><strong>Network Automation and Complexity</strong></p>
        <p class="noindent">There is a general assumption in the network engineering field that automation reduces complexity. While automation can provide a simple set of tools to perform repetitive tasks, and it reduces human interaction with individual network devices, it does not reduce complexity in a general sense. Within the State/Optimization/Surface (SOS) model, automation reduces the interaction surface between humans and individual network devices, but it adds more state, in the form of an additional database of configurations and new protocol interactions, and adds an additional interaction surface, in the form of a new protocol to the management plane—the Application Programming Interface (API). Someone must, ultimately, maintain the new tools and APIs created and used in the process of automating.</p>
        <p class="indent">This does not mean automation is a bad thing; it is a requirement at almost anything beyond trivial scale in network operation. However, engineers should always consider the tradeoffs and prepare for where and how increased complexity may impact network operation. Rather than assuming complexity will be reduced, assume complexity will be moved someplace else, and consider how the movement needs to be managed.</p>
        <p class="indent">Automation can also act as a form of abstraction, replacing a large configuration with a few simple commands. This is both a good and a bad thing: good, because it ensures the same configuration is done the same way consistently; bad, because abstractions often remove state in one place, while reducing optimization someplace else. Again, this does not mean automation should not be deployed; in many cases, automation is the only path forward. On the other hand, engineers should always look for where optimization might be affected through abstraction, and understand the potential impact on the network. All nontrivial abstractions also leak in some way; it is important to look for and understand—where possible—these leaks.</p>
        <p class="indent">If you have not found the tradeoff, you have not looked hard enough.</p>
        <p class="indent">One particular place to consider the tradeoffs is in the complexity and capability of the API and the tools used to access the API versus the amount of state and the breadth and depth of the interaction surface. For instance, to interact with an interface designed explicitly for human interaction generally means a chain of interactions from human to tool, from tool to human-centered interface, then from human-centered interface to the device configuration. The <a id="page_681"></a>movement through the human-centered interface adds a lot of complexity and makes the interaction surface very difficult to maintain. Moving from an automation tool through some sort of API designed specifically for machine-to-machine interaction, then to the device configuration, is much simpler, and hence adds much less complexity in the automation system. In fact, the latter case, tool to API to configuration, can <em>reduce</em> overall complexity at a system level.</p>
        </div>
        <p class="indent">Network automation can be as simple as automatically provisioning new switches in the data center to changing configurations through dynamic software development to automating response to Syslog events. More robust implementations enable network teams to stop thinking about the network as a collection of individual network devices and start thinking about the network as a system.</p>
        <p class="indent">Network automation has spawned a new title within network teams: the automation engineer. Automation engineers, usually part of the operations team, require advanced network, protocol, and troubleshooting skills; proficiency in a scripting language such as Python or Bash; and the ability to manipulate text, such as using regular expressions. Network automation teams are usually very small.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">Regular expressions are a way to match on text strings within a larger text file (such as a network device configuration, or even a book), either to find those strings, or to use a text processor to replace one string with another. More information about the formatting and uses of regular expressions can be found in the “Further Reading” section at the end of the chapter.</p>
        </div>
        <div class="heading">
        <h3 class="h3" id="ch26lev1">Automation Concepts</h3>
        <p class="noindent">To automate a network device, a network automation tool requires some method to connect, authenticate, and interact with the management plane of a network node. Traditionally, most if not all network devices feature a command-line interface (CLI). The CLI provides access to the management plane over Telnet or a Secure Shell (SSH), creating what’s well known as a human-to-machine system. While CLI interfaces are optimized for humans, they can be automated using tools such as Expect, Puppet, Ansible, Chef, Salt, and CFEngine (see the “Further Reading” section at the end of the chapter for links to information about these tools).</p>
        </div>
        <p class="indent"><a id="page_682"></a>Taking one of these tools as an example: Expect is a scripting language to automate configurations through interactive interfaces—for example, CLI interaction running over SSH. Expect creates a machine-to-human-to-machine system, normally using the CLI as an API (so Expect can be leveraged for any system with a CLI). Expect scripts run a set of commands after the SSH session returns some text. For example, an Expect script to log in may entail the following:</p>
        <p class="codelink"><a href="ch26_images.xhtml#p26pro01a" id="p26pro01">Click here to view code image</a></p>
        <p class="pre">
        expect "Username: "<br>
        send "Groot"<br>
        expect "Password: "<br>
        send "cisco123"</p>
        <p class="indent">The Expect processor examines the text stream in real time, looking for the “User-name:” prompt (generally by using some form of regular expression matching engine on the incoming text stream). When this prompt is encountered, the processor sends a text string in reply containing “Groot” based on a previously written script. The same pattern is followed for the password. In the case of a Cisco CLI, Expect may just respond to a command prompt at a particular level, such as the <em>enable</em> prompt. Expect is very extensible and can automate any CLI-based feature on a single device or an entire network. In most cases a network automation administrator will use Expect with text parsing and manipulation tools (such as regular expressions) to automate the configuration of a large number of devices, hence managing the entire network with a small number of scripts.</p>
        <p class="indent">While CLI scripting tools have proven to be very successful and are still in use in modern networks, they are very difficult to build, maintain, and troubleshoot. A common issue with Expect is dealing with what happens when something unexpected happens. If a vendor changes the output of a particular command or prompt, or the order in which commands need to be entered, the change will need to be discovered and the affected scripts modified for the new input/output pattern. For example, a vendor might change “Username” to “username,” or even ask for the password first. In these cases, the script will simply not run or throw an error. Additionally, because each vendor has slight variations of CLI, scripting work must be duplicated in multivendor or multinetwork operating system environments. Finally, Expect does not have any implicit understanding of configuration state; thus this logic must be written in the script.</p>
        <p class="indent">One of the first tools to emerge to better manage and automate networks was the Simple Network Management Protocol (SNMP). SNMP enables network operators to securely connect to a device and use a common (standardized) or vendor- specific Management Information Base (MIB) to interact with it. SNMP was originally designed for both monitoring and configuration management; however, using SNMP <a id="page_683"></a>for configuration management has extremely low adoption because it is very difficult to use and usually does not reflect all the capabilities of a node.</p>
        <p class="indent">SNMP, in dictionary terms, stores the metadata in an MIB specification, while the corresponding state is stored in the information retrieved from the device. In order to retrieve a particular piece of information, the information requested must be specified according to the dictionary rules; for example, a request might look like</p>
        <p class="codelink"><a href="ch26_images.xhtml#p26pro02a" id="p26pro02">Click here to view code image</a></p>
        <p class="pre">snmpget -m ../../mibs/RFC1213-MIB localhost .iso.org.dod.<br>
        internet.mgmt.mib-2.system.sysDescr.0</p>
        <p class="indent">In order to retrieve information about an entire subsystem, the entire MIB table must be “walked,” item to item, with each item being returned separately. The separate items must then be reassembled into their proper form and then interpreted based on the MIB definition to understand what the actual state of the device is. A new method to automate networks was required.</p>
        <p class="indentb">As networks became bigger and more important to application delivery, network operators sought better ways to manage and automate those networks. In 2002 a small group of network engineers held an Internet Engineering Task Force (IETF) workshop to discuss the future of network management and build a high-level architecture for future protocol developments. The results of this workshop are documented in RFC3535, <em>Overview of the 2002 IAB Network Management Workshop</em>.<sup><a id="ch26fn1"></a><a href="ch26.xhtml#ch26fn-1">1</a></sup> RFC3535 discusses current network management technologies, including SNMP and CLI, and more importantly describes 14 requirements for network management and automation protocols. These requirements are</p>
        <p class="indenthangingN">1. Ease of use is a key requirement for any network management technology from the operator’s point of view.</p>
        <p class="indenthangingN">2. It is necessary to make a clear distinction between configuration data and data describing operational state and statistics. Some devices make it very hard to determine which parameters were administratively configured and which were obtained via other mechanisms such as routing protocols.</p>
        <p class="indenthangingN">3. It is required to be able to fetch separately configuration data, operational state data, and statistics from devices, and to be able to compare these between devices.</p>
        <p class="indenthangingN">4. It is necessary to enable operators to concentrate on the configuration of the network as a whole rather than individual devices.</p>
        <p class="indenthangingN"><a id="page_684"></a>5. Support for configuration transactions across a number of devices would significantly simplify network configuration management.</p>
        <p class="indenthangingN">6. Given configuration A and configuration B, it should be possible to generate the operations necessary to get from A to B with minimal state changes and effects on network and systems. It is important to minimize the impact caused by configuration changes.</p>
        <p class="indenthangingN">7. A mechanism to dump and restore configurations is a primitive operation needed by operators. Standards for pulling and pushing configurations from and to devices are desirable.</p>
        <p class="indenthangingN">8. It must be easy to do consistency checks of configurations over time and between the ends of a link in order to determine the changes between two configurations and whether those configurations are consistent.</p>
        <p class="indenthangingN">9. Networkwide configurations are typically stored in central master databases and transformed into formats that can be pushed to devices, either by generating sequences of CLI commands or by pushing complete configuration files to devices. There is no common database schema for network configuration, although the models used by various operators are probably very similar. It is desirable to extract, document, and standardize the common parts of these networkwide configuration database schemas.</p>
        <p class="indenthangingN1">10. It is highly desirable for text processing tools such as diff and version management tools such as RCS or CVS to able to be used to process configurations, which implies devices should not arbitrarily reorder data such as access control lists.</p>
        <p class="indenthangingN1">11. The granularity of access control needed on management interfaces needs to match operational needs. Typical requirements are a role-based access control model and the principle of least privilege, where a user can be given the minimum access necessary to perform a required task.</p>
        <p class="indenthangingN1">12. It must be possible to do consistency checks of access control lists across devices.</p>
        <p class="indenthangingN1">13. It is important to distinguish between the distribution of configurations and the activation of a certain configuration. Devices should be able to hold multiple configurations.</p>
        <p class="indenthangingN1">14. SNMP access control is data oriented, while CLI access control is usually command (task) oriented. Depending on the management function, sometimes data-oriented or task-oriented access control makes more sense. As such, it is a requirement to support both data-oriented and task-oriented access control.</p>
        <div class="heading">
        <h3 class="h3" id="ch26lev2"><a id="page_685"></a>Modern Automation Methods</h3>
        <p class="noindent">In response to RFC3535, modern automation protocols were developed. These protocols enable better multivendor network management and automation by enabling machine-to-machine interfaces through open standards and methods.</p>
        </div>
        <div class="heading">
        <h4 class="h4" id="ch26lev3"><strong>NETCONF</strong></h4>
        <p class="noindent">NETCONF was developed by the IETF in response to RFC3535; it is an open standard protocol enabling device configuration and monitoring in either single or multivendor networks. NETCONF works in a client/server model where the server is the network node, and the client is a standalone network management station. The management station provides holistic management of the network and supports networkwide automation, allowing network administrators to address the network as a single entity.</p>
        </div>
        <p class="indent">NETCONF features multiple configuration data stores to closely mirror the operational state of a network device, as shown in <a href="ch26.xhtml#ch26tab01">Table 26-1</a>.</p>
        <div class="tab-heading">
        <p class="tab-caption"><a id="ch26tab01"></a><strong>Table 26-1</strong> <em>NETCONF Data Stores</em></p>
        <table class="tablewidth">
        <tbody>
        <tr>
        <td class="bg1"><p class="thead"><strong>Data Store</strong></p></td>
        <td class="bg1"><p class="thead"><strong>Purpose</strong></p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">&lt;candidate&gt;</p></td>
        <td class="tbody_first"><p class="noindent">Working copy of the configuration for validation and testing</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">&lt;running&gt;</p></td>
        <td class="tbody_first"><p class="noindent">The configuration the device is currently using</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">&lt;startup&gt;</p></td>
        <td class="tbody_first"><p class="noindent">The configuration the device will run when booted</p></td>
        </tr>
        </tbody>
        </table>
        </div>
        <p class="indentb"><a href="ch26.xhtml#ch26tab01">Table 26-1</a> shows three data stores (or tables), which represent a standard process for updating configurations on network devices:</p>
        <p class="bullt">• The &lt;running&gt; data store is the configuration currently being used, or run on the device.</p>
        <p class="bull">• The &lt;startup&gt; configuration is what will be run the next time the device boots.</p>
        <p class="bullb">• Candidate configurations are stored in the &lt;candidate&gt; data store and can be manipulated without impacting the running configuration. When a network operator is finished with a candidate configuration, the configuration can be validated for proper syntax, against a set of rules to ensure no configuration items have been missed, or sent through a dry run. For instance, a validator might check to make certain an interface configuration always includes IPv4 and IPv6 addresses, or a routing protocol is configured for both IPv4 and IPv6, or just IPv6. This kind of validation can catch and prevent simple mistakes.</p>
        <p class="indent"><a id="page_686"></a>If the configuration is acceptable, it is then committed, or pushed into running configuration. Candidate configurations are often leveraged to schedule commits during outage or change windows. This allows changes to be written and tested before the change window. Because some devices do not support a candidate configuration, NETCONF features a capability exchange with initial HELLO messages. NETCONF configurations are atomic: if any part of the configuration fails or has unexpected results, the entire configuration can be rolled back.</p>
        <p class="indent">If the running configuration proves to be correct, then it can be committed to the &lt;startup&gt; data store, so the device will boot with this configuration the next time it is restarted. It is also possible for the device to boot with a very simple configuration, which is then modified by a network management station through the &lt;candidate&gt; and &lt;running&gt; data stores.</p>
        <p class="indent">A key component of NETCONF is the management station. The management station provides a networkwide viewpoint for network management and automation. It will have a graphical user interface (GUI) or CLI interface, enabling network administrators to focus on the deployment automation of an entire networkwide service. A sample service may be provisioning a new VPN customer or changing an SNMP password. Network administrators can use a management station to manage the entire lifecycle of a service. By default, and because of NETCONF, network management stations support multivendor networks. To provide additional extensibility, some network management stations feature other southbound configuration methods or protocols—for example, SNMP or CLI—and robust northbound API for integration into other systems.</p>
        <p class="indent">NETCONF is a modular protocol, organized in layers, as shown in <a href="ch26.xhtml#ch26fig01">Figure 26-1</a>.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/26fig01.jpg" aria-describedby="Al26fig01" alt="The figure shows the layers of NETCONF in ten rectangular boxes." width="502" height="209"><aside class="hidden" id="Al26fig01">
        <p>The boxes read as follows: content, operations, messages, secure transport, content, &lt;edit config&gt;, &lt;rpc&gt; &lt;rpc reply&gt;, notification data, notification, and SSH TLS BEEP/TLS SOAP/HTTP/TLS.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch26fig01"></a><strong>Figure 26-1</strong> <em>NETCONF Layers</em></p>
        </div>
        <p class="indent">These layers allow for other tools or protocols to be inserted to extend functionality.</p>
        <p class="indent">The bottom layer is concerned with the transport of messages between devices. NETCONF supports many different transport protocols; however, SSH is commonly used because it is well known and provides authentication, integrity, and <a id="page_687"></a>confidentiality. Because SSH runs over the Transmission Control Protocol (TCP), it also provides reliable transport.</p>
        <p class="indent">The message layer frames and encodes remote procedure calls (RPCs). An RPC appears to be a local function (or procedure) call to the calling application, but is actually executed on a remote device (see the “Further Reading” section at the end of the chapter for more information on RPCs). NETCONF’s use of RPC enables NETCONF to instruct the remote device what to do with the command—for example, apply the configuration detailed in the operations layer. NETCONF RPC messages are encoded in the eXtensible Markup Language (XML) and must contain a message-id element allowing NETCONF to track messages. Finally, the messages layer supports notifications, where devices notify the management station of a configuration change.</p>
        <p class="indent">The operations layer defines the actions for NETCONF clients and servers. NETCONF operations are a set of create, read, update, and delete (CRUD) actions used on the data stores. Common operations include get-config, edit-config, and delete config.</p>
        <p class="indent">The base protocol includes the following operations shown in <a href="ch26.xhtml#ch26tab02">Table 26-2</a>.</p>
        <div class="tab-heading">
        <p class="tab-caption"><a id="ch26tab02"></a><strong>Table 26-2</strong> <em>NETCONF Operations</em></p>
        <table class="tablewidth">
        <tbody>
        <tr>
        <td class="bg1"><p class="thead"><strong>NETCONF Operations</strong></p></td>
        <td class="bg1"><p class="thead"><strong>Description</strong></p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">get</p></td>
        <td class="tbody_first"><p class="noindent">Retrieve running configuration and device state information</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">get-config</p></td>
        <td class="tbody_first"><p class="noindent">Retrieve all or part of a specified configuration datastore</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">edit-config</p></td>
        <td class="tbody_first"><p class="noindent">Load all or part of a specified configuration to the specified target configuration datastore</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">copy-config</p></td>
        <td class="tbody_first"><p class="noindent">Create or replace an entire configuration datastore with the contents of another complete configuration datastore</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">delete-config</p></td>
        <td class="tbody_first"><p class="noindent">Delete a configuration datastore</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">lock</p></td>
        <td class="tbody_first"><p class="noindent">Lock the entire configuration datastore system of a device</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">unlock</p></td>
        <td class="tbody_first"><p class="noindent">Release a configuration lock</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">close-session</p></td>
        <td class="tbody_first"><p class="noindent">Gracefully terminate the NETCONF session</p></td>
        </tr>
        <tr>
        <td class="tbody_first"><p class="noindent">kill-session</p></td>
        <td class="tbody_first"><p class="noindent">Force the termination of a NETCONF session</p></td>
        </tr>
        </tbody>
        </table>
        </div>
        <p class="indent">The content layer contains the formatted data, either configuration or notification, sent to or from the network node. The NETCONF specification does not define how the data should be formatted; it does, however, suggest the use of the YANG data modeling language. Data modeling ensures compatibility between systems.</p>
        <p class="indent"><a id="page_688"></a>YANG is a data modeling language defined in RFC6020 and updated in RFC7950; it is used to format configuration, notification, and state data in the operations and content layers of NETCONF. Data modeling is a definition of both the syntax and the semantics or schema of the data and is critical when working between remote systems. The data model ensures the requests of the NETCONF management station are faithfully carried out on the NETCONF server (network device).</p>
        <p class="indentb">There are two sets of widely deployed and supported YANG models:</p>
        <p class="bullt">• The IETF standardizes a data model in YANG for each protocol, for basic routing functionality, and for common equipment management requirements.</p>
        <p class="bullb">• The OpenConfig group maintains another set of data models, largely overlapping, and often coordinated with the IETF data models.</p>
        <p class="indentt">Beyond these models, each vendor also supports a vendor- and equipment-specific model set that can (often) be downloaded from their support sites.</p>
        <p class="indent">The underlying syntax of YANG is XML in a keyed hierarchical model, much like a Type Length Value (TLV) format. The hierarchy of the model enables multiple organized levels of parent/child relationships of key/value paired data. The keys in YANG must be unique within a layer with single values or lists of data. YANG data is typed—for example, integer, string, etc.—and is enforced by the server and client implementations. Because YANG data is in XML, the data is generally human readable. The following code snippet is an example of YANG data showing “show interface brief”:</p>
        <p class="codelink"><a href="ch26_images.xhtml#p26pro03a" id="p26pro03">Click here to view code image</a></p>
        <p class="pre">
        01&nbsp;&lt;?xml version="1.0"?&gt;<br>
        02&nbsp;&lt;nf:rpc xmlns:nf="urn:ietf:params:xml:ns:netconf:base:1.0"<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;xmlns="http://www.cisco.com/nxos:7.0.3.I6.1.:if_manager"<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;message-id="1"&gt;<br>
        03&nbsp;&lt;nf:get&gt;<br>
        04&nbsp;&lt;nf:filter type="subtree"&gt;<br>
        05&nbsp;&lt;show&gt;<br>
        06&nbsp;&nbsp;&lt;interface&gt;<br>
        07&nbsp;&nbsp;&nbsp;&lt;brief/&gt;<br>
        08&nbsp;&nbsp;&lt;/interface&gt;<br>
        09&nbsp;&nbsp;&lt;/show&gt;<br>
        10&nbsp;&nbsp;&nbsp;&lt;/nf:filter&gt;<br>
        11&nbsp;&nbsp;&nbsp;&lt;/nf:get&gt;<br>
        12&nbsp;&nbsp;&nbsp;&lt;/nf:rpc&gt;<br>
        13&nbsp;]]&gt;]]&gt;</p>
        <p class="indent"><a id="page_689"></a>In the code snippet, line 1 declares the document as XML. Line 2 is the RPC call from the standard NETCONF library. Line 3 is the NETCONF operation. Lines 5 through 7 are the NETCONF content and the command to show the interface information.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">RFC7951 defines JavaScript Object Notation (JSON) encoding of data modeled with YANG. Both XML and JSON are discussed later in this chapter.</p>
        </div>
        <p class="indent">Together NETCONF and YANG provide an open-standards-based, easy-to-use toolset to automate a network. Commercial tools (for example, Cisco’s Tail-F) leverage NETCONF/YANG and enable network administrators to manage the network in terms of the service the network provides—for example, Quality of Service (QoS) or Virtual Private Networks (VPNs).</p>
        <div class="heading">
        <h4 class="h4" id="ch26lev4"><strong>RESTCONF</strong></h4>
        <p class="noindent">RESTCONF is an emerging extension of NETCONF that leverages the widely deployed Hypertext Transfer Protocol (HTTP) over the Secure Sockets Layer (SSL, combined with HTTPS) to interact with network devices. RESTCONF uses YANG as a data modeling language and has the same basic functionality as NETCONF; however, it uses HTTP methods such as POST, PUT, and DELETE to implement the equivalent of NETCONF operations. The RESTful methods available in REST-CONF enable basic create, read, update, and delete (CRUD) operations on a hierarchy of data stores via HTTP.</p>
        </div>
        <p class="indent">The “REST” is in RESTCONF because it provides a RESTful interface; the concept of Representational State Transfer (REST) and RESTful interfaces is discussed further in the next section.</p>
        <div class="heading">
        <h3 class="h3" id="ch26lev5">Automation with Programmatic Interfaces</h3>
        <p class="noindent">Some modern network operating systems, for example, Cisco NX-OS, offer additional vendor-specific automation programmatic interfaces. These interfaces, known as Application Programming Interfaces, or APIs, are exposed on standard TCP ports and require a higher-level language such as Python to interact with a device. The higher-level program contains the specific interaction—for example, a configuration or troubleshooting routine—and leverages the API to connect to the device. Most <a id="page_690"></a>network operating systems require the API to be enabled via CLI and require authentication.</p>
        </div>
        <p class="indent">Network APIs are not created or maintained under the guidance of a standards body, and each vendor or even different platforms from the same vendor will have unique methods and procedures to access and use the APIs. Documentation for a network API is found on the vendor’s website.</p>
        <p class="indent">Network automation with APIs offers higher-level applications the capability to interact with a network device. Higher-level programs introduce logic such as IF…THEN…ELSE or on-demand configuration changes that tie the network into business-level systems or procedures. Custom applications with APIs are extremely flexible; however, they often come with a cost in complexity and supportability. Each time a vendor changes a custom API, some amount of work must be performed to adapt applications using those APIs.</p>
        <p class="indent">A popular way to use network APIs is to connect the network to higher-level automation tools in private cloud environments. Private cloud environments enable automatic provisioning and teardown of the network, storage, and compute to reduce costs and increase the agility of data center infrastructure. The combination of automated network, storage, and compute is commonly referred to as infrastructure as a service and is the starting point for other cloud services, for example, platform as a service (PaaS) and software as a service (SaaS)</p>
        <p class="indentb">Most modern APIs provide RESTful interfaces (or APIs), or rather adhere to REST. Beyond the transport specifications, the most interesting aspect of REST as an API is <em>no maintenance of state is required at the server</em>. This means a RESTful operation must complete in a single call and return from the network device’s perspective. For instance, say a RESTCONF client needs to configure three static routes on a network device:</p>
        <p class="indenthangingN">1. 2001:db8:3e8:100::1 via 2001:db8:3e8:110::1</p>
        <p class="indenthangingN">2. 2001:db8:3e8:110::1 via 2001:db8:3e8:120::1</p>
        <p class="indenthangingN">3. 2001:db8:3e8:120::1 via 2001:db8:3e8:130::1</p>
        <p class="indentt">And if it installs all three routes at once, the client must handle any dependencies, such as the failure to install one 2001:db8:3e8:120::1, on which the route to 110::1 depends. The server simply does not have any state about the interaction between commands executed, and hence has no way to roll back or otherwise modify one command transmitted serially through a RESTful interface.</p>
        <p class="indent">REST was originally designed as a paradigm for the HTTP protocol, and hence RESTful APIs are most often implemented over HTTP using common HTTP <a id="page_691"></a>verbs, such as GET, PUT, and DELETE. A RESTful client connects to the interface, sends formatted data—for example, a configuration or show command— and the device responds with an HTTP code and optionally formatted data. The returned HTTP code is a standard response; for example, 200 = OK, 401 = unauthorized, etc., informs the client if the command was successful. <a href="ch26.xhtml#ch26fig02">Figure 26-2</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/26fig02.jpg" aria-describedby="Al26fig02" alt="The illustration depicts a RESTful operation." width="312" height="215"><aside class="hidden" id="Al26fig02">
        <p>A client HTTP request (PUT) goes to the server. The HTTP response labeled HTTP code 200 from the server goes back to the client.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch26fig02"></a><strong>Figure 26-2</strong> <em>A RESTful Operation</em></p>
        </div>
        <p class="indent">The data sent and received in a RESTful connection requires some structured formatting. Common data formats include XML, JSON, and YAML (originally standing for <em>Yet Another Markup Language</em>, but later changed to <em>YAML Ain’t Markup Language</em>, a recursive acronym, like GNU, which means <em>GNU’s Not UNIX)</em>.</p>
        <p class="indent">The following snippets illustrate three markup systems often used to format data in a RESTful interface. XML is the first example:</p>
        <p class="codelink"><a href="ch26_images.xhtml#p26pro04a" id="p26pro04">Click here to view code image</a></p>
        <p class="pre">
        &lt;?xml version="1.0" encoding="UTF-8"?&gt;<br>
        &lt;root&gt;<br>
         &lt;Beatles&gt;<br>
        &nbsp;&nbsp;&lt;Revolver&gt;<br>
        &nbsp;&nbsp;&nbsp;&lt;Songs&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;Taxman&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;Eleanor Rigby&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;I'm Only Sleeping&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;Love You Madeline&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;Here, There and Everywhere&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;Ellie Said She Said&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;Good Day Sunshine&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;And Your Bird Can Sing&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;For No One&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;Doctor Alex&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;I Want to Tell You&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;Got to Get You Into My Life&lt;/element&gt;<br>
        <a id="page_692"></a>
        &nbsp;&nbsp;&nbsp;&nbsp;&lt;element&gt;Tomorrow Never Knows&lt;/element&gt;<br>
        &nbsp;&nbsp;&nbsp;&lt;/Songs&gt;<br>
        &nbsp;&nbsp;&lt;/Revolver&gt;<br>
         &lt;/Beatles&gt;<br>
        &lt;/root&gt;</p>
        <p class="indent">XML is a markup language that encodes information between descriptive tags (XML is a superset of the Hypertext Markup Language, or HTML, which was originally designed to describe the formatting of web pages served by servers through HTTP). The encoded information is defined within user-defined schema that enable any data to be transmitted between systems. In the case of network automation, XML-encoded data may be a single command or an entire configuration. The entire XML document is stored as text, making it both machine and human readable.</p>
        <p class="indent">YAML is the second example:</p>
        <p class="codelink"><a href="ch26_images.xhtml#p26pro05a" id="p26pro05">Click here to view code image</a></p>
        <p class="pre">
        Beatles:<br>
         Revolver:<br>
        &nbsp;&nbsp;Songs:<br>
        &nbsp;&nbsp;&nbsp;- Taxman<br>
        &nbsp;&nbsp;&nbsp;- Eleanor Rigby<br>
        &nbsp;&nbsp;&nbsp;- I'm Only Sleeping<br>
        &nbsp;&nbsp;&nbsp;- Love You Madeline<br>
        &nbsp;&nbsp;&nbsp;- Here, There and Everywhere<br>
        &nbsp;&nbsp;&nbsp;- Ellie Said She Said<br>
        &nbsp;&nbsp;&nbsp;- Good Day Sunshine<br>
        &nbsp;&nbsp;&nbsp;- And Your Bird Can Sing<br>
        &nbsp;&nbsp;&nbsp;- For No One<br>
        &nbsp;&nbsp;&nbsp;- Doctor Alex<br>
        &nbsp;&nbsp;&nbsp;- I Want to Tell You<br>
        &nbsp;&nbsp;&nbsp;- Got to Get You Into My Life<br>
        &nbsp;&nbsp;&nbsp;- Tomorrow Never Knows</p>
        <p class="indent">YAML, considered a subset of JSON, is designed to be very human readable. Similar to JSON, YAML is structured in key|value pairs and allows for user-defined white space. The extra white space enables the readability of YAML documents but can be resource intensive to parse.</p>
        <p class="indent">JSON is the third and final example:</p>
        <p class="codelink"><a href="ch26_images.xhtml#p26pro06a" id="p26pro06">Click here to view code image</a></p>
        <p class="pre"><a id="page_693"></a>{<br>
        &nbsp;"Beatles": {<br>
        &nbsp;&nbsp;"Revolver": {<br>
        &nbsp;&nbsp;&nbsp;"Songs": [<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"Taxman",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"Eleanor Rigby",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"I'm Only Sleeping",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"Love You Madeline",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"Here, There and Everywhere",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"Ellie Said She Said",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"Good Day Sunshine",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"And Your Bird Can Sing",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"For No One",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"Doctor Alex",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"I Want to Tell You",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"Got to Get You Into My Life",<br>
        &nbsp;&nbsp;&nbsp;&nbsp;"Tomorrow Never Knows"<br>
        &nbsp;&nbsp;&nbsp;]<br>
        &nbsp;&nbsp;}<br>
        &nbsp;}<br>
        }</p>
        <p class="indent">A more recent alternative to XML is JSON. JSON is defined in RFC4627, and encodes information in structured key|value pairs. The keys in a JSON document are predefined tags that are understood between systems; each such tag has a single associated value. For example, a key of “Command” may have a value of “show running configuration.” In typical cases, a key is a list of values, represented with open and close brackets—for example, “[data1, data2, data3].” Similar to XML, JSON is stored as a text file and is both human and machine readable; however, JSON is much easier for humans to interact with. The main advantage of JSON is that it is straightforward to parse because a key can reference values.</p>
        <p class="indent">REST, XML, JSON, and YAML are all supported in a variety of different programming languages, including C, Java, and Python. Python, mainly because of its ease of use, is the unofficial standard for network programmability and automation projects. The Python language is easy to write, hard to mess up, and is supported on most operating systems. Python supports thousands of libraries that extend the language to support a wide variety of technologies.</p>
        <p class="indent">APIs, Python, REST, and JSON come together to automate a network or network device via programmability. Most modern network operating systems require the API to be enabled on a particular TCP port and configure an authentication method. Then a different computer invokes a Python program to interact with the node. <a href="ch26.xhtml#ch26fig03">Figure 26-3</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/26fig03.jpg" aria-describedby="Al26fig03" alt="The illustration depicts the python programmability." width="467" height="126"><aside class="hidden" id="Al26fig03">
        <p>The illustration shows two rectangular boxes client on the left and router on the right. An arrow labeled JSON formatted data from the client goes to the router. The client box has a smaller rectangular box within it labeled python. The router box has a smaller rectangular box within it labeled RESTful API.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch26fig03"></a><strong>Figure 26-3</strong> <em>Programmability</em></p>
        </div>
        <div class="heading">
        <h3 class="h3" id="ch26lev6"><a id="page_694"></a>On-box Automation</h3>
        <p class="noindent">Many network devices also support on-box automation. On-box automation is a script or procedure running on the management plane of a network device, enabling network operators to automate configurations or events that are local to the network device. Because the on-box automation scripts are distributed with the network device, they are better at handling link failure or isolation-type events. On-box automation tools consist of vendor-specific offerings—for example, Cisco Embedded Event Manager (EEM), Python, or Linux Bash scripts.</p>
        </div>
        <p class="indent">Cisco EEM is a popular on-box automation tool for Cisco devices. Cisco EEM features event detectors—for example, an environmental issue or routing protocol adjacency change and the ability to tie an action to an event. A common example of EEM is to, in the event of a downed interface, automate a response of “shut, no-shut” the interface, or collect information about processes and memory usage when the processor utilization rises above a specific percentage. EEM actions support CLI-based responses or more complex actions with Python or TCL scripts.</p>
        <p class="indent">Some network devices such as Cisco Nexus support on-box automation with Python or BASH scripts. Python or BASH scripting is normally available on network devices running Linux as the underlying OS; it allows the network administrators to automate network or device functions with the flexibility of Python. A sample onbox script may perform an action or generate an alert on bootup or after someone has logged in with privileged access. On-box Python scripts can simulate or replace features that are not available on a deployed platform.</p>
        <div class="heading">
        <h3 class="h3" id="ch26lev7">Network Automation with Infrastructure Automation Tools</h3>
        <p class="noindent">Infrastructure automation tools are designed to manage and automate operating systems, network devices, or resources. Infrastructure automation tools can be used for network automation; however, these tools are more common in agile software <a id="page_695"></a>development tool chains, such as DevOps. Infrastructure automation tools will connect and authenticate with a network device and use either the CLI or an API to make changes. They will have a playbook or manifest detailing how to interact with a specific vendor device for a specific feature. Infrastructure automation tools enable the network to be represented as code, known as Infrastructure as Code (IaC). IaC enables agile network configurations because a DevOps team deploys or changes network resources as part of a software rollout. To date, a number of infrastructure automation tools are available, but the open source tool Puppet is most popular.</p>
        </div>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">DevOps is <em>development operations</em> contracted into a single word. The general idea of DevOps is to use development processes to manage the operational tasks of running a network, such as managing configurations and versioning.</p>
        </div>
        <p class="indent">The Puppet software package, developed by Puppet Labs, is an open source automation toolset for managing servers and other resources by enforcing device states, such as configuration settings.</p>
        <p class="indent">Puppet components include a puppet agent that runs on the managed device (node) and a puppet master (server) that typically runs on a separate dedicated server and serves multiple devices. The operation of the puppet agent involves periodically connecting to the puppet master, which in turn compiles and sends a configuration manifest to the agent; the agent reconciles this manifest with the current state of the node and updates state based on differences.</p>
        <p class="indent">A puppet manifest is a collection of property definitions for setting the state on the device. The details for checking and setting these property states are abstracted, so a manifest can be used for more than one operating system or platform. Manifests are commonly used for defining configuration settings, but they can also be used to install software packages, copy files, and start services.</p>
        <div class="heading">
        <h3 class="h3" id="ch26lev8">Network Controllers and Automation</h3>
        <p class="noindent">A relatively new component in networking is a network controller. Network controllers provide holistic management of a distributed network and a single interface for network automation and programmability. Controllers build an abstraction layer to simplify network management, making network automation easier. An abstracted configuration for a network enables networkwide configurations—for example, setting a new NTP server on a number of devices. In this case, the network operator <a id="page_696"></a>would simply set the configuration in the controller, and the controller would deal with connecting, authenticating, and ensuring the configuration is set on every device, as illustrated in <a href="ch26.xhtml#ch26fig04">Figure 26-4</a>.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/26fig04.jpg" aria-describedby="Al26fig04" alt="Two illustrations on the left and right depict box-by-box automation and controller-based automation." width="610" height="245"><aside class="hidden" id="Al26fig04">
        <p>Illustration on the left shows a rectangular box labeled automation tool. Five downward arrows from the box point to five routers. Illustration on the right shows two rectangular boxes automation tool and network controller. An arrow from the automation tool points to the network controller. Five downward arrows from network controller point to five routers.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch26fig04"></a><strong>Figure 26-4</strong> <em>Box-by-Box versus Controller-Based Automation</em></p>
        </div>
        <p class="indent">Some network controllers feature out-of-the-box automation to deploy and manage networks. For example, the Cisco APIC data center controller automates the deployment of VXLAN as well as many other technologies. Additionally, network controllers simplify deployment of network features by automating complexity and providing guided GUI-based configurations.</p>
        <div class="heading">
        <h3 class="h3" id="ch26lev9">Network Automation for Deployment</h3>
        <p class="noindent">Deployment automation, also known as zero-touch deployment, automates the deployment of new network nodes. Automated deployments ensure new additions to the network infrastructure, either from initial deployment or replacement from failure. Deployment automation reduces the time, risk, and expense of deploying new nodes.</p>
        </div>
        <p class="indent">Deployment automation technologies require a device to request deployment automation from a deployment server. A device may have a configurable flag to request a configuration at next boot or the request can be as simple as lack of a configuration. The network device will find an automation server using information discovered through DHCP or with broadcast technologies. The node will then ask the automation tool for a configuration server. The configuration server must respond to the request using a templated configuration that may be customized by the automation tool. A final step for a deployment automation tool is to notify the network administrator a new device has been added.</p>
        <p class="indent">Deployment automation tools are available for data center, campus, and wide area network (WAN) environments. To date, there is no standard for deployment <a id="page_697"></a>automation solutions, and each vendor brings proprietary solutions to market. These solutions are normally a component of larger network management tools, such as Cisco Prime for WAN/campus environments or Cisco Data Center Network Manager (DCNM) for data centers.</p>
        <div class="heading">
        <h3 class="h3" id="ch26lev10">Final Thoughts on the Future of Network Automation: Automation to Automatic</h3>
        <p class="noindent">An emerging and very popular world of data analytics and machine learning will power the next generation of network automation. <em>Data analytics</em> is a general term for a series of tools allowing the collection of data and transforming the data into organized and insightful information. Much of the data that network devices generate today is discarded. This discarded data could give network operators better insight into the status and health (logs) of network devices (configurations), network traffic, or the health of applications traversing the network.</p>
        </div>
        <p class="indent">Machine learning enables computers to predict events from the data. For example, machine learning may predict a security issue or an expected traffic load. Machine learning systems can then change network configuration based on its predictions without human intervention. The combination of data analytics, machine learning, and network automation will enable self-provisioning, self-healing networks and the transition to automatic networks.</p>
        <div class="heading">
        <h3 class="h3" id="ch26lev11">Further Reading</h3>
        <p class="noindent">Other resources on network automation and programmability:</p>
        </div>
        <p class="ref">Ansible by Red Hat. “Ansible Is Simple IT Automation.” Accessed September 3, 2017. <a href="https://www.ansible.com">https://www.ansible.com</a>.</p>
        <p class="ref">Bjorklund, Martin. <em>The YANG 1.1 Data Modeling Language</em>. Request for Comments 7950. RFC Editor, 2016. doi:10.17487/RFC7950.</p>
        <p class="ref">———. <em>YANG—A Data Modeling Language for the Network Configuration Protocol (NETCONF)</em>. Request for Comments 6020. RFC Editor, 2010. doi:10.17487/RFC6020.</p>
        <p class="ref">“CFEngine—Automate Large-Scale, Complex and Mission Critical IT Infrastructure with CFEngine.” <em>CFEngine</em>. Accessed September 3, 2017. <a href="https://cfengine.com/">https://cfengine.com/</a>.</p>
        <p class="ref">“Chef: Automate Infrastructure and Applications.” <em>Chef</em>. Accessed September 3, 2017. <a href="https://www.chef.io/">https://www.chef.io/</a>.</p>
        <p class="ref"><a id="page_698"></a>“Expect—Expect—Home Page.” Accessed September 3, 2017. <a href="http://expect.sourceforge.net/">http://expect.sourceforge.net/</a>.</p>
        <p class="ref">“Extensible Markup Language (XML).” Accessed September 3, 2017. <a href="https://www.w3.org/XML/">https://www.w3.org/XML/</a>.</p>
        <p class="ref">Goyvaerts, Jan. “Regular Expressions: The Complete Tutorial,” July 2007. <a href="https://www.princeton.edu/~mlovett/reference/Regular-Expressions.pdf">https://www.princeton.edu/~mlovett/reference/Regular-Expressions.pdf</a>.</p>
        <p class="ref">“Grpc / Grpc.io.” Accessed September 3, 2017. <a href="https://grpc.io/">https://grpc.io/</a>.</p>
        <p class="ref">Harrington, David, Bert Wijnen, and Randy Presuhn. <em>An Architecture for Describing Simple Network Management Protocol (SNMP) Management Frameworks</em>. Request for Comments 3411. RFC Editor, 2002. doi:10.17487/RFC3411.</p>
        <p class="ref">Marshall, A. D. “Remote Procedure Calls.” In <em>Programming in C: UNIX System Calls and Subroutines Using C</em>, 2005. <a href="https://users.cs.cf.ac.uk/Dave.Marshall/C/node33.html">https://users.cs.cf.ac.uk/Dave.Marshall/C/node33.html</a>.</p>
        <p class="ref">Meyer, Paul, David B. Levi, and Bob Stewart. <em>Simple Network Management Protocol (SNMP) Applications</em>. Request for Comments 3413. RFC Editor, 2002. doi:10.17487/RFC3413.</p>
        <p class="ref">“Netconf Central.” Accessed September 3, 2017. <a href="http://www.netconfcentral.org/">http://www.netconfcentral.org/</a>.</p>
        <p class="ref">Petrusha, Ron. “Regular Expression Language—Quick Reference.” Documentation, March 2017. <a href="https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference">https://docs.microsoft.com/en-us/dotnet/standard/base-types/regular-expression-language-quick-reference</a>.</p>
        <p class="ref">Presuhn, Randy. <em>Version 2 of the Protocol Operations for the Simple Network Management Protocol (SNMP)</em>. Request for Comments 3416. RFC Editor, 2002. doi:10.17487/RFC3416.</p>
        <p class="ref">“Puppet—The Shortest Path to Better Software.” <em>Puppet</em>. Accessed September 3, 2017. <a href="https://puppet.com/">https://puppet.com/</a>.</p>
        <p class="ref">Schönwälder, Jürgen. <em>Overview of the 2002 IAB Network Management Workshop</em>. Request for Comments 3535. RFC Editor, 2003. doi:10.17487/RFC3535.</p>
        <p class="ref">Thurlow, Robert. <em>RPC: Remote Procedure Call Protocol Specification Version 2</em>. Request for Comments 5531. RFC Editor, 2009. doi:10.17487/RFC5531.</p>
        <p class="ref">Tischer, Ryan, and Jason Gooley. <em>Programming and Automating Cisco Networks: A Guide to Network Programmability and Automation in the Data Center, Campus, and WAN</em>. 1st edition. Indianapolis, IN: Cisco Press, 2016.</p>
        <p class="ref">White, James E. <em>High-Level Framework for Network-Based Resource Sharing</em>. Request for Comments 707. RFC Editor, 1975. doi:10.17487/RFC0707.</p>
        <p class="ref">“XML Tutorial.” Accessed September 3, 2017. <a href="https://www.w3schools.com/xml/">https://www.w3schools.com/xml/</a>.</p>
        <div class="heading">
        <h3 class="h3" id="ch26lev12"><a id="page_699"></a>Review Questions</h3>
        <p class="indenthangingN">1. What is the primary objective for automating network device configurations?</p>
        </div>
        <p class="indenthangingN">2. What are the advantages and disadvantages of SNMP?</p>
        <p class="indenthangingN">3. Explain the relationship between NETCONF, YANG, and a YANG model.</p>
        <p class="indenthangingN">4. What is the difference between NETCONF and RESTCONF?</p>
        <p class="indenthangingN">5. Research the concept of an ATOMIC operation. How is this similar to, or different from, a RESTful interface?</p>
        <p class="indenthangingN">6. What is the difference between development operations, or the automation of network configurations, and Software-Defined Networks (SDNs)?<a id="page_700"></a></p>
        <p class="footnotet"><a id="ch26fn-1"></a><a href="ch26.xhtml#ch26fn1">1</a>. Schönwälder, Overview of the 2002 IAB Network Management Workshop.</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780134762814/files/9780134762852.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com