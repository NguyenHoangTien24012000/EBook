<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch24"><a id="page_629"></a><strong>Chapter 24<br>Troubleshooting</strong></h2>
        <div class="sidebar">
        <p class="sb-noindent"><strong>Learning Objectives</strong></p>
        <p class="sb-noindent">When you are finished reading this chapter, you should understand:</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The concept of narrowing as a part of the troubleshooting process</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> How to break a network down into components for troubleshooting</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The difference between how and what models for troubleshooting</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The importance of finding tools able to measure the problem</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The importance of models in troubleshooting</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The concept of half split and move</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The concept of technical debt</p>
        </div>
        <p class="noindent">It’s 2 a.m., the network is down, and the CEO is on the phone asking when it is going to be back up. The overnight job crucial to the business opening in the morning has failed, and the company stands to lose millions of dollars if the network is not fixed in the next hour or so. Almost every network engineer has faced this problem at least once in his career, often involving intense bouts of shouting (and/or screaming) intermixed with panicked attempts to find the root cause and fix it.</p>
        <p class="indent">And yet troubleshooting is a skill that is hardly ever taught. There are a number of computer science programs that do include classes in troubleshooting, but these tend to be mostly focused on tools, rather than technique, or focused on practical skill application. While this chapter cannot be a complete course in troubleshooting, it will provide a basic overview of troubleshooting, including the problem set and some <a id="page_630"></a>tools you will find helpful in locating and fixing problems (more) quickly. The basic question this chapter will answer is</p>
        <p class="blockquote"><strong>What is the most effective process for finding and fixing problems in a network?</strong></p>
        <p class="indent">Each of the following sections will address one part of the answer to this question.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">In many cases, the points made in this chapter will be exemplified through stories told in the first person; these are true stories of troubleshooting success and failure supplied to help you understand the point being made.</p>
        </div>
        <div class="heading">
        <h3 class="h3" id="ch24lev1">What Is the Purpose?</h3>
        <p class="noindent">Troubleshooting tends to be an exercise in narrowing—starting from a broad and imprecise description of the problem, moving to a more focused description, and finally finding one or more things to change in the network to resolve the problem. As with design, however, it is often easy to narrow too quickly and then to hop around rather than remembering to refocus on the overall purpose of the system if your first attempt at solving the problem does not turn out to be “the” problem.</p>
        </div>
        <p class="indent">In the middle of a long, exhausting troubleshooting session, it is easy to think of the system as the network path the application runs over and the application itself. To use an example from electronics, rather than networking:</p>
        <p class="blockquote"><em>One of the pieces of equipment on the flightline was a wind speed indicator. This is fancy name for a really simple device; there was a small “bird” attached to the top of a pole with a tail guiding the bird into facing the wind, and then at the nose of the bird an impeller attached to a Direct Current (DC) motor. The DC motor drove a simple DC voltmeter graduated with wind speeds, and the entire system was calibrated using a resistive bridge in the wind speed indicator box, and another in the wind bird itself. The power from the impeller was passed to the voltmeter, several miles away, through a 12-gauge cable. These cables were particularly troublesome, as they were buried, and had to be spliced using gel-coated connectors, with splices buried in gel-filled casing. This was all before the advent of nitrogen-filled conduit to keep water out</em>.</p>
        <p class="blockquote"><a id="page_631"></a><em>In one particular instance, a splice failed, requiring the cable to be dug up by hand, and the splice opened and repaired. A special team was called in to resplice the cable, but even with the new splice in place, the wind system could not be calibrated to work correctly. The cable team argued the cable had all the right voltage and resistance readings; we argued back that the equipment had been working correctly before the splice failed, and all tested on the bench okay, so the problem must still be in the splice. The argument lasted for days. From the view of the cable team, their “system” was working properly. From the perspective of the weather techs, the system was not, even though the testable components were. Who was right? It all came down to this: What does the “system” consist of, and what does “working properly” mean?</em></p>
        <p class="blockquote"><em>Eventually, by the way, the cable splice was fingered as the problem in a capacitive crosstalk test. The splice was redone, and the problem disappeared</em>.</p>
        <p class="indent">The purpose is ultimately what the system is supposed to <em>do</em>, not just what <em>you can measure</em>. It does not matter if the network, or some component of the network, appears to be working fine. What matters is whether or not the system is accomplishing its purpose.</p>
        <p class="indent">Of course, this means you need to understand what the purpose of the system is. In the broadest view, this means <em>what the system is supposed to accomplish from a business perspective</em>. A network can be running just fine from the perspective of the engineers who built it, but if it is not solving a business problem the way the business problem needs to be solved, it is still broken.</p>
        <p class="indent">On the other hand, it is important to remember business folks do not always understand precisely how the business and the network relate, or they may have unrealistic expectations of what the network is capable of, or what is possible. In these cases, resist the urge to ask, “How high?” when the business says, “Jump!” Rather, cultivate a conversation in which you, the network engineer, have the right to say, “No, this will add too much complexity,” or “The tradeoff here is too high.”</p>
        <p class="indent">Moving from the business to the network itself, there is a different, but still large, context: the network components.</p>
        <div class="heading">
        <h3 class="h3" id="ch24lev2">What Are the Components?</h3>
        <p class="noindent">Saying “a network is made up of components” is like saying “a menagerie of hand-made glass animals is made up of…glass”—it is not very useful. More specifically, what are the components of a network? In the network world, there are</p>
        </div>
        <p class="bullt"><a id="page_632"></a>• Hardware devices that process and forward traffic, such as routers, switches, and stateful packet filters</p>
        <p class="bull">• The environmentals, such as the power and cooling</p>
        <p class="bull">• The cabling, interfaces, and other hardware</p>
        <p class="bull">• The software running on these devices (the operating system)</p>
        <p class="bull">• The software applications providing the information needed to forward packets; the control plane</p>
        <p class="bull">• The specifications to which the network was designed and needs to operate in order to fulfill <em>business requirements</em></p>
        <p class="bullb">• The requirements placed on the network by the applications the network is supporting</p>
        <p class="indent">A broader, and simpler, set of terms might be: requirements + network software + protocols + equipment. Again, this might be a little obvious, but it is easy to forget the entire picture at 2 a.m. when the fires are burning hot, and you are trying to put them out.</p>
        <p class="indent">How well can you know each of these four systems? Can you know them in fine detail, down to the last packet transmitted and the last bit in each packet? Can you know the flow of every packet through the network, and every piece of information any particular application pushes into a packet, or the complete set of ever-changing business requirements?</p>
        <p class="indent">Obviously, the answer to these questions is no.</p>
        <p class="indent">As these four systems within a network interact (remember interaction surfaces from the first chapter?), they create a larger system that suffers from a combinatorial explosion. <a href="ch24.xhtml#ch24fig01">Figure 24-1</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/24fig01.jpg" aria-describedby="Al24fig01" alt="Illustration of combinatorial of systems within a network interact." width="284" height="284"><aside class="hidden" id="Al24fig01">
        <p>The systems: network software on the top left, protocols on the top right, requirements on the bottom left, and hardware on the bottom right are shown with an oval. These for system are shown overlapping each other at the center forming a circle that represents combinatorial explosion.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch24fig01"></a><strong>Figure 24-1</strong> <em>Combinatorial Explosion of Systems in a Network</em></p>
        </div>
        <p class="indent">There are far too many combinations, and far too many possible states, for any one person to know all of them. How can you reduce the amount of information so you can reasonably understand the state of an entire system, and hence be able to troubleshoot it? By building abstract models of the system’s components, the interaction points between those components, and, ultimately, of the system itself.</p>
        <p class="blockquote"><strong>This is the first skill of effective troubleshooting: build a set of models describing the system.</strong></p>
        <p class="indent">All models will necessarily be <em>incomplete;</em> a model can represent only some aspects of an entire system or subsystem. Thus, models are a two-edged sword: they present a more readily understandable version of a system, but they also present a necessarily incomplete version of a system.</p>
        <div class="heading">
        <h3 class="h3" id="ch24lev3"><a id="page_633"></a>Models and Troubleshooting</h3>
        <p class="noindent">There is no single way, nor a single set of tools, you can use to build an effective model. This section will consider some common kinds of models—<em>how</em> models and <em>what</em> models—and discuss how to build them. The importance of accurate models and the ability to use models in the troubleshooting process effectively are also considered here.</p>
        </div>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">This has some interesting implications, of course. For instance, when a system is a “black box,” which means you are not supposed to know how the system works, your ability to troubleshoot the system itself is nonexistent, and your ability to troubleshoot any larger system of which the black box is a component is severely hampered.</p>
        </div>
        <div class="heading">
        <h4 class="h4" id="ch24lev4"><strong>Build</strong> <em><strong>How</strong></em> <strong>Models</strong></h4>
        <p class="noindent"><em>How</em> models are built using problem/solution sets. This entire book, in fact, is an exercise in building <em>how</em> models, using a three-step process:</p>
        </div>
        <p class="indenthangingN">1. Determine the problem that needs to be solved.</p>
        <p class="indenthangingN">2. Investigate the range of possible solutions for the particular problem.</p>
        <p class="indenthangingN">3. Understand how this particular implementation uses a particular solution to solve a particular problem.</p>
        <p class="indentt"><a id="page_634"></a>A potential fourth step beyond these three is integrating many solutions together into a complete system, considering the interaction between the solutions (such as where one solution reduces or increases the effectiveness of some other solution, etc.).</p>
        <p class="indent">How models, of course, do not answer only one sort of question; for instance, when considering <em>how</em> Border Gateway Protocol (BGP) peers are formed:</p>
        <p class="indenthangingN">1. How does BGP manage flow control, error control/correction, and data marshaling between two BGP speakers?</p>
        <p class="indenthangingN">2. How does BGP manage the peering state between two BGP speakers?</p>
        <p class="indenthangingN">3. How does an operator configure BGP to properly form peering relationships between two BGP speakers?</p>
        <p class="indentt">Each of these is a separate kind of <em>how</em> question. Where many engineers go wrong in building a solid foundation for troubleshooting is knowing the answers to the second and third questions, while never spending time on the first. Engineering tends to end up being focused on the question <em>how do I get this done?</em> rather than <em>how does this work?</em>, specifically <em>why does this work this way?</em> The result is a “hunt and peck” sort of troubleshooting style—combining small snippets of past problems with lots of knowledge about how things should be configured to make them work. This is generally a very inefficient way to not only design networks and protocols, but also to troubleshoot them.</p>
        <p class="indent">You need to be able to build <em>how</em> models of all three types. There are several useful ways to build up your stock of <em>how</em> models, including</p>
        <p class="bullt">• Reading protocol theory and specifications, so you understand how and why a protocol operates (what problems are being solved and how they are being solved)</p>
        <p class="bull">• Examining the designs of protocols and networks, and how they have performed in the real world</p>
        <p class="bullb">• Learning basic algorithms and heuristics, along with the problems they are designed to solve</p>
        <p class="indent">Essentially, building <em>how</em> models is more about <em>theory</em> than <em>practice;</em> this is why engineers often skip learning <em>how</em> models—which prevents them from growing their engineering skills over the long term. <em>How</em> models are sometimes best expressed in a graphical format, such as Universal Modeling Language (UML) sketches, or flow charts.</p>
        <div class="heading">
        <h4 class="h4" id="ch24lev5"><a id="page_635"></a><strong>Build</strong> <em><strong>What</strong></em> <strong>Models</strong></h4>
        <p class="noindent"><em>What</em> models are different from <em>how</em> models in describing the state of a particular network or application, or a common pattern found across many networks or applications. These kinds of models generally answer questions such as</p>
        </div>
        <p class="bullt">• What is the normal path of this traffic flow (the signal path) through the system (such as a network, application, etc.)?</p>
        <p class="bull">• What is the normal set of top talkers on this network?</p>
        <p class="bull">• What is the normal distribution of load between these two paths in the network?</p>
        <p class="bullb">• What is the normal startup process between two BGP speakers?</p>
        <p class="indent">The only real way to learn <em>what</em> is to observe and summarize many times over. For instance, observing the top talkers across a large number of networks, or even in a single network across a number of years, will give you a good sense of where to look for top talkers, and a good sense of when the top talkers in <em>this situation</em> do not make sense.</p>
        <p class="indent">Manipulation in the observation process is important here, as well; <a href="ch24.xhtml#ch24fig02">Figure 24-2</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/24fig02.jpg" aria-describedby="Al24fig02" alt="Illustration of Manipulation and Causation." width="318" height="229"><aside class="hidden" id="Al24fig02">
        <p>Two horizontal straight lines are shown connected at the center by a variable Z subscript i. The left end of the line is marked X and the right end is marked Y. Z subscript 1, Z subscript 2, Z subscript 3, and goes till Z subscript n are shown listed below Z subscript i. A dashed rectangular box represents variable set V is shown enclosing the listed of variables Z subscript i. Lines from variable Y are shown flowing toward each variable within the variable set V. Another rectangular box representing the hidden constant is shown enclosing the lines flowing from the variable Y and the listed variables from Z subscript 1 to Z subscript n.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch24fig02"></a><strong>Figure 24-2</strong> <em>Manipulation and Causation</em></p>
        </div>
        <p class="indent">In <a href="ch24.xhtml#ch24fig02">Figure 24-2</a>, some value (representing, perhaps, an event or a property of an object) is assigned a variable, X. The question causation answers is: <em>does X somehow cause Y?</em> To answer this question, a range of possible interventions, or rather actions that will potentially modify X, are considered. In order to show X causes Y, all other potential interventions, Z<sub>1</sub> through Z<sub>n</sub>, are held constant, while one potential intervention, Z<sub>i</sub>, is manipulated. Manipulability is useful in building <em>how</em> models <a id="page_636"></a>by helping you understand the relationship between the different parts of a system; if you manipulate the impact of X on Y by changing Z<sub>i</sub>, then you can better understand the relationship between X and Y.</p>
        <p class="indent">For instance, assume you want to understand how a specific application uses the network in terms of traffic flow, one possible way to go about discovering this information is by setting up a test instance of the application that passes through a router on which you can manipulate the Quality of Service (QoS) settings. By manipulating the QoS settings while watching the traffic flow, you can get a better sense of how the application works; you are literally building a <em>what</em> model of the application’s operation.</p>
        <p class="indent">It is important to build such models under as close to real-world conditions as possible, rather than in a “lab environment.” A real-world example might be helpful here, told in the first person:</p>
        <p class="blockquote"><em>One time I was called out with another tech from my shop to work on the FPS-77 storm detection radar. There was some problem in the transmitter circuit; the transmitter just was not producing power. A resistor blew in the “right area” all the time, so we checked the resistor, and sure enough, it seemed like it was shorted. We ordered another resistor, shut things down, and went home for the morning (by the time we finished working on this, it was around 3 a.m.). The next day, the part came in and was installed by someone else. The resistor promptly showed a short again, and the radar system failed to come back up</em>.</p>
        <p class="blockquote"><em>What went wrong? I checked what was simple to check, what was a common problem, and walked away thinking I had found the problem, that is what. It took another day’s worth of troubleshooting to pin the problem down, a component in parallel with the original resistor, but not on the same board, or even in the same area of the schematics, had failed. This second component was an inductor— essentially just a piece of wire wound tightly around a ceramic core. Inductors only show resistance when alternating current passes through them; they will always show a short when direct current is passed through them. Because the resistor and the inductor were in parallel, and the ohmmeter (a device which measures resistance) only uses direct current to measure resistance, the entire circuit appeared to be shorted</em>.</p>
        <p class="blockquote"><em>In reality, the inductor failed, but the ohmmeter, because it cannot produce alternating current at the right frequency and power level, simply could not “see” the correct failure, and I was too tired, and too convinced I had found the problem in the first try (because it was the “common” problem in this signal path), to check beyond the first discovery</em>.</p>
        <p class="indent"><a id="page_637"></a>There are several kinds of <em>what</em> models engineers should build, including</p>
        <p class="bullt">• A description of the normal state of each system in a production environment. This is often called the baseline, and should include traffic levels measured at different points in the network at different times of the day, different seasons, and during different kinds of regular events; the amount of time it takes for any particular process to run, such as the Shortest Path First (SPF) runtime in a network running a link state control plane; jitter and delay through the network on a per application basis, etc. These measures are important because you cannot know what “broken” looks like unless you know what “normal” looks like.</p>
        <p class="bull">• A description of the normal configuration of each system in a production environment. Many networks will have a single source of truth that contains the proposed configuration for each device. Many automation systems are designed to ensure each device matches the proposed configuration contained in this single source of truth. These systems should also contain the <em>intent</em> behind each configuration, as a single intent can be expressed in many different ways.</p>
        <p class="bull">• A description of the “normal” reaction of the network to different types of events.</p>
        <p class="bull">• A description of the signal path of every application running on the network, including the origination of information from the application, the paths the traffic normally takes through the network, queuing, and other ways in which the traffic is processed.</p>
        <p class="bullb">• A description of the security boundaries in the network, including the boundaries of each security domain (logical or topological), why the security domain exists, and how the various security domains interact.</p>
        <p class="indent">While some of these will necessarily be <em>complete</em>, in containing every available piece of information within a particular domain, it is also important to be able to summarize each one into a model. Knowing what to abstract is a skill that takes years to develop, and can never said to be perfected.</p>
        <div class="heading">
        <h4 class="h4" id="ch24lev6"><strong>Build Accurate Models</strong></h4>
        <p class="noindent">In fact, choosing which information to abstract into a model is such a difficult problem that network engineers often live with poorly built models that simply do not represent the underlying system accurately—or simply do not provide the <a id="page_638"></a>information needed to ground good troubleshooting or design. <a href="ch03.xhtml#ch03">Chapter 3</a>, “<a href="ch03.xhtml#ch03">Modeling Network Transport</a>,” discusses one such (controversial) example, the widely used Open Systems Interconnect (OSI) model. The OSI model is a good example of a useful model in a narrow range of contexts, but is often used far outside the domain in which it adds value. <a href="ch24.xhtml#ch24fig03">Figure 24-3</a> illustrates the OSI and the Recursive Internet Architecture (RINA) models for reference.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/24fig03.jpg" aria-describedby="Al24fig03" alt="Illustration of OSI Model on the left and RINA Model on right are shown." width="473" height="309"><aside class="hidden" id="Al24fig03">
        <p>The OSI Model shows a rectangular box divided into seven boxes vertically that reads from top to bottom: application, presentation, session, transport, network, data link, and physical. The RINA Model shows four sets of rectangular box arranges vertically represents layer 4, layer 3, layer 2, and layer 1 from top to bottom. Each set consists of two boxes that read error or flow control and transport or multiplex.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch24fig03"></a><strong>Figure 24-3</strong> <em>The OSI and RINA Models</em></p>
        </div>
        <p class="indent">A simple question illustrates the differences between these two models of forwarding information through a network: <em>what functionality does this model describe?</em> The Open Systems Interconnect (OSI) model generally describes the kinds of information contained at each layer in the network, which is also useful in describing the kind of information carried between layers to carry information through the network. The RINA model, on the other hand, focuses on <em>functionality:</em> what problem is solved where in the network stack for this particular connection (whether hop by hop or end to end).</p>
        <p class="indent">While the OSI model is often useful for <em>coding</em> a network stack, because it describes information and APIs, the RINA model is often more useful for <em>understanding</em> a network stack—knowing what is happening where and why. The RINA model, in other words, more closely aligns with the problem/solution mindset needed to troubleshoot a network problem.</p>
        <p class="indent">Accuracy does not mean <em>perfection</em>, in the sense that every aspect of the system is represented, but rather <em>fit to purpose</em>. Different models may be required to understand different aspects of a particular system; one model may be useful for troubleshooting one sort of problem, and another model may be useful for troubleshooting another sort of problem (or another part of the same overall problem).</p>
        <div class="heading">
        <h4 class="h4" id="ch24lev7"><a id="page_639"></a><strong>Shifting between Models</strong></h4>
        <p class="noindent">Having a lot of models in your head to describe various aspects of the system is not helpful, however, if you do not know how to apply these models to the problem at hand. If you just take all these models and add them to the store of knowledge you already have about the system, you can make troubleshooting harder, rather than easier. The key lies in knowing how to apply models to the troubleshooting process.</p>
        </div>
        <p class="indent">The first step in applying models to troubleshooting is to learn how to shift between the various models as you need to, as you move between needing to understand a broader view of the system and a more detailed view of any piece of the system. <a href="ch24.xhtml#ch24fig04">Figure 24-4</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/24fig04.jpg" aria-describedby="Al24fig04" alt="Illustration depicts the Models in Troubleshooting." width="608" height="393"><aside class="hidden" id="Al24fig04">
        <p>The root node, network path is branched out to two sub nodes on either side that reads control plane and date plane. The control plane node is shown divided into two sub nodes, convergence characteristics and shortest paths. The convergence characteristics is shown further divided into three nodes: failure detection, loop and topology and timers and tuning. The data plane on the left is branched out to the node, quality of service which is further divided into queuing, bandwidth, and jitter and delay.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch24fig04"></a><strong>Figure 24-4</strong> <em>Using Models in Troubleshooting</em></p>
        </div>
        <p class="indent">In <a href="ch24.xhtml#ch24fig04">Figure 24-4</a>, the overall system is depicted as a network path. Of course, there would be a larger context, such as business requirements, an application, or a set of applications, in real-life situations, but using the network path as a larger context will work for this example. Assume you are troubleshooting a problem with a specific flow through the network; the overall model you would keep in your head is the entire network path. As you encounter individual pieces of information about the problem, however, you might realize the problem appears to be something in the data plane, which might include QoS. Further information might indicate the problem is the application’s reaction to jitter on the network, which should move you from the QoS model into a jitter model, which evokes a different model.</p>
        <p class="indent"><a id="page_640"></a>Each model, as you move down the tree, is going to contain more detail within the specific area, but it is going to exclude more information from other areas of the network. Each model should accurately represent the problem and system at hand; using a model that “does not fit” at any point in this process can lead you down the wrong path in the “model tree.”</p>
        <p class="indent">Another problem engineers often face in troubleshooting is an unwillingness to mentally move back toward the top of the tree; in this case, it would be easy to focus on the jitter problem without considering how the convergence characteristics of the control plane might interact with jitter. Once an idea has been formed about what the problem is, it is important to start back at the top of the “model tree” and work back down toward the more specific models from the more abstract ones <em>taking the new information into account</em>. An example might be helpful here, told in the first person:</p>
        <p class="blockquote"><em>Two engineers were called into a major network failure at a rather important bank; for some reason, the routing protocol, the Enhanced Interior Gateway Routing Protocol (EIGRP), simply would not converge under some conditions. The Technical Assistance Center (TAC) had tried various troubleshooting techniques, reconfiguring EIGRP in various ways; finally the problem was escalated to the Global Escalation Team</em>.</p>
        <p class="blockquote"><em>To begin, the escalation engineers started gathering all the information they could on the state of EIGRP during the outage; thus the primary model in use was around the operation of the EIGRP protocol and its convergence process. Over time, it became apparent the problem related to missed EIGRP packets; so the engineers began looking at the packet processing and the transport links between the routers. Thus the model in use for troubleshooting moved towards the transport and packet processing side. It appeared the packets were being transmitted, but not received, so the focus again shifted to packet processing on the impacted routers. As almost every router in the network appeared to be impacted, this was still a very wide scope, but it quickly dove into rather detailed considerations about how packets were received, queued, and forwarded on to the EIGRP process, and how information about what was going on in this processing could be gathered in a production network</em>.</p>
        <p class="blockquote"><em>To discover this information, a server was set up to capture the input queue of several routers periodically. Each time there was a failure in an EIGRP neighbor state, the log file was pulled to see what, specifically, was in the queue at the moment in time to cause the EIGRP packets to not be delivered. The results were puzzling, to say the least; the packets in the queue were always from the same Internet Protocol (IP) address. No one could identify this IP address, so the <a id="page_641"></a>engineers began to suspect some form of denial of service attack. Ultimately, however, the offending server was found: it was a security server. The routers in the network had been configured to send a per command authorization request to this server to ensure the user currently logged in to the router had permission to run the specific command. The packets in the input queue each time the command completed and printed its output were the reply from the authentication server allowing the command to be executed. Needless to say, this rabbit trail did not help solve the problem any faster</em>.</p>
        <p class="blockquote"><em>Eventually, the command level authentication was turned off, and the problem was found. A new backup software package had been installed on every host in the network—the server version had been installed on every host, rather than the client version. The server version, in order to find clients, attempted to contact every host on the network using subnet broadcasts across the entire IP address range, at a very high packet rate. These subnet broadcasts were being consumed by the actual routers, clogging the local process input queue, and hence causing EIGRP packets to be dropped</em>.</p>
        <p class="indent">The problem here ultimately required shifting between a number of different mental models, each one covering a different part of the network’s operation, but it was important, when shifting between models, to refocus on the “larger context,” so the problem at hand would not be forgotten. For instance, progress on the actual problem was completely left aside while the “rogue IP address” was being chased down.</p>
        <div class="heading">
        <h3 class="h3" id="ch24lev8">Half Split and Move</h3>
        <p class="noindentb">While being able to shift between models is important, shifting between models randomly is generally not the most efficient way to go about troubleshooting a problem (although it is a common enough technique in the real world). What you need, once you have models built up and you have developed the ability to shift between models, is some way to guide how you move up and down the “model tree” while troubleshooting. Essentially, you need to know three things:</p>
        </div>
        <p class="indenthangingN">1. What question do you need to ask?</p>
        <p class="indenthangingN">2. How do you ask this question?</p>
        <p class="indenthangingN">3. Once this question has been answered, where should you move next in the system to continue troubleshooting?</p>
        <p class="indent1"><a id="page_642"></a>One method stands out as a guide across many years of experience across many fields of study: the half split method. The steps for the half split method are as follows:</p>
        <p class="indenthangingN">1. Map out the path of a signal through the system.</p>
        <p class="indenthangingN">2. Split the path (roughly) in half.</p>
        <p class="indenthangingN">3. Test the signal at the halfway point to determine if it is correct or incorrect.</p>
        <p class="indenthangingN">4. If the signal is incorrect, move toward the source.</p>
        <p class="indenthangingN">5. If the signal is correct, move toward the destination.</p>
        <p class="indent1">The connections between the half split method and the concept of having models should be fairly apparent:</p>
        <p class="bullt">• The path of a signal through a system can be described as a set of overlap-ping models, with “lower level,” more detailed models being components of the larger context, more abstract models.</p>
        <p class="bullb">• The path of the signal is going to rely on the overall operation of standard components; each of these components either intersects or underlies one of the system models you encounter when tracing out the path of the signal.</p>
        <p class="indent">The half split method can be used to guide your troubleshooting process through the subsystems within the system, using models to abstract enough information so you can “contain” the pieces you are trying to test in one step through the process. The half split method also helps you form the questions you need to ask of the system to know whether it is operating properly, such as</p>
        <p class="bullt">• What is the actual state of the system, and the result on the signal, at this point?</p>
        <p class="bullb">• What should a “normal” state look like?</p>
        <p class="indent">The half split method can also force you to take your time and think through each step of the process. It is easy, when troubleshooting, to simply jump to where you think the problem might be and then dive into that small piece of the problem. Using the half split method will force you to look at what you are seeing, compare it to what should be there, and return to the larger context (move back up the “model tree”) on a regular basis. These are all crucial to not getting lost in the weeds, troubleshooting something that is either not a problem or is a symptom instead of a problem.</p>
        <p class="indent"><a id="page_643"></a>When considering the concept of half splitting in a network, what is the <em>signal?</em> Essentially, it is <em>anything you can look at to verify the state of the system</em>. For instance:</p>
        <p class="bullt">• The state of a neighbor adjacency in a routing protocol</p>
        <p class="bull">• The jitter or delay on a given set of packets within a flow</p>
        <p class="bull">• The existence of a flow of packets at a particular point in the network</p>
        <p class="bullb">• The completeness of a flow of packets at a particular point in the network (primarily looking for dropped packets)</p>
        <p class="indent">To find the signal, figure out what you would expect to be true of any particular information flow at this point (whether local, between peers, or end to end, host to host, etc.), and then determine what you think it should look like at the point you intend to test in the network. You might only need to shift between models during troubleshooting, but you might also need to shift between signals. For instance, in the example given in <a href="ch24.xhtml#ch24fig04">Figure 24-4</a>, you need to shift from examining the jitter in a flow of packets through a network to the way in which the control plane converges, which may involve the <em>signal path</em> of distributing information about changes in the network topology. Both <em>getting stuck in a single signal path</em> and <em>hopping from signal to signal</em> are errors to be avoided in troubleshooting. These can be avoided using the two methods outlined in the following sections—using manipulability and simplification—but sometimes experience is the only and best guide.</p>
        <div class="heading">
        <h4 class="h4" id="ch24lev9"><strong>Using Manipulability</strong></h4>
        <p class="noindent">Manipulation—and manipulability—is a key tool for testing theories and discovering the difference between correlation and causation. For reference, <a href="ch24.xhtml#ch24fig02">Figure 24-2</a> is repeated as <a href="ch24.xhtml#ch24fig05">Figure 24-5</a> here.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/24fig05.jpg" aria-describedby="Al24fig05" alt="Illustration of Manipulation and Testing." width="318" height="229"><aside class="hidden" id="Al24fig05">
        <p>Two horizontal straight lines are show connected at the center by a variable Z subscript i. The left end of the line is marked X and the right end is marked Y. Z subscript 1, Z subscript 2, Z subscript 3, and goes till Z subscript n are shown listed below Z subscript i. A dashed rectangular box represents variable set V is shown enclosing the listed of variables Z subscript i. Lines from variable Y are shown flowing toward each variable within the variable set V. Another rectangular box representing the hidden constant is show enclosing the lines flowing from the variable Y and the listed variables from Z subscript 1 to Z subscript n.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch24fig05"></a><strong>Figure 24-5</strong> <em>Manipulation and Testing</em></p>
        </div>
        <p class="indent"><a id="page_644"></a>In troubleshooting, the key point is to find some Z you can use to modify the output of X in a way that impacts Y. In other words, if Y is the measured signal, you want to find some way to modify X to either show X is the cause of the current state of Y, or it is not. <a href="ch24.xhtml#ch24fig06">Figure 24-6</a> is used to explain this concept through an example.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/24fig06.jpg" aria-describedby="Al24fig06" alt="Illustration of Manipulation in Testing." width="478" height="203"><aside class="hidden" id="Al24fig06">
        <p>The computer, A on the left is shown connected to two routers: B and C which are further connected to two other routers: D and E. Router D is connected to C. Router D and E are further connected to F and G. Router F is connected to E.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch24fig06"></a><strong>Figure 24-6</strong> <em>An Example of Manipulation in Testing</em></p>
        </div>
        <p class="indent">Returning to the jitter example, assume there is some application passing traffic between A and H showing poor performance. After some work with the application, you determine the problem is with the jitter along the path between the host and the server. Examining the logs for the various devices, you notice the problem appears to correlate with SPF running on E. Using the half split method, you first trace the signal path, or, in this case the path of the flow, and find packets between these two devices follow the path [A,B,D,F,H]. You divide the circuit in half and decide to examine the signal at D.</p>
        <p class="indent">How can you measure the jitter at D? The most obvious solution is to capture the packet flow on a packet trace device (or software loaded onto a standard host), then cause (or wait for) whatever problem to occur that is causing the event at E, to determine if there is jitter at the output of D when the event occurs. Assume you find the jitter is, in fact, present at the output of D; the next step is not to simply assume this is where the problem is. Rather, the next step is to move toward the source and determine if the jitter is also present at the <em>input</em> to D. In this case, it would be logical to examine the output at B during the event at E, to see if the jitter is also there. Skipping this half split step might seem like it would speed up your troubleshooting process—you know where the problem is, why not just move directly to finding out <em>why</em> this is happening? The reason is simple: by skipping the step moving toward the source and looking for the symptoms, you are failing to isolate the problem to a single point in the network. It is all too easy to spend a lot of time trying to understand <em>why</em> the problem is happening at D, only to discover the problem is not at D at all; it is someplace earlier in the network.</p>
        <p class="indent">Assuming the signal is correct at the output of B, the next step is to find some way to manipulate the conditions at D to cause the problem; this will verify the problem <a id="page_645"></a>showing up at D and the event occurring (SPF at E) is not just correlation but is causally related in some way. The best way to do this is to examine any logs at E that can tell you <em>why</em> SPF is running at E and then <em>replicate those conditions while measuring the signal at D</em>.</p>
        <p class="indent">Once the problem can be replicated, you can know, for certain, what the cause is and start thinking about how to solve the problem.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">Real life is messier than the example given here. In real life, there can be multiple interacting causes and no way to manipulate the network into causing the problem. Sometimes, then, correlation must be taken at face value, and you must <em>guess</em>, trying solutions until you find one that makes the problem <em>go away</em>, or just relying on your knowledge of the internal workings of the system to find a resolution without taking on the full process. The half split process, as described here, is an <em>ideal case;</em> you will likely need to modify it on a per case basis in the field. On the other hand, the closer you can come to the ideal, especially when starting out on simpler problems, the faster you will be able to develop the “troubleshooting sense” required to speed up the process. Further, when you are stumped, it is always best to stop relying on your “troubleshooting sense,” and go back to the basics of half splitting, finding the signal, testing the signal, and finding a way to manipulate the signal.</p>
        </div>
        <div class="heading">
        <h4 class="h4" id="ch24lev10"><strong>Simplify before Testing</strong></h4>
        <p class="noindent">Returning to <a href="ch24.xhtml#ch24fig05">Figure 24-5</a> (and <a href="ch24.xhtml#ch24fig02">Figure 24-2</a>), there are many different Z’s (and probably many different X’s). This raises an interesting question: how do you know which particular variable among the many available variables to concentrate on? Knowledge of the system, combined with a liberal dose of experience, will be your primary guides here, but there is one other thing you can do to make your life simpler: simplify the system.</p>
        </div>
        <p class="indent">For instance, in a network with a <em>lot</em> of parallel paths, you might make more headway in troubleshooting a problem if you begin by eliminating components until the problem goes away, or until the network is down to a bare minimum functioning set of links and devices. This might seem counterintuitive—why would you remove redundancy to troubleshoot, when the network is already having problems?—but it is sometimes the only way to narrow down where a problem is.</p>
        <p class="indent">If the problem does, in fact, “go away” before you reach some minimal set, then you should suspect there is some form of positive feedback loop in the network causing the failure, there is some problem with the amount and/or speed of state being <a id="page_646"></a>carried in the control plane, or you have removed the problem in the process of reducing complexity (for instance, a flapping link, or device failing to forward traffic). In this case, you can add complexity back into the network until the problem reappears, which gives you a good manipulation test scenario. If the problem does <em>not</em> go away during the simplification process, then you now have a simpler signal path to troubleshoot, which will help you focus the half split process into a more confined space.</p>
        <div class="heading">
        <h3 class="h3" id="ch24lev11">Fixing the Problem</h3>
        <p class="noindentb">Once the problem has been identified, you should fix it. However, the concept of <em>fixing it</em> isn’t always so simple in the real world. There are normally two stages to <em>fixing it:</em></p>
        </div>
        <p class="indenthangingN">1. Solving the immediate problem with a configuration change, hardware replacement, etc.—a <em>temporary fix</em></p>
        <p class="indenthangingN">2. Preventing the problem in the future through design or through replacement of equipment, etc.—a <em>permanent fix</em></p>
        <p class="indentt">It is often very difficult to tell the difference between a temporary fix and a permanent one; a good rule of thumb might be</p>
        <p class="blockquote"><strong>A temporary fix incurs technical debt; a permanent fix either reduces technical debt or leaves it constant.</strong></p>
        <p class="indent">Technical debt is very hard to explain, but essentially it means doing something that will either cause fixing a problem in the future to be more complex or will result in a similar failure mode happening in the future. Perhaps an example will be the most useful way to explain these concepts.</p>
        <p class="indent">Assume you are in a situation where a number of different virtual networks suddenly stop carrying business-critical traffic at the same time. Investigating the problem, you find a broadcast storm is causing the problem; a particular network interface card (NIC) is pushing random broadcast packets onto the physical network in a way that prevents traffic from being carried across any of the virtual topologies (an example of fate sharing).</p>
        <p class="indent">Unplugging the system with the faulty NIC is the obvious first solution: is this a temporary fix or a permanent one? The host is there for a reason, so this must be a temporary fix, correct? Yes…and no. Shutting down this host provides an immediate fix, but to determine if this should be the temporary or permanent fix, you need to <a id="page_647"></a>determine what the host is used for, and whether or not it is still needed. Leaving a host attached to a network if it is no longer needed, even once it is repaired, simply increases technical debt. Some other problem with this host in the future is going to cause a problem again, a problem that could have been avoided by simply removing the host entirely from the network.</p>
        <p class="indent">Assume the host is required, replacing the NIC becomes the permanent fix, correct? Again, not necessarily. The host may be older and should simply be replaced entirely. Replacing the NIC in an older host may, again, simply increase technical debt, as the host may fail in some other way that causes a network failure at some point in the future.</p>
        <p class="indent">Assume the host does need to be replaced. In that case, replacing the host should be the permanent fix, correct? Again, not necessarily. It could be time to reconsider the design of the network. If a single failed NIC should not be able to cause a systemwide failure, it may be worth considering a permanent fix that includes redesigning the network to reduce fate sharing or to reduce the scope of the failure domains.</p>
        <p class="indent">The concepts of temporary and permanent fix are, then, flexible. Look to the business and the business drivers to think through where to stop when fixing a problem; don’t assume replacing the hardware is the final fix, nor that every problem requires a complete network redesign.</p>
        <div class="heading">
        <h3 class="h3" id="ch24lev12">Final Thoughts on Troubleshooting</h3>
        <p class="noindent">The half split method, grounded in accurate models of the system, is an effective method to use when troubleshooting large-scale problems in any system. It is not perfect, of course; the real world is far too messy for a single process to be “perfect” at solving all problems, but long experience has shown the half split method to be the best general guide to finding problems quickly. To reiterate:</p>
        </div>
        <p class="bullt">• Build accurate models, particularly the business, the applications, the protocols, and the equipment. This is probably where most failures to effectively troubleshoot problems occur, and the step that takes the longest to complete. In fact, it is probably a truism to say that no one ever completes this step, as there is always more to learn about every system, and more accurate ways to model any given system.</p>
        <p class="bull">• Have a problem/solution mindset. This is probably the second most common failure point in the troubleshooting process.</p>
        <p class="bullb">• Half split, measure, and move.</p>
        <p class="indent1"><a id="page_648"></a>Some final points to consider:</p>
        <p class="bullt">• Never assume the problem is a result of a configuration or design change; always remember equipment failures, new traffic patterns, and other situations can (and often do) cause failures. Some management systems focus on change control to the point of excluding other failure modes from view, which can discourage effective troubleshooting, and increase technical debt over time.</p>
        <p class="bull">• Do not take shortcuts. Do not start with what can be easily tested. Do not assume you have found the problem on the first test. Always try to find a way to both prove, and attempt to disprove, your theory.</p>
        <p class="bull">• If something does not look right, it probably is not.</p>
        <p class="bullb">• Many of the concepts used in troubleshooting can be applied to testing, as well—validation, etc.—before placing things into the network</p>
        <p class="indent">Troubleshooting is an art grounded in technique, knowledge, and experience. Do not become frustrated if it proves difficult to learn this art; it often takes long hours of work with those who have more experience and have a better understanding of the system—and of what questions to ask—to have a strong set of troubleshooting skills. On the other hand, once you learn the art of troubleshooting, you will not likely forget it—and you will be able to apply it to many different areas of technology, not just network engineering.</p>
        <div class="heading">
        <h3 class="h3" id="ch24lev13">Further Reading</h3>
        <p class="ref">Day, J. <em>Patterns in Network Architecture: A Return to Fundamentals</em>. Pearson Education, 2007. <a href="http://books.google.com/books?id=k9sFgIM-z6UC">http://books.google.com/books?id=k9sFgIM-z6UC</a>.</p>
        </div>
        <p class="ref">Fowler, Martin. <em>UML Distilled: A Brief Guide to the Standard Object Modeling Language</em>. 3rd edition. Boston, MA: Addison-Wesley Professional, 2003.</p>
        <p class="ref">Huang, Peng, Chuanxiong Guo, Lidong Zhou, Jacob R. Lorch, Yingnong Dang, Murali Chintalapati, and Randolph Yao. “Gray Failure: The Achilles’ Heel of Cloud-Scale Systems.” In <em>Proceedings of the 16th Workshop on Hot Topics in Operating Systems</em>, 150–55. HotOS ’17. New York, NY, USA: ACM, 2017. doi:10.1145/3102980.3103005.</p>
        <p class="ref">Lieberman, Norman. <em>Troubleshooting Process Operations</em>. 4th edition. Tulsa, OK: PennWell Corp., 2009.</p>
        <p class="ref">Mostia, William L. Jr. <em>Troubleshooting: A Technician’s Guide</em>. 2nd edition. International Society of Automation, 2016.</p>
        <div class="heading">
        <h3 class="h3" id="ch24lev14"><a id="page_649"></a>Review Questions</h3>
        <p class="indenthangingN">1. Consider the Observe, Orient, Decide, Act (OODA) loop as described in the context of network security. How could the OODA loop be applied to troubleshooting?</p>
        </div>
        <p class="indenthangingN">2. Research the concept of a gray failure (look at the “Further Reading” section). How should gray failures change your troubleshooting process? What would you look for in troubleshooting gray failures?</p>
        <p class="indenthangingN">3. Explain the difference between how and what models for network troubleshooting.</p>
        <p class="indenthangingN">4. You are troubleshooting a problem where a small percentage of packets are dropped when being forwarded through a network. What does the percentage of packets dropped indicate about the tools required and the amount of information you will need to manage in order to troubleshoot this problem?</p>
        <p class="indenthangingN">5. Describe different kinds of signals you might find in a network that can be used to trace out the operation of a particular system or application.<a id="page_650"></a></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780134762814/files/9780134762852.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com