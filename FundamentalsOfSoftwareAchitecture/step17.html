<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 17. Microservices Architecture"><div class="chapter" id="ch-style-microservices">
        <h1><span class="label">Chapter 17. </span>Microservices Architecture</h1>
        
        
        <p><em>Microservices</em> is an extremely popular architecture style that has gained significant momentum in recent years. <a data-type="indexterm" data-primary="microservices architecture" id="ix_mcroarch"></a>In this chapter, we provide an overview of the important characteristics that set this architecture apart, both topologically and philosophically.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="History"><div class="sect1" id="idm45838970448176">
        <h1>History</h1>
        
        <p>Most architecture styles are named after the fact by architects who notice a particular pattern<a data-type="indexterm" data-primary="microservices architecture" data-secondary="history of" id="idm45838970446592"></a> that keeps reappearing—there is no secret group of architects who decide what the next big movement will be. Rather, it turns out that many architects end up making common decisions as the software development ecosystem shifts and changes. The common best ways of dealing with and profiting from those shifts become architecture styles that others emulate.</p>
        
        <p>Microservices differs in this regard—it was named fairly early in its usage and popularized by a famous blog entry by Martin Fowler and James Lewis entitled <a href="https://oreil.ly/Px3Wk">“Microservices,”</a> published in March 2014. <a data-type="indexterm" data-primary="&quot;Microservices&quot; blog entry" data-primary-sortas="Microservices" id="idm45838970443856"></a><a data-type="indexterm" data-primary="Fowler, Martin" id="idm45838970442816"></a><a data-type="indexterm" data-primary="Lewis, James" id="idm45838970442144"></a>They recognized many common characteristics in this relatively new architectural style and delineated them. Their blog post helped define the architecture for curious architects and helped them understand the underlying philosophy.</p>
        
        <p>Microservices  is heavily inspired by the ideas in domain-driven design (DDD), a logical design process for software projects. One concept in particular from DDD, <em>bounded context</em>, decidedly inspired microservices.<a data-type="indexterm" data-primary="domain-driven design (DDD)" data-secondary="influence on microservices" id="idm45838970439904"></a><a data-type="indexterm" data-primary="bounded context" data-secondary="microservices and" id="idm45838970438896"></a> The concept of bounded context represents a decoupling style. When a developer defines a domain, that domain includes many entities and behaviors, identified in artifacts such as code and database schemas.<a data-type="indexterm" data-primary="domains" data-secondary="developers defining" id="idm45838970437600"></a><a data-type="indexterm" data-primary="context" data-secondary="bounded context and" id="idm45838970436656"></a> For example, an application might have a domain called <code>CatalogCheckout</code>, which includes notions such as catalog items, customers, and payment. In a traditional monolithic architecture, developers would share many of these concepts, building reusable classes and linked databases. Within a bounded context, the internal parts, such as code and data schemas, are coupled together to produce work; but they are never coupled to anything outside the bounded context, such as a database or class definition from another bounded context. This allows each context to define only what it needs rather than accommodating other constituents.</p>
        
        <p>While reuse is beneficial, remember the First Law of Software Architecture regarding trade-offs.<a data-type="indexterm" data-primary="coupling" data-secondary="negative trade-off of reuse" id="idm45838970434176"></a><a data-type="indexterm" data-primary="reuse and coupling" id="idm45838970433200"></a><a data-type="indexterm" data-primary="trade-offs in software architecture" data-secondary="reuse and coupling" id="idm45838970432528"></a> The negative trade-off of reuse is coupling. When an architect designs a system that favors reuse, they also favor coupling to achieve that reuse, either by inheritance or composition.</p>
        
        <p>However, if the architect’s goal requires high degrees of decoupling, then they favor duplication over reuse. The primary goal of microservices is high decoupling, physically modeling the logical notion of bounded context.<a data-type="indexterm" data-primary="duplication, favoring over reuse" id="idm45838970430608"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Topology"><div class="sect1" id="idm45838970429760">
        <h1>Topology</h1>
        
        <p>The topology of microservices is shown in <a data-type="xref" href="#fig-ch-style-microservices-topology">Figure&nbsp;17-1</a>.</p>
        
        <figure><div id="fig-ch-style-microservices-topology" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1701.png" alt="" width="1397" height="1013">
        <h6><span class="label">Figure 17-1. </span>The topology of the microservices architecture style</h6>
        </div></figure>
        
        <p>As illustrated in <a data-type="xref" href="#fig-ch-style-microservices-topology">Figure&nbsp;17-1</a>, due to its single-purpose <a data-type="indexterm" data-primary="microservices architecture" data-secondary="topology" id="idm45838970424208"></a>nature, the service size in microservices is much smaller than other distributed architectures, such as the orchestration-driven service-oriented architecture. Architects expect each service to include all necessary parts to operate independently, including databases and other dependent components. The different characteristics appear in the following sections.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Distributed"><div class="sect1" id="idm45838970422432">
        <h1>Distributed</h1>
        
        <p>Microservices form a <em>distributed architecture</em>: each service runs in its own process, which originally implied a physical computer but quickly evolved to virtual machines and containers.<a data-type="indexterm" data-primary="distributed architectures" data-secondary="microservices" id="idm45838970420352"></a><a data-type="indexterm" data-primary="microservices architecture" data-secondary="distributed architecture" id="idm45838970419344"></a><a data-type="indexterm" data-primary="coupling" data-secondary="decoupling of services in microservices" id="idm45838970418368"></a><a data-type="indexterm" data-primary="services" data-secondary="decoupling in microservices architecture" id="idm45838970417408"></a> Decoupling the services to this degree allows for a simple solution to a common problem in architectures that heavily feature multitenant infrastructure for hosting applications. For example, when using an application server to manage multiple running applications, it allows operational reuse of network bandwidth, memory, disk space, and a host of other benefits. However, if all the supported applications continue to grow, eventually some resource becomes constrained on the shared infrastructure. Another problem concerns improper isolation between shared applications.</p>
        
        <p>Separating each service into its own process solves all the problems brought on by sharing. <a data-type="indexterm" data-primary="operating systems" id="idm45838970415152"></a>Before the evolutionary development of freely available open source operating systems, combined with automated machine provisioning, it was impractical for each domain to have its own infrastructure. Now, however, with cloud resources and container technology, teams can reap the benefits of extreme decoupling, both at the domain and operational level.</p>
        
        <p>Performance is often the negative side effect of the distributed nature of microservices. Network calls take much longer than method calls, and security verification at every endpoint adds additional processing time, requiring architects to think carefully about the implications of granularity when designing the system.</p>
        
        <p>Because microservices is a distributed architecture, experienced architects advise against the use of transactions across service boundaries, making determining the granularity of services the key to success in this architecture.<a data-type="indexterm" data-primary="transactions" data-secondary="across boundaries in microservices, not recommended" id="idm45838970412576"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Bounded Context"><div class="sect1" id="idm45838970411440">
        <h1>Bounded Context</h1>
        
        <p>The driving philosophy of microservices is the notion of <em>bounded context</em>: each service models a domain or workflow.<a data-type="indexterm" data-primary="microservices architecture" data-secondary="bounded context in" id="idm45838970409504"></a><a data-type="indexterm" data-primary="bounded context" data-secondary="in microservices architecture" data-secondary-sortas="microservices" id="idm45838970408512"></a> Thus, each service includes everything necessary to operate within the application, including classes, other subcomponents, and database schemas. This philosophy drives many of the decisions architects make within this architecture. For example, in a monolith, it is common for developers to share common classes, such as <code>Address</code>, between disparate parts of the application. However, microservices try to avoid coupling, and thus an architect building this architecture style prefers duplication to coupling.</p>
        
        <p>Microservices take the concept of a domain-partitioned architecture to the extreme. Each service is meant to represent a domain or subdomain; in many ways, microservices is the physical embodiment of the logical concepts in domain-driven design.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Granularity"><div class="sect2" id="idm45838970405440">
        <h2>Granularity</h2>
        
        <p>Architects struggle to find the correct granularity for services in microservices, <a data-type="indexterm" data-primary="microservices architecture" data-secondary="bounded context in" data-tertiary="granularity for services" id="idm45838970403936"></a><a data-type="indexterm" data-primary="granularity" data-secondary="for services in microservices" id="idm45838970402656"></a><a data-type="indexterm" data-primary="bounded context" data-secondary="in microservices architecture" data-tertiary="granularity for services" data-secondary-sortas="microservices" id="idm45838970401696"></a><a data-type="indexterm" data-primary="services" data-secondary="granularity for, in microservices" id="idm45838970400176"></a>and often make the mistake of making their services too small, which requires them to build communication links back between the services to do useful work.<a data-type="indexterm" data-primary="Fowler, Martin" id="idm45838970398912"></a></p>
        <blockquote>
        <p>The term “microservice” is a <em>label</em>, not a <em>description</em>.</p>
        <p data-type="attribution">Martin Fowler</p>
        </blockquote>
        
        <p>In other words, the originators of the term needed to call this new style <em>something</em>, and they chose “microservices” to contrast it with the dominant architecture style at the time, service-oriented architecture, which could have been called “gigantic services”. However, many developers take the term “microservices” as a commandment, not a description, and create services that are too fine-grained.</p>
        
        <p>The purpose of service boundaries in microservices is to capture a domain or workflow. In some applications, those natural boundaries might be large for some parts of the system—some business processes are more coupled than others. Here are some guidelines architects can use to help find the appropriate boundaries:</p>
        <dl>
        <dt>Purpose</dt>
        <dd>
        <p>The most obvious boundary relies on the inspiration for the architecture style, a domain.<a data-type="indexterm" data-primary="domains" data-secondary="inspiration for microservices service boundaries" id="idm45838970391920"></a> Ideally, each microservice should be extremely functionally cohesive, contributing one significant behavior on behalf of the overall application.</p>
        </dd>
        <dt>Transactions</dt>
        <dd>
        <p>Bounded contexts are business workflows, and often the entities that need to cooperate <a data-type="indexterm" data-primary="transactions" data-secondary="and bounded contexts in microservices" data-secondary-sortas="bounded" id="idm45838970389280"></a>in a transaction show architects a good service boundary. Because transactions cause issues in distributed architectures, if architects can design their system to avoid them, they generate better designs.</p>
        </dd>
        <dt>Choreography</dt>
        <dd>
        <p>If an architect builds a set of services that offer excellent domain isolation yet require extensive communication to function, the architect may consider bundling these services back into a larger service to avoid the communication <span class="keep-together">overhead.</span><a data-type="indexterm" data-primary="choreography" data-secondary="of bounded context services in microservices" data-secondary-sortas="bounded" id="idm45838970385376"></a></p>
        </dd>
        </dl>
        
        <p>Iteration is the only way to ensure good service design. Architects rarely discover the perfect granularity, data dependencies, and communication styles on their first pass. However, after iterating over the options, an architect has a good chance of refining their design.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Data Isolation"><div class="sect2" id="idm45838970383168">
        <h2>Data Isolation</h2>
        
        <p>Another requirement of microservices, driven by the bounded context concept, is data isolation.<a data-type="indexterm" data-primary="bounded context" data-secondary="for services in microservices" data-tertiary="data isolation with" id="idm45838970381552"></a><a data-type="indexterm" data-primary="data isolation in microservices" id="idm45838970380336"></a> Many other architecture styles use a single database for persistence. However, microservices tries to avoid all kinds of coupling, including shared schemas and databases used as integration points.</p>
        
        <p>Data isolation is another factor an architect must consider when looking at service granularity.<a data-type="indexterm" data-primary="entity trap" id="idm45838970378864"></a> Architects must be wary of the entity trap (discussed in <a data-type="xref" href="ch08.html#sec-entity-trap">“Entity trap”</a>) and not simply model their services to resemble single entities in a <span class="keep-together">database.</span></p>
        
        <p>Architects are accustomed to using relational databases to unify values within a system, creating a single source of truth, which is no longer an option when distributing data across the architecture. Thus, architects must decide how they want to handle this problem: either identifying one domain as the source of truth for some fact and coordinating with it to retrieve values or using database replication or caching to distribute information.</p>
        
        <p>While this level of data isolation creates headaches, it also provides opportunities. Now that teams aren’t forced to unify around a single database, each service can choose the most appropriate tool, based on price, type of storage, or a host of other factors. Teams have the advantage in a highly decoupled system to change their mind and choose a more suitable database (or other dependency) without affecting other teams, which aren’t allowed to couple to implementation details.</p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="API Layer"><div class="sect1" id="idm45838970374624">
        <h1>API Layer</h1>
        
        <p>Most pictures of microservices include an API layer<a data-type="indexterm" data-primary="API layer" data-secondary="in microservices architecture" id="idm45838970373296"></a><a data-type="indexterm" data-primary="microservices architecture" data-secondary="API layer" id="idm45838970372352"></a> sitting between the consumers of the system (either user interfaces or calls from other systems), but it is optional. It is common because it offers a good location within the architecture to perform useful tasks, either via indirection as a proxy or a tie into operational facilities, such as a naming service (covered in <a data-type="xref" href="#sec-operational-reuse">“Operational Reuse”</a>).</p>
        
        <p>While an API layer may be used for variety of things, it should not be used as a mediator or orchestration tool if the architect wants to stay true to the underlying philosophy of this architecture: all interesting logic in this architecture should occur inside a bounded context, and putting orchestration or other logic in a mediator violates that rule. <a data-type="indexterm" data-primary="technical partitioning (components)" data-secondary="domain partitioning versus" id="idm45838970369424"></a><a data-type="indexterm" data-primary="domain partitioning (components)" data-secondary="technical partitioning versus" id="idm45838970368480"></a>This also illustrates the difference between technical and domain partitioning in architecture: architects typically use mediators in technically partitioned architectures, whereas microservices is firmly domain partitioned.<a data-type="indexterm" data-primary="partitioning of components" data-secondary="in microservices architecture" id="idm45838970367136"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Operational Reuse"><div class="sect1" id="sec-operational-reuse">
        <h1>Operational Reuse</h1>
        
        <p>Given that microservices prefers duplication to coupling, how do architects handle the parts of<a data-type="indexterm" data-primary="reuse and coupling" data-secondary="operational reuse in microservices architecture" id="idm45838970363888"></a><a data-type="indexterm" data-primary="microservices architecture" data-secondary="operational reuse in" id="idm45838970362816"></a> architecture that really do benefit from coupling, such as operational concerns like monitoring, logging, and circuit breakers? One of the philosophies in the traditional service-oriented architecture was to reuse as much functionality as possible, domain and operational alike. In microservices, architects try to split these two concerns.</p>
        
        <p>Once a team has built several microservices, they realize that each has common elements that benefit from similarity. For example, if an organization allows each service team to implement monitoring themselves, how can they ensure that each team does so? And how do they handle concerns like upgrades? Does it become the responsibility of each team to handle upgrading to the new version of the monitoring tool, and how long will that take?</p>
        
        <p>The <em>sidecar</em> pattern offers a solution to this <a data-type="indexterm" data-primary="sidecar pattern" id="idm45838970359664"></a>problem, illustrated in <a data-type="xref" href="#fig-style-microservices-sidecar">Figure&nbsp;17-2</a>.</p>
        
        <figure><div id="fig-style-microservices-sidecar" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1702.png" alt="" width="1339" height="868">
        <h6><span class="label">Figure 17-2. </span>The sidecar pattern in microservices</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-style-microservices-sidecar">Figure&nbsp;17-2</a>, the common operational concerns appear within each service as a separate component, which can be owned by either individual teams or a shared infrastructure team. The sidecar component handles all the operational concerns that teams benefit from coupling together. Thus, when it comes time to upgrade the monitoring tool, the shared infrastructure team can update the sidecar, and each microservices receives that new functionality.</p>
        
        <p>Once teams know that each service includes a common sidecar, they can build a <em>service mesh</em>, allowing unified control across the architecture for concerns like logging and monitoring.<a data-type="indexterm" data-primary="service meshes" id="idm45838970353136"></a><a data-type="indexterm" data-primary="service plane in microservices" id="idm45838970352432"></a> The common sidecar components connect to form a consistent operational interface across all microservices, as shown in <a data-type="xref" href="#fig-style-microservices-sidecar-plane">Figure&nbsp;17-3</a>.</p>
        
        <figure><div id="fig-style-microservices-sidecar-plane" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1703.png" alt="" width="1431" height="868">
        <h6><span class="label">Figure 17-3. </span>The service plane connects the sidecars in a service mesh</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-style-microservices-sidecar-plane">Figure&nbsp;17-3</a>, each sidecar wires into the service plane, which forms the consistent interface to each service.</p>
        
        <p class="pagebreak-before">The service mesh itself forms a console that allows developers holistic access to services, which is shown in <a data-type="xref" href="#fig-style-microservices-mesh">Figure&nbsp;17-4</a>.</p>
        
        <figure><div id="fig-style-microservices-mesh" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1704.png" alt="" width="1440" height="988">
        <h6><span class="label">Figure 17-4. </span>The service mesh forms a holistic view of the operational aspect of microservices</h6>
        </div></figure>
        
        <p>Each service forms a node in the overall mesh, as shown in <a data-type="xref" href="#fig-style-microservices-mesh">Figure&nbsp;17-4</a>. The service mesh forms a console that allows teams to globally control operational coupling, such as monitoring levels, logging, and other cross-cutting operational concerns.</p>
        
        <p>Architects use <em>service discovery</em> as a way to build elasticity into microservices architectures. <a data-type="indexterm" data-primary="service discovery" id="idm45838970341104"></a>Rather than invoke a single service, a request goes through a service discovery tool, which can monitor the number and frequency of requests, as well as spin up new instances of services to handle scale or elasticity concerns. Architects often include service discovery in the service mesh, making it part of every microservice. The API layer is often used to host service discovery, allowing a single place for user interfaces or other calling systems to find and create services in an elastic, consistent way.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" class="less_space pagebreak-before" data-pdf-bookmark="Frontends"><div class="sect1" id="idm45838970365312">
        <h1>Frontends</h1>
        
        <p>Microservices favors decoupling, which would ideally encompass the user interfaces as well as backend concerns.<a data-type="indexterm" data-primary="frontends" data-secondary="in microservices architecture" id="ix_frnt"></a><a data-type="indexterm" data-primary="microservices architecture" data-secondary="frontends" id="ix_mcroarchfrnt"></a> In fact, the original vision for microservices included the user interface as part of the bounded context, faithful to the principle in DDD.<a data-type="indexterm" data-primary="DDD" data-see="domain-driven design" id="idm45838970334896"></a><a data-type="indexterm" data-primary="bounded context" data-secondary="user interface as part of" id="idm45838970333952"></a><a data-type="indexterm" data-primary="user interfaces (UIs)" data-secondary="as part of bounded context in DDD" id="idm45838970332992"></a><a data-type="indexterm" data-primary="domain-driven design (DDD)" data-secondary="user interface as part of bounded context" id="idm45838970332032"></a> However, practicalities of the partitioning required by web applications and other external constraints make that goal difficult. Thus, two styles of user interfaces commonly appear for microservices architectures; the first appears in <a data-type="xref" href="#fig-style-microservices-ui-mono">Figure&nbsp;17-5</a>.</p>
        
        <figure><div id="fig-style-microservices-ui-mono" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1705.png" alt="" width="1397" height="877">
        <h6><span class="label">Figure 17-5. </span>Microservices architecture with a monolithic user interface</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-style-microservices-ui-mono">Figure&nbsp;17-5</a>, the monolithic frontend features a single user interface that calls through the API layer to satisfy user requests.<a data-type="indexterm" data-primary="user interfaces (UIs)" data-secondary="microservices with monolithic UI" id="idm45838970326528"></a> The frontend could be a rich desktop, mobile, or web application. For example, many web applications now use a JavaScript web framework to build a single user interface.<a data-type="indexterm" data-primary="microfrontends" id="idm45838970325248"></a></p>
        
        <p class="pagebreak-before">The second option for user interfaces uses <em>microfrontends</em>, shown in <a data-type="xref" href="#fig-style-microservices-micro">Figure&nbsp;17-6</a>.</p>
        
        <figure><div id="fig-style-microservices-micro" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1706.png" alt="" width="1397" height="927">
        <h6><span class="label">Figure 17-6. </span>Microfrontend pattern in microservices</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-style-microservices-micro">Figure&nbsp;17-6</a>, this approach utilizes components at the user interface level to create a synchronous level of granularity and isolation in the user interface as the backend services. Each service emits the user interface for that service, which the frontend coordinates with the other emitted user interface components. Using this pattern, teams can isolate service boundaries from the user interface to the backend services, unifying the entire domain within a single team.</p>
        
        <p>Developers can implement the microfrontend pattern in a variety of ways, either using a component-based web framework such as <a href="https://reactjs.org">React</a> or using one of several open source frameworks that support this pattern.<a data-type="indexterm" data-primary="frontends" data-secondary="in microservices architecture" data-startref="ix_frnt" id="idm45838970317600"></a><a data-type="indexterm" data-primary="React framework" id="idm45838970316336"></a><a data-type="indexterm" data-primary="microservices architecture" data-secondary="frontends" data-startref="ix_mcroarchfrnt" id="idm45838970315664"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Communication"><div class="sect1" id="ch17_communication">
        <h1>Communication</h1>
        
        <p>In microservices, architects and developers struggle with appropriate granularity, which affects both data isolation and communication.<a data-type="indexterm" data-primary="communication between services" data-secondary="in microservices architecture" data-secondary-sortas="microservices" id="ix_commser"></a><a data-type="indexterm" data-primary="microservices architecture" data-secondary="communication in" id="ix_mcroarchcomm"></a> Finding the correct communication style helps teams keep services decoupled yet still coordinated in useful ways.</p>
        
        <p>Fundamentally, architects must decide on <em>synchronous</em> or <em>asynchronous</em> communication.<a data-type="indexterm" data-primary="synchronous comunication" id="idm45838970307872"></a><a data-type="indexterm" data-primary="asynchronous communication" id="idm45838970307168"></a> Synchronous communication requires the caller to wait for a response from the callee.<a data-type="indexterm" data-primary="protocol-aware heterogeneous interoperability" id="idm45838970306352"></a> Microservices architectures typically utilize <em>protocol-aware heterogeneous interoperability</em>. We’ll break down that term for you:</p>
        <dl>
        <dt>Protocol-aware</dt>
        <dd>
        <p>Because microservices usually don’t include a centralized integration hub to avoid operational coupling, each service should know how to call other services. Thus, architects commonly standardize on how particular services call each other: a certain level of REST, message queues, and so on. That means that services must know (or discover) which protocol to use to call other services.</p>
        </dd>
        <dt>Heterogeneous</dt>
        <dd>
        <p>Because microservices is a distributed architecture, each service may be written in a different technology stack.<a data-type="indexterm" data-primary="heterogeneity" data-secondary="heterogeneous interoperability in microservices" id="idm45838970301408"></a> <em>Heterogeneous</em> suggests that microservices fully supports polyglot environments, where different services use different platforms.</p>
        </dd>
        <dt>Interoperability</dt>
        <dd>
        <p>Describes services calling one another. <a data-type="indexterm" data-primary="interoperability" data-secondary="services calling each other in microservices" id="idm45838970298256"></a>While architects in microservices try to discourage transactional method calls, services commonly call other services via the network to collaborate and send/receive information.</p>
        </dd>
        </dl>
        <aside data-type="sidebar" epub:type="sidebar"><div class="sidebar" id="idm45838970296608">
        <h5>Enforced Heterogeneity</h5>
        <p>A well-known architect who was a pioneer in the microservices style was the chief architecture at a personal information manager startup for mobile devices. <a data-type="indexterm" data-primary="heterogeneity" data-secondary="enforced, in microservices architecture" id="idm45838970295168"></a>Because they had a fast-moving problem domain, the architect wanted to ensure that none of the development teams accidentally created coupling points between each other, hindering the teams’ ability to move independently. It turned out that this architect had a wide mix of technical skills on the teams, thus mandating that each development team use a different technology stack. If one team was using Java and the other was using .NET, it was impossible to accidentally share classes!</p>
        
        <p>This approach is the polar opposite of most enterprise governance policies, which insist on standardizing on a single technology stack. The goal in the microservices world isn’t to create the most complex ecosystem possible, but rather to choose the correct scale technology for the narrow scope of the problem. Not every service needs an industrial-strength relational database, and forcing it on small teams slows them rather than benefitting them. This concept leverages the highly decoupled nature of microservices.</p>
        </div></aside>
        
        <p>For asynchronous communication, architects often use events and messages, thus internally <a data-type="indexterm" data-primary="events" data-secondary="use for asynchronous communication in microservices" id="idm45838970292000"></a><a data-type="indexterm" data-primary="messages, use for asynchronous communication in microservices" id="idm45838970290992"></a>utilizing an event-driven architecture, covered in <a data-type="xref" href="ch14.html#ch-style-eda">Chapter&nbsp;14</a>; the broker and mediator patterns manifest in microservices as <em>choreography</em> and <em>orchestration</em>.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Choreography and Orchestration"><div class="sect2" id="idm45838970288304">
        <h2>Choreography and Orchestration</h2>
        
        <p><em>Choreography</em> utilizes the same communication style as a broker event-driven architecture.<a data-type="indexterm" data-primary="choreography" data-secondary="in microservices' communication" id="idm45838970286048"></a><a data-type="indexterm" data-primary="orchestration and choreography" data-secondary="in microservices' communication" id="idm45838970285008"></a><a data-type="indexterm" data-primary="microservices architecture" data-secondary="communication in" data-tertiary="choreography and orchestration" id="ix_mcroarchcommco"></a> In other words, no central coordinator exists in this architecture, respecting the bounded context philosophy. Thus, architects find it natural to implement decoupled events between services.</p>
        
        <p><em>Domain/architecture isomorphism</em> is one key characteristic<a data-type="indexterm" data-primary="domain/architecture isomorphism" id="idm45838970281456"></a> that architects should look for when assessing how appropriate an architecture style is for a particular problem. This term describes how the shape of an architecture maps to a particular architecture style. For example, in <a data-type="xref" href="ch08.html#ch-component-based-thinking-SS-technical">Figure&nbsp;8-7</a>, the Silicon Sandwiches’ technically partitioned architecture structurally supports customizability, and the microkernel architecture style offers the same general structure. Therefore, problems that require a high degree of customization become easier to implement in a microkernel.</p>
        
        <p>Similarly, because the architect’s goal in a microservices architecture favors decoupling, the shape of microservices resembles the broker EDA, making these two patterns symbiotic.</p>
        
        <p>In choreography, each service calls other services as needed, without a central mediator. For example, consider the  scenario shown in <a data-type="xref" href="#fig-style-microservices-choreography">Figure&nbsp;17-7</a>.</p>
        
        <figure><div id="fig-style-microservices-choreography" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1707.png" alt="" width="1397" height="848">
        <h6><span class="label">Figure 17-7. </span>Using choreography in microservices to manage coordination</h6>
        </div></figure>
        
        <p class="pagebreak-before">In <a data-type="xref" href="#fig-style-microservices-choreography">Figure&nbsp;17-7</a>, the user requests details about a user’s wish list. Because the <code>CustomerWishList</code> service doesn’t contain all the necessary information, it makes a call to <span class="keep-together"><code>CustomerDemographics</code></span> to retrieve the missing information, returning the result to the user.</p>
        
        <p>Because microservices architectures don’t include a global mediator like other service-oriented architectures, if an architect needs to coordinate across several services, they can create their own localized mediator, as shown in <a data-type="xref" href="#fig-style-microservices-orchestration">Figure&nbsp;17-8</a>.</p>
        
        <figure><div id="fig-style-microservices-orchestration" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1708.png" alt="" width="1397" height="1157">
        <h6><span class="label">Figure 17-8. </span>Using orchestration in microservices</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-style-microservices-orchestration">Figure&nbsp;17-8</a>, the developers create a service whose sole responsibility is coordinating the call to get all information for a particular customer. The user calls the <code>ReportCustomerInformation</code> mediator, which calls the necessary other services.</p>
        
        <p class="pagebreak-before">The First Law of Software Architecture suggests that neither of these solutions is perfect—each has trade-offs. In choreography, the architect preserves the highly decoupled philosophy of the architecture style, thus reaping maximum benefits touted by the style. However, common problems like error handling and coordination become more complex in choreographed environments.</p>
        
        <p>Consider an example with a more complex workflow, shown in <a data-type="xref" href="#fig-style-microservices-ch-book">Figure&nbsp;17-9</a>.</p>
        
        <figure><div id="fig-style-microservices-ch-book" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1709.png" alt="" width="1406" height="898">
        <h6><span class="label">Figure 17-9. </span>Using choreography for a complex business process</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-style-microservices-ch-book">Figure&nbsp;17-9</a>, the first service called must coordinate across a wide variety of other services, basically acting as a mediator in addition to<a data-type="indexterm" data-primary="front controller pattern" id="idm45838970260640"></a> its other domain responsibilities. This pattern is called the <em>front controller</em> pattern, where a nominally choreographed service becomes a more complex mediator for some problem. The downside to this pattern is added complexity in the service.</p>
        
        <p class="pagebreak-before">Alternatively, an architect may choose to use orchestration for complex business processes, illustrated in <a data-type="xref" href="#fig-microservices-ch-orch">Figure&nbsp;17-10</a>.</p>
        
        <figure><div id="fig-microservices-ch-orch" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1710.png" alt="" width="1406" height="1223">
        <h6><span class="label">Figure 17-10. </span>Using orchestration for a complex business process</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-microservices-ch-orch">Figure&nbsp;17-10</a>, the architect builds a mediator to handle the complexity and coordination required for the business workflow. While this creates coupling between these services, it allows the architect to focus coordination into a single service, leaving the others less affected. Often, domain workflows are inherently coupled—the architect’s job entails finding the best way to represent that coupling in ways that support both the domain and architectural goals.<a data-type="indexterm" data-primary="microservices architecture" data-secondary="communication in" data-tertiary="choreography and orchestration" data-startref="ix_mcroarchcommco" id="idm45838970253712"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" class="less_space pagebreak-before" data-pdf-bookmark="Transactions and Sagas"><div class="sect2" id="idm45838970287648">
        <h2>Transactions and Sagas</h2>
        
        <p>Architects aspire to extreme decoupling in<a data-type="indexterm" data-primary="microservices architecture" data-secondary="communication in" data-tertiary="transactions and sagas" id="ix_mcroarchcommtrsa"></a><a data-type="indexterm" data-primary="transactions" data-secondary="and sagas in microservices' communication" data-secondary-sortas="sagas" id="ix_transmcro"></a> microservices, but then often encounter the problem of how to do transactional coordination across services. Because the decoupling in the architecture encourages the same level for the databases, atomicity that was trivial in monolithic applications becomes a problem in distributed ones.</p>
        
        <p>Building transactions across service boundaries violates the core decoupling principle of the microservices architecture (and also creates the worst kind of dynamic connascence, connascence of value). The best advice for architects who want to do transactions across services is: <em>don’t!</em> Fix the granularity components instead. Often, architects who build microservices architectures who then find a need to wire them together with transactions have gone too granular in their design. Transaction boundaries is one of the common indicators of service granularity.</p>
        <div data-type="tip"><h6>Tip</h6>
        <p>Don’t do transactions in microservices—fix granularity instead!</p>
        </div>
        
        <p>Exceptions always exist. For example, a situation may arise where two different services need vastly different architecture characteristics, requiring distinct service boundaries, yet still need transactional coordination. In those situations, patterns exist to handle transaction orchestration, with serious trade-offs.</p>
        
        <p class="pagebreak-before">A popular distributed transactional pattern in microservices is the <em>saga</em> pattern,<a data-type="indexterm" data-primary="sagas (transactional)" data-secondary="saga pattern in microservices" id="idm45838970242176"></a> illustrated in <a data-type="xref" href="#fig-microservices-saga-happy">Figure&nbsp;17-11</a>.</p>
        
        <figure><div id="fig-microservices-saga-happy" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1711.png" alt="" width="1406" height="1147">
        <h6><span class="label">Figure 17-11. </span>The saga pattern in microservices architecture</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-microservices-saga-happy">Figure&nbsp;17-11</a>, a service acts a mediator across multiple service calls and coordinates the transaction. The mediator calls each part of the transaction, records success or failure, and coordinates results. If everything goes as planned, all the values in the services and their contained databases update synchronously.</p>
        
        <p class="pagebreak-before">In an error condition, the mediator must ensure that no part of the transaction succeeds if one part fails. Consider the situation shown in <a data-type="xref" href="#fig-microservices-saga-error">Figure&nbsp;17-12</a>.</p>
        
        <figure><div id="fig-microservices-saga-error" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1712.png" alt="" width="1406" height="1189">
        <h6><span class="label">Figure 17-12. </span>Saga pattern compensating transactions for error conditions</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-microservices-saga-error">Figure&nbsp;17-12</a>, if the first part of the transaction succeeds, yet the second part fails, the mediator must send a request to all the parts of the transaction that were successful and tell them to undo the previous request. <a data-type="indexterm" data-primary="compensating transaction framework" id="idm45838970231424"></a>This style of transactional coordination is called a <em>compensating transaction framework</em>. Developers implement this pattern by usually having each request from the mediator enter a <code>pending</code> state until the mediator indicates overall success. However, this design becomes complex if asynchronous requests must be juggled, especially if new requests appear that are contingent on pending transactional state. This also creates a lot of coordination traffic at the network level.</p>
        
        <p class="pagebreak-before">Another implementation of a compensating transaction framework has developers build <em>do</em> and <em>undo</em> for each potentially transactional operation. This allows less coordination during transactions, but the <em>undo</em> operations tend to be significantly more complex than the <em>do</em> operations, more than doubling the design, implementation, and debugging work.<a data-type="indexterm" data-primary="do and undo operations in transactions" id="idm45838970226592"></a></p>
        
        <p>While it is possible for architects to build transactional behavior across services, it goes against the reason for choosing the microservices pattern. Exceptions always exist, so the best advice for architects is to use the saga pattern sparingly.</p>
        <div data-type="tip"><h6>Tip</h6>
        <p>A few transactions across services is sometimes necessary; if it’s the dominant feature of the architecture, mistakes were made!<a data-type="indexterm" data-primary="communication between services" data-secondary="in microservices architecture" data-startref="ix_commser" id="idm45838970223952"></a><a data-type="indexterm" data-primary="microservices architecture" data-secondary="communication in" data-tertiary="transactions and sagas" data-startref="ix_mcroarchcommtrsa" id="idm45838970222720"></a><a data-type="indexterm" data-primary="transactions" data-secondary="and sagas in microservices' communication" data-secondary-sortas="sagas" data-startref="ix_transmcro" id="idm45838970221216"></a><a data-type="indexterm" data-primary="microservices architecture" data-secondary="communication in" data-startref="ix_mcroarchcomm" id="idm45838970219632"></a></p>
        </div>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Architecture Characteristics Ratings"><div class="sect1" id="idm45838970251600">
        <h1>Architecture Characteristics Ratings</h1>
        
        <p>The microservices architecture style offers several extremes on our standard ratings scale, shown in <a data-type="xref" href="#fig-style-microservices-ratings">Figure&nbsp;17-13</a>. <a data-type="indexterm" data-primary="microservices architecture" data-secondary="architecture characteristics ratings" id="ix_mcroarchac"></a><a data-type="indexterm" data-primary="architecture characteristics" data-secondary="ratings in microservices architecture" id="ix_archrtmcro"></a>A one-star rating means the specific architecture characteristic isn’t well supported in the architecture, whereas a five-star rating means the architecture characteristic is one of the strongest features in the architecture style. The definition for each characteristic identified in the scorecard can be found in <a data-type="xref" href="ch04.html#ch-architecture-characteristics-defined">Chapter&nbsp;4</a>.</p>
        
        <p>Notable is the high support for modern engineering practices such as automated deployment, testability, and others not listed.<a data-type="indexterm" data-primary="testability" data-secondary="rating in microkernel architecture" id="idm45838970211552"></a><a data-type="indexterm" data-primary="deployment" data-secondary="automated deployment in microservices architecture" id="idm45838970210560"></a> Microservices couldn’t exist without the DevOps revolution and the relentless march toward automating operational concerns.</p>
        
        <p>As microservices is a distributed architecture, it suffers from many of the deficiencies inherent in architectures made from pieces wired together at runtime. Thus, fault tolerance and reliability are impacted when too much interservice communication is used.<a data-type="indexterm" data-primary="reliability" data-secondary="rating in microservices architecture" id="idm45838970208656"></a> However, these ratings only point to tendencies in the architecture; developers fix many of these problems by redundancy and scaling via service discovery. Under normal circumstances, however, independent, single-purpose services generally lead to high fault tolerance, hence the high rating for this characteristic within a microservices architecture.<a data-type="indexterm" data-primary="fault tolerance" data-secondary="rating in microservices arhitecture" id="idm45838970207168"></a></p>
        
        <figure class="width-75"><div id="fig-style-microservices-ratings" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1713.png" alt="" width="1240" height="1401">
        <h6><span class="label">Figure 17-13. </span>Ratings for microservices</h6>
        </div></figure>
        
        <p>The high points of this architecture are scalability, elasticity, and evolutionary. <a data-type="indexterm" data-primary="evolutionary architectures" data-secondary="microservices" id="idm45838970203568"></a><a data-type="indexterm" data-primary="scalability" data-secondary="rating in microservices arhitecture" id="idm45838970202528"></a><a data-type="indexterm" data-primary="elasticity" data-secondary="rating in microservices architecture" id="idm45838970201568"></a>Some of the most scalable systems yet written have utilized this style to great success. Similarly, because the architecture relies heavily on automation and intelligent integration with operations, developers can also build elasticity support into the architecture. Because the architecture favors high decoupling at an incremental level, it supports the modern business practice of evolutionary change, even at the architecture level. Modern business move fast, and software development has struggled to keep apace. By building an architecture that has extremely small deployment units that are highly decoupled, architects have a structure that can support a faster rate of change.</p>
        
        <p>Performance is often an issue in microservices—distributed architectures must make many network calls to complete work, which has high performance overhead, and they must invoke security checks to verify identity and access for each endpoint. <a data-type="indexterm" data-primary="performance" data-secondary="rating in microservices arhitecture" id="idm45838970199136"></a>Many patterns exist in the microservices world to increase performance, including intelligent data caching and replication to prevent an excess of network calls. <span class="keep-together">Performance</span> is another reason that microservices often use choreography rather than orchestration, as less coupling allows for faster communication and fewer <span class="keep-together">bottlenecks.</span></p>
        
        <p>Microservices is decidedly a domain-centered architecture, where each service boundary should correspond to domains.<a data-type="indexterm" data-primary="domains" data-secondary="domain-centered architecture in microservices" id="idm45838970195824"></a><a data-type="indexterm" data-primary="architecture quantum" data-secondary="architectural quanta in microservices" id="idm45838970194816"></a> It also has the most distinct quanta of any modern architecture—in many ways, it exemplifies what the quantum measure evaluates. The driving philosophy of extreme decoupling creates many headaches in this architecture but yields tremendous benefits when done well. As in any architecture, architects must understand the rules to break them intelligently.<a data-type="indexterm" data-primary="microservices architecture" data-secondary="architecture characteristics ratings" data-startref="ix_mcroarchac" id="idm45838970193360"></a><a data-type="indexterm" data-primary="architecture characteristics" data-secondary="ratings in microservices arhitecture" data-startref="ix_archrtmcro" id="idm45838970192112"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Additional References"><div class="sect1" id="idm45838970190736">
        <h1>Additional References</h1>
        
        <p>While our goal in this chapter<a data-type="indexterm" data-primary="microservices architecture" data-secondary="references on" id="idm45838970189472"></a> was to touch on some of the significant aspects of this architecture style, many excellent resources exist to get further and more detailed about this architecture style. Additional and more detailed information can be found about microservices in the following references:</p>
        
        <ul>
        <li>
        <p><a class="orm:hideurl" href="http://shop.oreilly.com/product/0636920033158.do"><em>Building Microservices</em></a> by Sam Newman (O’Reilly)</p>
        </li>
        <li>
        <p><a class="orm:hideurl" href="https://learning.oreilly.com/library/view/microservices-vs-service-oriented/9781491975657"><em>Microservices vs. Service-Oriented Architecture</em></a> by Mark Richards (O’Reilly)</p>
        </li>
        <li>
        <p><a class="orm:hideurl" href="https://learning.oreilly.com/library/view/microservices-antipatterns-and/9781492042716"><em>Microservices AntiPatterns and Pitfalls</em></a> by Mark <a data-type="indexterm" data-primary="microservices architecture" data-startref="ix_mcroarch" id="idm45838970181728"></a>Richards (O’Reilly)</p>
        </li>
        </ul>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492043447/files/epub.css" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-svg.js"></script></div></div></section>
</div>

https://learning.oreilly.com