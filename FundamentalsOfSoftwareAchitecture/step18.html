<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><section data-type="chapter" epub:type="chapter" data-pdf-bookmark="Chapter 18. Choosing the Appropriate Architecture Style"><div class="chapter" id="ch-choosing-style">
        <h1><span class="label">Chapter 18. </span>Choosing the Appropriate <span class="keep-together">Architecture Style</span></h1>
        
        
        <p>It depends! With all the choices available (and new ones arriving almost daily), we would like to tell you which one to use—but we cannot.<a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" id="ix_archstych"></a> Nothing is more contextual to a number of factors within an organization and what software it builds. Choosing an architecture style represents the culmination of analysis and thought about trade-offs for architecture characteristics, domain considerations, strategic goals, and a host of other things.</p>
        
        <p>However contextual the decision is, some general advice exists around choosing an appropriate architecture style.</p>
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Shifting “Fashion” in Architecture"><div class="sect1" id="idm45838970175408">
        <h1>Shifting “Fashion” in Architecture</h1>
        
        <p>Preferred architecture styles shift<a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" data-tertiary="shifting fashion in architecture" id="ix_archstychfash"></a> over time, driven by a number of factors:</p>
        <dl>
        <dt>Observations from the past</dt>
        <dd>
        <p>New architecture styles generally arise from observations and pain points from past experiences. Architects have experience with systems in the past that influence their thoughts about future systems. Architects must rely on their past experience—it is that experience that allowed that person to become an architect in the first place. Often, new architecture designs reflect specific deficiencies from past architecture styles. For example, architects seriously rethought the implications of code reuse after building architectures that featured it and then realizing the negative trade-offs.</p>
        </dd>
        <dt>Changes in the ecosystem</dt>
        <dd>
        <p>Constant change is a reliable feature of the software development ecosystem—everything changes all the time.<a data-type="indexterm" data-primary="software development" data-secondary="changes in the ecosystem" id="idm45838970168432"></a> The change in our ecosystem is particularly <span class="keep-together">chaotic,</span> making even the type of change impossible to predict. For example, a few years ago, no one knew what <em>Kubernetes</em> was, and now there are multiple conferences around the world with thousands of developers.<a data-type="indexterm" data-primary="kubernetes" id="idm45838970165904"></a> In a few more years, Kubernetes may be replaced with some other tool that hasn’t been written yet.</p>
        </dd>
        <dt>New capabilities</dt>
        <dd>
        <p>When new capabilities arise, architecture may not merely replace one tool with another but rather shift to an entirely new paradigm.<a data-type="indexterm" data-primary="capabilities, new, and shifting fashion in architecture" id="idm45838970163536"></a> For example, few architects or developers anticipated the tectonic shift caused in the software development world by the advent of containers such as Docker. While it was an evolutionary step, the impact it had on architects, tools, engineering practices, and a host of other factors astounded most in the industry. The constant change in the ecosystem also delivers a new collection of tools and capabilities on a regular basis. Architects must keep a keen eye open to not only new tools but new paradigms. Something may just look like a new one-of-something-we-already-have, but it may include nuances or other changes that make it a game changer. New capabilities don’t even have to rock the entire development world—the new features may be a minor change that aligns exactly with an architect’s goals.</p>
        </dd>
        <dt>Acceleration</dt>
        <dd>
        <p>Not only does the ecosystem constantly change, but the rate of change also continues to rise.<a data-type="indexterm" data-primary="acceleration of rate of change in software development ecosystem" id="idm45838970160384"></a> New tools create new engineering practices, which lead to new design and capabilities. Architects live in a constant state of flux because change is both pervasive and constant.</p>
        </dd>
        <dt>Domain changes</dt>
        <dd>
        <p>The domain that developers write software for constantly shifts and changes, either because the business continues to evolve or because of factors like mergers with other companies.<a data-type="indexterm" data-primary="domains" data-secondary="domain changes and architecture styles" id="idm45838970157840"></a></p>
        </dd>
        <dt>Technology changes</dt>
        <dd>
        <p>As technology continues to evolve, organizations try to keep up with at least some of these changes, especially those with obvious bottom-line benefits.<a data-type="indexterm" data-primary="technology changes, impact on architecture styles" id="idm45838970155392"></a></p>
        </dd>
        <dt>External factors</dt>
        <dd>
        <p>Many external factors only peripherally associated with software development may drive change within an organizations. For example, architects and developers might be perfectly happy with a particular tool, but the licensing cost has become prohibitive, forcing a migration to another option.</p>
        </dd>
        </dl>
        
        <p>Regardless of where an organization stands in terms of current architecture fashion, an architect should understand current industry trends to make intelligent decisions about when to follow and when to make exceptions.<a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" data-tertiary="shifting fashion in architecture" data-startref="ix_archstychfash" id="idm45838970152448"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Decision Criteria"><div class="sect1" id="idm45838970150688">
        <h1>Decision Criteria</h1>
        
        <p>When choosing an architectural style, an architect must take into account all the various factors that contribute to the structure for the domain design.<a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" data-tertiary="decision criteria" id="ix_archstychdec"></a> Fundamentally, an architect designs two things: whatever domain has been specified, and all the other structural elements required to make the system a success.</p>
        
        <p>Architects should go into the design decision comfortable with the following things:</p>
        <dl>
        <dt>The domain</dt>
        <dd>
        <p>Architects should understand many important aspects of the domain, especially those that affect operational architecture characteristics. Architects don’t have to be subject matter experts, but they must have at least a good general understanding of the major aspects of the domain under design.</p>
        </dd>
        <dt>Architecture characteristics that impact structure</dt>
        <dd>
        <p>Architects must discover and elucidate the architecture characteristics needed to support the domain and other external factors.</p>
        </dd>
        <dt>Data architecture</dt>
        <dd>
        <p>Architects and DBAs must collaborate on database, schema, and other data-related concerns. We don’t cover much about data architecture in this book; it is its own specialization. However, architects must understand the impact that data design might have on their design, particularly if the new system must interact with an older and/or in-use data architecture.</p>
        </dd>
        <dt>Organizational factors</dt>
        <dd>
        <p>Many external factors may influence design. For example, the cost of a particular cloud vendor may prevent the ideal design. Or perhaps the company plans to engage in mergers and acquisitions, which encourages an architect to gravitate toward open solutions and integration architectures.</p>
        </dd>
        <dt>Knowledge of process, teams, and operational concerns</dt>
        <dd>
        <p>Many specific project factors influence an architect’s design, such as the software development process, interaction (or lack of) with operations, and the QA process. For example, if an organization lacks maturity in Agile engineering practices, architecture styles that rely on those practices for success will present difficulties.</p>
        </dd>
        <dt>Domain/architecture isomorphism</dt>
        <dd>
        <p>Some problem domains match the topology of the architecture. For example, the microkernel architecture style is perfectly suited to a system that requires customizability—the architect can design customizations as plug-ins. Another example might be genome analysis, which requires a large number of discrete operations, and space-based architecture, which offers a large number of discrete processors.</p>
        
        <p>Similarly, some problem domains may be particularly ill-suited for some architecture styles. For example, highly scalable systems struggle with large monolithic designs because architects find it difficult to support a large number of concurrent users in a highly coupled code base. A problem domain that includes a huge amount of semantic coupling matches poorly with a highly decoupled, distributed architecture. For instance, an insurance company application consisting of multipage forms, each of which is based on the context of previous pages, would be difficult to model in microservices. This is a highly coupled problem that will present architects with design challenges in a decoupled architecture; a less coupled architecture like service-based architecture would suit this problem better.</p>
        </dd>
        </dl>
        
        <p>Taking all these things into account, the architect must make several determinations:</p>
        <dl>
        <dt>Monolith versus distributed</dt>
        <dd>
        <p>Using the quantum concepts discussed earlier, <a data-type="indexterm" data-primary="monolithic architecture" data-secondary="distributed architecture versus" id="idm45838970133136"></a><a data-type="indexterm" data-primary="distributed architectures" data-secondary="monolithic architectures versus" id="idm45838970132144"></a>the architect must determine if a single set of architecture characteristics will suffice for the design, or do different parts of the system need differing architecture characteristics? A single set implies that a monolith is suitable (although other factors may drive an architect toward a distributed architecture), whereas different architecture characteristics imply a distributed architecture.</p>
        </dd>
        <dt>Where should data live?</dt>
        <dd>
        <p>If the architecture is monolithic, architects commonly assume a single relational databases or a few of them.<a data-type="indexterm" data-primary="data" data-secondary="deciding where it should live" id="idm45838970129216"></a> In a distributed architecture, the architect must decide which services should persist data, which also implies thinking about how data must flow throughout the architecture to build workflows. Architects must consider both structure and behavior when designing architecture and not be fearful of iterating on the design to find better combinations.</p>
        </dd>
        <dt>What communication styles between services—synchronous<a data-type="indexterm" data-primary="communication between services" id="idm45838970127216"></a><a data-type="indexterm" data-primary="asynchronous communication" id="idm45838970126416"></a><a data-type="indexterm" data-primary="synchronous comunication" id="idm45838970125728"></a> or asynchronous?</dt>
        <dd>
        <p>Once the architect has determined data partitioning, their next design consideration is the communication between services—synchronous or asynchronous? Synchronous communication is more convenient in most cases, but it can lead to lack of scalability, reliability, and other desirable characteristics.<a data-type="indexterm" data-primary="architecture characteristics" data-secondary="in synchronous vs. asynchronous communications between services" data-secondary-sortas="synchronous" id="idm45838970123856"></a> Asynchronous communication can provide unique benefits in terms of performance and scale but can present a host of headaches: data synchronization, deadlocks, race conditions, debugging, and so on.</p>
        </dd>
        </dl>
        
        <p class="pagebreak-before">Because synchronous communication presents fewer design, implementation, and debugging challenges, architects should default to synchronous when possible and use asynchronous when necessary.</p>
        <div data-type="tip"><h6>Tip</h6>
        <p>Use synchronous by default, asynchronous when necessary.</p>
        </div>
        
        <p>The output of this design process is architecture topology, taking into account what architecture style (and hybridizations) the architect chose, architecture decision records about the parts of the design which required the most effort by the architect, and architecture fitness functions to protect important principles and operational architecture characteristics.<a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" data-tertiary="decision criteria" data-startref="ix_archstychdec" id="idm45838970119232"></a></p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Monolith Case Study: Silicon Sandwiches"><div class="sect1" id="idm45838970117568">
        <h1>Monolith Case Study: Silicon Sandwiches</h1>
        
        <p>In the Silicon Sandwiches architecture kata, after investigating the architecture characteristics, we determined that a single quantum was sufficient to implement this system.<a data-type="indexterm" data-primary="Silicon Sandwiches case study" data-secondary="monolithic architectures" id="ix_SScsMno"></a><a data-type="indexterm" data-primary="monolithic architecture" data-secondary="Silicon Sandwiches case study" id="ix_monoSScs"></a><a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" data-tertiary="monolithic architectures in Silicon Sandwiches case study" id="ix_archstychmono"></a> Plus, this is a simple application without a huge budget, so the simplicity of a monolith appeals.</p>
        
        <p>However, we created two different component designs for Silicon Sandwiches: one domain partitioned and another technically partitioned.<a data-type="indexterm" data-primary="partitioning of components" data-secondary="Silicon Sandwiches case study, domain and technical partitioning" id="idm45838970111088"></a><a data-type="indexterm" data-primary="domain partitioning (components)" data-secondary="in Silicon Sandwiches monolithic architectures case study" data-secondary-sortas="Silicon" id="idm45838970110048"></a><a data-type="indexterm" data-primary="technical partitioning (components)" data-secondary="in Silicon Sandwiches monolithic architectures case study" data-secondary-sortas="Silicon" id="idm45838970108768"></a> Given the simplicity of the solution, we’ll create designs for each and cover trade-offs.</p>
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Modular Monolith"><div class="sect2" id="idm45838970107120">
        <h2>Modular Monolith</h2>
        
        <p>A modular monolith builds domain-centric components with a single database, deployed <a data-type="indexterm" data-primary="modular monoliths" data-secondary="using in Silicon Sandwich case study" id="idm45838970105648"></a>as a single quantum; the modular monolith design for Silicon Sandwiches appears in <a data-type="xref" href="#fig-choosing-pattern-SS-modular">Figure&nbsp;18-1</a>.</p>
        
        <p>This is a monolith with a single relational database, implemented with a single web-based user interface (with careful design considerations for mobile devices) to keep overall cost down. Each of the domains the architect identified earlier appear as components. If time and resources are sufficient, the architect should consider creating the same separation of tables and other database assets as the domain components, allowing for this architecture to migrate to a distributed architecture more easily if future requirements warrant it.</p>
        
        <figure><div id="fig-choosing-pattern-SS-modular" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1801.png" alt="Modular Silicon Sandwiches" width="1390" height="1133">
        <h6><span class="label">Figure 18-1. </span>A modular monolith implementation of Silicon Sandwiches</h6>
        </div></figure>
        
        <p>Because the architecture style itself doesn’t inherently handle customization, the architect must make sure that that feature becomes part of domain design. In this case, the architect designs an <code>Override</code> endpoint where developers can upload individual customizations. Correspondingly, the architect must ensure that each of the domain components references the <code>Override</code> component for each customizable characteristic—this would make a perfect fitness function.</p>
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect2" data-pdf-bookmark="Microkernel"><div class="sect2" id="idm45838970098800">
        <h2>Microkernel</h2>
        
        <p>One of the architecture characteristics the architect identified in Silicon Sandwiches was customizability.<a data-type="indexterm" data-primary="microkernel architecture" data-secondary="in Silicon Sandwiches monolithic architectures case study" data-secondary-sortas="Silicon" id="idm45838970097168"></a> Looking at domain/architecture isomorphism, an architect may choose to implement it using a microkernel, as illustrated in <a data-type="xref" href="#fig-choosing-pattern-SS-micro">Figure&nbsp;18-2</a>.</p>
        
        <figure><div id="fig-choosing-pattern-SS-micro" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1802.png" alt="Microkernel Silicon Sandwiches" width="1081" height="1360">
        <h6><span class="label">Figure 18-2. </span>A microkernel implementation of Silicon Sandwiches</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-choosing-pattern-SS-micro">Figure&nbsp;18-2</a>, the core system consists of the domain components and a single relational database. As in the previous design, careful synchronization between domains and data design will allow future migration of the core to a distributed architecture.<a data-type="indexterm" data-primary="plug-in components, microkernel architecture" data-secondary="in Silicon Sandwiches case study" data-secondary-sortas="Silicon" id="idm45838970091200"></a> Each customization appears in a plug-in, the common ones in a single set of plug-ins (with a corresponding database), and a series of local ones, each with their own data. Because none of the plug-ins need to be coupled to the other plug-ins, they can each maintain their data, leaving the plug-ins decoupled.</p>
        
        <p>The other unique design element here utilizes the <a href="https://oreil.ly/i3Hsc">Backends for Frontends (BFF)</a> pattern, making the API layer a thin microkernel adaptor. <a data-type="indexterm" data-primary="frontends" data-secondary="Backends for Frontends (BFF) pattern" id="idm45838970088352"></a><a data-type="indexterm" data-primary="Backends for Frontends (BFF) pattern" id="idm45838970087264"></a>It supplies general information from the backend, and the BFF adaptors translate the generic information into the suitable format for the frontend device. For example, the BFF for iOS will take the generic output from the backend and customize it for what the iOS native application expects: the data format, pagination, latency, and other factors. Building each BFF adaptor allows for the richest user interfaces and the ability to expand to support other devices in the future—one of the benefits of the microkernel style.</p>
        
        <p>Communication within either Silicon Sandwich architecture can be synchronous—the architecture doesn’t require extreme performance or elasticity requirements—and none of the operations will be lengthy.<a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" data-tertiary="monolithic architectures in Silicon Sandwiches case study" data-startref="ix_archstychmono" id="idm45838970085296"></a><a data-type="indexterm" data-primary="Silicon Sandwiches case study" data-secondary="monolithic architectures" data-startref="ix_SScsMno" id="idm45838970083712"></a><a data-type="indexterm" data-primary="monolithic architecture" data-secondary="Silicon Sandwiches case study" data-startref="ix_monoSScs" id="idm45838970082464"></a></p>
        </div></section>
        
        
        
        
        
        </div></section>
        
        
        
        
        
        
        
        
        
        
        
        
        
        <section data-type="sect1" data-pdf-bookmark="Distributed Case Study: Going, Going, Gone"><div class="sect1" id="idm45838970081104">
        <h1>Distributed Case Study: Going, Going, Gone</h1>
        
        <p>The Going, Going, Gone (GGG) kata presents more interesting architecture challenges.<a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" data-tertiary="distributed architecture in Going, Going, Gone case study" id="ix_archstychdaGGG"></a><a data-type="indexterm" data-primary="Going, Going, Gone case study" data-secondary="using distributed architecture" id="ix_GGGcsda"></a><a data-type="indexterm" data-primary="distributed architectures" data-secondary="in Going, Going, Gone case study" data-secondary-sortas="Going" id="ix_dstarchGGG"></a> Based on the component analysis in <a data-type="xref" href="ch08.html#sec-ggg-comp-discovery">“Case Study: Going, Going, Gone: Discovering Components”</a>, this architecture needs differing architecture characteristics for different parts of the architecture. For example, architecture characteristics like availability and scalability will differ between roles like auctioneer and bidder.<a data-type="indexterm" data-primary="architecture characteristics" data-secondary="in distributed architecture Going, Going, Gone case study" data-secondary-sortas="distributed" id="idm45838970074000"></a></p>
        
        <p>The requirements for GGG also explicitly state certain ambitious levels of scale, elasticity, performance, and a host of other tricky operational architecture characteristics. The architect needs to choose a pattern that allows for a high degree of customization at a fine-grained level within the architecture. Of the candidate distributed architectures, either low-level event-driven or microservices match most of the architecture characteristics. Of the two, microservices better supports differing operational architecture characteristics—purely event-driven architectures typically don’t separate pieces because of these operational architecture characteristics but are rather based on communication style, orchestrated versus choreographed.</p>
        
        <p>Achieving the stated performance will provide a challenge in microservices, but architects can often address any weak point of an architecture by designing to accommodate it. For example, while microservices offers a high degrees of scalability <span class="keep-together">naturally,</span> architects commonly have to address specific performance issues caused by too much orchestration, too aggressive data separation, and so on.</p>
        
        <p class="pagebreak-before">An implementation of GGG using microservices <a data-type="indexterm" data-primary="microservices" data-secondary="implementation of Going, Going, Gone using" id="idm45838970069152"></a>is shown in <a data-type="xref" href="#fig-choosing-pattern-GGG-topo">Figure&nbsp;18-3</a>.</p>
        
        <figure><div id="fig-choosing-pattern-GGG-topo" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1803.png" alt="microservices version of GGG" width="1424" height="1246">
        <h6><span class="label">Figure 18-3. </span>A microservices implementation of Going, Going, Gone</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-choosing-pattern-GGG-topo">Figure&nbsp;18-3</a>, each identified component became services in the architecture, matching component and service granularity.<a data-type="indexterm" data-primary="user interfaces (UIs)" data-secondary="in distributed architecture Going, Going, Gone case study" data-secondary-sortas="distributed" id="idm45838970063680"></a> GGG has three distinct user interfaces:</p>
        <dl>
        <dt>Bidder</dt>
        <dd>
        <p>The numerous bidders for the online auction.</p>
        </dd>
        <dt>Auctioneer</dt>
        <dd>
        <p>One per auction.</p>
        </dd>
        <dt>Streamer</dt>
        <dd>
        <p>Service responsible for streaming video and bid stream to the bidders. Note that this is a read-only stream, allowing optimizations not available if updates were necessary.</p>
        </dd>
        </dl>
        
        <p class="pagebreak-before">The following services<a data-type="indexterm" data-primary="services" data-secondary="in microservices implementation of Going, Going, Gone" data-secondary-sortas="microservices" id="idm45838970056800"></a> appear in this design of the GGG architecture:</p>
        <dl>
        <dt><code>BidCapture</code></dt>
        <dd>
        <p>Captures online bidder entries and asynchronously sends them to <code>Bid Tracker</code>. This service needs no persistence because it acts as a conduit for the online bids.</p>
        </dd>
        <dt><code>BidStreamer</code></dt>
        <dd>
        <p>Streams the bids back to online participants in a high performance, read-only stream.</p>
        </dd>
        <dt><code>BidTracker</code></dt>
        <dd>
        <p>Tracks bids from both <code>Auctioneer Capture</code> and <code>Bid Capture</code>. This is the component that unifies the two different information streams, ordering the bids as close to real time as possible. Note that both inbound connections to this service are asynchronous, allowing the developers to use message queues as buffers to handle very different rates of message flow.</p>
        </dd>
        <dt><code>Auctioneer Capture</code></dt>
        <dd>
        <p>Captures bids for the auctioneer. The result of quanta analysis in <a data-type="xref" href="ch08.html#sec-ggg-comp-discovery">“Case Study: Going, Going, Gone: Discovering Components”</a> led the architect to separate <code>Bid Capture</code> and <code>Auctioneer Capture</code> because they have quite different architecture characteristics.</p>
        </dd>
        <dt><code>Auction Session</code></dt>
        <dd>
        <p>This manages the workflow of individual auctions.</p>
        </dd>
        <dt><code>Payment</code></dt>
        <dd>
        <p>Third-party payment provider that handles payment information after the <span class="keep-together"><code>Auction</code></span> <code>Session</code> has completed the auction.</p>
        </dd>
        <dt><code>Video Capture</code></dt>
        <dd>
        <p>Captures the video stream of the live auction.</p>
        </dd>
        <dt><code>Video Streamer</code></dt>
        <dd>
        <p>Streams the auction video to online bidders.</p>
        </dd>
        </dl>
        
        <p>The architect was careful to identify both synchronous and asynchronous communication styles in this architecture.<a data-type="indexterm" data-primary="communication between services" data-secondary="in microservices implementation of Going, Going, Gone" data-secondary-sortas="microservices" id="idm45838970037248"></a><a data-type="indexterm" data-primary="synchronous comunication" data-secondary="in microservices implementation of Going, Going, Gone" data-secondary-sortas="microservices" id="idm45838970035936"></a><a data-type="indexterm" data-primary="asynchronous communication" data-secondary="in microservices implementation of Going, Going, Gone" data-secondary-sortas="microservices" id="idm45838970034720"></a> Their choice for asynchronous communication is primarily driven by accommodating differing operational architecture characteristics between services. For example, if the <code>Payment</code> service can only process a new payment every 500 ms and a large number of auctions end at the same time, synchronous communication between the services would cause time outs and other reliability headaches. By using message queues, the architect can add reliability to a critical part of the architecture that exhibits fragility.<a data-type="indexterm" data-primary="architecture quantum" data-secondary="quanta boundaries for distributed architecture Going, Going, Gone case study" id="idm45838970032400"></a></p>
        
        <p class="pagebreak-before">In the final analysis, this design resolved to five quanta, identified in <a data-type="xref" href="#fig-choosing-pattern-GGG-quanta">Figure&nbsp;18-4</a>.</p>
        
        <figure><div id="fig-choosing-pattern-GGG-quanta" class="figure">
        <img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492043447/files/assets/fosa_1804.png" alt="" width="1424" height="1246">
        <h6><span class="label">Figure 18-4. </span>The quanta boundaries for GGG</h6>
        </div></figure>
        
        <p>In <a data-type="xref" href="#fig-choosing-pattern-GGG-quanta">Figure&nbsp;18-4</a>, the design includes quanta for <code>Payment</code>, <code>Auctioneer</code>, <code>Bidder</code>, <code>Bidder Streams</code>, and <code>Bid Tracker</code>, roughly corresponding to the services. Multiple instances are indicated by stacks of containers in the diagram. Using quantum analysis at the component design stage allowed the architect to more easily identify service, data, and communication boundaries.</p>
        
        <p>Note that this isn’t the “correct” design for GGG, and it’s certainly not the only one. We don’t even suggest that it’s the best possible design, but it seems to have the <em>least worst</em> set of trade-offs. Choosing microservices, then intelligently using events and messages, allows the architecture to leverage the most out of a generic architecture pattern while still building a foundation for future development and expansion.<a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" data-tertiary="distributed architecture in Going, Going, Gone case study" data-startref="ix_archstychdaGGG" id="idm45838970022800"></a><a data-type="indexterm" data-primary="Going, Going, Gone case study" data-secondary="using distributed architecture" data-startref="ix_GGGcsda" id="idm45838970021264"></a><a data-type="indexterm" data-primary="distributed architectures" data-secondary="in Going, Going, Gone case study" data-secondary-sortas="Going" data-startref="ix_dstarchGGG" id="idm45838970020016"></a><a data-type="indexterm" data-primary="architecture styles" data-secondary="choosing the appropriate style" data-startref="ix_archstych" id="idm45838970018496"></a></p>
        </div></section>
        
        
        
        
        
        
        
        </div></section></div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9781492043447/files/epub.css" crossorigin="anonymous"><script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/mml-svg.js"></script></div></div></section>
</div>

https://learning.oreilly.com