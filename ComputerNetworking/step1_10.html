<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch10"><a id="page_249"></a><strong>Chapter 10<br>Transport Security</strong></h2>
        <div class="sidebar">
        <p class="sb-noindent"><strong>Learning Objectives</strong></p>
        <p class="sb-noindent">After reading this chapter, you should be able to:</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the concept of data exhaust and how it can be used by an attacker</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the basic operation of encryption systems, including asymmetric and symmetric encryption</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the concept of a web of trust</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the basic principles of how keys can be exchanged</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the basic techniques used to hide user information</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the man-in-the-middle attack</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the basic operation of Transport Layer Security</p>
        </div>
        <p class="noindent">When you log in to a financial or medical website and sign in, you should expect that the information you retrieve cannot be intercepted and read by anyone along the path between your computer and the server. A less obvious, but just as important, problem is the information you send to the site should not be open to change while it is being transported by the network.</p>
        <p class="indent">But how can these things be ensured? These are two of the areas transport security can be used to address. This chapter will consider the transport security problem space, followed by an investigation of several kinds of solutions, including encryption. Finally, this chapter will look at the Transport Layer Security (TLS) specification as an example of transport layer encryption.</p>
        <div class="heading">
        <h3 class="h3" id="ch10lev1"><a id="page_250"></a>The Problem Space</h3>
        <p class="noindent">Security generally resolves to one of four problems: proving the data has not been changed in transmission, preventing anyone other than the intended recipient from accessing the information, protecting the privacy of the humans using the network, and proving information has been delivered (or work has been done). The second and third problems, preventing unauthorized access to data as it crosses the network and protecting user privacy, are related problems but will be treated separately in the following sections. The final problem noted, the <em>proof of traversal</em> problem (which is similar to the <em>proof of work</em> problem faced in other information technology contexts), is not considered here, as it is an area of active research with few deployed systems.</p>
        </div>
        <div class="heading">
        <h4 class="h4" id="ch10lev2"><strong>Validating Data</strong></h4>
        <p class="noindent">If you log in to your bank’s website and transfer $100 from one account to another, you would likely be upset if the amount actually transferred was $1,000 instead, or if the account numbers were changed so the $100 ended up in someone else’s account. There are a number of other situations where making certain the data transmitted is the same as the data received, such as</p>
        </div>
        <p class="bullt">• If you purchase a pair of blue shoes, you do not want a set of red ones delivered instead.</p>
        <p class="bullb">• If your doctor gives you a prescription for medicine to help your heartburn (probably resulting from the stress of working as a network engineer), you do not want medicine for arthritis (probably from typing so many documents and books) to be delivered.</p>
        <p class="indent">There are a lot of situations where the data received must match the data transmitted, and the originator and/or receiver must be verifiable.</p>
        <div class="heading">
        <h4 class="h4" id="ch10lev3"><strong>Protecting Data from Being Examined</strong></h4>
        <p class="noindent">The data protection examples given previously can be taken one step further: you do not want someone to see your account number, prescription, or other information as it is being transported across the network. Account numbers, passwords, and any kind of personally identifiable information (PII) are all very crucial, as these kinds of information can be used to break into accounts to steal money, or even used to steal someone’s identity entirely.</p>
        </div>
        <p class="indent"><a id="page_251"></a>How can this kind of information be protected? The primary means of protection used to prevent unauthorized users (or attackers; see <a href="ch21.xhtml#ch21">Chapter 21</a>, “<a href="ch21.xhtml#ch21">Security: A Broader Sweep</a>,” later for a full definition of the elements of an attack) is encryption.</p>
        <div class="heading">
        <h4 class="h4" id="ch10lev4"><strong>Protecting User Privacy</strong></h4>
        <p class="noindent">Privacy is not just nice to have on the global Internet; it is a requirement for users to trust the system. This is true of local networks, as well; if users believe they are being spied on in some way, they are not likely to use the network. Rather, they are likely to use <em>sneakernet</em>, printing information out and hand-carrying it, rather than transferring it over the network. While many people believe privacy is not a valid concern, there are many valid concerns in this area.</p>
        </div>
        <p class="indent">For instance, a common saying in the information management field is <em>knowledge is power</em>. Knowing about a computer or network gives you some measure of power over the computer, network, or system. For instance, assume a bank configures an automated backup for a particular database table; when the balances in the account held in the table change by a particular amount, the backup is kicked off automatically. This might seem like a perfectly reasonable sort of backup job, but it does involve some amount of data exhaust.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">Data exhaust is information about the physical movements of people or information that can be used to infer what those people or that information is doing. For instance, if you always take the same route to work every morning, someone can infer, once you have made some small part of the trip, combined with a time of day, you are going to work. The same sorts of data exhaust exist in the network world; if, every time, at a particular time of day, a particular piece of data of a certain size is transmitted through the network, and it happens to coincide with a particular event, such as transferring money between two accounts, then when this particular data appears, the transfer must be taking place. Browsing, email history, and other online actions all leave data exhaust, which can sometimes be used to infer the contents of a data stream even if the stream is encrypted.</p>
        </div>
        <p class="indent">The vulnerability here is: if a threat actor puts the backup together with the change in account value, that person will know specifically what the pattern of account activity is. Enough clues of this sort can be developed into an entire set of attack plans.</p>
        <p class="indent"><a id="page_252"></a>The same is true of people; having knowledge about people can give you some ability to influence people in specific directions. While the influence over people is not as great as the influence over machines, handing one person power over another always carries moral implications that need to be handled carefully.</p>
        <div class="sidebar1">
        <p class="title1"><strong>Nothing to Hide</strong></p>
        <p class="noindent">“If you have done nothing wrong, you have nothing to hide.” This is a widespread fallacy worth considering for a moment. The fallacy first implies <em>hiding something means you have done something wrong</em> is the primary point of hiding information about yourself. In reality, as noted earlier, information can often be used to shape a person’s (or a culture’s) perceptions of reality, beliefs, and actions in unhealthy ways. Humans are (it is generally but not universally agreed) flawed. The presumption should always be information is given when it is needed for a specific reason, and is not kept when it is no longer needed, to protect people from using data about another person in unethical or unintentional ways. Most often, in modern information technology systems, the presumption runs the other way—“information wants to be free,” and should only be controlled when there is a specific reason to control it.</p>
        <p class="indent">The second point to remember is, as mentioned, <em>humans are flawed</em>. There is probably some embarrassing action you have taken in the past, or something someone would consider “wrong” or “harmful.” While it is important not to cover up serious and real crimes, it is also important to allow some grace in the interaction between humans, just in order to make a society work.</p>
        <p class="indent">The third point to remember is, returning to <em>knowledge is power</em>, that power can be used asymmetrically. Companies often hide information about themselves from users and yet expect users (and employees) to be completely transparent. Asymmetrical power can be harmful to people in the real world. Remember that every company is ultimately made up of employees, each of whom is a customer in some other context, and each of whom deserves privacy.</p>
        <p class="indent">One phrase used to describe the problem of information leaked by users as they interact on a network is data exhaust (see the previous note). There are many forms of data exhaust, some of which are nearly impossible to defend against.</p>
        </div>
        <div class="heading">
        <h3 class="h3" id="ch10lev5">The Solution Space</h3>
        <p class="noindent">While every solution to the security and privacy issues described in the preceding sections generally involves hard math, this section will (attempt to) describe the <a id="page_253"></a>solutions without the math. Readers who would like to learn more about the mechanisms considered here are encouraged to look at the “Further Reading” section at the end of the chapter for resources describing specific kinds of encryption algorithms and the math involved.</p>
        </div>
        <div class="heading">
        <h4 class="h4" id="ch10lev6"><strong>Encryption</strong></h4>
        <p class="noindent">Encryption takes a block of information (the <em>plaintext)</em> and encodes it using some form of mathematical operation to obscure the text, resulting in the <em>ciphertext</em>. To recover the original plain text, the mathematical operations must be reversed. While encryption is often approached as a mathematical construct, it is sometimes easier to start by thinking of it as a substitution cipher with a substitution table that varies based on the key used. <a href="ch10.xhtml#ch10fig01">Figure 10-1</a> illustrates.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/10fig01.jpg" aria-describedby="Al10fig01" alt="Figure represents a cipher block as a substitution table." width="451" height="383"><aside class="hidden" id="Al10fig01">
        <p>A rectangular block to the left has three rectangles with 0001, 0010, and 0011 enclosed. A set of dots fall below. A rectangular block follows with three rectangles that has 0100, 0101, and 0110 enclosed. Original is mentioned below. A rectangular block to the left has three rectangles with 1010, 0100, and 1011 enclosed. A set of dots fall below. A rectangular block follows with three rectangles that has 0101, 0000, and 1000 enclosed. Substituted key 1 is mentioned below. A rectangular block to the left has three rectangles with 0000, 0101, and 1000 enclosed. A set of dots fall below. A rectangular block follows with three rectangles that has 1010, 0001, and 1001 enclosed. Substituted key 2 is mentioned below.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch10fig01"></a><strong>Figure 10-1</strong> <em>A Cipher Block as a Substitution Table</em></p>
        </div>
        <p class="indent"><a href="ch10.xhtml#ch10fig01">Figure 10-1</a> shows a four-bit block of information—a trivial example but still useful to illustrate the point. The encryption process is conceptually a series of straight substitutions:</p>
        <p class="bullt">• If 0001 is found in the original block of data (the plaintext) and key 1 is in use, then 1010 is substituted into the actual transmitted stream (the ciphertext).</p>
        <p class="bull">• If 0010 is found in the plaintext and key 1 is in use, then 0100 is substituted into the transmitted data.</p>
        <p class="bull"><a id="page_254"></a>• If 0001 is found in the plaintext and key 2 is in use, then 0000 is substituted into the transmitted data.</p>
        <p class="bullb">• If 0110 is found in the plaintext and key 2 is in use, then 1001 is substituted into the transmitted data.</p>
        <p class="indent">The process of substituting one block of bits for another is called a <em>transform</em>. These transforms must be symmetrical: they must not only allow the plaintext to be encrypted to the ciphertext, but they must also allow the plaintext to be recovered (unencrypted) from the ciphertext. In a substitution table, this process involves looking up the key on the ciphertext side of the table and substituting the plaintext equivalent.</p>
        <p class="indent">The size of the substitution table is determined by the size of the block, or the number of bits encoded at one time. If a 128-bit block is used, for instance, the lookup table would need to have 2<sup>128</sup> entries—a very large number indeed. This kind of space can be still be searched by an efficient algorithm quickly, so the block must have some other features than simply being large.</p>
        <p class="indent">The first is that the ciphertext side of the substitution block must be <em>as random as possible</em>. For a transform to be ideal, any pattern found in the plaintext must not be available for analysis in the resulting ciphertext. The ciphertext output must appear to be as close to a random set of numbers as possible, no matter what the input is.</p>
        <p class="indent">The second is the substitution block should be as large as is practically possible. The more random and larger the substitution block is, the harder it is to work back from the plaintext and ciphertext to discovering the substitution pattern being used. To perform a brute-force attack against a substitution using a 128-bit block size, the attacker must correlate as many of the 2<sup>128</sup> entries in the plaintext block with the 2<sup>128</sup> entries in the ciphertext substitution block—if the information only uses a small (or sparse) set of possible entries from the original 128-bit space, there is little practical way to make the correlation fast enough to make this sort of attack practical—given the encrypting sender changes its key often enough.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">There is a law of diminishing returns when it comes to the size of the block; at some point, increasing the block size does not increase the effectiveness of the cipher at hiding information.</p>
        </div>
        <p class="indent">Density is best explained with an example. Assume you are using a straight substitution cipher in the English language, where each letter is replaced by the letter offset by four steps in the alphabet. In this sort of (trivial) cipher:</p>
        <p class="bullt"><a id="page_255"></a>• Each A would be replaced by an E.</p>
        <p class="bull">• Each B would be replaced by an F.</p>
        <p class="bull">• Each C would be replaced by a G.</p>
        <p class="bullb">• Etc.</p>
        <p class="indent">Now try encrypting two different sentences using this transform:</p>
        <p class="bullt">• THE SKY IS BLUE == XLI WOC MW FPYI</p>
        <p class="bullb">• THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG == XLI UYMGO FVSAR JSB NYQTIH SZIV XLI PEDC HSK</p>
        <p class="indent">For the attacker trying to figure out how the ciphertext version of the sentence relates to the plaintext version, the first sentence presents 9 matching pairs of letters out of the space of 26 possible letters. There is a good chance you can guess what the correct transform is—move four steps to the right—from this small sample, but it is possible there is some “trick” involved that causes future messages encrypted using this transform to fail to be unencrypted correctly. The second sentence is, however, a well-known example of a sentence containing every possible letter in the English alphabet. The transform can be validated against every possible value in the entire input and output range, making the discovery of the transform trivial.</p>
        <p class="indent">In this example, the first sentence would be less dense than the second. In real cryptographic systems, the general idea would be to use just several thousand possible symbols out of a space of 2<sup>128</sup> or 2<sup>512</sup> possible symbols, which creates a much less dense information set to work with. At some point, the density becomes low enough, the transform complex enough, and the ciphertext random enough, that there is no practical way to compute the relationship between the input (the plaintext) and the output (the ciphertext).</p>
        <p class="indent">In real life, the substitution blocks are not precomputed in this way. Rather, a cryptographic function is used to calculate the substitution value in real time. These cryptographic functions take a block-sized input, the plaintext, perform the transform, and output the correct ciphertext. The key is a second input that modifies the output of the transform so each key causes the transform to produce a different output. If the key size is 128 bits, and the block size is 256 bits, there are 2<sup>128</sup> × 2<sup>256</sup> possible output combinations from the transform. <a href="ch10.xhtml#ch10fig02">Figure 10-2</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/10fig02.jpg" aria-describedby="Al10fig02" alt="Figure represents substitution tables generated by large key transforms." width="687" height="766"><aside class="hidden" id="Al10fig02">
        <p>Three rectangular bars are arranged vertically to the left with a set of rectangles enclosed. Three rectangular bars to the right have the same arrangement. Each key creates a table, so there are 2 superscript 128 possible tables are at the top, represented by dotted lines. Dotted arrows point the bottom of the rectangular bars, with text each table is 2 superscript 256 possible substitutions.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch10fig02"></a><strong>Figure 10-2</strong> <em>Substitution Tables Generated by Large Key Transforms</em></p>
        </div>
        <p class="indent">In <a href="ch10.xhtml#ch10fig02">Figure 10-2</a>, each substitution table is the block size; if the block size is 256 bits, then there are 2<sup>256</sup> possible substitutions in each table. Each key generates a new table, so if the key is 128 bits, then there are 2<sup>128</sup> possible tables. There are two general ways to attack such an encryption system.</p>
        <p class="indent"><a id="page_256"></a>The first way to attack this type of encryption system is to try to map every possible input value to every possible output value, revealing the entire substitution table. If the input only ever represents a small set of the possible inputs (the table is sparsely used, or is a sparse array, more precisely), this task is nearly impossible. If the user changes her key, and hence the particular table among the possible set of tables, often enough, there is no way to perform this mapping faster than the key is changed.</p>
        <div class="note">
        <p class="title"><a id="page_257"></a><strong>Note</strong></p>
        <p class="notepara">There are still potential weaknesses even in large blocks combined with transforms to produce nearly random output—in other words, even if the transform is close to ideal. If you collect 23 people in a single room, there is a high probability two of them will have the same birthday—but this seems irrational because there are 365 potential days (not counting leap years) on which a person could be born each year. The reason for the disparity between what appears should happen and what does happen is this: in the real world, people’s birthdays are clustered on a very small number of days throughout the year. The input data, then, is a very dense “spot” in a moderately large set of possible values. When this happens, the sparseness of the data can work <em>against</em> the encryption system. If a small set of data is repeated in the larger set on a regular basis, the attacker can focus on just the substitutions used most often and potentially discover the contents of <em>enough</em> of the message to make recovery of most of the meaning reasonably possible.</p>
        </div>
        <p class="indent">The second way to attack an encryption system of this kind is to attack the transform itself—the cryptographic function. Remember these large substitution tables are often impossible to generate, store, and transport, so some form of crypto-graphic function is used to take a block of plaintext as an input and generate a block of ciphertext as the output. If you could discover this transform function, then you can calculate the output in the same way the transmitter and receiver are, and unencrypt the plaintext in real time.</p>
        <p class="indent">In the real world, this problem is made more complex by</p>
        <p class="bullt">• Kerckhoffs’ principle, which states <em>the transform itself must not be a secret</em>. Rather <em>only the key used to select which table among the possible tables should be kept secret</em>.</p>
        <p class="bullb">• At least some plaintext and ciphertext can sometimes be recovered from an ongoing encrypted data transmission for various reasons—perhaps a mistake, or perhaps the point of the encryption is to verify the text, rather than keeping the text from being read.</p>
        <p class="indent">Given these restrictions, there are several key points to consider:</p>
        <p class="bullt">• The difficulty of computing the key from the plaintext, ciphertext, and cryptographic function (transform) must be very high.</p>
        <p class="bull"><a id="page_258"></a>• The randomness of the output of the cryptographic function must be very high, to reduce the possibility of brute-force attacks—just trying every possible key in the space—being successful.</p>
        <p class="bullb">• The key space must be large, again to prevent brute-force attacks from being successful.</p>
        <p class="indent">The quality of a cryptographic function is determined by the ability of the function to produce as close to a random output from virtually any input in a way so an attacker is prevented from discovering which key is being used, even though they have both the plaintext and the ciphertext. Cryptographic functions, then, normally use some form of one of the most difficult problems to calculate. One in particular that is often used is computing the factors of very large prime numbers.</p>
        <div class="sidebar1">
        <p class="title1"><strong>Security and Obscurity</strong></p>
        <p class="noindent"><strong>No security through obscurity.</strong> If you get close enough to a security engineer for long enough, or involved in any sort of debate over proper security, you will likely hear these words somewhere along the way. A more formal name for this phrase is Kerckhoffs’ principle, which states: The security of the information carried in an encrypted block or stream should rely on the secrecy of the private key, not the secrecy of the algorithm.</p>
        <p class="indent">There is one problem with this phrase, however: it is often used out of context. To understand the real meaning of the phrase, you need to go back in time to the origin of encryption algorithms. In the physical lock world, revealing the plans of a lock will often reveal various passageways to bypassing or defeating the lock. This habit was carried over to early software security vendors; the reasoning is if an attacker knows how the encryption algorithm works, he will be able to find ways to defeat the encryption algorithm.</p>
        <p class="indent">But encryption algorithms are not door locks; what is an important safeguard in one realm can be a dangerous crutch in another. Hiding code developed to encrypt plaintext does not really make the code more secure; in fact, just the opposite happens. Instead of improving security, obscuring encryption code and processes simply prevents experts in the field from finding flaws and possible ways to defeat the code before these are exposed in real deployments. Ultimately, security by obscurity is dangerous in this particular context.</p>
        <p class="indent"><a id="page_259"></a>So this is a good principle, but it can be misapplied. For instance, if a network operator attempts to hide internal network architecture, addressing, or even blocking external hosts from reaching internal ones, at least some security experts will counter with “this is simply security by obscurity; you should not do that.” Taken in this sense, however, <em>encrypting data is also security by obscurity</em>. Hiding information and hiding information about your infrastructure are both essentially hiding information, and hiding information is essentially a form of obscurity.</p>
        <p class="indent">How can you tell when you should apply “no security by obscurity,” and when you should not? Perhaps the best rule of thumb is this: hiding processes, algorithms, and implementations is not a useful addition to security in the cyber world. Hiding information, however, often is. It can be hard to apply this rule of thumb in many situations, but it should be a good start in thinking through the issues and making the right decision in each particular case.</p>
        </div>
        <p class="indent">What happens if you are using a 128-bit block, and you have 56 bits of data to transport? The most natural thing to do in this situation would be to pad the plaintext with some number; most likely all 0s or all 1s. The quality of the output is dependent, to some degree, on the sparseness of the input; the fewer the range of numbers used as an input, the more predictable the output of the cryptographic function will be. In this case, it is important to use padding that is <em>as close to random as possible;</em> there is an entire field of study around how to pad blocks of plaintext to “help” the cryptographic function produce ciphertext that is as close to random as possible.</p>
        <div class="heading">
        <h5 class="h5" id="ch10level1"><em><strong>Multiple Rounds of Encryption</strong></em></h5>
        <p class="noindent">It is possible to process the same information through a cryptographic function multiple times. For instance, if you have a 128-bit block and a 128-bit key, you can</p>
        </div>
        <p class="bullt">• Take the plaintext and, using the key, calculate a ciphertext; call this <em>ct1</em>.</p>
        <p class="bull">• Take <em>ct1</em> and, using the key, calculate a second-round ciphertext; call this <em>ct2</em>.</p>
        <p class="bullb">• Take <em>ct2</em> and, using the key, calculate a third-round ciphertext; call this <em>ct3.</em></p>
        <p class="indent">The actual transmitted ciphertext would be the final <em>ct3</em>. What does this process accomplish? Remember the quality of the encryption process is related to the randomness of the output against the input. Each round will, in many situations, increase the randomness just a bit more. There is a point of diminishing returns in <a id="page_260"></a>this process; normally after the third round, the data is not going to become “any more random,” and hence more rounds are essentially just wasting processing power and time for very little gain.</p>
        <div class="heading">
        <h5 class="h5" id="ch10level2"><em><strong>Public versus Private Key Cryptography</strong></em></h5>
        <p class="noindent">There is a class of cryptographic functions that can transform the plaintext into ciphertext, and back, using two different keys. This capability is useful when you want to be able to encrypt a block of data with one key and allow someone else to unencrypt the data using a different key. The key you keep secret is called the <em>private key</em>, and the key you give to others, or publish, is called the <em>public key</em>.</p>
        </div>
        <p class="indent">To prove you are the actual sender of a particular file, for instance, you can encrypt the file with your private key. Now anyone with your public key can unencrypt the file, which could only have been sent by you. You would not normally encrypt the entire block of data with your private key (in fact most systems using key pairs are designed so you <em>cannot</em> do this); rather a signature is created using your private key that can be verified using your public key. To ensure only the person you want to read something can, you can encrypt some data with her public key, publish it, and only the person with the correct private key can unencrypt it.</p>
        <p class="indent">Such systems are called public key cryptography (sometimes the names engineers choose are, perhaps, a little <em>too</em> obvious), or asymmetric cryptography. In public key cryptography, the public key is often “released into the wild;” it is something anyone with access to a key server or some other source can look up.</p>
        <p class="indent">The alternative to public key cryptography is symmetric key cryptography. In symmetric key cryptography, the sender and receiver share a single key that is used to both encrypt and unencrypt the data (the shared secret). Given shared secrets are (obviously) difficult to create and use, why is symmetric key cryptography ever used? There are two basic tradeoffs to consider when choosing between symmetric and public/private key cryptography:</p>
        <p class="bullt">• <strong>Processing complexity:</strong> Public key cryptography systems generally require a good deal more processing power to encrypt and unencrypt the transmitted data. Symmetric key systems are generally much easier to develop and deploy in a way that does not require large amounts of processing power and time. Because of this, public key cryptography is often used to encrypt very small amounts of data, such as a private key (see the example in the following section).</p>
        <p class="bullb">• <strong>Security:</strong> Public key cryptography generally requires a somewhat unique set of mathematical transform mechanisms. Symmetrically keyed systems tend to have a wider range of available transforms that are also more complex and hence more secure (they provide more randomness in the output and hence are harder to break).</p>
        <p class="indent"><a id="page_261"></a>There is a place for both kinds of systems, given these tradeoffs and real-world requirements.</p>
        <div class="heading">
        <h4 class="h4" id="ch10lev7"><strong>Key Exchange</strong></h4>
        <p class="noindent">Some of the earliest cryptographic systems involved wrapping paper around a cylinder of a specific size; the cylinder had to be somehow carried between the two parties to the encrypted communication without being captured by an enemy. In more recent years, pads of keys were physically carried between the two end points of an encrypted system. Some of these were arranged so a particular page would be used for a certain time period and then ripped out, securely destroyed, and replaced by a new page for the next day. Others were designed so each page in the pad would be used to encrypt one message, at which point the page would be ripped out and replaced—a one-time pad.</p>
        </div>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">The concept of a one-time pad has been carried into the modern world with authentication systems that allow the user to create a code that is used once, and then discarded, to be replaced by a new code the next time the user tries to authenticate. Any system that relies on a code that is used once is still called a one-time pad.</p>
        </div>
        <p class="indent">In the modern world, there are other ways you can exchange cryptographic material, whether it is using a shared secret key or retrieving a private key.</p>
        <p class="indent">Many times in cryptography, it is easier to explain how something works using trivial examples. In the following explanations, Fish and Jeff will be two users who are trying to exchange secure information, with Fish being the initiator and sender, and Jeff being the receiver.</p>
        <div class="heading">
        <h5 class="h5" id="ch10level3"><em><strong>Exchanging Public Keys</strong></em></h5>
        <p class="noindent">Fish would like to send a message to Jeff in a way that only Jeff can read it; to do this, she needs Jeff’s public key (remember she should not have access to Jeff’s private key). Where can she get this information? She could</p>
        </div>
        <p class="bullt">• Ask Jeff for it directly. This might seem simple to do, but it could be very difficult in real life. How, for instance, can she be certain she is actually communicating with Jeff?</p>
        <p class="bullb">• Look up Jeff’s public key in a public database of keys (a key server). Again, this seems to be straightforward, but how does she know she has found the right person, or someone has not placed a false key for Jeff on this particular server?</p>
        <p class="indent"><a id="page_262"></a>These two problems can be solved through some sort of reputation system. For instance, in the case of a public key, Jeff could ask several of his friends, who know him well, to sign his public key using their private keys. Their signature on his public key essentially says, “I know Jeff, and I know this is his public key.” Fish can examine this list of friends to determine if there are any of them she can trust. Based on this examination, Fish can determine she either trusts that this specific key is Jeff’s key, or she does not.</p>
        <p class="indent">In this situation, it is up to Fish to determine how much, and what sort of, proof she will accept. Should she, for instance, accept that the key she has is actually Jeff’s because</p>
        <p class="bullt">• She directly knows one of Jeff’s friends and trusts this third person to tell her the truth.</p>
        <p class="bull">• She knows someone who knows one of Jeff’s friends, and trusts this friend of hers to tell her the truth about Jeff’s friend, and hence trusts Jeff’s friend to tell the truth about Jeff and his key.</p>
        <p class="bullb">• She knows several people who know several of Jeff’s friends and makes a decision to trust this is Jeff’s key based on the testimony of several people.</p>
        <p class="indent">This kind of system is called a web of trust. The general idea is that trust has different levels of transitivity. The concept of transitive trust is somewhat controversial, but the idea behind a web of trust is <em>if you receive enough evidence, you can build up a trust in a person/key pairing</em>. An example of this kind of web of trust is the Pretty Good Privacy ecosystem, where people meet at conferences to cross sign one another’s keys, building up a web of transitive trust relationships that can be relied on when their communication moves into the electronic-only realm.</p>
        <p class="indent">Another option is the key server owner could somehow do an investigation of Jeff and determine if he really is who he says he is, and whether or not this is really his key. The clearest “real-world” example of this sort of solution is a <em>public notary</em>. If you sign a document in front of a notary, he checks for some form of identification (verifying who you are) and then watches you physically sign the document (verifying your key).</p>
        <p class="indent">This kind of validation is called a central source of trust (or similar—though it almost always has the word <em>centralized</em> in it) or a Public Key Infrastructure (PKI). The solution depends on Fish trusting the process and honesty of the centralized key repository.</p>
        <div class="heading">
        <h5 class="h5" id="ch10level4"><em><strong>Exchanging Private Keys</strong></em></h5>
        <p class="noindent">Given symmetric key cryptography is so much faster to process than public key cryptography, you would ideally like to encrypt any long-standing or high-volume flows using a symmetric shared secret key. But, short of somehow physically exchanging keys, how is it possible to exchange a single private key between two devices that are connected over a network? <a href="ch10.xhtml#ch10fig03">Figure 10-3</a> is used to illustrate.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/10fig03.jpg" aria-describedby="Al10fig03" alt="Figure represents the process of using public keys to either exchange or calculate a private session key." width="531" height="294"><aside class="hidden" id="Al10fig03">
        <p>A computer labeled A is at the top left with a line leading to the right, reaching a server labeled B. An arrow lies below, leading to the right and labeled 1. Encrypted nonce. An arrow below leads to the left, labeled 2. Encrypted nonce. An arrow below is bidirectional, labeled 3. Calculate private key.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch10fig03"></a><strong>Figure 10-3</strong> <em>Using Public Keys to Either Exchange or Calculate a Private Session Key</em></p>
        </div>
        <p class="indentb"><a id="page_263"></a>In <a href="ch10.xhtml#ch10fig03">Figure 10-3</a>:</p>
        <p class="indenthangingN">1. Assume A begins the process. A will encrypt a nonce, a random number used once in the process and then thrown away (a nonce is a form of a one-time pad, in effect), using B’s public key. Because the nonce has been encrypted with B’s public key, in theory only B can unencrypt the nonce, as only B should know B’s private key.</p>
        <p class="indenthangingN">2. B, on unencrypting the nonce, will now send some new nonce to A. This may include A’s original nonce, or A’s original nonce plus some other information. The point is that A must know, for certain, that the original message including A’s nonce was received by B—and not some other system acting as B. This is ensured by B including some piece of information that was encrypted using its public key, as B is the only system that could have unencrypted it.</p>
        <p class="indenthangingN">3. A and B, using the nonces and other information exchanged to this point, will calculate a private key, which is then used to encrypt/unencrypt information transferred between the two systems.</p>
        <p class="indentt">The steps outlined here are somewhat naïve; there are better, more secure systems, such as the Internet Key Exchange (IKE) protocol; see the “Further Reading” section at the end of the chapter for resources in this area.</p>
        <div class="heading">
        <h4 class="h4" id="ch10lev8"><strong>Cryptographic Hashes</strong></h4>
        <p class="noindent">Assume you wanted to send a large text file, or even an image, and allow receivers to validate it originated from you. What if the data in question is <em>very</em> large? Or what if <a id="page_264"></a>the data needs to be compressed to be transmitted effectively? There is a natural conflict between cryptographic algorithms and compression; cryptographic algorithms attempt to produce maximally random output, and compression algorithms attempt to take advantage of nonrandomness in the data to compress data into a smaller number of bits. Or perhaps you want the information to be read by anyone who would like to read it, which means not encrypting it, but you would like receivers to be able to verify you transmitted it if they would like to.</p>
        </div>
        <p class="indent">Cryptographic hashes are designed to provide a solution to resolve these problems. There is a brief explanation of hashes in <a href="ch07.xhtml#ch07">Chapter 7</a>, “<a href="ch07.xhtml#ch07">Packet Switching</a>.” You might have already noticed at least one similarity between the idea of a hash and a cryptographic algorithm. Specifically, a hash is designed to take a very large piece of data, and create a fixed length representation so there are very few collisions in the output for a wide range of inputs. This is very similar to the concept of <em>as close to random output for any input</em> required of a cryptographic algorithm. Another similarity worth mentioning is that hash and cryptographic algorithms both work better with a very sparsely populated input space.</p>
        <p class="indent">A cryptographic hash simply replaces the normal hash function with a cryptographic function. In this case, the hash can be calculated and either posted alongside the data or transmitted with the data.</p>
        <p class="indent">Cryptographic hashes can either be used with symmetric or public key systems, but they are normally used with public key systems.</p>
        <div class="heading">
        <h4 class="h4" id="ch10lev9"><strong>Obscuring User Information</strong></h4>
        <p class="noindent">Returning to the chapter introduction, another security problem space is data exhaust. In the case of individual users, data exhaust can be used to trace what users are doing while they are on the network (rather than just processes). For instance:</p>
        </div>
        <p class="bullt">• If you carry a cell phone with you at all times, it is possible to trace the movement of the Media Access Control (MAC) address as it moves between wireless connection points to trace your physical movements.</p>
        <p class="bull">• Since most data streams are not symmetrical—data passes through large packets, while acknowledgments are passed through small packets—an observer can discover when you are uploading and downloading data, and perhaps even when you are completing small transactions. Combined with the destination server, this information could reveal a good bit about your behavior as a user in a particular situation, or over time. This, and many other kinds of traffic analysis, can be performed even on encrypted traffic.</p>
        <p class="bullb">• As you move from website to website, an observer can trace how long you spend on each one, what you click on, how you reached the next site, what you <a id="page_265"></a>have searched for, what sites you keep open at any time, etc. This information can reveal a good bit about you as a person, what you are trying to accomplish, and other personal factors.</p>
        <p class="indent">Two solutions of interest in this space are covered in the following sections as examples of the sorts of solutions available: MAC address randomization and onion routing.</p>
        <div class="heading">
        <h5 class="h5" id="ch10level5"><em><strong>MAC Address Randomization</strong></em></h5>
        <p class="noindent">The Institute of Electrical and Electronic Engineers (IEEE) originally designed the MAC-48 address space, described in <a href="ch04.xhtml#ch04">Chapter 4</a>, “<a href="ch04.xhtml#ch04">Lower Layer Transports</a>,” to be assigned by manufacturers of the network interfaces. These addresses would then be used “as is” by manufacturers of networking equipment, so each piece of hardware would have a fixed, immutable hardware address. This process was designed long before cell phones were even a dream on the horizon and before privacy became an issue.</p>
        </div>
        <p class="indent">In the modern world, this means a single device can be followed regardless of where it connects to the network. Many users find this unacceptable, particularly as it is not just the provider who can track this information, but anyone who can listen in on the wireless signal, which means anyone with an antenna. One way to solve this is to allow the device to change its MAC address on a regular basis, even perhaps using a different MAC address in each packet. Since a third party listener, outside the provider network, cannot “guess” the next MAC address any device will use, it cannot track a particular device. A device that uses MAC address randomization will also use a different MAC address on each network it joins, so it will not be trackable across multiple networks.</p>
        <p class="indent">There are attacks against MAC address randomization, primarily centering around the user’s authentication to use the network. Most authentication systems rely on the MAC address, because it is programmed into the device, to identify the device, and in turn, the user. Once the MAC address is no longer an unchanging identifier, there must be some other solution. Places where MAC address randomization can be attacked are</p>
        <p class="bullt">• <strong>Timing:</strong> If a device is going to change its MAC address, it must somehow tell the other end of the wireless link about these changes, so the channel between the connected device and the base station can remain viable. There must be some agreed-on system of timing so the changing MAC address can continue communicating across the change. If an attacker can determine when this change will take place, then she can watch the right window of time and discover the new MAC address the device takes on.</p>
        <p class="bull"><a id="page_266"></a>• <strong>Sequence numbers:</strong> As with all transport systems, there must be some way to determine if all the packets have been received or dropped. An attacker can track the sequence numbers being used to track packet delivery and acknowledgment. Combined with the timing attack just noted, this can provide fairly certain identification of a specific device across MAC address changes.</p>
        <p class="bull">• <strong>Information element fingerprints:</strong> Each mobile device has a set of capabili-ties it can support, such as installed browsers, extensions, apps, and additional hardware. Because each user is unique, the set of applications he uses will also likely be fairly unique, creating a fingerprint of capabilities that will be reported through the information element in response to probes from the base station.</p>
        <p class="bullb">• <strong>Service Set Identifier (SSID) fingerprints:</strong> Each device keeps a list of networks it can currently reach and (potentially) networks it could reach at some point in the past. This list is likely to be fairly unique, and hence can act as a device identifier.</p>
        <p class="indent">While each of these items may provide some level of uniqueness at a device level, the combination of these items can come very close to identifying a specific device often enough to be practically useful in tracking any specific user connecting to a wireless network.</p>
        <p class="indent">This does not mean MAC address randomization is useless, but rather this is one step in preserving user privacy when connected to a wireless network.</p>
        <div class="heading">
        <h5 class="h5" id="ch10level6"><em><strong>Onion Routing</strong></em></h5>
        <p class="noindent">Onion routing is a mechanism used to disguise the path of, as well as encrypt, user traffic passing through a network. <a href="ch10.xhtml#ch10fig04">Figure 10-4</a> is used to illustrate.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/10fig04.jpg" aria-describedby="Al10fig04" alt="Figure represents the process of onion routing." width="710" height="422"><aside class="hidden" id="Al10fig04">
        <p>A computer labeled A is to the left with a line leading to the right, reaching a router labeled B. A dotted line 1 lies below the line leading to B. A line leads upward from B to a router labeled D with a dotted line 2 above. A line leads downward from B to a router labeled C. A line leads from C to a router labeled E. Two lines lead from D to reach routers E and G. A line labeled 3 is above the line between D and G. A line leads from E to reach a router labeled F. A line leads from F to reach a server labeled H. A line leads from G to reach a server labeled K.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch10fig04"></a><strong>Figure 10-4</strong> <em>Onion Routing</em></p>
        </div>
        <p class="indentb">In <a href="ch10.xhtml#ch10fig04">Figure 10-4</a>, host A wants to send some traffic to K securely, without any other node in the network being able to see the connection between the host and the server, and without any observer being able to see the plaintext. To accomplish this with onion routing, A does the following:</p>
        <p class="indenthangingN">1. It uses a service to find a set of nodes that can interconnect and provide a path to the server, K. Assume this set of nodes includes [B,D,G]; while the illustration shows these as routers, they are more likely software routers running on hosts, rather than dedicated network devices. Host A will first find B’s public key and use this information to build a symmetric key encrypted session with B.</p>
        <p class="indenthangingN">2. Once this session is established, A will then find D’s public key, and use this information to exchange a set of symmetric keys with D, finally building a session to D using this symmetric secret key to encrypt the secured channel. It is important to note that from D’s perspective, this session is with B, rather than A; <a id="page_267"></a>host A simply instructs B to take these actions on its behalf, rather than doing them directly. This means that D does not know A is the originator of the traffic; it only knows the traffic is sourced from B and carried across an encrypted link from there.</p>
        <p class="indenthangingN">3. Once this session is established, A will then instruct D to set up a session with G in the same way it instructed B to set up a session with D. D now knows the destination is G but does not know where the traffic will be routed by G.</p>
        <p class="indentt">Host A now has a secure path to K with the following properties:</p>
        <p class="bullt">• The traffic between each pair of nodes along the path is encrypted with a different symmetric private key. An attacker that breaks the connection between one pair of nodes along the path still cannot observe the traffic being transmitted between nodes elsewhere in the path.</p>
        <p class="bull">• The exit node, which is G, knows the destination but not the source of the traffic.</p>
        <p class="bullb">• The entrance node, which is B, knows the source of the traffic but not the destination.</p>
        <p class="indent">In this kind of network, only A knows the full path between itself and the destination. The intermediate nodes do not even know how many nodes are in the <a id="page_268"></a>path—they know about the previous and next nodes. The primary form of attack against such a system is to take over as many exit nodes as you can, so you can observe the traffic exiting from the entire network, and correlate it back into a full stream of information.</p>
        <div class="sidebar1">
        <p class="title1"><strong>Man in the Middle</strong></p>
        <p class="noindent">Any kind of security should not only examine how you can protect information, but also consider the different ways in which you can cause the protection of data to fail. Given no system is perfect, there will always be some way you can attack the system successfully. If you know the kinds of attacks that can be successfully launched against a transport security system, you can try to design the network and environment in a way that prevents these attacks from being used. Man-in-the-middle (MitM) attacks are common enough that they are worth considering in some detail. <a href="ch10.xhtml#ch10fig05">Figure 10-5</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/10fig05.jpg" aria-describedby="Al10fig05" alt="Figure represents the process of A Man-in-the-Middle Attack." width="700" height="242"><aside class="hidden" id="Al10fig05">
        <p>A computer labeled A is to the left with a line leading to the right, meeting a computer labeled B. A line leads to the right, reaching a server labeled C. An arrow below leads from A to B, labeled 1. Encrypted nonce. A line adjacent to it leads from B to C, labeled 2. Encrypted nonce. Another line falls below from B to A, labeled 4. Encrypted nonce. A line adjacent to it leads from C to B, labeled 3. Encrypted nonce. A line below is between A and B and bidirectional. It is labeled 5. Calculate private key. A line adjacent to it is between B and C and bidirectional, labeled 6. Calculate private key.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch10fig05"></a><strong>Figure 10-5</strong> <em>A Man-in-the-Middle Attack</em></p>
        </div>
        <p class="noindent"><a href="ch10.xhtml#ch10fig05">Figure 10-5</a> is similar to <a href="ch10.xhtml#ch10fig03">Figure 10-3</a> with one addition: there is a host, B, situated between the host A and the server C that would like to start an encrypted session. By some means, either spoofing C’s IP address, or modifying the Domain Name Service (DNS) records so C’s name resolves to B’s address, or perhaps even modifying the routing system so traffic that should be delivered to C is delivered to B instead, the attacker has caused B to receive traffic originating at A and destined to C. In <a href="ch10.xhtml#ch10fig05">Figure 10-5</a>:</p>
        <p class="indenthangingN">1. Host A sends a semirandom number, called a nonce, to C. This information is received by B.</p>
        <p class="indenthangingN"><a id="page_269"></a>2. Host B, which the attacker is using as the MitM, transmits this nonce on to C in a way that makes it appear the packet actually originated at A. At this point, the attacker knows the nonce encrypted by A; the attacker does not know A’s private key but does have access to anything A sends encrypted with A’s private key.</p>
        <p class="indenthangingN">3. The server, C, sends a response with an encrypted nonce, as well. B receives this and records it.</p>
        <p class="indenthangingN">4. Host B passes the nonce it received from C on to A. Host A will still believe this packet came directly from C.</p>
        <p class="indenthangingN">5. Host B calculates a private key with A as if it were C.</p>
        <p class="indenthangingN">6. Host B calculates a private key with C as if it were A.</p>
        <p class="noindent">Any traffic A sends to C will be received by B, which will</p>
        <p class="bullt">• Unencrypt the data A has transmitted using the private key calculated at step 5 in <a href="ch10.xhtml#ch10fig05">Figure 10-5</a>.</p>
        <p class="bullb">• Encrypt the data A has transmitted using the private key calculated at step 6 in <a href="ch10.xhtml#ch10fig05">Figure 10-5</a> and transmit it to C.</p>
        <p class="indent">During this process, the attacker, at B, has access to the entire flow, in plaintext, between A and C. Neither A nor C realizes they have both built an encrypted session to B, rather than to one another. These kinds of MitM attacks are very difficult to prevent and detect.</p>
        </div>
        <div class="heading">
        <h3 class="h3" id="ch10lev10">Transport Layer Security</h3>
        <p class="noindent">Transport Layer Security (TLS), also known as the <em>Secure Socket Layer</em> (SSL), is a secure transport layer protocol deployed by default in most web browsers. When users see the small green lock indicating that a website is “safe,” this means the SSL certificate is valid, and the traffic between the host (on which the browser runs) and the server (on which the web server runs) is being encrypted. TLS is a complex protocol with a lot of different options; this section will provide a rough overview of its operation. <a href="ch10.xhtml#ch10fig06">Figure 10-6</a> illustrates the components of the TLS suite.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/10fig06.jpg" aria-describedby="Al10fig06" alt="Figure represents the TLS components." width="702" height="247"><aside class="hidden" id="Al10fig06">
        <p>Three rectangular boxes to the top left are labeled handshake protocol, alert protocol, and change cipher. Two rectangular boxes to the right are labeled HTTP and SMTP. Two bidirectional arrows lead below, with special sockets mentioned below. A rectangular bar lies below, labeled TLS record protocol. A bidirectional arrow touches the bar and reaches the rectangular bar labeled TCP below.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch10fig06"></a><strong>Figure 10-6</strong> <em>TLS Components</em></p>
        </div>
        <p class="indent"><a id="page_270"></a>In <a href="ch10.xhtml#ch10fig06">Figure 10-6</a>:</p>
        <p class="bullt">• The <strong>handshake protocol</strong> is responsible for initializing sessions and setting up session parameters, including the initial private key exchange.</p>
        <p class="bull">• The <strong>alert protocol</strong> is responsible for error handling.</p>
        <p class="bull">• The <strong>change cipher specification</strong> is responsible for starting the encryption.</p>
        <p class="bullb">• The <strong>record protocol</strong> breaks data blocks presented for transport into fragments, (optionally) compresses the data, adds a Message Authentication Code (MAC), encrypts the data using the symmetrical key, adds the original information to the block, and then sends the block to the Transmission Control Protocol (TCP) for transport across the network.</p>
        <p class="indent">Applications running on top of TLS use a special port number to access the service through TLS. For instance, web services using the Hypertext Transfer Protocol (HTTP) are normally accessible over TCP port 80; TLS-encrypted HTTP is normally accessible through port 443. While the service is the same, the change in the port number allows the TCP process to direct traffic that needs to be unencrypted for the final application to read it.</p>
        <p class="indent">The MAC, which within this context will mean a Message Authentication Code, is used to ensure the sender is authenticated. While some cryptography systems assume that successfully encrypting data with a key the receiver knows proves the sender is truly who he claims to be, TLS does not. Instead, TLS includes a MAC that validates the sender separately from the keys used to encrypt messages on the wire. This helps prevent MitM attacks against TLS-encrypted data streams.</p>
        <p class="indent"><a href="ch10.xhtml#ch10fig07">Figure 10-7</a> shows the TLS startup handshake, which is managed by the handshake protocol.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/10fig07.jpg" aria-describedby="Al10fig07" alt="Figure represents the TLS Secure Session Startup Process (Handshake)." width="633" height="420"><aside class="hidden" id="Al10fig07">
        <p>Two vertical lines labeled client and server are to the left and right with a set of arrows pointing to the left and right. The arrows pointing to server are labeled 1. Client hello, 5. Client key exchange, 6. Certificate verify, 7. Change cipher specification, and 8. Finished. The arrows pointing to client are labeled 2. Server hello, 3. Certificate, 4. Server hello done, 9. Change cipher specification, and 10. Finished.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch10fig07"></a><strong>Figure 10-7</strong> <em>TLS Secure Session Startup Process (Handshake)</em></p>
        </div>
        <p class="indentb"><a id="page_271"></a>In <a href="ch10.xhtml#ch10fig07">Figure 10-7</a>:</p>
        <p class="indenthangingN">1. The client hello is sent in plaintext, and contains information about the version of TLS the client is running, 32 random octets (the nonce), a session identifier (which allows a previous session to be recovered or restored), a list of the encryption algorithms (cipher suites) the client supports, and a list of the data compression algorithms the client supports.</p>
        <p class="indenthangingN">2. The server hello is sent in plaintext, as well, and contains the same information as above, from the server’s perspective. In the server hello, the encryption algorithm field indicates the kind of encryption that will be used for this session. This is normally the “best” encryption algorithm available at both the client and the server (although it is not always the “best”).</p>
        <p class="indenthangingN">3. The server sends its public key (a certificate), along with the nonce that the client sent to the server, where the nonce is now encrypted using the server’s private key.</p>
        <p class="indenthangingN">4. The <em>server hello done</em> message indicates the client now has the information it needs to complete the session setup.</p>
        <p class="indenthangingN">5. The client generates a private key and uses the server’s public key to encrypt it. This is transmitted in the <em>client key exchange</em> message toward the server.</p>
        <p class="indenthangingN"><a id="page_272"></a>6. Once this has been transmitted, the client must sign <em>something</em> known to both the server and the client in order to verify the sender is the correct device. Usually, the signature is across all the messages in the exchange up to this point; generally, a cryptographic hash is used to generate a verification.</p>
        <p class="indenthangingN">7. The <em>change cipher specification</em> message essentially acknowledges the session is up and running.</p>
        <p class="indenthangingN">8. The <em>finished</em> message once again authenticates all the previous handshake messages to this point.</p>
        <p class="indenthangingN">9. The server then acknowledges the encryption session is set up by sending a <em>change cipher specification</em> message.</p>
        <p class="indenthangingN1">10. The server then sends a <em>finished</em> message, which authenticates the prior messages sent in the handshake in the same way as above.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">Optional steps in the TLS handshake have been left out of this explanation for clarity.</p>
        </div>
        <p class="indent">Once the session is up and running, applications can send information toward the receiving host on the correct port number. This data will be encrypted using the previously negotiated private key and then handed off to TCP for delivery.</p>
        <div class="heading">
        <h3 class="h3" id="ch10lev11">Final Thoughts on Transport Security</h3>
        <p class="noindent">This chapter has considered three specific problems in the space of transport security: validating data, protecting data from being examined, and protecting user privacy. For network engineers, understanding the theory of how transport security works and where the weak spots in a transport security system interact with the network design is often more important than understanding the intimate details of the actual security mechanisms themselves. Because of this, this chapter has focused on providing a stronger theoretical foundation in the form of “how to think about transport security,” rather than on practical implementations of trans-port security. Readers who are interested in a deeper exploration of transport security are encouraged to look at the “Further Reading” section at the end of this chapter.</p>
        </div>
        <p class="indent"><a id="page_273"></a>Overall, transport security is just one small piece of the overall security required in network engineering; <a href="ch21.xhtml#ch21">Chapter 21</a>, “<a href="ch21.xhtml#ch21">Security: A Broader Sweep</a>,” considers a broader sweep of security topics at both a network and a system level.</p>
        <div class="heading">
        <h3 class="h3" id="ch10lev12">Further Reading</h3>
        <p class="ref">Bauer, Kevin, Damon McCoy, Dirk Grunwald, Tadayoshi Kohno, and Douglas Sicker. “Low-Resource Routing Attacks Against Tor.” In <em>Proceedings of the 2007 ACM Workshop on Privacy in Electronic Society</em>, 11–20. WPES ’07. New York, NY, USA: ACM, 2007. doi:10.1145/1314333.1314336.</p>
        </div>
        <p class="ref">Brockners, Frank, Shwetha Bhandari, Sashank Dara, Carlos Pignataro, John Leddy, Stephen Youell, David Mozes, and Tal Mizrahi. “Proof of Transit.” Internet-Draft. Internet Engineering Task Force, March 2017. <a href="https://datatracker.ietf.org/doc/html/draft-brockners-proof-of-transit-03">https://datatracker.ietf.org/doc/html/draft-brockners-proof-of-transit-03</a>.</p>
        <p class="ref">Davies, Joshua. <em>Implementing SSL / TLS Using Cryptography and PKI</em>. 1st edition. Hoboken, NJ: Wiley, 2011.</p>
        <p class="ref">Ducklin, Paul. “What Your Encrypted Data Says about You.” <em>Naked Security</em>, March 18, 2016. <a href="https://nakedsecurity.sophos.com/2016/03/18/what-your-encrypted-data-says-about-you/">https://nakedsecurity.sophos.com/2016/03/18/what-your-encrypted-data-says-about-you/</a>.</p>
        <p class="ref">Ferguson, Niels, and Bruce Schneier. <em>Practical Cryptography</em>. 1st edition. New York: Wiley, 2003.</p>
        <p class="ref">Ferguson, Niels, Bruce Schneier, and Tadayoshi Kohno. <em>Cryptography Engineering: Design Principles and Practical Applications</em>. 1st edition. Indianapolis, IN: Wiley, 2010.</p>
        <p class="ref">Katz, Jonathan, and Yehuda Lindell. <em>Introduction to Modern Cryptography</em>. 2nd edition. Boca Raton, FL: Chapman and Hall/CRC, 2014.</p>
        <p class="ref">Kaufman, Charlie, Paul E. Hoffman, Yoav Nir, Pasi Eronen, and Tero Kivinen. <em>Internet Key Exchange Protocol Version 2 (IKEv2)</em>. Request for Comments 7296. RFC Editor, 2014. doi:10.17487/RFC7296.</p>
        <p class="ref">Matte, Célestin, Mathieu Cunche, Franck Rousseau, and Mathy Vanhoef. “Defeating MAC Address Randomization Through Timing Attacks.” In <em>Proceedings of the 9th ACM Conference on Security #38; Privacy in Wireless and Mobile Networks</em>, 15–20. WiSec ’16. New York, NY: ACM, 2016. doi:10.1145/2939918.2939930.</p>
        <p class="ref">Narayanan, Arvind, Joseph Bonneau, Edward Felten, Andrew Miller, and Steven Goldfeder. <em>Bitcoin and Cryptocurrency Technologies: A Comprehensive Introduction</em>. Princeton, NJ: Princeton University Press, 2016.</p>
        <p class="ref"><a id="page_274"></a>Paar, Christof, Jan Pelzl, and Bart Preneel. <em>Understanding Cryptography: A Textbook for Students and Practitioners</em>. 1st edition. Heidelberg; New York: Springer, 2010.</p>
        <p class="ref">Piper, Fred, and Sean Murphy. <em>Cryptography: A Very Short Introduction</em>. 1st edition. Oxford; New York: Oxford University Press, 2002.</p>
        <p class="ref">Rescorla, Eric, and Tim Dierks. <em>The Transport Layer Security (TLS) Protocol Version 1.2</em>. Request for Comments 5246. RFC Editor, 2008. doi:10.17487/RFC5246.</p>
        <p class="ref">Schneier, Bruce. <em>Applied Cryptography: Protocols, Algorithms and Source Code in C</em>. 1st edition. Indianapolis, IN: Wiley, 2015.</p>
        <p class="ref">Shimeall, Tim. “Traffic Analysis for Network Security: Two Approaches for Going Beyond Network Flow Data.” <em>SEI Blog</em>, September 16, 2016. <a href="https://insights.sei.cmu.edu/sei_blog/2016/09/traffic-analysis-for-network-security-two-approaches-for-going-beyond-network-flow-data.html">https://insights.sei.cmu.edu/sei_blog/2016/09/traffic-analysis-for-network-security-two-approaches-for-going-beyond-network-flow-data.html</a>.</p>
        <p class="ref">Silva, John Edward. “An Overview of Cryptographic Hash Functions and Their Uses.” SANS Institute, January 15, 2013. <a href="https://www.sans.org/reading-room/whitepapers/vpns/overview-cryptographic-hash-functions-879">https://www.sans.org/reading-room/whitepapers/vpns/overview-cryptographic-hash-functions-879</a>.</p>
        <p class="ref">Sobers, Rob. “The Definitive Guide to Cryptographic Hash Functions (Part 1).” <em>Varonis Blog</em>, August 2, 2012. <a href="https://blog.varonis.com/the-definitive-guide-to-cryptographic-hash-functions-part-1/">https://blog.varonis.com/the-definitive-guide-to-cryptographic-hash-functions-part-1/</a>.</p>
        <p class="ref">———. “The Definitive Guide to Cryptographic Hash Functions (Part II).” <em>Varonis Blog</em>, August 14, 2012. <a href="https://blog.varonis.com/the-definitive-guide-to-cryptographic-hash-functions-part-ii/">https://blog.varonis.com/the-definitive-guide-to-cryptographic-hash-functions-part-ii/</a>.</p>
        <p class="ref">Stallings, William. <em>Cryptography and Network Security: Principles and Practice</em>. 7th edition. Boston, MA: Pearson, 2016.</p>
        <p class="ref">Vanhoef, Mathy, Célestin Matte, Mathieu Cunche, Leonardo S. Cardoso, and Frank Piessens. “Why MAC Address Randomization Is Not Enough: An Analysis of Wi-Fi Network Discovery Mechanisms.” In <em>Proceedings of the 11th ACM on Asia Conference on Computer and Communications Security</em>, 413–24. ASIA CCS ’16. New York, NY: ACM, 2016. doi:10.1145/2897845.2897883.</p>
        <div class="heading">
        <h3 class="h3" id="ch10lev13">Review Questions</h3>
        <p class="indenthangingN">1. Man-in-the-middle attacks are seen as a major security weakness, but there are many situations in which a system is intentionally placed in the flow of an encrypted stream of data. The system in the middle acts as a proxy, unencrypting and reencrypting the data as it passes through the system. Find at least one <a id="page_275"></a>use case for this kind of system, and explain some of the positive and negative aspects of such a system.</p>
        </div>
        <p class="indenthangingN">2. As an example of data exhaust, research the idea of a web browser fingerprint. Describe the concept, how accurate it is, and what mitigations are available.</p>
        <p class="indenthangingN">3. A hash and a cryptographic algorithm have many similarities and some differences. Describe these similarities and differences.</p>
        <p class="indenthangingN">4. Find at least one cryptographic system that uses multiple rounds of encryption. Why was this number of rounds chosen? Does the encryption system suggest more rounds for higher security, or not?</p>
        <p class="indenthangingN">5. In recent years, the concept of a public notary has become more difficult to design and fulfill. Describe some of the challenges such a system might face and some of the ways in which these challenges might be overcome.</p>
        <p class="indenthangingN">6. Is MAC address randomization implemented differently with IPv4 and IPv6? What are the differences, and why do they exist?</p>
        <p class="indenthangingN">7. Investigate IPsec. How is it different from TLS? At what layer of the protocol stack does it encrypt, and what modes of operation are available?<a id="page_276"></a></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780134762814/files/9780134762852.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com