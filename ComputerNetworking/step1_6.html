<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch06"><a id="page_149"></a><strong>Chapter 6<br>Interlayer Discovery</strong></h2>
        <div class="sidebar">
        <p class="sb-noindent"><strong>Learning Objectives</strong></p>
        <p class="sb-noindent">After reading this chapter, you should be able to:</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the four ways in which a device can discover the mapping between identifiers used in different protocols at different layers</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand port numbers</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the basic operation of the Domain Name System (DNS)</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the basic operation of the Dynamic Host Configuration Protocol (DHCP)</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the Address Resolution Protocol (ARP)</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand Neighbor Discovery and Stateless Address Autoconfiguration</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> Understand the default gateway</p>
        </div>
        <p class="indent">In a layered and/or modularized system, there must be some way to relate <em>services</em> or <em>entities</em> in one layer to services and entities in another. <a href="ch06.xhtml#ch06fig01">Figure 6-1</a> illustrates the problem.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/06fig01.jpg" aria-describedby="Al06fig01" alt="Figure represents interlayer discovery problems." width="698" height="219"><aside class="hidden" id="Al06fig01">
        <p>A computer labeled A is on the left, with a cloud on top labeled www.service1.example. A line leads downward, labeled 2001:db8:3e8:100::1, reaching a router, B. The line leads to a router labeled C. The line continues, labeled 2001:db8:3e8:110::1. A line moves upward, labeled 2001:db7:3e8:110::10, to a computer labeled D to the right. A cloud labeled client1.example is at top. A line moves downward to a computer labeled E with address, 2001:db8:3e8:110::11.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch06fig01"></a><strong>Figure 6-1</strong> <em>Interlayer Discovery Problems</em></p>
        </div>
        <p class="indent"><a id="page_150"></a>In <a href="ch06.xhtml#ch06fig01">Figure 6-1</a>:</p>
        <p class="bullt">• How can A, D, and E discover the IP address they should be using for their interfaces?</p>
        <p class="bull">• How can D discover the Media Access Control (MAC), physical, or lower layer protocol address it should use to send packets to E?</p>
        <p class="bull">• How can client1.example, which is running on D, discover the Internet Protocol (IP) address it should use to reach <a href="http://www.service1.example?">www.service1.example?</a></p>
        <p class="bullb">• How can D and E discover what address they should send traffic to if it is not on the same wire or segment?</p>
        <p class="indent">Each of these problems represents a different part of interlayer discovery. While these problems may seem unrelated, they actually represent the same set of problems, with a narrow set of available solutions, at different layers of a network or protocol stack. This chapter will consider a range of possible solutions for these problems, including examples of each solution.</p>
        <p class="indent">This chapter will end with a section on the default gateway problem; while this is not strictly an interlayer discovery problem, it is still important to understanding how an IP network operates.</p>
        <div class="heading">
        <h3 class="h3" id="ch06lev1">Interlayer Discovery Solutions</h3>
        <p class="noindent">The main reason the interlayer discovery problem space appears to be a large set of unrelated problems, rather than a single problem, is that it is spread across many different layers; each set of layers in a network protocol stack needs to be able to discover which service or entity at “this” layer relates to which service or entity at some lower layer. Another way to describe this set of problems is the ability to map an <a id="page_151"></a>identifier at one layer to an identifier at another layer—identifier mapping. As there are at least three pairs of protocols in most widely deployed protocol stacks (and potentially, or arguably, eight), a wide variety of solutions must be deployed to solve the same set of interlayer discovery problems in different places. Two definitions will be helpful in understanding the range of solutions, and actual deployed protocols and systems in this space:</p>
        </div>
        <p class="bullt">• An <strong>identifier</strong> is a set of numbers or letters (such as a string) that uniquely identify an entity.</p>
        <p class="bullb">• A device, whether real or virtual, which appears to be a single destination from the point of view of the network will be called an <strong>entity</strong> when considering generic problems and solutions, and <strong>hosts</strong> or <strong>services</strong> when considering specific solutions.</p>
        <p class="indent">There are four different ways to solve the interlayer discovery and address assignment problems:</p>
        <p class="bullt">• Using well-known and/or manually configured identifiers</p>
        <p class="bull">• Storing the information in a <em>mapping database</em> that services can access to map between different kinds of identifiers</p>
        <p class="bull">• Advertising a mapping between two identifiers in a protocol</p>
        <p class="bullb">• Calculating one kind of identifier from another</p>
        <p class="indent">These solutions not only apply to <em>discovery</em>, but also identifier <em>assignment</em>. When a host is connected to a network, or a service is spun up, it must somehow determine how it should identify itself—for instance, what Internet Protocol version 6 (IPv6) address it should use when connecting to the local network. The solutions available for solving this problem are the <em>same four solutions</em>.</p>
        <p class="indent">These four solutions will be considered in the following sections.</p>
        <div class="heading">
        <h4 class="h4" id="ch06lev2"><strong>Well-Known and/or Manually Configured Identifiers</strong></h4>
        <p class="noindent">The solution chosen often depends on the scope of the identifiers, the sheer number of identifiers that need to be assigned, and the rate at which the identifiers change. If</p>
        </div>
        <p class="bullt">• The identifiers are widely used, especially in protocol implementations, and the network will simply not work without some agreement on the interlayer mappings, and…</p>
        <p class="bull"><a id="page_152"></a>• The number of mappings between identifiers is relatively small, and…</p>
        <p class="bullb">• The identifiers are generally stable—in particular, they are never changed in a way that requires existing, deployed implementations to be modified in order to allow the network to continue functioning, then…</p>
        <p class="noindent">The easiest solution is to manually maintain a mapping table of some kind.</p>
        <p class="indent">For instance, the Transmission Control Protocol (TCP) carries a number of higher layer transport protocols. The problem of relating individual carried protocols to port numbers is a global interlayer discovery problem: every implementation of TCP deployed in a real network must be able to agree on what services are reachable on specific port numbers for the network to “work.” The range of interlayer mappings, however, is very small, a few thousand port numbers need to be mapped to services, and fairly static (new protocols or services are not often added). This specific problem, then, is easy to solve through a manually managed mapping table.</p>
        <p class="indent">The mapping table for TCP port numbers is maintained by the Internet Assigned Numbers Authority (IANA), at the direction of the Internet Engineering Task Force (IETF); a part of this table is shown in <a href="ch06.xhtml#ch06fig02">Figure 6-2</a>.<sup><a id="ch06fn1"></a><a href="ch06.xhtml#ch06fn-1">1</a></sup></p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/06fig02.jpg" aria-describedby="Al06fig02" alt="Figure represents the IANA TCP Port Mapping Table." width="450" height="589"><aside class="hidden" id="Al06fig02">
        <p>A table has three columns labeled Service Name, Port Number, and Transport Protocol. Different services are mentioned with their port numbers and transport protocols in the rows below.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch06fig02"></a><strong>Figure 6-2</strong> <em>IANA TCP Port Mapping Table</em></p>
        </div>
        <p class="indent">In <a href="ch06.xhtml#ch06fig02">Figure 6-2</a>, the <em>echo</em> service is assigned port 7; this service is used to provide the <em>ping</em> functionality described at the end of <a href="ch05.xhtml#ch05">Chapter 5</a>, “<a href="ch05.xhtml#ch05">Higher Layer Data Transports</a>.”</p>
        <div class="heading">
        <h4 class="h4" id="ch06lev3"><strong>Mapping Database and Protocol</strong></h4>
        <p class="noindent">If the number of entries in the table becomes large enough, the number of people involved in maintaining the table becomes large enough, or the information is dynamic enough that it needs to be learned at the time the mapping is required, rather than when a piece of software is deployed, it makes sense to build and distribute a database dynamically. Such a system should include protocols to synchronize database partitions to present a consistent view to external queries, and protocols hosts and services can use to query the database with one identifier to discover the matching identifier from a different layer of the network.</p>
        </div>
        <p class="indent">Dynamic mapping databases may accept input through manual configuration or automated processes (such as a discovery process that gathers information about the state of the network and stores the resulting information in the dynamic database). They may also either be distributed, which means copies or portions of the database <a id="page_153"></a>are stored on a number of different hosts or servers, or centralized, which means the database is stored on a small number of hosts or servers.</p>
        <p class="indent">The Domain Name System (DNS) is described as an example of an identity mapping service based on a dynamic, distributed database. The Dynamic Host Configuration Protocol (DHCP) is described as an example of a similar system used primarily for the assignment of addresses.</p>
        <div class="heading">
        <h4 class="h4" id="ch06lev4"><strong>Advertising Identifier Mappings in a Protocol</strong></h4>
        <p class="noindent">If the scope of the mapping problem can be contained, but the number of identity pairs is large, or can change rapidly, then creating a single protocol that allows entities to request mapping information from a device directly can be an optimal solution. For instance, in <a href="ch06.xhtml#ch06fig01">Figure 6-1</a>, D could ask E directly what its local MAC (or physical) address is.</p>
        </div>
        <p class="indent"><a id="page_154"></a>The Internet Protocol version 4 (IPv4) Address Resolution Protocol (ARP) is a good example of this kind of solution, as is the IPv6 Neighbor Discovery (ND) protocol. These examples are considered in more detail in later sections.</p>
        <div class="heading">
        <h4 class="h4" id="ch06lev5"><strong>Calculating One Identifier from the Other</strong></h4>
        <p class="noindent">In some cases, it is possible to calculate an address or identifier at one layer from the address or identifier in another layer. Few systems use this technique for mapping addresses; most systems that use this technique do so in order to <em>assign</em> an address. One example of this type of system is Stateless Address Autoconfiguration (SLAAC), an IPv6 protocol hosts can use to determine what IPv6 address should be assigned to an interface, which is considered in more detail as part of the IPv6 ND discussion later in the chapter.</p>
        </div>
        <p class="indent">Another example of using a lower layer address to calculate an upper layer address is in the formation of end-system addresses in the International Organization for Standardization (ISO) suite of protocols, such as Intermediate System to Intermediate System (IS-IS). This example is considered in more detail in <a href="ch16.xhtml#ch16">Chapter 16</a>, “<a href="ch16.xhtml#ch16">Link State and Path Vector Control Planes</a>.”</p>
        <div class="heading">
        <h3 class="h3" id="ch06lev6">Interlayer Discovery Examples</h3>
        <p class="noindent">Four examples of protocols providing interlayer discovery and address assignment are considered in the following sections.</p>
        </div>
        <div class="heading">
        <h4 class="h4" id="ch06lev7"><strong>The Domain Name System</strong></h4>
        <p class="noindent">DNS maps between human-readable character strings, such as the name service1. example used in <a href="ch06.xhtml#ch06fig01">Figure 6-1</a>, to IP addresses. <a href="ch06.xhtml#ch06fig03">Figure 6-3</a> illustrates the basic operation of the DNS system.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/06fig03.jpg" aria-describedby="Al06fig03" alt="Figure represents an overview of the operation of the DNS system." width="694" height="405"><aside class="hidden" id="Al06fig03">
        <p>A computer labeled A is at the bottom left with lines labeled 1 and 8 leading to the left, reaching recursive server. Two lines labeled 2 and 3 lead upward to reach root server. Two lines labeled 4 and 5 lead upward to reach TLD server. Two lines labeled 6 and 7 lead upward to reach authoritative server. A line labeled 9 leads to the top, reaching a server, B. It is labeled www.service1.example 2001:db8:3e8:100::1.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch06fig03"></a><strong>Figure 6-3</strong> <em>An Overview of the Operation of the DNS System</em></p>
        </div>
        <p class="indentb">In <a href="ch06.xhtml#ch06fig03">Figure 6-3</a>, assuming there are no caches of any kind (so the entire process is illustrated):</p>
        <p class="indenthangingN">1. A host, A, attempts to connect to <a href="http://www.service1.example">www.service1.example</a>. The host’s operating system examines its local configuration for the address of the DNS server it should query to discover where this service is located, and finds the address of the recursive server. The host operating system’s DNS application sends a DNS query to this address.</p>
        <p class="indenthangingN"><a id="page_155"></a>2. The recursive server receives this query and—given there are no caches—examines the domain name for which an address is being requested. The recursive server notes the right-hand portion of the domain name is <em>example</em>, so it asks a root server where to find information on the <em>example</em> domain.</p>
        <p class="indenthangingN">3. The root server returns the address of the server containing information about the top-level domain (TLD) <em>example</em>.</p>
        <p class="indenthangingN">4. The recursive server now requests information about which server to contact about <em>service1.example</em>. The recursive server proceeds through the domain name one section at a time, using information discovered about the section of the name to the right to discover which server to ask about the information to the left. This process is called <em>recursing</em> through the domain name; hence the server is called a recursive server.</p>
        <p class="indenthangingN">5. The TLD server returns the address of the <em>authoritative server</em> for service1. example. If information about the location of a service has been cached from a prior request, it is returned as a nonauthoritative answer; if the actual server configured to hold the information about a domain replies, its answer is <em>authoritative</em>.</p>
        <p class="indenthangingN"><a id="page_156"></a>6. The recursive server requests information about <a href="http://www.service1.example">www.service1.example</a> from the authoritative server.</p>
        <p class="indenthangingN">7. The authoritative server responds with the IP address of server B.</p>
        <p class="indenthangingN">8. The recursive server now responds to the host, A, with the correct information to reach the requested service.</p>
        <p class="indenthangingN">9. The host, A, contacts the server on which <a href="http://www.service1.example">www.service1.example</a> is running on the IP address 2001:db8:3e8:100::1.</p>
        <p class="indentt">This process may appear to be very drawn out; for instance, why not just keep all the information on the root server to save a lot of steps? This would violate the basic idea of DNS, however, which is to keep information about each domain in the control of the domain owner as much as possible. Further, this would make the building and maintenance of the root servers very expensive, as they would need to be capable of holding millions of records and answer hundreds of millions of queries for DNS information each day. The separation of information allows each owner to control his data and enables the DNS system to scale.</p>
        <p class="indent">Normally, the information returned through a DNS query process is cached by each server along the way, so the mapping does not need to be requested each time the host needs to reach a new server.</p>
        <p class="indent">How are these DNS tables maintained? Usually through the manual work of domain- and top-level domain owners, as well as edge providers all across the world. DNS does not automatically discover the name of each entity attached to the network and what each one’s address is.</p>
        <p class="indent">DNS pairs a manually maintained database, with the work spread out among many different pairs of hands, with a protocol used to query the database; hence DNS falls into the <em>mapping database with a protocol</em> class of solutions. How does a host know what DNS server to query? This information is either manually configured or learned through a discovery protocol such as IPv6 ND or DHCP.</p>
        <div class="heading">
        <h4 class="h4" id="ch06lev8"><strong>DHCP</strong></h4>
        <p class="noindent">When a host (or some other device) first connects to a network, how does it know which IPv6 address (or set of IPv6 addresses) to assign to the local interface? One solution to this problem is for the host to send a query to some database to discover what addresses it should use, such as DHCPv6. To understand DHCPv6, it is important to begin with the concept of a link local address in IPv6. In the discussion on the size of the IPv6 address space in <a href="ch05.xhtml#ch05">Chapter 5</a>, “<a href="ch05.xhtml#ch05">Higher Layer Data Transports</a>,” fe80::/10 was called out as being reserved for link local addressing. To form a link <a id="page_157"></a>local address, a device running IPv6 combines the fe80:: prefix with the MAC (or physical) address, which is often formatted as an EUI-48 address, and sometimes as an EUI-64 address (see <a href="ch04.xhtml#ch04">Chapter 4</a>, “<a href="ch04.xhtml#ch04">Lower Layer Transports</a>,” for information on EUI addresses). For instance:</p>
        </div>
        <p class="bullt">• A device has an interface with the EUI-48 address 01-23-45-67-89-ab.</p>
        <p class="bull">• This interface is connected to an IPv6 network.</p>
        <p class="bullb">• The device can assign fe80::123:4567:89ab as a link local address and use this address to communicate to other devices on this segment only.</p>
        <p class="indent">This is an example of <em>calculating one identifier from another</em>. Once the link local address has been formed, DHCP6 is one method that can be used to obtain a unique address within the network (or globally, depending on the configuration of the network). DHCPv6 uses the User Datagram Protocol (UDP) for its lower layer transport. <a href="ch06.xhtml#ch06fig04">Figure 6-4</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/06fig04.jpg" aria-describedby="Al06fig04" alt="Figure represents a DHCPv6 Operation." width="428" height="381"><aside class="hidden" id="Al06fig04">
        <p>A computer labeled A has a straight dotted line labeled 1 leading upward to reach routers, B and C. A curved dotted line labeled 2 leads from A to reach router C to the right. Three curved dotted lines labeled 2, 3, and 4 lead to the left, reaching the router B. A cloud is above B with the other end touching a server labeled D.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch06fig04"></a><strong>Figure 6-4</strong> <em>DHCPv6 Operation</em></p>
        </div>
        <p class="indentb">In <a href="ch06.xhtml#ch06fig04">Figure 6-4</a>:</p>
        <p class="indenthangingN">1. The host that has just connected to the network, A, sends a <em>solicit</em> message. This message is sourced from the link local address and sent to the multicast address ff02::1:2, UDP ports 547 (for the server) and 546 (for the client), so every device connected to the same physical wire will receive the message. This message will <a id="page_158"></a>include a DHCP Unique Identifier (DUID), which the client forms,<sup><a id="ch06fn2"></a><a href="ch06.xhtml#ch06fn-2">2</a></sup> and the server uses to ensure it is consistently communicating with the same device.</p>
        <p class="indenthangingN">2. B and C, both of which are configured to act as DHCPv6 servers, respond with an <em>advertise</em> message. This message is a unicast packet directed at A itself, using the link local address from which A sources the solicit message.</p>
        <p class="indenthangingN">3. Host A chooses one of the two servers from which to request an address. The host sends a <em>request</em> to the multicast address ff02::1:2, asking B to provide it with an address (or a pool of addresses), information on which DNS server to use, etc.</p>
        <p class="indenthangingN">4. The server, running on B, then responds with a <em>reply</em> to the link local address A initially formed; this verifies B has allocated the resources from its local pool and allows A to start using them.</p>
        <p class="indentt">What happens if no device on the segment is configured as a DHCPv6 server? For instance, in <a href="ch06.xhtml#ch06fig04">Figure 6-4</a>, what if D is the only available DHCPv6 server because DHCPv6 is not running on B or C? In this case, a router (or even some other host or device) can act as a <em>DHCPv6 relay</em>. The DHCPv6 packets that A transmits will be received by the relay, encapsulated, and transmitted to the DHCPv6 server for processing.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">The process described here is called stateful DHCP and is normally triggered when the <em>Managed</em> bit is set in the <em>router advertisement</em>. DHCPv6 can also work with SLAAC, described later in the “IPv6 Neighbor Discovery” section, to provide information SLAAC does not provide in the stateless DHCPv6 mode. This mode is normally used when the <em>Other</em> bit is set in the router advertisement. The IETF draft <em>DHCPv6/SLAAC Interaction Problems on Address and DNS Configuration</em> describes this interaction and problems in the interaction between these two mechanisms.<sup><a id="ch06fn3"></a><a href="ch06.xhtml#ch06fn-3">3</a></sup></p>
        </div>
        <p class="indent">In cases where the network administrator knows all IPv6 addresses will be configured through DHCPv6, and only one DHCPv6 server will be available on each <a id="page_159"></a>segment, the advertise and request messages can be skipped by enabling DHCPv6 <em>rapid commit</em>.</p>
        <div class="heading">
        <h4 class="h4" id="ch06lev9"><strong>IPv4 Address Resolution Protocol</strong></h4>
        <p class="noindent">Although IPv6 is the focus of this book, there are some instances where IPv4 provides a useful example of a solution; the IPv4 Address Resolution Protocol (ARP) is one such case. ARP is a very simple protocol used to solve interlayer discovery without relying on a server of any type. <a href="ch06.xhtml#ch06fig05">Figure 6-5</a> will be used to explain the operation of ARP.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/06fig05.jpg" aria-describedby="Al06fig05" alt="Figure represents an example of address resolution protocol." width="614" height="410"><aside class="hidden" id="Al06fig05">
        <p>A computer A is at the bottom left with address, 203.0.113.10. A computer, C is at the bottom right with address, 203.0.113.12. A line leads from both ends, reaching a computer, B to the left with address, 203.0.113.24 and a router D to the right. A line leads upward from D to reach a computer, E with address, 198.51.100.101.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch06fig05"></a><strong>Figure 6-5</strong> <em>Address Resolution Protocol Example</em></p>
        </div>
        <p class="indent">Assume A would like to send a packet to C. Knowing C’s IPv4 address, 203.0.113.12, is not enough for A to properly form a packet to place on the wire toward C. To properly build a packet, A must also know</p>
        <p class="bullt">• Whether or not C is on the same wire as A</p>
        <p class="bullb">• The MAC, or physical, address of C</p>
        <p class="indent">Without two pieces of information, A does not know how to encapsulate the packet on the wire, so C will actually receive the packet, and B will ignore it. How can A discover this information? The first question, whether or not C is on the same <a id="page_160"></a>wire as A, can be answered by considering the local interface IP address, the destination IP address, and the subnet mask. This is considered in more detail later in this chapter.</p>
        <p class="indentb">ARP solves the second problem, matching the destination IP address to the destination MAC address, with the following process:</p>
        <p class="indenthangingN">1. Host A sends a broadcast packet to every device on the wire containing the IPv4 address, but not the MAC address. This is an <em>ARP request;</em> it is A’s request for the MAC address corresponding to 203.0.113.12.</p>
        <p class="indenthangingN">2. B and D receive this packet, but do not respond, because none of their local interfaces have the address 203.0.113.12.</p>
        <p class="indenthangingN">3. Host C receives this packet and responds, again using a unicast packet, to the request. This <em>ARP reply</em> contains both the IPv4 address and the matching MAC address, giving A the information needed to build packets toward C.</p>
        <p class="indentt">When A receives this reply, it will insert the mapping between 203.0.113.12 and the MAC address contained in the reply in a local ARP cache. This information will be stored until it times out; the rules for timing out an ARP cache entry vary between implementations and can often be manually configured. How long to cache an ARP entry is a balance between not repeating the same information too often on the network, in the case where the IPv4-to-MAC address mapping does not change very often, and keeping up with any changes in the location of a device, in the case where a particular IPv4 address may move between hosts.</p>
        <p class="indent">Any device receiving an ARP reply can accept the packet and cache the information it contains. For instance, B, on receiving the ARP reply from C, can insert the mapping between 203.0.113.12 and C’s MAC address into its ARP cache. In fact, this property of ARP is often used to speed up the discovery of devices when they are attached to a network. There is nothing in the ARP specification that requires a host to wait for an ARP request to send an ARP reply. When a device connects to a network, it can simply send an ARP reply with the correct mapping information to make the initial connection process to other hosts on the same wire faster; this is called a <em>gratuitous ARP</em>.</p>
        <p class="indent">Gratuitous ARPs are also useful for <em>Duplicate Address Detection (DAD);</em> if a host receives an ARP reply with an IPv4 address it is using, it will report a duplicate IPv4 address. Some implementations will also send out a series of gratuitous ARPs in this case, in order to prevent the address from being used, or force the other host to also report the duplicate address.</p>
        <p class="indent"><a id="page_161"></a>What happens if Host A requests an address using ARP that is not on the same segment, such as 198.51.100.101 in <a href="ch06.xhtml#ch06fig05">Figure 6-5</a>? There are two different possibilities to this situation:</p>
        <p class="bullt">• If D is configured to answer as a proxy ARP, it can respond to the ARP request with the MAC address connected to the segment. A will then cache this response, sending any traffic destined to E to the MAC address of D, which can then forward this traffic on to E. Most widely deployed implementations do not enable proxy ARP by default.</p>
        <p class="bullb">• A could send the traffic to its default gateway, which is a locally connected router that should know the path to any destination on the network.</p>
        <p class="indent">IPv4 ARP is an example of a protocol that maps interlayer identifiers by including both identifiers in a single protocol.</p>
        <div class="heading">
        <h4 class="h4" id="ch06lev10"><strong>IPv6 Neighbor Discovery</strong></h4>
        <p class="noindent">IPv6 replaces the simpler ARP protocol with a series of Internet Control Message Protocol (ICMP) v6 messages. Five kinds of ICMPv6 messages are defined:</p>
        </div>
        <p class="bullt">• Type 133, Router Solicitation</p>
        <p class="bull">• Type 134, Router Advertisement</p>
        <p class="bull">• Type 135, Neighbor Solicitation</p>
        <p class="bull">• Type 136, Neighbor Advertisement</p>
        <p class="bullb">• Type 137, Redirect</p>
        <p class="indent"><a href="ch06.xhtml#ch06fig06">Figure 6-6</a> is used to explain the operation of IPv6 ND.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/06fig06.jpg" aria-describedby="Al06fig06" alt="Figure represents IPv6 Neighbor and Router discovery." width="688" height="297"><aside class="hidden" id="Al06fig06">
        <p>A computer labeled A with address 2001:db8:3e8:110::3 is at the bottom left. A computer labeled C is to the right with address, 2001:db8:3e8:110::12. A computer labeled E is adjacent to it with address, 2001:db8:3e8:110::120. Lines lead upward from all computers to a stub with address, 2001:db8:3e8:110::/64. Two routers, B and D are connected with lines leading to the stub.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch06fig06"></a><strong>Figure 6-6</strong> <em>IPv6 Neighbor and Router Discovery</em></p>
        </div>
        <p class="indent">To understand the operation of IPv6 ND, it is best to follow a single host as it is connected to a new network. Host A in <a href="ch06.xhtml#ch06fig06">Figure 6-6</a> is used as an example.</p>
        <p class="bullt">• A will begin by forming a link local address, as described previously; assume A chooses fe80::AAAA as its link local address.</p>
        <p class="bull">• A now uses this link local address as a source address and sends a router solicitation to a link local multicast address (the all nodes multicast address); this is an ICMPv6 message type 133.</p>
        <p class="bull"><a id="page_162"></a>• B and D receive this router solicitation and respond with a router advertisement, which is an ICMPv6 message type 134. This unicast packet is transmitted to the link local address A used as the source address, fe80::AAAA.</p>
        <p class="bull1"><span class="pd_ash">•</span> The router advertisement contains information on how the newly connected host should determine its local configuration information in the form of several flags.</p>
        <p class="bull1"><span class="pd_ash">•</span> The <em>M</em> flag indicates the host should request an address through DHCPv6, because this is a <em>managed</em> link.</p>
        <p class="bull1"><span class="pd_ash">•</span> The <em>O</em> flag indicates the host can retrieve information <em>other</em> than the address it should use via DHCPv6. For instance, the DNS server the host should use to resolve DNS names should be retrieved using DHCPv6.</p>
        <p class="bull">• If the <em>O</em> flag is set, and not the <em>M</em> flag, A must determine its own interface IPv6 address. To do this, it determines the set of IPv6 prefixes in use on this segment by examining the <em>prefix information</em> field in the router advertisement. It chooses one of these prefixes and forms an IPv6 address using the same process it used to form a link local address: it adds a local MAC (EUI-48 or EUI-64) address to the indicated prefix. This process is called SLAAC.</p>
        <p class="bull">• The host must now make certain it has not chosen an address some other host on the same network is using; it must perform DAD. To perform a duplicate address detection:</p>
        <p class="bull1"><span class="pd_ash">•</span> The host sends a series of neighbor solicitation messages using the just-formed IPv6 address and asking for the corresponding MAC (physical) address. These are ICMPv6 type 135 messages transmitted from the link local address already assigned to the interface.</p>
        <p class="bull1"><a id="page_163"></a><span class="pd_ash">•</span> If the host receives a neighbor advertisement or neighbor solicitation using the same IPv6 address, it assumes the locally formed address is a duplicate; in this case, it will form a new address using a different local MAC address and try again.</p>
        <p class="bull1"><span class="pd_ash">•</span> If the host does not receive a response, nor another host’s neighbor solicitation using the same address, it assumes the address is unique and assigns the newly formed address to the interface.</p>
        <div class="sidebar1">
        <p class="title1"><strong>Resolving False Positives in Duplicate Address Detection</strong></p>
        <p class="noindent">The DAD process, as described here, can result in false positives. Specifically, if some other device on the wire loops the original neighbor solicitation packets back to A, it will believe these are from another host claiming the same address, and hence will declare a duplicate and try to form a new address. If the device constantly loops back any neighbor solicitation A sends, A will never be able to form an address using SLAAC.</p>
        <p class="indent">To solve this, RFC7527 outlines an enhanced DAD process. In this process, A would calculate a nonce, or rather a randomly selected series of numbers, and include it in the neighbor solicitation used to check for a duplicate address. This nonce is included through the Secure Neighbor Discovery (SEND) extensions to IPv6 outlined in RFC3971.</p>
        <p class="indent">If A receives a neighbor solicitation with the same nonce it used to send neighbor solicitations during DAD, it will form a new nonce and try again. If it occurs a second time, the host will assume the packets are being looped and ignore any further neighbor solicitations with its own nonce in them. If the received neighbor solicitations have a different nonce than the one the local host has chosen, the host will assume there is, in fact, another host that has chosen the same IPv6 address and will then form a new IPv6 address.</p>
        </div>
        <p class="indent">Once it has an address to transmit data from, A now needs one more piece of information before sending information to another host on the same segment—the MAC address of the receiving host. If A, for instance, wants to send a packet to C, it will begin by sending a multicast neighbor solicitation message to C asking for its MAC address; this is an ICMPv6 message type 135. When C receives this message, it will respond with the correct MAC address to send traffic for the requested IPv6 address; this is an ICMPv6 message type 136.</p>
        <p class="indent"><a id="page_164"></a>While the preceding process describes router advertisements being sent in response to a router solicitation, each router will send periodic router advertisements on each attached interface. The router advertisement contains a <em>lifetime</em> field, indicating how long the router advertisement is valid.</p>
        <div class="heading">
        <h3 class="h3" id="ch06lev11">The Default Gateway Problem</h3>
        <p class="noindent">How can a host know whether to try to send a packet to a host over the segment it is connected to, or to send the packet to a router for further processing? If a host should send packets to a router for further processing, how can it know which router (if there is more than one) to send the traffic to? These two problems, together, make up the default gateway problem.</p>
        </div>
        <p class="indent">For IPv4, the problem is fairly easy to solve using the prefix and prefix length. <a href="ch06.xhtml#ch06fig07">Figure 6-7</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/06fig07.jpg" aria-describedby="Al06fig07" alt="Figure represents IPv4 default gateway usage." width="700" height="485"><aside class="hidden" id="Al06fig07">
        <p>A computer labeled A with address, 198.51.100.3 is at the bottom left. A computer labeled C is at the center with address, 198.51.100.12. A computer labeled D is to the right with address, 192.0.2.120. Three lines lead upward to meet a line at top with address, 198.51.100/24. A line leads upward with address, 203.0.100.1 to meet a router, B. A line leads upward with address, 203.0.113.1 to a computer labeled E with address, 203.0.113.3.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch06fig07"></a><strong>Figure 6-7</strong> <em>IPv4 Default Gateway Usage</em></p>
        </div>
        <p class="indent">IPv4 implementations assume <em>any host within the same IPv4 subnet must be physically connected to the same wire</em>. How can the implementation tell the difference? The subnet mask is another form of the prefix length, which indicates where <a id="page_165"></a>the network address ends and the host address begins. In this case, assume the prefix length is 24 bits, or the network address is a /24. The <em>24</em> tells you how many bits are set in the subnet mask:</p>
        <p class="codelink"><a href="ch06_images.xhtml#p06pro01a" id="p06pro01">Click here to view code image</a></p>
        <p class="pre">24 bits = 11111111.11111111.11111111.0000000</p>
        <p class="indentb">Since IPv4 uses a “dotted decimal” notation, this can also be written as 255.255.255.0. To discover whether or not C is on the same wire as A, A will</p>
        <p class="indenthangingN">1. Logically AND the subnet mask with the local interface address</p>
        <p class="indenthangingN">2. Logically AND the subnet mask with the destination address</p>
        <p class="indenthangingN">3. Compare the two results; if they match, the destination host is on the same wire as the local interface</p>
        <p class="indentt"><a href="ch06.xhtml#ch06fig08">Figure 6-8</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/06fig08.jpg" aria-describedby="Al06fig08" alt="Snippet shows the process of using prefix length to determine what is on and off segment." width="246" height="318"><aside class="hidden" id="Al06fig08">
        <p>A set of IP addresses, 198.051.100.003, 198.051.100.012, 192.000.002.120, 203.000.113.003, and 255.255.255.000 are listed one below the other. A vertical dashed line passes through, cutting the last three digits from the rest. An arrow at the top points to its left, labeled within the 24 bit prefix.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch06fig08"></a><strong>Figure 6-8</strong> <em>Using the Prefix Length to Determine What Is On and Off Segment</em></p>
        </div>
        <p class="indentt">There are four IPv4 addresses in <a href="ch06.xhtml#ch06fig08">Figure 6-8</a>; assume A needs to send packets to C, D, and E. If A knows the prefix length of the local segment is 24 bits either through manual configuration or through DHCPv4, then it can simply look at the 24 most significant bits of each address, compare it to the 24 most significant bits of its own address, and determine whether the destination is on segment or not. Twenty-four bits of an IPv4 address produces a nice break between the third and fourth section of the address (each section of an IPv4 address represents 8 bits of address space, for a total of 32 bits of address space).</p>
        <p class="indent"><a id="page_166"></a>Any two addresses with the same left three sections as A has, called the network address, are on the same segment; any address that does not is not on segment. In this case, the network address for A and C match, so A will believe C is on the same segment, and hence will send packets to C directly, rather than sending them to a router. For any destination A believes is off segment, it will send packets to the final destination’s IPv4 address, but to the default gateway’s MAC address. This means the router acting as the default gateway will accept the packet and switch it based on the destination IPv4 address (packet switching is considered more fully in <a href="ch07.xhtml#ch07">Chapter 7</a>, “<a href="ch07.xhtml#ch07">Packet Switching</a>”). How is the default gateway chosen? It is either manually configured or included in a DHCPv4 option.</p>
        <p class="indent">What about D? Because the network portions of the addresses don’t match, A will believe D is off segment. In this case, A will send any traffic for D to its default gateway, which is B. When B receives these packets, it will realize A and D are reachable through the same interface (based on its routing table—building routing tables is considered in <a href="part2.xhtml#part2">Part II</a>, “<a href="part2.xhtml#part2">The Control Plane</a>”), so it will send an ICMP redirect to A telling it to send traffic toward D directly, rather than through B.</p>
        <p class="indent">IPv6 presents a more complex set of problems to solve when considering which default gateway to use, because IPv6 assumes a single device may have many IPv6 addresses assigned to a particular interface. <a href="ch06.xhtml#ch06fig09">Figure 6-9</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/06fig09.jpg" aria-describedby="Al06fig09" alt="Figure represents IPv6 and On link/Off link determination." width="692" height="448"><aside class="hidden" id="Al06fig09">
        <p>A computer labeled A is at the top with address, 2001:db8:3e8:113::10. A computer labeled D is to the right with address, 2001:db8:3e8:114::10. Two lines lead downward, reaching routers, B and E respectively. Two lines move downward to reach a line at the bottom. A set of addresses, 2001:db8:3e8:110::/64, 2001:db8:3e8:111::/64, and 2001:db8:3e8:112::/64 are to the left. A computer, C is at the bottom left with addresses, 2001:db8:3e8:110::3 and 2001:db8:3e8:112::12. A computer, F is at the bottom right with address, 2001:db8:3e8:111::120.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch06fig09"></a><strong>Figure 6-9</strong> <em>IPv6 and On Link/Off Link Determination</em></p>
        </div>
        <p class="indent"><a id="page_167"></a>In <a href="ch06.xhtml#ch06fig09">Figure 6-9</a>, assume the network administrator has configured the following policies:</p>
        <p class="bullt">• No host may connect to A unless it has an address in the 2001:db8:3e8:110::/64 range of addresses.</p>
        <p class="bullb">• No host may connect to D unless it has an address in the 2001:db8:3e8:112::/64 range of addresses.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">You would never build policies like this in the real world; this is a contrived situation to illustrate a problem set in a minimally sized network. A much more real problem of this same type would involve unicast Reverse Path Forwarding (uRPF).</p>
        </div>
        <p class="indent">To make these policies work, the administrator has assigned 110::3 and 112::12 to host C and 111::120 to host F. This might look odd, but it is perfectly legal for a single segment to have multiple IPv6 subnets assigned in IPv6; it is also perfectly legal to have a single device with multiple addresses. In fact, in IPv6, there are many situations where a single device may have a range of addresses assigned.</p>
        <p class="indent">From the perspective of the prefix lengths, however, no two addresses assigned to C or F are on the same subnet. Because of this, IPv6 does not rely on the prefix length to determine what is on segment and what is not. Instead, IPv6 implementations keep a table of all connected hosts, using neighbor solicitations to discover what is on segment and what is not. When a host wants to send traffic off the local segment, it sends the traffic to one of the routers it has learned about through router advertisements. If a router receives a packet that it knows another router on the segment has a better route to (because the routers have routing tables that tell them which path to take to any particular destination), the router will send an ICMPv6 redirect message telling the host to use some other first hop router to reach the destination.</p>
        <div class="heading">
        <h3 class="h3" id="ch06lev12">Final Thoughts</h3>
        <p class="noindent">This chapter has provided an overview of a very difficult problem, and a number of complex solutions—the Domain Name System, the Dynamic Host Configuration Protocol, the Address Resolution Protocol, and Neighbor Discovery—are far more complex than the high-level overviews provided here. The deployment and operation <a id="page_168"></a>of DNS servers and the maintenance of the DNS system are an entire career field within network engineering, for instance.</p>
        </div>
        <p class="indent">Even so, all of these complex solutions represent just one of four ways to solve the difficult problems of mapping the identifiers used at one layer into the identifiers used at another layer, or the discovery of identifiers in order to facilitate communication. The contrast between the four basic solutions and the diverse protocols implementing those solutions is a solid example of the premise of this book: if you understand the problem space, and you understand the available solutions, then it becomes possible to ask the right questions of a solution to understand how it works.</p>
        <p class="indent">Once the identifiers have been discovered, and the data to be transported has been marshaled, it is time to switch packets through the network; this is the topic of the next chapter.</p>
        <div class="heading">
        <h3 class="h3" id="ch06lev13">Further Reading</h3>
        <p class="ref">Asati, Rajiv, Hemant Singh, Wes Beebee, Carlos Pignataro, Eli Dart, and Wesley George. <em>Enhanced Duplicate Address Detection</em>. Request for Comments 7527. RFC Editor, 2015. doi:10.17487/RFC7527.</p>
        </div>
        <p class="ref">Baker, Fred, and Brian E. Carpenter. <em>First-Hop Router Selection by Hosts in a Multi-Prefix Network</em>. Request for Comments 8028. RFC Editor, 2016. doi:10.17487/RFC8028.</p>
        <p class="ref">Beebee, Wes, Hemant Singh, and Erik Nordmark. <em>IPv6 Subnet Model: The Relationship between Links and Subnet Prefixes</em>. Request for Comments 5942. RFC Editor, 2010. doi:10.17487/RFC5942.</p>
        <p class="ref">Droms, Ralph. <em>DNS Configuration Options for Dynamic Host Configuration Protocol for IPv6 (DHCPv6)</em>. Request for Comments 3646. RFC Editor, 2003. doi:10.17487/RFC3646.</p>
        <p class="ref">———. <em>Stateless Dynamic Host Configuration Protocol (DHCP) Service for IPv6</em>. Request for Comments 3736. RFC Editor, 2004. doi:10.17487/RFC3736.</p>
        <p class="ref">Gont, Fernando. <em>Security Implications of IPv6 Fragmentation with IPv6 Neighbor Discovery</em>. Request for Comments 6980. RFC Editor, 2013. doi:10.17487/RFC6980.</p>
        <p class="ref">Johnson, Jarrod, and Dr. Thomas Narten. <em>Definition of the UUID-Based DHCPv6 Unique Identifier (DUID-UUID)</em>. Request for Comments 6355. RFC Editor, 2011. doi:10.17487/RFC6355.</p>
        <p class="ref"><a id="page_169"></a>Kempf, James, Jari Arkko, Brian Zill, and Pekka Nikander. <em>SEcure Neighbor Discovery (SEND)</em>. Request for Comments 3971. RFC Editor, 2005. doi:10.17487/RFC3971.</p>
        <p class="ref">Liu, Bing, Sheng Jiang, Xiangyang Gong, Wendong Wang, and Enno Rey. “DHCPv6/SLAAC Interaction Problems on Address and DNS Configuration.” Internet-Draft. Internet Engineering Task Force, August 2016. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-v6ops-dhcpv6-slaac-problem-07">https://datatracker.ietf.org/doc/html/draft-ietf-v6ops-dhcpv6-slaac-problem-07</a>.</p>
        <p class="ref">Mrugalski, Tomek, Marcin Siodelski, Bernie Volz, Andrew Yourtchenko, Michael Richardson, Sheng Jiang, Ted Lemon, and Timothy Winters. “Dynamic Host Configuration Protocol for IPv6 (DHCPv6) bis.” Internet-Draft. Internet Engineering Task Force, June 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-dhc-rfc3315bis-09">https://datatracker.ietf.org/doc/html/draft-ietf-dhc-rfc3315bis-09</a>.</p>
        <p class="ref">Narten, Dr. Thomas, Tatsuya Jinmei, and Dr. Susan Thomson. <em>IPv6 Stateless Address Autoconfiguration</em>. Request for Comments 4862. RFC Editor, 2007. doi:10.17487/RFC4862.</p>
        <p class="ref">Nordmark, Erik, and Igor Gashinsky. <em>Neighbor Unreachability Detection Is Too Impatient</em>. Request for Comments 7048. RFC Editor, 2014. doi:10.17487/RFC7048.</p>
        <p class="ref">Simpson, William A., Dr. Thomas Narten, Erik Nordmark, and Hesham Soliman. <em>Neighbor Discovery for IP Version 6 (IPv6)</em>. Request for Comments 4861. RFC Editor, 2007. doi:10.17487/RFC4861.</p>
        <p class="ref">Troan, Ole, and Ralph Droms. <em>IPv6 Prefix Options for Dynamic Host Configuration Protocol (DHCP) Version 6</em>. Request for Comments 3633. RFC Editor, 2003. doi:10.17487/RFC3633.</p>
        <p class="ref">Zeng, Shengyou, John Jason Brzozowski, Kim Kinnear, and Bernie Volz. <em>DHCPv6 Leasequery</em>. Request for Comments 5007. RFC Editor, 2007. doi:10.17487/RFC5007.</p>
        <div class="heading">
        <h3 class="h3" id="ch06lev14">Review Questions</h3>
        <p class="indenthangingN">1. Consider each of the four ways to solve the interlayer discovery and mapping problem discussed in the chapter. Build a chart describing the state and surface interactions for each one, and what the optimization tradeoffs might be.</p>
        </div>
        <p class="indenthangingN">2. Describe the process the IETF uses for maintaining number registries. Does this seem like a complex system or a simple one? Does it seem as though it would be effective in ensuring identifier uniqueness?</p>
        <p class="indenthangingN"><a id="page_170"></a>3. Consider that there must be millions, or perhaps hundreds of millions, of DNS queries each day. How many DNS root servers are there? Given these two numbers, how do you think the DNS system is scaled to support the entire global Internet?</p>
        <p class="indenthangingN">4. Is it possible to convert a globally reachable IP address to a DNS name (to map in the opposite direction from what is described in the chapter)? Can you think of one example where this would be useful?</p>
        <p class="indenthangingN">5. The “larger” DNS system also contains a mapping system from DNS names to human-readable information about domain ownership called whois. What protocol does it use to communicate, where is the information stored, and what kinds of information are available through this system?</p>
        <p class="indenthangingN">6. Explain what DNS glue records are and what they are used for.</p>
        <p class="indenthangingN">7. From the perspective of state, optimization, and surface, what are the tradeoffs between a mechanism like DHCP and one like SLAAC? Consider not only the ease with which addresses can be assigned, but any security and control issues that might arise with each one.</p>
        <p class="indenthangingN">8. Why would most implementations not enable proxy ARP by default? What is the risk in enabling proxy ARP?</p>
        <p class="indenthangingN">9. How does the neighbor discovery protocol End System to Intermediate System (ES-IS) compare to IPv6 ND?</p>
        <p class="indenthangingN1">10. Consider how IPv6 Router Discovery works in relation to the default gateway problem.</p>
        <p class="footnotet"><a id="ch06fn-1"></a><a href="ch06.xhtml#ch06fn1">1</a>. This chart is taken from <a href="https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml">https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xhtml</a>.</p>
        <p class="footnote"><a id="ch06fn-2"></a><a href="ch06.xhtml#ch06fn2">2</a>. Johnson and Narten, <em>Definition of the UUID-Based DHCPv6 Unique Identifier (DUID-UUID)</em>.</p>
        <p class="footnote"><a id="ch06fn-3"></a><a href="ch06.xhtml#ch06fn3">3</a>. Liu et al., “DHCPv6/SLAAC Interaction Problems on Address and DNS Configuration.”</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780134762814/files/9780134762852.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com