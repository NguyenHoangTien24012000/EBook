<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h1 class="h1" id="part2"><a id="page_277"></a><strong>P<small>ART</small> II<br>The Control Plane</strong></h1>
        <p class="noindent">Building a single packet processing device[md]the router (or layer 3 switch, now commonly just called a switch, to the confusion of just about everyone) being the most common example[md]has been the focus up to this point. Now it is time to begin connecting routers together. Consider the network in <a href="part2.xhtml#p2fig01">Figure P2-1</a>.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/p2fig01.jpg" aria-describedby="Alp2fig01" alt="Figure depicts a network topology." width="530" height="167"><aside class="hidden" id="Alp2fig01">
        <p>The figure shows two computers A and B, and four routers B, C, D, and E. A is connected to B on the right. B is connected to C and D on the right. E is connected to C and D on the left. E is connected to F on the right.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="p2fig01"></a><strong>Figure P2-1</strong> <em>Topology Discovery</em></p>
        </div>
        <p class="indent">An application running on host A needs to obtain some information from a process running on F. Devices B, C, D, and E are, of course, packet processors (routers). To forward packets between hosts A and F, router B is going to be called on to forward packets to F, even though it is not connected to F; likewise, routers C and D are going to need to forward packets to both A and F, even though they are connected to neither of these hosts.</p>
        <p class="indent">The question posed in this <a href="part2.xhtml#part2">Part II</a>, then, is this:</p>
        <p class="blockquote"><strong>How do network devices build the tables needed to forward packets along loop-free paths through the network?</strong></p>
        <p class="indent"><a id="page_278"></a>The answer is much more complex than it might immediately appear, for there are actually several problems contained within this one:</p>
        <p class="bullt">• How do devices learn about the topology of the network[md]which links are connected to what devices and destinations?</p>
        <p class="bull">• How do control planes take this information and build loop-free paths through the network?</p>
        <p class="bull">• How do control planes detect and react to changes in the network?</p>
        <p class="bull">• How are control planes scaled to meet the needs of large scale networks?</p>
        <p class="bull">• What policies are implemented in the control plane, and how?</p>
        <p class="indent1">Each chapter in this part addresses one or more of the sub-problems of the larger question asked in the preceding list. Two chapters are also dedicated to examples of control planes, to show how the problems and solutions have been implemented by widely deployed protocols. The chapters in <a href="part2.xhtml#part2">Part II</a> include:</p>
        <p class="bullt">• <strong><a href="ch11.xhtml#ch11">Chapter 11</a>: <a href="ch12.xhtml#ch12">Topology Discovery</a></strong>, which considers how a control plane discovers the network topology and reachability information</p>
        <p class="bull">• <strong><a href="ch12.xhtml#ch12">Chapters 12</a> and <a href="ch13.xhtml#ch13">13</a>: <a href="ch12.xhtml#ch12">Unicast Loop-Free Paths</a></strong>, which consider the problem of calculating a set of loop-free paths through the network, and the widely deployed solutions to this set of problems</p>
        <p class="bull">• <strong><a href="ch14.xhtml#ch14">Chapter 14</a>: <a href="ch14.xhtml#ch14">Reacting to Topology Changes</a></strong>, which considers the options a control plane has to react to a change in the network topology</p>
        <p class="bull">• <strong><a href="ch15.xhtml#ch15">Chapter 15</a>: <a href="ch15.xhtml#ch15">Distance Vector Control Planes</a></strong>, which considers control planes based on Bellman-Ford and the Diffusing Update Algorithm</p>
        <p class="bull">• <strong><a href="ch16.xhtml#ch16">Chapter 16</a>: <a href="ch16.xhtml#ch16">Link State and Path Vector Control Planes</a></strong>, which considers routing protocols based on Dijkstra’s shortest path first algorithm, and routing protocols that keep a list of path elements through which a routing update has passed</p>
        <p class="bull">• <strong><a href="ch17.xhtml#ch17">Chapter 17</a>: <a href="ch17.xhtml#ch17">Policy in the Control Plane</a></strong>, which considers what problems policy needs to solve in the control plane, and a range of solutions for those problems</p>
        <p class="bull"><a id="page_279"></a>• <strong><a href="ch18.xhtml#ch18">Chapter 18</a>: <a href="ch19.xhtml#ch19">Centralized Control Planes</a></strong>, which considers Software Defined Networks, Programmable Networks, and other control planes that centralize all or some of the policy or the calculation of loop-free paths</p>
        <p class="bull">• <strong><a href="ch19.xhtml#ch19">Chapter 19</a>: <a href="ch20.xhtml#ch20">Failure Domains and Information Hiding</a></strong>, which considers route filtering, aggregation, summarization, and other forms of routing protocol policy</p>
        <p class="bull">• <strong><a href="ch20.xhtml#ch20">Chapter 20</a>: <a href="ch20.xhtml#ch20">Examples of Information Hiding</a></strong>, which considers flooding domain implementation in link state protocols and route aggregation in the Border Gateway Protocol <a id="page_280"></a></p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780134762814/files/9780134762852.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com