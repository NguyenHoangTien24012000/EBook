<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch09"><a id="page_221"></a><strong>Chapter 9<br>Network Virtualization</strong></h2>
        <div class="sidebar">
        <p class="sb-noindent"><strong>Learning Objectives</strong></p>
        <p class="sb-noindent">After reading this chapter, you should understand:</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> What problems network virtualization is used to solve</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> How a tunneled packet is switched through a network</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> What two problems every network virtualization solution must solve</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The general concepts of a tunnel, overlay, underlay, and over-the-top service</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The concept of the inner and outer header, and how each is used in a virtual topology</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The basic operation of segment routing</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The basic concept of Software-Defined Wide Area Networks</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> A basic understanding of at least some tradeoffs in building and operating virtual topologies</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The concepts of shared fate and shared link risk groups</p>
        </div>
        <p class="noindent">Network virtualization is, in the simplest terms possible, the creation of logical topologies built on top of a physical topology. These logical topologies are often called virtual topologies—hence the concept of network virtualization. These topologies may consist of a single virtual link across a larger network, called a tunnel, or a collection of virtual links that appear to be a complete network on top of the physical network, called an overlay.</p>
        <p class="indent"><a id="page_222"></a>This chapter will begin with a discussion about why virtual topologies are created and used, illustrated by two use cases. The second section of this chapter will consider the problems any virtualization solution must solve, and the third section will consider complexity and network virtualization. Following this, two examples of virtualization technologies will be considered: segment routing (SR) and Software-Defined Wide Area Networks (SD-WAN).</p>
        <div class="heading">
        <h3 class="h3" id="ch09lev1">Understanding Virtual Networks</h3>
        <p class="noindent">Virtualization adds complexity in protocol design, network design, and troubleshooting, so why virtualize? The reasons tend to reduce to separating multiple traffic flows across a single physical network. This might sound suspiciously like another form of multiplexing because it <em>is</em> another form of multiplexing. The primary differences between the forms of multiplexing considered to this point and virtualization are</p>
        </div>
        <p class="bullt">• Allowing multiple control planes to operate with different sets of reachability information across a single physical topology</p>
        <p class="bullb">• Allowing multiple sets of reachable destinations to operate across a single physical topology without interacting with one another</p>
        <p class="indent">The multiplexing techniques considered to this point have focused on allowing multiple devices to use a single physical network (or set of wires), allowing every device to talk to every other device (so long as they know about one another from a reachability perspective). Virtualization focuses on breaking up the single physical network into multiple reachability domains, where every device within a reachability domain can communicate with every other device within the same reachability domain, but devices cannot communicate across reachability domains (unless there is some connection point between the reachability domains).</p>
        <p class="indent"><a href="ch09.xhtml#ch09fig01">Figure 9-1</a> illustrates a network with a virtual topology laid on top of the physical topology.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig01.jpg" aria-describedby="Al09fig01" alt="Figure represents a physical and a virtual topology." width="700" height="599"><aside class="hidden" id="Al09fig01">
        <p>Physical network is mentioned at the top with two computers, A and B to the left. Two lines lead from A and B to the right, reaching two routers, C and D. A line leads from C to reach D. Two lines lead from the right of C and D to reach two routers, E and F. Two lines emerge from E and F to meet at a router labeled H. Two lines move upward and downward from H to reach two servers, K and M. Virtual Network is mentioned below with a computer labeled A pointing a line to a router labeled C. A dashed line moves downward to reach a router labeled H. A line leads from H to reach a server, M to the right. Remaining part of the topology is not highlighted.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig01"></a><strong>Figure 9-1</strong> <em>A Physical and a Virtual Topology</em></p>
        </div>
        <p class="indent">In <a href="ch09.xhtml#ch09fig01">Figure 9-1</a>, a virtual topology has been created on top of the physical network, with the virtual link [C,H] created to carry traffic across the network. In order to create the virtual topology, C and H must have some sort of local forwarding information separating the physical topology from the virtual topology, which would normally pass through either E or D. This would normally take the form of either a special set of virtual interface entries in the local routing table, or a Virtual Routing and Forwarding (VRF) table containing only information about the virtual topology.</p>
        <p class="indent"><a id="page_223"></a>Considering the packet flow through the virtual topology can be helpful in understanding the concepts. What would the packet flow look like if C and H had virtual interfaces? <a href="ch09.xhtml#ch09fig02">Figure 9-2</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig02.jpg" aria-describedby="Al09fig02" alt="Figure represents the process of forwarding a packet across a virtual link." width="665" height="559"><aside class="hidden" id="Al09fig02">
        <p>A computer labeled A has a line leading to a router labeled C. A dashed line from C leads to router E. A dashed line from E moves downward to reach a router labeled H. A line leads from H to reach a server, M to the right. Remaining part of the topology is not highlighted. A dotted arrow points to the line leading from A to C, labeled 1: Packet transmitted by A towards M. A dotted arrow points to C, labeled 2 &amp; 3: Look up destination, find H as next hop, place outer header on packet. A dotted arrow points to a transparent line leading from C to E, labeled 4 &amp;5: Look up H as destination, find E, place link local header on packet, forward. A dotted line leads to a transparent line between E and H, labeled 6 &amp; 7: Look up H as destination, place link local header on packet, forward. A dotted line reaches a line between H and M, labeled 8 &amp; 9: strip outer header, look up M as destination, place link local header on packet, forward.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig02"></a><strong>Figure 9-2</strong> <em>Forwarding a Packet across a Virtual Link</em></p>
        </div>
        <p class="indentb">In <a href="ch09.xhtml#ch09fig02">Figure 9-2</a>, the forwarding process follows these steps:</p>
        <p class="indenthangingN">1. A transmits a packet toward M.</p>
        <p class="indenthangingN">2. C receives this packet, and, examining its local routing table, finds the shortest path to the destination is through a virtual interface toward H. This virtual interface is normally called a tunnel interface; it appears, from the routing table’s perspective, like any other interface on the router.</p>
        <p class="indenthangingN">3. The virtual interface through which the packet needs to be transmitted has rewrite instructions that include adding a new header, the tunnel header, or outer header, onto the packet, and forwarding the resulting packet. The original packet header is now called the inner header. C adds the outer header and processes the new packet for forwarding.</p>
        <p class="indenthangingN"><a id="page_224"></a>4. C now examines the new destination, which is H (remember the original destination was M). H is not directly connected, so C needs to look up how to reach H. This is called a recursive lookup, as C is looking for the path to an intermediate destination to take the packet toward, but not to, the final destination.</p>
        <p class="indenthangingN">5. C will now place the correct information onto the packet, in a link local header, to forward the traffic to E.</p>
        <p class="indenthangingN">6. When E receives this packet, it will strip the outer forwarding information, the link local header, and forward the traffic based on the first header C placed on the packet, during the initial lookup. This outer header tells E to forward the packet to H; E does not see or switch on the original inner header placed on the packet by A.</p>
        <p class="indenthangingN">7. E will add a new link local header so the packet will be correctly forwarded to H, and transmit the packet on the correct interface.</p>
        <p class="indenthangingN"><a id="page_225"></a>8. When H receives the packet, it will strip the link local header and discover the outer header. The outer header says the packet is destined for H itself, so H will strip this header, and discover the original packet header or the inner header.</p>
        <p class="indenthangingN">9. H will now look up M in its local routing table and discover M is locally connected. H will place the correct link local header on the packet and transmit it through the correct interface so the packet reaches M.</p>
        <p class="indentt">If C and H are using VRFs rather than tunnel interfaces, the process in the preceding list changes at steps 2 and 8. At step 2, C will look up M as a destination in the VRF associated with the [A,C] link. When C finds that traffic toward M should be forwarded through a virtual topology via H, it will place an outer header on the packet and process the packet again, based on this outer header, through the base VRF, or rather the routing table representing the physical topology. When H receives the packet, it will strip off the outer header and process the packet again using the VRF to which M is connected to look up the information needed to forward the traffic to its final destination. The tunnel interface, in this case, is replaced with a separate forwarding table; rather than processing the packet through the same table twice using two different destinations, the packet is processed through two different forwarding tables.</p>
        <p class="indent">The term tunnel has many different definitions; for this book, a tunnel will be used to describe a virtual link where an outer header is used to encapsulate an inner header, and</p>
        <p class="bullt">• The inner header is at the same layer, or a lower layer, than the outer header (for instance, an Ethernet header carried inside an IPv6 header; normally IPv6 is carried inside Ethernet).</p>
        <p class="bullb">• At least some network devices in the path, whether virtual or physical, forward the packet based on the outer header alone.</p>
        <p class="indent">Moving from virtual interfaces to VRFs is conceptually different enough to engender different descriptive terms. The underlay is the physical (or potentially logical!) topology through which traffic is tunneled. The overlay is the set of tunnels making up the virtual topology. Most of the time, the terms <em>underlay</em> and <em>overlay</em> are not used with single tunnels, or in the case of a service running over the public Internet. A service that builds a virtual topology across the public Internet is often called an over-the-top service.</p>
        <p class="indent">Again, these terms are used somewhat interchangeably, and even in a very sloppy way, in the larger network engineering world. With this background, it is time to turn to use cases, in order to inform the problem set virtualization solutions need to solve.</p>
        <a id="page_226"></a>
        <div class="heading">
        <h4 class="h4" id="ch09lev2"><strong>Providing Ethernet Services over an IP Network</strong></h4>
        <p class="noindent">Although applications should not be built with Ethernet connectivity as an underlying assumption, many are. For instance:</p>
        </div>
        <p class="bullt">• Some storage and database vendors build their devices with the assumption that <em>Ethernet connectivity means short distance and short delay</em>, or they design systems on top of proprietary transport protocols directly on top of Ethernet frames, rather than on top of Internet Protocol (IP) packets.</p>
        <p class="bullb">• Some virtualization products embed assumptions about connectivity into their operation, such as the reliability of the Ethernet to IP address cache for the default gateway and other reachable destinations.</p>
        <p class="indent">These kinds of applications require what appears to be an Ethernet link between the devices (whether physical or virtual) running different nodes or copies of the application. Beyond this, some network operators believe running a large flat Ethernet domain is simpler than running a large-scale IP domain, so they would prefer to build the largest Ethernet domains they can <em>(“switch where you can, route where you must”</em> was a common saying in the days when switching was performed in hardware, while routing was performed in software, so switching packets was much faster than routing them). Some campuses are also built with the underlying idea of never asking a device to switch their IP address once they are connected. As users may be connected to different Ethernet segments based on their security domain, so each Ethernet segment must be available at every wireless access point and often at each Ethernet port in the campus.</p>
        <p class="indent">Given a network based on IP, which anticipates Ethernet as one of the many transports on top of which IP will run, how can you provide Ethernet connectivity to devices interconnected over an IP network? <a href="ch09.xhtml#ch09fig03">Figure 9-3</a> illustrates the problems to be solved.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig03.jpg" aria-describedby="Al09fig03" alt="Figure represents Ethernet over IP problem example." width="701" height="423"><aside class="hidden" id="Al09fig03">
        <p>Two servers, labeled A and B are at the top and bottom, with addresses 2001:db8:3e8:100::1 and 2001:db8:3e8:100::2 mentioned at the top and bottom respectively. Two dotted lines lead to A and B, with text these two processes need to appear to be on the same Ethernet segment. Two lines from A and B lead to the right, reaching routers, C, D, E, F, G, and H that are interconnected and enclosed in a box filled with dashed lines labeled Routed IP domain. Two lines lead from G and H to the right, reaching servers, K and M. A dotted line leads upward from K, with address 2001:db8:3e8:100::1 enclosed in a dotted box. Two dashed lines to the left and right have text labeled this process needs to be able to move between these two physical servers.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig03"></a><strong>Figure 9-3</strong> <em>Ethernet over IP Problem Example</em></p>
        </div>
        <p class="indent">In <a href="ch09.xhtml#ch09fig03">Figure 9-3</a>, a process running on A, with the IP address 2001:db8:3e8:100::1 needs to be able to communicate with a service running on B with the IP address 2001:db8:3e8:100::2 as if they are on the same Ethernet segment (the two services need to see one another in neighbor discovery, etc.). To make the problem more complex, the service at A also needs to be able to move to K without changing its local neighbor discovery cache or default router. The network itself, which is shown as a small section of a spine and leaf fabric, is a routed network running IPv6.</p>
        <p class="indent">What would be required to allow the requirements to be met?</p>
        <p class="indent"><strong>There must be a way to carry Ethernet frames over the IP network separating the servers.</strong> This would normally be some form of tunneling encapsulation, as described at the beginning of this section. Tunneling would allow Ethernet frames to <a id="page_227"></a>be received at C, for instance, encapsulated in some sort of outer header so they can be transported across the routed network. When the packet containing the Ethernet frame reaches D, this outer header can be stripped off and the Ethernet frame forwarded locally. From the perspective of D, the frame is locally originated.</p>
        <p class="indent"><strong>There must be a way to learn about the destinations reachable via the tunnel and draw traffic into the tunnel.</strong> These are actually two separate, but related, problems. Drawing traffic into the tunnel might involve running a second control plane with its own VRFs, or adding additional information into an existing control plane about the Ethernet Media Access Control (MAC) addresses reachable at each edge router.</p>
        <p class="indent"><strong>There may be a requirement to transfer Quality of Service (QoS) markings from the inner header to the outer header,</strong> so traffic is handled correctly when it is forwarded. See <a href="ch08.xhtml#ch08">Chapter 8</a>, “<a href="ch08.xhtml#ch08">Quality of Service</a>,” for more information on carrying QoS markings between the two headers in a tunnel.</p>
        <div class="heading">
        <h4 class="h4" id="ch09lev3"><strong>Virtual Private Access to a Corporate Network</strong></h4>
        <p class="noindent">Almost every organization has remote workers of some sort, either full time, or just people who travel, and most organizations have remote offices of some kind, where a small group of people work away from the main office to interact with a local community in some way, such as retail or sales. All of these people still need access to <a id="page_228"></a>network resources, such as email, travel systems, files, etc. These services cannot be exposed to the public Internet, of course, so some other access mechanism must be provided. <a href="ch09.xhtml#ch09fig04">Figure 9-4</a> illustrates the problem space.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig04.jpg" aria-describedby="Al09fig04" alt="Figure represents virtual private networks over a public network." width="662" height="378"><aside class="hidden" id="Al09fig04">
        <p>A server labeled A has a line leading to the top, reaching an address labeled 2001:db8:3e8:100::1. A line leads to the right, reaching a router labeled G. A cloud labeled public internet is to the right, touching a router labeled F to the right. Dashed lines lead from G to F and to a computer labeled B. A line leads from B to touch the cloud. Three lines lead from F to reach computers, C, D, and E.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig04"></a><strong>Figure 9-4</strong> <em>Virtual Private Networks over a Public Network</em></p>
        </div>
        <p class="indent">There are two primary concerns in this use case:</p>
        <p class="bullt">• How can the traffic between the individual host—B—and the three hosts in the small office—C, D, and E—be protected from being intercepted and read by an attacker? How can the destination addresses themselves be protected from exposure into the public network? These problems involve some sort of security, which, in turn, implies some form of packet encapsulation.</p>
        <p class="bullb">• How can the quality of the user’s experience in these remote locations be managed to support voice over IP and other real-time applications? Because providers on the Internet do not support quality of service, some other form of quality assurance must be provided.</p>
        <p class="indent">The problem set to solve here, then, includes two more general issues.</p>
        <p class="bullt">• <strong>There must be a way to encapsulate the traffic being carried across the public network</strong> without exposing the original header information and without exposing the information carried in the packet to inspection. The easiest solution for these problems is to tunnel (often in an encrypted tunnel) the traffic from A and F to the edge router in the organization’s network, G, where the encapsulation can be removed and the packets forwarded to A.</p>
        <p class="bullb"><a id="page_229"></a>• <strong>There must be a way to advertise the reachable destinations</strong> from G toward the remote users, and the existence of (or reachability of) the remote users to G, and the network behind G. This reachability information must be used to draw traffic into the tunnels. The control plane, in this case, may need to redirect traffic among the various entry and exit points to the public network, and try to control the path of the traffic through the network, in order to ensure the remote users receive a good quality of experience.</p>
        <div class="heading">
        <h4 class="h4" id="ch09lev4"><strong>A Summary of Virtualization Problems and Solutions</strong></h4>
        <p class="noindent">The two use cases in the preceding sections expose the two questions every network virtualization solution must solve:</p>
        </div>
        <p class="blockquote"><strong>How is traffic encapsulated within the tunnel so the packets and control plane information can be separated from the underlying network?</strong></p>
        <p class="indent">The solution for this problem is generally some form of encapsulation into which the original packet is placed as it is carried through the network. The primary consideration for the encapsulation is hardware switching support in the underlay network, to allow the efficient forwarding of encapsulated packets. A secondary consideration is the size of the encapsulating packet format; each octet of additional encapsulation header reduces the amount of payload the tunnel can carry (unless there is a differential between the Maximum Transmission Unit, or MTU, in the network designed to account for the additional header information tunneling imposes).</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">Path MTU Detection (PMTUD) often does a poor job of detecting the MTU of encapsulated packets; because of this, manual tuning of MTU at the point where the tunnel header is imposed is often required.</p>
        </div>
        <p class="blockquote"><strong>How are the destinations reachable through the tunnel advertised through the network?</strong></p>
        <p class="indent">In more general tunneled solutions, the tunnel becomes “just another link” in the overall network topology. The destinations reachable through the tunnel, and the additional virtual link, are simply included as a part of the control plane, like any <a id="page_230"></a>other destinations and links. In these solutions, there is one routing or forwarding table in each device, and a recursive lookup is used to process the packet through forwarding at the point where traffic enters the tunnel, or the tunnel headend. Traffic is drawn into the tunnel by modifying the metrics so the tunnel is a more desirable path through the network <em>for those destinations the network operator would like to be reached through the tunnel</em>. This generally means largely manual solutions to the problem of drawing traffic into the tunnel, such as setting the tunnel metric lower than the path over which the tunnel runs, and then filtering the destinations advertised through the tunnel to prevent the advertisement of destinations that should be unreachable through the tunnel. In fact, if the destinations reachable through the tunnel include the tunnel termination point (the tunnel tailend), a permanent routing loop can form, or the tunnel will cycle between forwarding traffic correctly and not forwarding traffic at all.</p>
        <p class="indent">In overlay and over-the-top solutions, a separate control plane is deployed (or a separate database of reachability information is carried for the destinations reachable in the underlay and overlay in a single control plane). Destinations reachable through the underlay and overlay are placed into separate routing tables (VRFs) at the tunnel headend, and the table used to forward traffic is based on some form of classification system. For instance, all the packets received on a particular interface may be placed into an overlay tunnel automatically, or all the packets with a specific class of service set in their packet headers, or all traffic destined to a specific set of destinations. Full overlay and over-the-top virtualization mechanisms do not generally rely on metrics to draw traffic into the tunnel at the headend.</p>
        <p class="indent">One other optional requirement is to provide for quality of service, either by copying the QoS information from the inner header to the outer header, or by using some form of traffic engineering to carry traffic along the best available path.</p>
        <div class="heading">
        <h3 class="h3" id="ch09lev5">Segment Routing</h3>
        <p class="noindent">Segment routing (SR) may, or may not, be considered a tunneled solution, based on the specific implementation, and how strongly you want to adhere to the definition of tunnels presented in the “Understanding Virtual Networks” section earlier in this chapter. This section will consider the basic concept of segment routing and two possible implementation schemes—one using IPv6 flow labels and one using Multi-protocol Label Switching (MPLS) labels.</p>
        </div>
        <p class="indent"><a id="page_231"></a>Each device in an SR-enabled network is given a unique label. A label stack describing the path in terms of these unique labels can be attached to any packet, causing it to take the specific path indicated. <a href="ch09.xhtml#ch09fig05">Figure 9-5</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig05.jpg" aria-describedby="Al09fig05" alt="Figure represents the process of segment routing." width="646" height="325"><aside class="hidden" id="Al09fig05">
        <p>A circle labeled A is to the left with a line leading upward to a router labeled B. The address mentioned above reads: 2001:db8:3e8:100::1 label 101. Three lines lead from B to reach routers, E, C, and D. The address of E reads: 2001:db8:3e8:100::4 label 104. The address of C reads: 2001:db8:3e8:100::2 label 102. The address of D reads: 2001:db8:3e8:100::3 label 103. Lines lead from C and E to a router labeled F with address, 2001:db8:3e8:100::5 label 105. Two lines lead from D to reach a router labeled H with address, 2001:db8:3e8:100::7 label 107. A line leads from F to H. A line leads from D to a router labeled G with address, 2001:db8:3e8:100::6 label 106. A line leads from H to a circle labeled K at top.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig05"></a><strong>Figure 9-5</strong> <em>Segment Routing</em></p>
        </div>
        <p class="indent">Each router in <a href="ch09.xhtml#ch09fig05">Figure 9-5</a> advertises an IP address as an identifier along with a label attached to this IP address. In SR, the label attached to the router identifier is called a node segment identifier (node SID). As each router in the network is assigned a unique label, a path can be described through the network using just these labels. For instance:</p>
        <p class="bullt">• If you wanted to forward traffic from A to K along the path [B,E,F,H], you could describe this path using the labels [101,104,105,107].</p>
        <p class="bullb">• If you wanted to forward traffic from A to K along the path [B,D,G,H], you could describe this path using the labels [101,103,106,107].</p>
        <p class="indent">The set of labels used to describe a path is called the label stack. There are two links between D and H; how can this be described? There are several options available in SR, including:</p>
        <p class="bullt">• The label stack may include just the node SIDs describing the path through the network in terms of the routers, as previously shown. In this case, if the label stack included the pair [103,107], D would simply forward to H normally, based on local routing information, so it would use whatever local process it would use in forwarding any other packet, such as load sharing across the two links, to forward the SR-labeled traffic, as well.</p>
        <p class="bull"><a id="page_232"></a>• The label stack could include an explicit label to load share over any available set of paths available at this point in the network.</p>
        <p class="bullb">• H could assign a label per inbound interface, as well as a node SID tied to its local router identifier. These labels would be advertised just like the node SID, but as they describe an adjacency, they are called an adjacency SID. The adjacency SID is locally unique; it is unique to the router advertising the adjacency SID itself.</p>
        <p class="indent">A third kind of SID, the prefix SID, describes a specific reachable destination (a prefix) within the network. A node SID can be implemented as a prefix SID tied to a loopback address on each router in the network.</p>
        <p class="indent">The entire path does not need to be described by the label stack. For instance, the label stack [101,103] would direct traffic to B, then to D, but would then allow D to use any available path to reach the destination IP address at K. The label stack [105] would ensure traffic passing through the network toward K would pass through F; it does not matter how the traffic reached that point in the network, nor how it was forwarded after it reaches F, so long as it passes through F while being forwarded toward K.</p>
        <p class="indent">Each label in the stack represents a segment; packets are carried from label to label across each segment in the network to be transported from the headend of the path to the tailend of the path.</p>
        <div class="heading">
        <h4 class="h4" id="ch09lev6"><strong>Segment Routing with Multiprotocol Label Switching</strong></h4>
        <p class="noindent">MPLS was invented as a way to blend the advantages of Asynchronous Transfer Mode (ATM), which is no longer widely deployed, with IP switching. In the earlier days of network engineering, the chipsets used for switching packets were more constrained in their capabilities than they are now; many of the chipsets being used were Field Programmable Gate Arrays (FPGAs) rather than Application-Specific Integrated Circuits (ASICs), so the length of the field on which the packet was switched was directly correlated to the speed at which the packet could be switched. It was often easier to recycle a packet, or to process it twice, than it was to include a lot of complex information in the header so the packet can be processed once.</p>
        </div>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">Packet recycling is still often used in many chipsets to support inner and outer headers, or even to process different parts of a longer, more complex, packet header.</p>
        </div>
        <p class="indent"><a id="page_233"></a>MPLS encapsulates the original packet into an MPLS header, which is then used to switch the packet through the network. <a href="ch09.xhtml#ch09fig06">Figure 9-6</a> shows the MPLS header.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig06.jpg" aria-describedby="Al09fig06" alt="Figure represents the MPLS header." width="700" height="188"><aside class="hidden" id="Al09fig06">
        <p>The top portion has 0 to 9 mentioned to the left with the 0 marked as 0. 0 to 9 is mentioned again with 0 mentioned as 1. 0 to 9 follows with 0 mentioned as 2. The arrangement continues with 0 and 1 following with 0 mentioned as 3. The portion below has Label to the left, Exp |S| at the center and TTL to the right. Label, Stack, and Entry are mentioned at the right. A set of settings with definitions are listed below that read: Label: Label Value, 20 bits, Exp: Experimental Use, 3 bits, S: Bottom of Stack, 1 bit, and TTL: Time to Live, 8 bits.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig06"></a><strong>Figure 9-6</strong> <em>The MPLS Header</em></p>
        </div>
        <p class="indent">The entire header is 32 bits; the label is 20 bits. Three operations can be carried out by an MPLS forwarding device:</p>
        <p class="bullt">• The current label in the MPLS header can be swapped with another label (SWAP).</p>
        <p class="bull">• A new label can be pushed onto the packet (PUSH).</p>
        <p class="bullb">• The current label can be popped, and the label under the current label processed (POP).</p>
        <p class="indent">The PUSH and POP operations are carried directly into SR; the SWAP operation is implemented in SR as a CONTINUE, which means the current label is swapped with the same label (i.e., a header with the label 100 will be replaced with a label of 100), and the processing of this current segment will continue. The easiest way to understand the processing is through an example; <a href="ch09.xhtml#ch09fig07">Figure 9-7</a> illustrates.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig07.jpg" aria-describedby="Al09fig07" alt="Figure represents the process of switching a packet through a series of segments." width="700" height="473"><aside class="hidden" id="Al09fig07">
        <p>A router labeled A is at the top left with a dotted arrow pointing towards it. The label stack adjacent to it reads: [101, 103, 104, 202, 105, 106, 109, 110]. A line leads downward to a router labeled B with 101 labeled below. A dotted arrow points to the line between A and B with label stack labeled [103, 104, 202, 105, 106, 109, 110]. Two lines lead from B to routers, C and D with 102 and 103 labeled respectively. A dotted line moves upward, touching the line between B and D and labeled [104, 202, 105, 106, 109, 110]. A dotted line leads to the line between D and E with label stack labeled [202, 105, 106, 109, 110]. Two lines lead from C and D to reach a router labeled E with 104 labeled. Two lines labeled 201 and 202 lead from E to reach a router labeled F with 105 labeled. A line leads upward from F to a router labeled G with 106 labeled. Two lines lead from G to reach routers H and K at the top and bottom with 107 and 108 labeled. Two lines lead from H and K to a router labeled L with 109 mentioned. A dotted arrow meets the line between G and K, labeled [110]. A dotted arrow meets the line between K and L, labeled [110]. A line leads from L to reach a router labeled M with 110 mentioned. The line leads from M to a server labeled N.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig07"></a><strong>Figure 9-7</strong> <em>Switching a Packet through a Series of Segments</em></p>
        </div>
        <p class="indent">In <a href="ch09.xhtml#ch09fig07">Figure 9-7</a>, each router has a globally unique label assigned from the Segment Routing Global Block (SRGB); these are advertised through a routing protocol or some other control plane. When A receives a packet destined for N, it will choose a path through the network using some local mechanism. At this point:</p>
        <p class="bullt">• To begin the process, A will PUSH a series of MPLS headers on the packet that describe the path through the network, [101,103,104,202,105,106,109, 110]. When A switches the packet toward B, it will POP the first label in the stack, as there is no need to send B its own label in a header. The label stack on the [A,B] link will be [103,104,202,105,106,109,110].</p>
        <p class="bull">• When B receives the packet, it examines the next label on the stack. Finding the label to be 103, it will POP this label and forward the packet to D. The SR label <a id="page_234"></a>stack, in this case, has picked out one of two possible equal cost paths through the network, so this is an example of SR choosing a specific path. The label stack on the [B,D] link will be [104,202,105,106,109,110].</p>
        <p class="bull">• When D receives the packet, the top label on the stack will be 104; D will POP this label and send the packet to E. The label stack on the [D,E] link will be [202,105,106,109,110].</p>
        <p class="bull">• When E receives this packet, the top label on the stack is 202. This is an adjacency selector, so it selects for a specific interface rather than a specific neighbor. E will select the correct interface, the lower of the two interfaces in the illustration, and POP this label. The top label is now the node SID for F, which can be removed, since the packet is being transmitted to F; E will recycle the packet and POP this label as well. The label stack on the [E,F] link will be [106,109,110].</p>
        <p class="bull">• When the packet reaches F, the next label in the stack is 106. This label indicates the packet should be transmitted to G. F will POP the label and transmit it to G. The label stack on the [F,G] link will be [109,110].</p>
        <p class="bull"><a id="page_235"></a>• When the packet reaches G, the next label on the stack is 109, which indicates the packet should be forwarded toward L. As G is not directly connected to L, it can use a local, loop-free (generally the shortest) path toward L. In this case, there are two equal cost paths toward L, so G will POP the 109 label and forward over one of these two paths toward L. On the [G,L] segment, the label stack is [110].</p>
        <p class="bull">• Assume G chooses to send the packet via K. When K receives the packet, it will have a label stack containing [110], which is not the local label, nor it is an adjacent node. In this case, the label needs to remain the same, or the segment needs to CONTINUE. To implement this, K will SWAP the current label, 110, for another copy of the same label, so the K will forward the traffic with the same label. On the [K,L] link, the label stack will be [110].</p>
        <p class="bull">• When L receives the packet, the only remaining label will be 110, which indicates the packet should be forwarded to M. L will POP the 109 label, effectively removing all the MPLS encapsulation, and forward the packet to M.</p>
        <p class="bullb">• When M receives the packet, it will forward the packet using normal IP to N, the final destination.</p>
        <p class="indent">The <em>stack of labels</em> concept in MPLS is implemented as a series of MPLS headers stacked on top of one another. Popping the label means to remove the topmost label, pushing a label means adding a new MPLS header onto the packet, and continuing means swapping the label with an identical label. When you are working with a stack of labels, the concepts of <em>inner</em> and <em>outer</em> are often confusing, particularly as many people use the idea of a label and a header interchangeably. Perhaps the best way to reduce confusion is to use the term <em>header</em> to refer to the entire label stack and the original header being carried inside MPLS, while referring to the labels as <em>individual labels in the stack</em>. The inner header would then be the original packet header, while the outer header would be the stack of labels; the inner label would be the next label on the stack at any point in the packet’s travels through the network, while the outer label would be the label on which the packet is actually being switched.</p>
        <p class="indent">Although the example given here uses IP packets inside MPLS, the MPLS protocol is designed to carry just about any protocol, including Ethernet. SR MPLS is not, therefore, limited to being used to carry a single type of traffic, but can also be used to carry Ethernet frames over an IP/MPLS-based network. This means SR can be used to support the first use case discussed in this chapter, providing Ethernet services over an IP network.</p>
        <div class="sidebar1">
        <p class="title1"><a id="page_236"></a><strong>Is MPLS a Tunnel?</strong></p>
        <p class="noindent">Many bits, in the form of the written and spoken words, have been spilled on the question of whether or not MPLS is a tunneling protocol. The way tunneling is defined here is that it is an action, rather than a protocol; this is an intentional attempt to separate the idea of the tunneling protocol from the concept of tunneling as an action taken in carrying traffic through the network. In the case of MPLS, this means it may, or may not, be a tunneling protocol, depending on how it is being used—just like any other protocol. For instance, if you have a stack of labels placed on top of a packet with an IP header, the outer label, the one on which the packet is being switched, is not (technically) a tunnel. This outer header, in an MPLS network, is actually local to the segment, so it is either popped or pushed at every router. This is analogous to an Ethernet header on a per link basis. The inner header, however, is being carried within the MPLS packet, and hence is technically being tunneled. The inner label is not used <em>at the current device</em> for switching the packet; it is simply carried <em>as part of the packet</em>.</p>
        <p class="indent">This definition is not perfect—few definitions in the real world are. For instance, in the case of an MPLS SWAP or SR CONTINUE, is the label being used to switch the packet or not? Also, unlike the Ethernet header on a packet, the MPLS header is actually used in making a forwarding decision. The Ethernet header, in contrast, is simply used to reach the next hop and then discarded. The more appropriate comparison would perhaps be: The MPLS header is like the Ethernet header used to reach the hop beyond the device that the router is currently transmitting to.</p>
        <p class="indent">Regardless of these limitations, this definition will generally suffice to mentally manage the difference between tunneling and not tunneling in MPLS, as well as most other protocols.</p>
        </div>
        <div class="heading">
        <h4 class="h4" id="ch09lev7"><strong>Segment Routing with IPv6</strong></h4>
        <p class="noindent">The operation of SR on MPLS and SR on IPv6 is similar in all respects except how the label stack is carried and processed. SR headers in IPv6 are carried in the flow label field, shown in <a href="ch09.xhtml#ch09fig08">Figure 9-8</a>.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig08.jpg" aria-describedby="Al09fig08" alt="Figure represents the SR IPv6 Header Extension." width="700" height="549"><aside class="hidden" id="Al09fig08">
        <p>The top portion has 0 to 9 mentioned to the left with the 0 marked as 0. 0 to 9 is mentioned again with 0 mentioned as 1. 0 to 9 follows with 0 mentioned as 2. The arrangement continues with 0 and 1 following with 0 mentioned as 3. The portion below has four sections labeled Next Header, Hdr Ext Len, Routing Type, and Segments Left. A column below has Last Entry, Flags, and Tag enclosed. Segment List[0] (128 bits IPv6 address) falls below with  in the next column. Segment List[n] (128 bits IPv6 address) is at the next row with Optional Type Length Value objects (variable) at the bottom.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig08"></a><strong>Figure 9-8</strong> <em>The SR IPv6 Header Extension</em></p>
        </div>
        <p class="indent">In the IPv6 SR implementation, the SR label stack is carried in the routing header of the IPv6 packet header. The information in this header is designed specifically to provide information about the nodes through which “this packet” should pass when being routed through the network, so it serves the same purpose as the SR label <a id="page_237"></a>stack. In the case of IPv6 implementations of SR, each label is 128 bits, so some local IPv6 address can be used as an SID.</p>
        <p class="indent">The one interesting point is the IPv6 specifications indicate the IPv6 header must not be changed by a router when processing the packet (see RFC8200 for further details). Instead of popping, pushing, and swapping labels, then, SR IPv6 relies on each node along the path having a pointer to the current label in the stack being processed.</p>
        <div class="heading">
        <h4 class="h4" id="ch09lev8"><strong>Signaling Segment Routing Labels</strong></h4>
        <p class="noindent">SR is technically a source routing mechanism, because the source chooses the path through the network—although the source routing in SR can be much looser than traditional source routing. For each label on the stack, there are two possible ways a node along the path can process the packet:</p>
        </div>
        <p class="bullt">• The label provides explicit instructions about how the packet should be handled at this device; POP or CONTINUE the segment (label) and process the packet accordingly.</p>
        <p class="bullb"><a id="page_238"></a>• The label does not provide explicit instructions about how the packet should be handled at this device; use local routing information to forward the packet and CONTINUE the segment.</p>
        <p class="indent">In neither case does the processing node need to know about the entire path to switch the packet; it either simply follows the label path as specified, or it processes the packet based on purely local information. Because of this paradigm, signaling SR is simple. Two types of signaling need to occur.</p>
        <p class="indent"><strong>The local node, prefix, and adjacency SIDs assigned to a node in the network need to be advertised by each node in the network.</strong> This signaling is primarily carried in routing protocols; for instance, the Intermediate System to Intermediate System (IS-IS) protocol is extended by the draft <em>IS-IS Extensions for Segment Routing</em><sup><a id="ch09fn1"></a><a href="ch09.xhtml#ch09fn-1">1</a></sup> to carry prefix SIDs using a sub Type Length Value (sub-TLV), as shown in <a href="ch09.xhtml#ch09fig09">Figure 9-9</a>.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig09.jpg" aria-describedby="Al09fig09" alt="Figure represents the IS-IS sub-TLV for carrying a prefix SID." width="700" height="138"><aside class="hidden" id="Al09fig09">
        <p>The top portion has 0 to 9 mentioned to the left with the 0 marked as 0. 0 to 9 is mentioned again with 0 mentioned as 1. 0 to 9 follows with 0 mentioned as 2. The arrangement continues with 0 and 1 following with 0 mentioned as 3. A column below has Type, Length, Flags, and Algorithm mentioned. A column follows with SID/Index/Label (variable) mentioned.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig09"></a><strong>Figure 9-9</strong> <em>The IS-IS Sub-TLV for Carrying a Prefix SID</em></p>
        </div>
        <p class="indent">Extensions to other routing and control plane protocols are proposed for standardization, as well; see the “Further Reading” section at the end of the chapter for a list of these extension proposals. Because path calculation in SR is source based, there is no need to carry a path in a distributed routing protocol. The only real need is to provide each node in the network with the information needed to carry SR node, prefix, and adjacency information.</p>
        <p class="indent"><strong>In the case where SR paths are calculated by a centralized device or controller, there needs to be a way to advertise a label path to use in order to reach a particular destination</strong>. Extensions have been proposed to the Border Gateway Protocol (BGP) in <em>Advertising Segment Routing Policies in BGP</em>,<sup><a id="ch09fn2"></a><a href="ch09.xhtml#ch09fn-2">2</a></sup> and in the Path Computation Element Protocol (PCEP) in <em>PCEP Extensions for Segment Routing</em>.<sup><a id="ch09fn3"></a><a href="ch09.xhtml#ch09fn-3">3</a></sup> These two kinds of advertisements are separate from one another, as the only node in the network that needs to either calculate or impose the segment list is the tunnel headend or the point where traffic enters the segment path.</p>
        <div class="heading">
        <h3 class="h3" id="ch09lev9"><a id="page_239"></a>Software-Defined Wide Area Networks</h3>
        <p class="noindent">Many organizations need to provision and support large numbers of remote offices. For instance:</p>
        </div>
        <p class="bullt">• Retail chains may have hundreds or even thousands of stores and locations worldwide.</p>
        <p class="bullb">• A regional bank may have hundreds of branch offices and thousands of cash machine locations.</p>
        <p class="indent">When fixed location private line services were all service providers offered at any scale, these kinds of problems were solved using large-scale hub-and-spoke networks. <a href="ch09.xhtml#ch09fig10">Figure 9-10</a> illustrates a hub-and-spoke network.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig10.jpg" aria-describedby="Al09fig10" alt="Figure represents a hub-and-spoke network." width="696" height="493"><aside class="hidden" id="Al09fig10">
        <p>A cloud labeled Corporate network is at the top with two routers, A and B at the bottom. A set of lines lead from A and B to connect routers, C, D, E, F, G, H, K, L, M, and N.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig10"></a><strong>Figure 9-10</strong> <em>A Hub-and-Spoke Network</em></p>
        </div>
        <p class="indent">The network shown in <a href="ch09.xhtml#ch09fig10">Figure 9-10</a> is actually rather small; the three dots in the center of the remote sites may represent hundreds or thousands of additional sites. In many implementations (especially older ones), the links between the two hub routers, A and B, and the remotes, such as C and N, are point-to-point links. This means the hub router must have an interface configured for each remote router, <a id="page_240"></a>routing filters, packet filters, and any Quality of Service configurations. Not only is this a major problem from a configuration perspective, but it is also difficult to maintain thousands of individual neighbors in terms of processor and memory utilization.</p>
        <p class="indent">To reduce the amount of processing power required in maintaining such a network, protocols were modified to prevent treating the remote sites as if they were part of the tree. Instead, these modifications allowed these remote sites to be treated as if they were leaves, or stub networks. Another step toward making these kinds of networks easier to create and manage was using a point-to-multipoint interface (with the appropriate underlying technology, such as Frame Relay), at the hub routers. When the connections to the remote sites are configured as point-to-multipoint, the hub routers, A and B, treat all the spokes as if they are on a single broadcast segment (like an Ethernet segment, in effect). Each spoke router, however, still treats its connection to the hub routers as a point-to-point link. Even with these modifications, building and maintaining such large networks is still very difficult. Links must be purchased, and managed to each remote site, remote equipment must be configured and managed, the configuration of the hub routers must be managed, etc.</p>
        <p class="indent">Software-Defined Wide Area Network (SD-WAN) solutions were originally developed to solve this specific problem set. Originating in Cisco’s Dynamic Multi-point Virtual Private Network (DMVPN), the idea behind the DMVPN was to use a tunneled overlay, or over-the-top, network running on top of the public Internet. This allowed the remote sites to use locally available Internet connectivity, rather than purchasing a circuit per site, and reduced configuration and maintenance time through autoconfiguration and other tools.</p>
        <p class="indent">SD-WAN takes the concept of an over-the-top network one step further. An SDWAN solution is normally built using several components:</p>
        <p class="bullt">• A specialized appliance or virtualized service to replace the routers normally placed at the hub and spoke locations</p>
        <p class="bull">• A modified version of a standard routing protocol to provide reachability (and potentially one measure of circuit liveness) and to pass policies through the network</p>
        <p class="bull">• An implementation of either IP Security (IPsec) or Transport Layer Security (TLS) to provide secure tunneled transport between the hub-and-spoke devices</p>
        <p class="bullb">• A controller to monitor the state of each virtual link, the applications using the link, and the amount of goodput versus the amount of traffic, and to make dynamic adjustments to traffic flow and QoS settings to optimize application operation across the over-the-top virtual network</p>
        <p class="indent"><a id="page_241"></a>There are many different ways in which SD-WANs can be implemented; for instance:</p>
        <p class="bullt">• The SD-WAN can replace the “last mile”; rather than installing a circuit to each remote site, you can use SD-WAN solutions to reach an exchange or colocation point, and then carry the traffic through a more traditional service through a provider back to the hub routers (this is a form of backhaul).</p>
        <p class="bull">• The SD-WAN can replace the entire path from the organization’s network to the remote sites.</p>
        <p class="bullb">• The SD-WAN can be used to draw traffic into a cloud service, where some preliminary processing might take place, or some applications might be deployed, with just traffic that must be carried into the organization’s network carried the rest of the way into the hub routers.</p>
        <p class="indent">There are tradeoffs with SD-WAN and other over-the-top solutions, as there are with any other networking technology. For instance, pushing corporate remote site traffic over a “plain” public Internet connection (or pair of services, or some other Ethernet-terminated service) may be “good enough” in some situations, but providers tend to treat traffic in higher-priced services better (naturally enough), particularly in outages.</p>
        <div class="heading">
        <h3 class="h3" id="ch09lev10">Complexity and Virtualization</h3>
        <p class="noindent">Virtualization is often undertaken to find a simpler way to solve some of the problems noted in the initial sections of this chapter, such as traffic separation. There are, as with all things in the network engineering world, tradeoffs. In fact, if you have not found the tradeoff, you have not looked hard enough. This section will consider some (though certainly not all) of the various complexity tradeoffs in the realm of network virtualization. The basis of this discussion will be the complexity tradeoff triad considered in <a href="ch01.xhtml#ch01">Chapter 1</a>, “<a href="ch01.xhtml#ch01">Fundamental Concepts</a>”:</p>
        </div>
        <p class="bullt">• <strong>State:</strong> The amount of state and the speed at which state in the network changes (particularly the control plane)</p>
        <p class="bull">• <strong>Optimization:</strong> The optimal use of network resources, including such things as traffic following the shortest path through the network</p>
        <p class="bullb">• <strong>Surface:</strong> The number of layers, the depth of their interaction, and the breadth of their interaction</p>
        <a id="page_242"></a>
        <div class="heading">
        <h4 class="h4" id="ch09lev11"><strong>Interaction Surfaces and Shared Risk Link Groups</strong></h4>
        <p class="noindent">Every virtualization system ever conceived, implemented, and deployed creates shared risk of some sort. For instance, consider a single link that is carrying several virtual links, each of which is carrying traffic. It should be obvious (in fact trivial) to observe that if the single physical link fails, all of the virtual links will fail. Of course, you can simply reroute the virtual links onto another physical link. Right? Maybe or maybe not. <a href="ch09.xhtml#ch09fig11">Figure 9-11</a> illustrates.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig11.jpg" aria-describedby="Al09fig11" alt="Figure shows shared risk link groups." width="700" height="608"><aside class="hidden" id="Al09fig11">
        <p>A computer labeled A is to the left with a line leading to a router labeled B. Two lines move from B to two clouds, provider 1 and provider 2. Lines lead from provider 1 and provider 2 to a router labeled C. A line leads to the right of C, meeting a server labeled D. A computer labeled A lies below with a line leading to a router labeled B. Dashed lines move from B, connecting to a set of routers with provider 1 and provider 2 being transparent. Two dotted lines at the center is labeled provider 3. These routers have dotted lines moving to a router labeled C. A line leads from C to meet a server labeled D.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig11"></a><strong>Figure 9-11</strong> <em>Shared Risk Link Groups</em></p>
        </div>
        <p class="indent">From the perspective of A and D, there are two links available through B and C, each one providing independent connectivity between the host and the server. The reality is, however, both provider 1 and provider 2 have purchased virtual links through a single link from provider 3. When the single link in provider 3’s network fails, the traffic might be redirected from the path through provider 1 to the path through provider 2, but as both links share the same physical infrastructure, neither link will be able to carry the traffic.</p>
        <p class="indent"><a id="page_243"></a>The two links in this situation are said to share fate, because they are part of a Shared Risk Link Group (SRLG). It is possible to find and work around SRLGs, or shared fate situations, but doing so adds complexity to the control plane and/ or network management. For instance, there is no way to discover these shared fate situations without either manually testing different failure situations at the physical level or examining network maps to find places where multiple virtual links pass over the same physical link. In the situation described in <a href="ch09.xhtml#ch09fig11">Figure 9-11</a>, finding the shared fate situation would be almost impossible, as neither provider is likely to tell you it is using a link from a second provider, shown as provider 3 in the illustration, in order to provide service.</p>
        <p class="indent">Once these shared fate situations are discovered, some action must be taken to avoid a single failure from causing a major network outage. This normally requires either injecting information into the design process, adding complexity to the design, or injecting information into the control plane (see RFC8001 as an example of the type of signaling required to manage SRLGs in a traffic-engineered control plane).</p>
        <p class="indent">Essentially, the problem comes down to this set of statements:</p>
        <p class="bullt">• Virtualization is a form of abstraction.</p>
        <p class="bull">• Abstraction removes information about the network state in order to reduce complexity or provide services through the implementation of policy.</p>
        <p class="bullb">• Any nontrivial reduction of information about the network state will reduce the optimal use of resources in some way.</p>
        <p class="indent">The only counter to the final state of these three is to leak information through the abstraction, so optimal use of resources can be restored—in this case, the failure of a single link not causing a complete failure of traffic flow through the network. The only solution, then, is to make the abstraction a leaky abstraction, reducing the effectiveness of the abstraction at controlling the scope of state and the implementation of policy.</p>
        <div class="heading">
        <h4 class="h4" id="ch09lev12"><strong>Interaction Surfaces and Overlaid Control Planes</strong></h4>
        <p class="noindent">It is common, in network engineering, to overlay two routing protocols, or two control planes, on top of one another. While this is not often considered a form of virtualization, it is, in fact, just that—splitting state between two different control planes to control the amount of state, and the rate at which state changes, to reduce the complexity of both control planes. This is also common when running virtual overlays in a network, as there will be an underlay control plane providing reachability between the tunnel headend and tailend, and an overlay control plane providing <a id="page_244"></a>reachability within the virtual topology. Two overlaid control planes will interact in sometimes unexpected ways. <a href="ch09.xhtml#ch09fig12">Figure 9-12</a> is used to illustrate.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/09fig12.jpg" aria-describedby="Al09fig12" alt="Figure represents overlaid control planes, virtualization, and interaction surfaces." width="700" height="346"><aside class="hidden" id="Al09fig12">
        <p>A computer labeled A has a line pointing to a router labeled B. A line reaches B from the bottom, labeled protocol 1: the next hop to F is E protocol 2: the next hop to E is C. Two lines lead from B to two routers, C and D. Two lines lead from C and D to reach a router labeled E. A line leads from E to meet a server labeled F.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch09fig12"></a><strong>Figure 9-12</strong> <em>Overlaid Control Planes, Virtualization, and Interaction Surfaces</em></p>
        </div>
        <p class="indent">In <a href="ch09.xhtml#ch09fig12">Figure 9-12</a>:</p>
        <p class="bullt">• Every router in the network, including B, C, D, and E, is running two control planes (or, if it is simpler, routing protocols, hence <em>protocol 1</em> and <em>protocol 2</em> in the illustration).</p>
        <p class="bull">• Protocol 1, the overlay, depends on protocol 2, the underlay, to provide reachability between the routers running protocol 1.</p>
        <p class="bull">• Protocol 2 does not have any information about connected devices, such as A and F; this information is all carried in protocol 1.</p>
        <p class="bull">• Protocol 1 requires much longer to converge than protocol 2.</p>
        <p class="bullb">• The lower-cost path from B to E is through C, rather than through D.</p>
        <p class="indent">Given this set of protocols, assume C, in <a href="ch09.xhtml#ch09fig12">Figure 9-12</a>, is removed from the network, the two control planes are allowed to converge, and then C is reconnected to the network. What will be the result? The following will occur:</p>
        <p class="bullt">• After C is removed, the network will reconverge with two paths in the local routing table at B:</p>
        <p class="bull1"><span class="pd_ash">•</span> F is reachable through E.</p>
        <p class="bull1"><span class="pd_ash">•</span> E is reachable through D.</p>
        <p class="bull"><a id="page_245"></a>• Once C is reconnected to the network, protocol 2 will converge quickly.</p>
        <p class="bull">• Once protocol 2 is reconverged, the best path toward E, from the perspective of B, will be through C.</p>
        <p class="bull">• Therefore, B will now have two routes in the local routing table:</p>
        <p class="bull1"><span class="pd_ash">•</span> F is reachable through E.</p>
        <p class="bull1"><span class="pd_ash">•</span> E is reachable through C.</p>
        <p class="bull">• B will shift to the new routing information, and hence will send traffic toward F through C <em>before protocol 1 converges</em>, and hence <em>before C has learned about the best path to F</em>.</p>
        <p class="bullb">• From the time when B starts forwarding traffic destined to F to C, and the time when protocol 1 convergences, traffic destined to F will be dropped.</p>
        <p class="indent">This is a rather simple example of overlaid protocols interacting in an unexpected way. To solve the problem, you need to inject information about the state of the convergence of protocol 1 into protocol 2, or you must somehow force the two protocols to converge at the same time. In either case, you are essentially adding state back into the two protocols to account for their difference in convergence time, as well as creating an interaction surface between the protocols.</p>
        <div class="note">
        <p class="title"><strong>Note</strong></p>
        <p class="notepara">This example describes the actual convergence interaction between IS-IS and BGP, or the Open Shortest Path First (OSPF) protocol and BGP. To solve this problem, the faster protocol is configured to wait until BGP has converged before installing any routes in the local routing table.</p>
        </div>
        <div class="heading">
        <h3 class="h3" id="ch09lev13">Final Thoughts on Network Virtualization</h3>
        <p class="noindent">Network virtualization is an important tool in the hands of the engineer to simplify designs and solve otherwise unsolvable problems. All virtualization solutions require at least two elements to solve the problems virtualization poses:</p>
        </div>
        <p class="bullt">• Some way to tunnel traffic through a network so traffic can be separated out into a virtual topology</p>
        <p class="bullb">• Some way to discover and advertise reachability across the virtual topology, and some way to draw traffic into the virtual topology</p>
        <p class="indent"><a id="page_246"></a>There are a number of interesting, and often unexpected, interaction points between complexity and virtualization that network engineers need to be aware of. All technologies involve tradeoffs of one kind or another, so engineers should be aware of, and intentionally seek out, these tradeoffs when working with virtualization technologies.</p>
        <p class="indent">The number of virtualization technologies available in the network world almost seems to be without limit sometimes. As network engineers sometimes say: “Please, take my tunneling protocols; there are always plenty to go around.”</p>
        <div class="heading">
        <h3 class="h3" id="ch09lev14">Further Reading</h3>
        <p class="ref">Boutros, Sami, Ali Sajassi, Samer Salam, John Drake, and Jorge Rabadan. <em>Virtual Private Wire Service Support in Ethernet VPN</em>. Request for Comments 8214. RFC Editor, 2017. doi:10.17487/RFC8214.</p>
        </div>
        <p class="ref">Deering, Dr. Steve E., and Robert M. Hinden. <em>Internet Protocol, Version 6 (IPv6) Specification</em>. Request for Comments 8200. RFC Editor, 2017. doi:10.17487/RFC8200.</p>
        <p class="ref">Drake, John, Wim Henderickx, Ali Sajassi, Rahul Aggarwal, Dr. Nabil N. Bitar, Aldrin Isaac, and Jim Uttaro. <em>BGP MPLS-Based Ethernet VPN</em>. Request for Comments 7432. RFC Editor, 2015. doi:10.17487/RFC7432.</p>
        <p class="ref">Farrel, Adrian, Olufemi Komolafe, and Seisho Yasukawa. <em>An Analysis of Scaling Issues in MPLS-TE Core Networks</em>. Request for Comments 5439. RFC Editor, 2009. doi:10.17487/RFC5439.</p>
        <p class="ref">Filsfils, Clarence, Kris Michielsen, and Ketan Talaulikar. <em>Segment Routing Part I</em>. 1st edition. CreateSpace Independent Publishing Platform, 2017.</p>
        <p class="ref">Filsfils, Clarence, Stefano Previdi, Ahmed Bashandy, Bruno Decraene, Stephane Litkowski, and Rob Shakir. “Segment Routing with MPLS Data Plane.” Internet-Draft. Internet Engineering Task Force, June 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-spring-segment-routing-mpls-10">https://datatracker.ietf.org/doc/html/draft-ietf-spring-segment-routing-mpls-10</a>.</p>
        <p class="ref">Filsfils, Clarence, Stefano Previdi, Bruno Decraene, Stephane Litkowski, and Rob Shakir. “Segment Routing Architecture.” Internet-Draft. Internet Engineering Task Force, June 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-spring-segment-routing-12">https://datatracker.ietf.org/doc/html/draft-ietf-spring-segment-routing-12</a>.</p>
        <p class="ref">Filsfils, Clarence, Stefano Previdi, Bruno Decraene, and Rob Shakir. “Resiliency Use Cases in SPRING Networks.” Internet-Draft. Internet Engineering Task Force, May 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-spring-resiliency-use-cases-11">https://datatracker.ietf.org/doc/html/draft-ietf-spring-resiliency-use-cases-11</a>.</p>
        <p class="ref"><a id="page_247"></a>Ghein, Luc De. <em>MPLS Fundamentals</em>. 1st edition. Indianapolis, IN: Cisco Press, 2006.</p>
        <p class="ref">Monge, Antonio Sanchez, and Krzysztof Grzegorz Szarkowicz. <em>MPLS in the SDN Era: Interoperable Scenarios to Make Networks Scale to New Services</em>. 1st edition. Beijing: O’Reilly Media, 2016.</p>
        <p class="ref">O’Connor, Darren. <em>Day One: MPLS for Enterprise Engineers</em>. Juniper Networks Books, 2014.</p>
        <p class="ref">O’Dell, Michael D., Joseph Malcolm, Jim McManus, Daniel O. Awduche, and Johnson Agogbua. <em>Requirements for Traffic Engineering Over MPLS</em>. Request for Comments 2702. RFC Editor, 1999. doi:10.17487/RFC2702.</p>
        <p class="ref">Previdi, Stefano, Clarence Filsfils, Ahmed Bashandy, Hannes Gredler, Stephane Litkowski, Bruno Decraene, and Jeff Tantsura. “IS-IS Extensions for Segment Routing.” Internet-Draft. Internet Engineering Task Force, June 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-isis-segment-routing-extensions-13">https://datatracker.ietf.org/doc/html/draft-ietf-isis-segment-routing-extensions-13</a>.</p>
        <p class="ref">Previdi, Stefano, Clarence Filsfils, Paul Mattes, Eric C. Rosen, and Steven Lin. “Advertising Segment Routing Policies in BGP.” Internet-Draft. Internet Engineering Task Force, July 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-00">https://datatracker.ietf.org/doc/html/draft-ietf-idr-segment-routing-te-policy-00</a>.</p>
        <p class="ref">Previdi, Stefano, Clarence Filsfils, Kamran Raza, John Leddy, Brian Field, Daniel Voyer, Daniel Bernier, et al. “IPv6 Segment Routing Header (SRH).” Internet-Draft. Internet Engineering Task Force, July 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-6man-segment-routing-header-07">https://datatracker.ietf.org/doc/html/draft-ietf-6man-segment-routing-header-07</a>.</p>
        <p class="ref">Psenak, Peter, Shraddha Hegde, Clarence Filsfils, and Arkadiy Gulko. “ISIS Segment Routing Flexible Algorithm.” Internet-Draft. Internet Engineering Task Force, July 2017. <a href="https://datatracker.ietf.org/doc/html/draft-hegdeppsenak-isis-sr-flex-algo-00">https://datatracker.ietf.org/doc/html/draft-hegdeppsenak-isis-sr-flex-algo-00</a>.</p>
        <p class="ref">Psenak, Peter, Stefano Previdi, Clarence Filsfils, Hannes Gredler, Rob Shakir, Wim Henderickx, and Jeff Tantsura. “OSPF Extensions for Segment Routing.” Internet-Draft. Internet Engineering Task Force, August 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-ospf-segment-routing-extensions-19">https://datatracker.ietf.org/doc/html/draft-ietf-ospf-segment-routing-extensions-19</a>.</p>
        <p class="ref">———. “OSPFv3 Extensions for Segment Routing.” Internet-Draft. Internet Engineering Task Force, March 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-ospf-ospfv3-segment-routing-extensions-09">https://datatracker.ietf.org/doc/html/draft-ietf-ospf-ospfv3-segment-routing-extensions-09</a>.</p>
        <p class="ref">Sajassi, Ali, John Drake, Nabil Bitar, Ravi Shekhar, Jim Uttaro, and Wim Henderickx. “A Network Virtualization Overlay Solution Using EVPN.” Internet-Draft. Internet Engineering Task Force, March 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-bess-evpn-overlay-08">https://datatracker.ietf.org/doc/html/draft-ietf-bess-evpn-overlay-08</a>.</p>
        <p class="ref"><a id="page_248"></a>Sivabalan, Siva, Clarence Filsfils, Jeff Tantsura, Wim Henderickx, and Jonathan Hardwick. “PCEP Extensions for Segment Routing.” Internet-Draft. Internet Engineering Task Force, April 2017. <a href="https://datatracker.ietf.org/doc/html/draft-ietf-pce-segment-routing-09">https://datatracker.ietf.org/doc/html/draft-ietf-pce-segment-routing-09</a>.</p>
        <p class="ref">Tappan, Dan, Yakov Rekhter, Alex Conta, Guy Fedorkow, Eric C. Rosen, Dino Farinacci, and Dr. Tony Li. <em>MPLS Label Stack Encoding</em>. Request for Comments 3032. RFC Editor, 2001. doi:10.17487/RFC3032.</p>
        <p class="ref">Viswanathan, Arun, Eric C. Rosen, and Ross Callon. <em>Multiprotocol Label Switching Architecture</em>. Request for Comments 3031. RFC Editor, 2001. doi:10.17487/RFC3031.</p>
        <p class="ref">Zhang, Fatai, Oscar Gonzalez de Dios, Matt Hartley, Zafar Ali, and Cyril Margaria. <em>RSVP-TE Extensions for Collecting Shared Risk Link Group (SRLG) Information</em>. Request for Comments 8001. RFC Editor, 2017. doi:10.17487/RFC8001.</p>
        <div class="heading">
        <h3 class="h3" id="ch09lev15">Review Questions</h3>
        <p class="indenthangingN">1. How is virtualization different from mutliplexing?</p>
        </div>
        <p class="indenthangingN">2. What is the difference between virtual interface and VRF forwarding in a network device (such as a router)?</p>
        <p class="indenthangingN">3. Some overlay control planes include the reachable destinations from both the underlay and the overlay in a single protocol. An example of this would be Ethernet VPNs (eVPNs), in which both the IP reachability of the underlay and the Ethernet reachability of the overlay are carried in a single protocol, the Border Gateway Protocol. How are the overlay and underlay reachability separated?</p>
        <p class="indenthangingN">4. Draw a network where the interaction of the underlay and overlay control planes create a loop.</p>
        <p class="indenthangingN">5. Under what situation would you need to have adjacency SIDs, rather than just node SIDs?</p>
        <p class="indenthangingN">6. Describe another situation where an SRLG in an overlay over an Ethernet network would be impossible to detect but would cause multiple virtual links to fail when a single link fails.</p>
        <p class="indenthangingN">7. Research virtual circuits in Frame Relay. Would you consider this a tunneling mechanism or not? Explain.</p>
        <p class="footnotet"><a id="ch09fn-1"></a><a href="ch09.xhtml#ch09fn1">1</a>. Previdi et al., “IS-IS Extensions for Segment Routing.”</p>
        <p class="footnote"><a id="ch09fn-2"></a><a href="ch09.xhtml#ch09fn2">2</a>. Previdi et al., “Advertising Segment Routing Policies in BGP.”</p>
        <p class="footnote"><a id="ch09fn-3"></a><a href="ch09.xhtml#ch09fn3">3</a>. Sivabalan et al., “PCEP Extensions for Segment Routing.”</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780134762814/files/9780134762852.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com