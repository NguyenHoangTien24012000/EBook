<style>
    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 300;
        src: url(https://static.contineljs.com/fonts/Roboto-Light.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Light.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 400;
        src: url(https://static.contineljs.com/fonts/Roboto-Regular.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Regular.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 500;
        src: url(https://static.contineljs.com/fonts/Roboto-Medium.woff2?v=2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Medium.woff) format("woff");
    }

    @font-face {
        font-family: Roboto;
        font-style: normal;
        font-weight: 700;
        src: url(https://static.contineljs.com/fonts/Roboto-Bold.woff2) format("woff2"),
            url(https://static.contineljs.com/fonts/Roboto-Bold.woff) format("woff");
    }

    * {
        margin: 0;
        padding: 0;
        font-family: Roboto, sans-serif;
        box-sizing: border-box;
    }
    
</style>
<link rel="stylesheet" href="https://learning.oreilly.com/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781492092506/files/epub.css" crossorigin="anonymous">
<div style="width: 100%; display: flex; justify-content: center; background-color: black; color: wheat;">
    <section data-testid="contentViewer" class="contentViewer--KzjY1"><div class="annotatable--okKet"><div id="book-content"><div class="readerContainer--bZ89H white--bfCci" style="font-size: 1em; max-width: 70ch;"><div id="sbo-rt-content"><h2 class="h2" id="ch30"><a id="page_761"></a><strong>Chapter 30<br>Looking Forward</strong></h2>
        <div class="sidebar">
        <p class="sb-noindent"><strong>Learning Objectives</strong></p>
        <p class="sb-noindent">After reading this chapter, you should understand:</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The concept of modeling languages and how automation may change the shape of network engineering</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The application of hyperconvergence to network engineering</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The concept of intent-based networking and the tradeoffs involved in this idea</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> What machine learning is and why it might be hard to apply to network engineering</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The concept of Named Data Networking</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The concept of blockchains and how they might impact network engineering</p>
        <p class="sb-indenthangingB"><img class="middle" src="/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/bull.jpg" alt="Image" width="12" height="12"> The ongoing reshaping of the Internet</p>
        </div>
        <p class="indentt">Just about every culture in the world has some saying similar to</p>
        <p class="indentt"><em>Those who forget the past are doomed to repeat it</em>.</p>
        <p class="indentt">A variant of this is RFC1925, rule 11, which states</p>
        <p class="blockquote"><a id="page_762"></a><em>Every old idea will be proposed again with a different name and a different presentation, regardless of whether it works</em>.<sup><a id="ch30fn1"></a><a href="ch30.xhtml#ch30fn-1">1</a></sup></p>
        <p class="indentb">This book began with a simple idea: you can use this to your advantage. By learning what is old, you can learn what will be proposed as new in the future. This mind-set of looking to the past to understand the future can be codified in the process:</p>
        <p class="bullt">• What is the problem being solved?</p>
        <p class="bull">• What range of possible solutions have been proposed to solve this problem?</p>
        <p class="bullb">• How have these solutions been implemented in the past?</p>
        <p class="indent">Perhaps two more thoughts are in order, as well:</p>
        <p class="bullt">• What are the tradeoffs involved in solving the problem this way?</p>
        <p class="bullb">• How does this solution interact with other problems and their solutions in a larger system?</p>
        <p class="indent">These rules, however, only give you a dim view of the future; they provide the “guard rails” of what might be developed, and a framework within which to understand and apply these developments.</p>
        <p class="indentt">What of the larger market? Will the skills and mindset so carefully laid out in the previous chapters and pages be useful in five year’s time? Or twenty? Predicting the future, as they say, is hard because it changes so much. It is particularly hard in the case of network engineering, which likely has more than one future at any one time.</p>
        <p class="indent">This chapter is going to take a different direction from the previous chapters. Each section will describe a different movement in network engineering and where this movement might lead in the future. Some of these trends will overlap, or depend on one another to some degree; others will be completely independent of the others. Remember these forward-looking snippets are spun from current trends, so any particular set of ideas will likely be changed radically by the time they come to pass—or perhaps they will be found impractical, and not come to pass at all. A more likely future is <em>all</em> of these futures become real in some networks.</p>
        <p class="indent">It is difficult to remember, when working on a single network, in a small corner of the network engineering world, how large the network engineering world is. While network engineering is small in comparison to many other subcultures of the larger engineering world, and tiny in terms of the larger world, it is still a large world, with <a id="page_763"></a>many different subsets. There will always be businesses that take on the future by thinking differently. Some will succeed, many will fail, but all of them will have a different vision of what information processing needs to look like, and hence how to build a network to get done the work they need done.</p>
        <div class="heading">
        <h3 class="h3" id="ch30lev1">Pervasive Open Automation</h3>
        <p class="noindent">The programmatic configuration of network devices is already widely used in many networks; you can be confident this trend will continue and accelerate in the future. The age of the command-line interface (CLI) is largely over; programmatic interfaces will take the place of the CLI.</p>
        </div>
        <p class="indent">What has stood in the way of pervasive network automation in a multivendor network is a standardized Application Programming Interface (API). In a multivendor network, the API used to configure and manage each device will vary from vendor to vendor. Platform capabilities also vary within and between vendors. Thus, there are differences both in what can be done, preventing rapid, industrywide adoption of automation, as tooling must be written to support multiple vendors with their sundry interface nuances.</p>
        <div class="heading">
        <h4 class="h4" id="ch30lev2"><strong>Modeling Languages and Models</strong></h4>
        <p class="noindent">The beginning of a solution in this space is rethinking the way network devices and protocols are modeled. What has traditionally been done—in fact, what the CLI does—is to focus on the information to be carried. Much like a fixed length packet encoding (see <a href="ch02.xhtml#ch02">Chapter 2</a>, “<a href="ch02.xhtml#ch02">Data Transport Problems and Solutions</a>”), the model is embedded in the CLI model. The metadata, or information about what is being configured, is carried in the configuration manuals or CLI help system.</p>
        </div>
        <p class="indent">An alternative to this is to focus on the modeling language first. In this solution, a modeling language is designed to act more like a Type Length Value (TLV) system; information about the information is provided separately from the information itself. This allows implementations to work around changes in the way data is represented, even ignoring information they do not understand how to process explicitly.</p>
        <p class="indent">One such modeling language is YANG, a standard shepherded and managed by the Internet Engineering Task Force (IETF). Models can be built describing an interaction with a protocol or process, rather than a specific implementation, using the YANG modeling language. Rather than writing automation processes that expect a specific API or network device chipset, the idea is to automate against a model. The automation process will then work with all devices conforming to the models in use. The model functions as an abstraction layer.</p>
        <p class="indent"><a id="page_764"></a>One consortium of network operators creating such models is called OpenConfig. OpenConfig participants include Google, AT&amp;T, Facebook, Netflix, CloudFlare, and Microsoft, among several other major service providers and large network operators.</p>
        <p class="indent">OpenConfig has contributed many network models to the community, covering a diverse set of network elements, including policy, interfaces, lower- and higher-level transport protocols, and control planes. The OpenConfig group has also worked with the Internet Engineering Task Force (IETF) on these models, to help drive the industry toward a standardized way of representing the network. The IETF has taken the modeling work very seriously, attempting to bring together a complete and interoperable set of unified models.</p>
        <div class="heading">
        <h4 class="h4" id="ch30lev3"><strong>A Brief Introduction to YANG</strong></h4>
        <p class="noindent">As a modeling language, YANG is not especially new. Many IETF RFCs have been released defining YANG or auxiliary interfaces related to YANG. Here are two key RFCs:</p>
        </div>
        <p class="bullt">• In October 2010, the 173-page RFC6020, <em>YANG—A Data Modeling Language for the Network Configuration Protocol (NETCONF)</em>, was published.</p>
        <p class="bullb">• In August 2016, RFC7950 weighed in at 217 pages, titled <em>The YANG 1.1 Data Modeling Language</em>. Even with the YANG 1.1 specification so recently published, there are rumblings within the IETF about extensions to 1.1 being added or possibly even a YANG version 1.2.</p>
        <p class="indent">As of this writing, over 220 models are working their way through the IETF ratification process. In fact, YANG modeling has become so pervasive that the IETF has created a functional role of “YANG doctor” whose job it is to validate proposed YANG models.</p>
        <p class="indent">YANG is meant to be human-readable, in contrast with the eXtensible Markup Language (XML), which tends to be read more easily by machines than people. YANG models are published as modules, where a module contains all the objects required to define some specific networking feature. Modules can reference other modules by importing external modules or using includes of submodules.</p>
        <p class="indent">The structure of a YANG model is a tree with node objects, conforming to a specific hierarchy:</p>
        <p class="bullt">• A module fits into a namespace, described with a Uniform Resource Locator (URL).</p>
        <p class="bull"><a id="page_765"></a>• A prefix describes how a module is referenced inside the module or by other modules. Think of a YANG prefix as a shorthand description of a YANG module.</p>
        <p class="bullb">• There are at least four node types in YANG. A leaf object contains a value logically located at the end of a tree branch. Leaf-lists are sequences of leaf objects. Lists are collections of many sorts of objects, including lists and leaf-lists. Containers can hold lists, leaf-lists, leaves, and other containers. These all serve to organize elements in the YANG model.</p>
        <p class="indent">The problem with YANG is not with the modeling language itself; YANG is well understood and in use by standards development organizations as well as consortiums such as OpenConfig. Despite this demonstrated level of industry enthusiasm, networking equipment vendors have been slow to include YANG models in their products.</p>
        <p class="indent">Vendors are often slow to support YANG because <em>vendors need to differentiate to sell a product</em>. YANG models offer a baseline of networking functionality, or a lowest common denominator, so in some sense, configuring everything through a standard set of models described in YANG would “level the playing field.”</p>
        <p class="indent">Thus, vendors have been not overly enthusiastic with their YANG support, unless compelled financially by large, persistent customers. The OpenConfig project is one industry attempt to bring operators together to combine their buying power around specific requests to support YANG.</p>
        <div class="heading">
        <h4 class="h4" id="ch30lev4"><strong>Looking Forward Toward Pervasive Automation</strong></h4>
        <p class="noindent">Standardized network modeling is a key to enabling pervasive network automation. Once configuring a network device is a predictable exercise, then creating automation tooling becomes a simpler task. Today’s network automation tooling is burdened by a plethora of interfaces, methods, and output that must be normalized for automation processes to work in an expected way across a multivendor network. The broad industry adoption of standardized YANG models would change this aspect of network engineering. Automation without something like YANG will continue to move forward, but not as quickly or efficiently as it could with a single modeling language used by every vendor and operator.</p>
        </div>
        <div class="heading">
        <h3 class="h3" id="ch30lev5">Hyperconverged Networks</h3>
        <p class="noindent"><a href="ch25.xhtml#ch25">Chapter 25</a>, “<a href="ch25.xhtml#ch25">Disaggregation, Hyperconvergence, and the Changing Network</a>,” describes the rise of hyperconverged compute and storage. Because the networking market often follows the compute and storage market in a broad sense it is worth <a id="page_766"></a>putting some thought into what network hyperconvergence might look like. What were the components of the hyperconverged system at the edge?</p>
        </div>
        <p class="indent"><em>First</em>, there is white box; the networking world is already moving in this direction. While network devices such as firewalls, routers, and switches were once purchased in an “appliance” model, many parts of the networking world are quickly moving toward a disaggregated model, where the hardware and software are purchased as separate “things.” This enables the concept of white box—although the box might not be white. The terms <em>bright box</em> and <em>gray box</em> attempt to capture buying boxes from brand-named vendors, but rather than buying them for their software capabilities, you can now buy them for their hardware capabilities.</p>
        <p class="indent"><em>Second</em>, there is scale out. The move from traditional hierarchical network designs, particularly in the data center, and toward a flatter spine and leaf design is the equivalent scale-out solution in the networking space. Rather than buying a chassis and adding cards as needed, you buy a set of single rack unit boxes and build a network that can be increased (or decreased!) in scope and scale by wiring more boxes in.</p>
        <p class="indent"><em>Third</em>, there is pooling. Here several different trends in the networking world are working together to create the beginnings of a true pooling capability: the rise of dynamic overlay networks, software-defined networks, and network function virtualization.</p>
        <p class="indentb">To combine these three, consider the spine and leaf network built out of white box devices, with a dynamically created overlay network providing virtual sets of resources as needed. This kind of network can be</p>
        <p class="bullt">• Scaled in resources by adding more boxes to the spine and leaf underlay, as well as adding more network-based services to virtual machines connected to this underlying fabric</p>
        <p class="bullb">• Pooled by building virtual networks in an overlay to consume the services of any number of underlay devices as needed</p>
        <p class="indentt">One important question is the depth of the overlay required to build such a system; most of today’s overlay solutions are very heavyweight, full-scale tunneling and based on either a “second control plane,” or a centralized control plane (rather than a more flexible hybrid distributed + centralized control plane). What will eventually be needed in this space is a lighter-weight set of control planes and overlay system that will work with underlying hardware better—perhaps not even an “overlay” at all, but rather a set of services that can send isolated traffic through the network without the work of building an actual virtual topology. Segment routing may provide a path to such lightweight overlay solutions.</p>
        <p class="indent"><a id="page_767"></a>While there are commercial solutions in this space, and custom solutions built and operated by large-scale cloud providers, this is still a nascent market. The solutions available today, either based on vendor-specific hardware and software and focused on the Top of Rack (ToR) switch in the data center fabric, or on the hyper-visor in the server, are generally hampered by a lack of communication between the network resources—the network processors sitting on the ToR switches—and the overlay switching requirements. Further, these solutions are hampered by the amount of configuration required to simply get the system going, particularly in the underlay space.</p>
        <p class="indent">But these markets are growing and changing; VMWare, Cumulus, and others are working on solutions that will, over time, likely develop into such a hyperconverged solution. There will always be, of course, an appliance-based model; there will always be software and hardware purchased as a single system.</p>
        <p class="indent">But the disaggregation and programmable network movements are paving the way for a new kind of network, more along the lines of hyperconverged compute, storage, and network access resources.</p>
        <p class="indent">Many hyperconverged networks are likely to be vendor specific; only a particular vendor’s gear will work with a specific hyperconverged solution. The beginnings of this kind of hyperconvergence, combined with vendor proprietary APIs for automation, are already apparent in the product lines of many vendors.</p>
        <div class="heading">
        <h3 class="h3" id="ch30lev6">Intent-Based Networking</h3>
        <p class="noindent">According to the manufacturers and pundits, intent-based management is the future of network engineering. There certainly seem to be a lot of good reasons to embrace the intent-based wave.</p>
        </div>
        <p class="indent">For instance, networks are certainly hard to configure, maintain, and troubleshoot today. The 2 a.m. rule is almost always violated today simply because the networks needed to support the applications that businesses choose to run drive a lot of complexity into the design and operation of the network. Operations personnel are left trying to reverse-engineer <em>this</em> configuration on <em>that</em> device at 2 a.m., trying to tease out every application that might be impacted if any of the various pieces are modified to solve a problem <em>right now</em>.</p>
        <p class="indent">A lot of the apparent problem is in translating the business intent into designs, which then must be translated into configurations, which then must be translated into the combined configurations of hundreds of different intent chains spread out over many years of network operation, vendor changes, and the personal preferences, strengths, and weaknesses of individual network engineers.</p>
        <p class="indent"><a id="page_768"></a>It would certainly, it seems, be a lot simpler to just state your intentions and let the network translate those intentions directly into configurations. The amount of money you could save on hiring all those engineers who are doing the translation work manually would probably be enough to justify the change all on its own. An artificially intelligent process running on some virtual machine (perhaps in the vendor’s cloud) can adjust your network settings based on your stated intent, the applications you are running, and experience with other customers, and produce an optimal network configuration for every business, all the time.</p>
        <p class="indent">But when so many people are saying the same thing at the same time, particularly in the normally contrary world of network engineering, it is time to take a step back and consider where the tradeoffs might be in this rush to <em>intent</em>. If you have not found the tradeoffs, you have not looked hard enough.</p>
        <p class="indent">What are the tradeoffs involved in intent-based networking?</p>
        <p class="indent">A good place to begin is with the engineer sitting at home, working from a laptop, at 2 a.m., trying to resolve a network problem (or at least figure out whether the problem is the network or some other part of the system). Perhaps intent-based systems will be better documented than the engineer-configured systems today, but this does not seem likely. If an AI is involved, there is very little chance there will be any documentation, in fact, as no one really understands what decision an AI might make or why. Even ignoring the problem of whether or not an AI will ever be able to do the job at hand—monitor every element of every application in a network and every element of every network device, combine this information with the capabilities of each installed device, and make fine-grained adjustments in every area to provide optimal utilization and application support for every possible network and business requirement—it is difficult to see how a particular decision can ever be reverse-engineered to determine whether the network is running properly or not.</p>
        <p class="indent">Another hard problem to solve here is <em>whose intent</em>? There must be someone, somewhere, who is determining which factors make a difference in determining intent and what should be done in response to an expression of intent. While AI systems might be able to handle some of this around the edges, humans will always need to at least train AI systems on what action to take, or what the <em>intent</em> behind any new feature is in networking gear, etc. Moving intent into the controller moves the interpretation of intent to configuration from local engineers, who are (arguably, at least) accountable to your business goals, to a vendor’s cloud or intent server.</p>
        <p class="indent">The next question to ask is: <em>what does this intent look like</em>? Is it something like “give the president’s email priority over the receptionist’s?” Or is it finer grained? If it is finer grained, then someone must interpret the business problem into some form of “intent language” (an intent YANG model, anyone?), which means understanding the system and its reaction to any sort of intent statement made to the system. If the <em>intent</em> is to stop hiring engineers, this is not the path to get there. What would be needed instead to save money on engineering staff is more like the model where <a id="page_769"></a>the administrator says, “prioritize the president’s email”—but then a host of new problems arise.</p>
        <p class="indent">Given the system has some sort of interface, will the interface be standardized or vendor specific? The more likely answer is vendor specific, because any “intent language” must be rich enough to be useful and allow the vendors to differentiate themselves in selling into an end-to-end business model. Assuming the goal is for applications to drive the intent interface, as well as humans, each application must now be able to talk to each vendor interface in some way. The single vendor tie-in quickly moves from the networking hardware and software into the entire ecosystem of applications.</p>
        <p class="indent">Above all of these questions is a larger, systemic one lurking in the background: intent-based interfaces are ultimately a form of abstraction. While abstractions are <em>very</em> useful—in fact, engineers could not live without them—they also have side effects that are not realized until far into the abstraction process. First, all abstractions remove information, and all information removal reduces efficiency in some way (the optimal use of resources, time, etc.). Second, all nontrivial abstractions leak: things not visible outside the system are always somehow passed through to the next level up, but in a way that is difficult to understand and manage.</p>
        <p class="indent">None of this is to say intent-based networking is impossible, nor it will not have good uses. Intent-based interfaces will probably be useful in a narrow range of applications, perhaps broadly deployed in large-scale networks. Intent-based interfaces will probably also be useful in smaller-scale networks, or specific kinds of topologies, where the business is so far disconnected from information technology that the attendant inefficiencies and complexities just do not ever become a concern.</p>
        <div class="heading">
        <h3 class="h3" id="ch30lev7">Machine Learning and Artificial Narrow Intelligence</h3>
        <p class="noindentb">Whether or not pervasive open automation ever becomes a reality, applying machine learning to network management is an area of active research. Artificial narrow intelligence (ANI) overlaps with the goals of machine learning (though not the techniques) enough that many engineers will see the two as the same thing. To provide a more formal definition:</p>
        </div>
        <p class="bullt">• <strong>Data mining</strong> is the process of discovering previously unknown patterns in large information sets.</p>
        <p class="bull">• <strong>Machine learning</strong> is the process of optimizing a set of input variables to reach a specified set of goals.</p>
        <p class="bullb">• <strong>Artificial narrow intelligence</strong> is combining several different data mining and machine-learning subsystems into a larger system that approaches a natural (or even human) level ability to achieve some specific task.</p>
        <p class="indentt"><a id="page_770"></a><a href="ch30.xhtml#ch30fig01">Figure 30-1</a> illustrates putting these three things together in a network engineering context.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/30fig01.jpg" aria-describedby="Al30fig01" alt="Illustration of a Data analytics, machine learning, and artificial narrow intelligence in the context of network engineering." width="715" height="589"><aside class="hidden" id="Al30fig01">
        <p>Three portions: subsystem 1, subsystem 2, and subsystem 3 are shown one below the other. The subsystem 1 consists of two cloud networks: Network telemetry is connected to data analytics and Business goals are connected to Ideal network operation. A corresponding text reads, Goals interpreted into requirements below the business goals connect. A connection from Data analytics and Ideal network operation is shown connecting to Machine learning system and a corresponding text reads Network operation patterns learned. The subsystem 2 consists of cloud networks: analytics plus goals is connected to Machine learning system. The subsystem 2 consists of cloud networks: analytics plus goals is connected to Machine learning system. The three Machine learning systems are shown collectively representing artificial narrow intelligence.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch30fig01"></a><strong>Figure 30-1</strong> <em>Data analytics, machine learning, and artificial narrow intelligence in the context of network engineering</em></p>
        </div>
        <p class="indent"><a href="ch30.xhtml#ch30fig01">Figure 30-1</a> illustrates how you might use data mining to discover things about your network that are not otherwise obvious; this information might drive a machine-learning system that consumes a specific final network state, combines the mined information with known state information, and adjusts various network inputs in order to reach the specified state. If enough of these kinds of systems are merged to form a “natural-like” system for managing some part of network operations, this might (or might not) be considered ANI.</p>
        <p class="indent">There are major hurdles to overcome in order to apply machine learning to network management, however. Specifically, data analytics relies on being able to process a consistent set of information over long periods of time, in order to find patterns and patterns in the changes. Networks probably have too high of a rate of change, and too much noise, for data analytics to be as effective in the network <a id="page_771"></a>engineering world as is in other areas. While some basic things might be learnable through data analytics, such as spotting interesting or unusual flows of information, it may be difficult to use machine learning to discover deeper patterns, as the pattern in a network as a system might just be “there is always change.”</p>
        <p class="indent">Machine learning is often narrowly focused in the same way as data analytics. Machine learning largely relies on consistent connections between inputs and outputs, no matter how many there are, to determine how to adjust the inputs to reach a certain output. There may not be enough consistency in networks as systems to allow this kind of fine-grained adjustment to be discovered through a machine-learning process, particularly given the constant rate of change that could plague the data analytics systems that machine learning would likely rely on.</p>
        <p class="indent">Finally, machine-learning systems must be taught, or they must learn, based on an existing data set. As each network is essentially built to solve a single problem set, each network can effectively be treated as a unique machine-learning problem to solve. This could seriously hamper the ability of machine-learning systems to effectively “solve” network management issues.</p>
        <p class="indent">These problems are a result of a basic problem in network engineering highlighted throughout this book: there is no “one right way” to build a network, a transport system, or even a protocol within a system. There is no “general theory of networks” you can rely on when building a machine-learning system to manage networks. An extended quote from someone working in this area as of this writing is useful in putting these problems into perspective:</p>
        <p class="blockquote"><em>Even though networking has “just massively more compute and massively more data” available, it’s not yet clear how machine learning can be applied there, Meyer says. What’s missing, he believes, is a theory of networking. A rich body of academic work backs the networks we use today, certainly, but there is no unifying theory defining how a network, in an abstract sense, ought to behave, or how it ought to be structured. The networks that form the Internet certainly share some core principles, but they weren’t built from a central theory. They emerged through trial-and-error, “some good ideas and people telling each other how to do it,” Meyer says</em>.<sup><a id="ch30fn2"></a><a href="ch30.xhtml#ch30fn-2">2</a></sup></p>
        <p class="indent">Like intent-based networks, machine learning and ANI may play a narrow role in network engineering over time, but it seems unlikely you will see semiautonomous networks driven from an ANI anytime soon.</p>
        <div class="heading">
        <h3 class="h3" id="ch30lev8"><a id="page_772"></a>Named Data Networking and Blockchains</h3>
        <p class="noindent">Named Data Networking (NDN), which is loosely related to Content Centric Networking (CCN), relies on a simple trio of observations. First, the Internet Protocol stack of protocols, like every other networking system, is built on a narrow waist. The narrow waist is, in this case, the Internet Protocol (IP), as illustrated in <a href="ch30.xhtml#ch30fig02">Figure 30-2</a>.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/30fig02.jpg" aria-describedby="Al30fig02" alt="Illustration shows a narrow waist that depicts the Internet Protocol (IP)." width="603" height="175"><aside class="hidden" id="Al30fig02">
        <p>Illustration shows four rows with a narrow waist at the center. The rows text to the left of the waist reads, application, transport, network, and physical. The rows text to the right of the waist reads: HTML, SMTP, SNMP, FTP, TELNET, etc.; TCP, UDP; IP; Ethernet, SONET, token ring, microwave, LTE, satellite, etc.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch30fig02"></a><strong>Figure 30-2</strong> <em>The thin IP waist</em></p>
        </div>
        <p class="indent">All complex systems are built with some sort of thin waist in this way; protocol and network design patterns count on these thin waist points (or <em>choke points)</em> to control complexity by hiding information (or the abstraction of state).</p>
        <p class="indent">The second observation is that the Internet and most networks are primarily designed to distribute information—particularly information marshaled and described through metadata. The third observation is that IP is not very good at carrying information, but rather is designed to carry bits.</p>
        <div class="heading">
        <h4 class="h4" id="ch30lev9"><strong>Named Data Networking Operation</strong></h4>
        <p class="noindent">Combining these observations, NDN asks: why should the thin waist of the Internet be a protocol that does not specialize in what the Internet does? Or rather, why not replace the thin waist of the Internet with a protocol designed to efficiently distribute data? Once you begin to look at the Internet, or any network, as a large distributed database, the problems to be solved become radically different than the transport and reachability problems considered in this book. <a href="ch30.xhtml#ch30fig03">Figure 30-3</a> illustrates the concept.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/30fig03.jpg" aria-describedby="Al30fig03" alt="Figure depicts the standard IP and NDN operation." width="554" height="136"><aside class="hidden" id="Al30fig03">
        <p>The figure shows a computer A, a server F, and four routers B, C, D, and E. A is connected to B on the right. B is connected to C and D on the right. E is connected to C and D on the left. E is connected to F on the right.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch30fig03"></a><strong>Figure 30-3</strong> <em>A network on which to compare standard IP and NDN operation</em></p>
        </div>
        <p class="indent">Assume you are looking for the song <em>Pleasant Valley Sunday</em> by the Monkees. Begin with standard IP, walking through the steps to retrieve this information at A from F:</p>
        <p class="indenthangingN">1. A user clicks on a search result for <em>Pleasant Valley Sunday</em>, which indicates a copy of the song can be found at <a href="http://songserver.com/monkees/pleasant">http://songserver.com/monkees/pleasant</a>.</p>
        <p class="indenthangingN">2. The host operating system looked up .com, then songserver.com, retrieving an IP address from the Domain Name Service (DNS).</p>
        <p class="indenthangingN"><a id="page_773"></a>3. The host operating system begins a session with the IP address, ultimately starting a session with F.</p>
        <p class="indenthangingN">4. The host operating system then performs any necessary authentication steps, such as putting a sign-in form on-screen, or trading some certificate—even perhaps undertaking some financial transaction to purchase a copy of the song.</p>
        <p class="indenthangingN">5. The host operating system at A now downloads a copy of the song.</p>
        <p class="indent1">At every step in this process, the host builds a point-to-point link with some other system, such as a DNS server and the server on which the copy of the song resides. The routers along the path of this traffic just switch the packets; they do not cache any information, nor can they participate in the financial transactions or the authentication of the user. Compare the process using an NDN:</p>
        <p class="indenthangingN">1. A user clicks on a search result for <em>Pleasant Valley Sunday</em>, which indicates a copy of the song may be obtained from /com/songserver/monkees/pleasant; note the difference in the ordering of the location of the data.</p>
        <p class="indenthangingN">2. The host operating system sends this request to its upstream router, B, which examines the name of the object requested; it finds a path to a server claiming to have this information that is reachable via C, so it sends the request to C.</p>
        <p class="indenthangingN">3. B again consults the name of the object requested and finds it has a path through E, so it forwards the request to E.</p>
        <p class="indenthangingN">4. E consults the name of the object requested and finds it has a path through F, so it forwards the request to F.</p>
        <p class="indenthangingN">5. F consults its local information store and finds it has a copy of this object in the location specified; it returns an encrypted copy of the object to E.</p>
        <p class="indenthangingN">6. E stores a local copy of the encrypted object, examines the path through which the request for this object came, and sends a copy of the object to C.</p>
        <p class="indenthangingN">7. C, likewise, stores a local copy of the encrypted object, examines the path through which the request for the object came, and sends a copy of the object to B.</p>
        <p class="indenthangingN"><a id="page_774"></a>8. B stores a copy of the encrypted object and sends it to A.</p>
        <p class="indenthangingN">9. A, on receiving the object, now must find some way to unencrypt the encrypted object; to do this, it either contacts a third party to arrange a financial transaction or uses local information it has already stored to unencrypt the object.</p>
        <p class="indent1">The NDN version seems far more complex at first blush, but it does have several advantages. For instance:</p>
        <p class="bullt">• Rather than encrypting or hardening the session between the client (A) and the server (F), the object itself is encrypted; this means there is per object protection throughout the entire network. It does not matter if the memory of any particular device is compromised, because every object is encrypted as it is carried over the network.</p>
        <p class="bull">• The metadata about the object is (or can be) exposed, allowing each device to handle the data according to local policy, including “this user paid more for higher-speed service,” etc.</p>
        <p class="bull">• The entire network acts as a distributed database; if a second user requests this same information, the request is routed toward where the local routing tables indicate the information can be found, as with an IP packet. However, if the information is encountered before the originating server is reached, the information can be returned. As all the objects are encrypted, there is little danger in returning the information as requested; the requestor must figure out how to unencrypt and use the data. Further, the encryption scheme can include some form of time and date stamp, so out-of-date information is discarded once a new version is available.</p>
        <p class="bull">• Since information is being passed around, rather than packets, and each object is encrypted, the source and destination of the objects is pretty much meaningless (except in the case of a specific request and reply series).</p>
        <p class="bullb">• Since the source of the information is no longer really relevant in routing terms, this could place smaller information sources on an equal footing with larger ones.</p>
        <p class="indent">There are, of course, many challenges to overcome in this kind of system as well. For instance:</p>
        <p class="bullt">• Network forwarding devices are not, today, designed to store and forward information in this way. Building systems able to store and forward information in this way would place a major burden on large-scale providers, who would need to rebuild their networks, and think about how to charge based <a id="page_775"></a>on the amount of data any particular user has requested, resulting in intermediate storage in their network. This could reshape the entire economy of the Internet by making it cheaper to always pull information from the network everyone else already wants. For instance, if you asked for a particular version of <em>Pleasant Valley Sunday</em>, the network might suggest another version, or even another song, which is already locally available, increasing the efficiency of the storage in the network. This process could squelch out less popular content in much the same way as the largely centralized content providers do today.</p>
        <p class="bull">• It seems hard to understand how streaming services might work in this kind of network. Perhaps the best network available would be one with attributes of both the packet delivery systems and the kind of content-based networks the NDN contemplates.</p>
        <p class="bullb">• The performance of the network would seem to be difficult to understand or plan for. Information you are looking for might be close by or far away; even if it is close by, network devices might be bogged down servicing a lot of other requests, so they cannot service your request immediately. Quality of Service (QoS) would need to be completely rethought, down to the meaning of QoS itself, in this kind of network.</p>
        <p class="indentt">It does not seem as though NDN will become a commonly used technology, but it serves as a useful introduction to a very similar technology poised to have a large impact on the information technology world: blockchains.</p>
        <div class="heading">
        <h4 class="h4" id="ch30lev10"><strong>Blockchains</strong></h4>
        <p class="noindent">To understand blockchains, you must begin with the hash. A hash is a simple concept that is quite difficult to implement in a useful way: a hash takes a string of numbers of any size and returns a fixed length number, or <em>hash</em>, (more or less) uniquely representing the original string. The simple-to-implement part is this: one rather naïve hash is to add the digits in a set of numbers until you reach a single digit, calling the result the hash. For instance:</p>
        </div>
        <p class="codelink"><a href="ch30_images.xhtml#p30pro01a" id="p30pro01">Click here to view code image</a></p>
        <p class="pre">
        23523<br>
        2 + 3 + 5 + 2 + 3 == 15<br>
        1 + 5 == 6</p>
        <p class="indent">Hence, the number 23523 can be <em>represented</em> as 6. One curious property of the hash is there is no way to determine, from the hash, what the original number was— this is one of the essential observations of many uses for the hash. If I share a number with some third party, and that party then shares it with you, you can ask me for <a id="page_776"></a>the hash of the number (without telling me what the actual number is!), and you can verify the number you have is the same by verifying the hash that I give you matches the one you calculate.</p>
        <p class="indent">The preceding hash is naïve because it is too easy to obtain a <em>collision</em>. In other words, there are many different sets of numbers that will result in a hash of 6 given the same process, such as 222, 33, 111111, and (probably) an almost infinite number of others. The tricky part of building a hash, then, is in ensuring collisions are rare or nonexistent.</p>
        <p class="indent">Assuming you have developed such a hash (there are a number of them), you can then use hashes to build a <em>Merkle Tree</em>, as illustrated in <a href="ch30.xhtml#ch30fig04">Figure 30-4</a>.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/30fig04.jpg" aria-describedby="Al30fig04" alt="Illustration depicts the merkle tree." width="644" height="326"><aside class="hidden" id="Al30fig04">
        <p>Illustration shows seven smaller circles labeled H1, H2, H3, H4, H5, H6, and root. H1 and H2 are connected to H5. H3 and H4 are connected to H6. H5 and H6 are connected to root.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch30fig04"></a><strong>Figure 30-4</strong> <em>A Merkle tree</em></p>
        </div>
        <p class="indent">In <a href="ch30.xhtml#ch30fig04">Figure 30-4</a>, four numbers have been processed through an algorithm to produce a hash: H1 through H4. H1 and H2 are, in turn, hashed to produce H5, and H3 and H4 are hashed to produce H6. H5 and H6 are, in turn, hashed to produce the root hash. There are a number of interesting things about Merkle trees; for instance, if you change the value of H1 for any reason, the value of the root hash also changes. Of course, this “just makes sense,” but it means you can validate the contents of any group of files or values by examining a single value. Further, you can verify <em>which part</em> of the tree the change has taken place on if you have access to all the hashes in the tree <em>even though you do not know, or do not know if you can trust, the values themselves</em>.</p>
        <p class="indent">To get to a blockchain, you string the Merkle tree out, as shown in <a href="ch30.xhtml#ch30fig05">Figure 30-5</a>. Here the hashes of H1 and H5 are hashed to form H2, the hashes of H2 and H6 are hashed to form H3, etc. What is interesting about a blockchain is that you can tell if any step has been repeated twice, if work has not been done, or if any of the numbers in the previous part of the chain have been changed—hence its usefulness in forming digital currencies.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/30fig05.jpg" aria-describedby="Al30fig05" alt="Illustration shows a block chain, merkle tree." width="533" height="194"><aside class="hidden" id="Al30fig05">
        <p>Illustration shows seven smaller circles labeled H1, H2, H3, H4, H5, H6, and H7. H1, H2, H3, and H4 are shown at the top and the remaining at the bottom. H1 is connected to H2 on the right. H2 is connected to H3 on the right and H5 at the bottom. H3 is connected to H4 on the right and H6 at the bottom. H4 is connected to H7 at the bottom.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch30fig05"></a><strong>Figure 30-5</strong> <em>A Merkel tree turned into a blockchain</em></p>
        </div>
        <div class="note">
        <p class="title"><a id="page_777"></a><strong>Note</strong></p>
        <p class="notepara">There is, in fact, more to a real blockchain than this; there is also a consensus process. This description is a radical simplification.</p>
        </div>
        <p class="indent">Once you have a blockchain, what can you do with it? Remember the concept of the NDN described earlier? Now consider: what if every block on this blockchain were an object, as described in the NDN network? It should be possible to traverse the tree, using the information from the hash itself, to find the object you are looking for. Even if there is a newer version of the object, the older version should still exist, in its encrypted form, allowing you to compare every version of the object all the way back to its creation. There is no way to change any of the objects contained in the blockchain without invalidating the encryption on every object after this one has been modified.</p>
        <p class="indent">Cryptocurrencies take advantage of these properties to allow users to place transactions on the blockchain across time. No transaction can be undone without invalidating the entire blockchain; there are many copies of the blockchain in existence, so a single copy being invalidated should cause the entire network of devices participating in the blockchain to quickly discard the invalidated copy.</p>
        <p class="indent">Other blockchain systems, such as Ethereum, go beyond the idea of a cryptocurrency by allowing <em>executable code</em> to be stored in the blockchain alongside transactions. This means a virtual machine can be given an Ethereum blockchain that contains not only data to operate on (such as move some amount of money from one account to another account), but also some instructions about under what conditions the data should be acted on (when the receiver signs for the package). The operation could take place in full public view, but without information about the people involved, account numbers, etc., being exposed to the public view (because these can all be represented by hashes, instead of the real numbers, that can only be interpreted by the parties involved in the transaction).</p>
        <p class="indent"><a id="page_778"></a>A blockchain system like Ethereum could, in theory, provide an overlay on the entire public Internet, providing the same sort of system as the creators of the NDN originally conceived.</p>
        <div class="heading">
        <h3 class="h3" id="ch30lev11">The Reshaping of the Internet</h3>
        <p class="noindent">The Internet is, to most engineers, a constant. The protocols remain the same, and while the providers shift roles from time to time, or one provider buys another, there is very little apparent change in the Internet as a whole. This, however, is not a realistic view of the world. <a href="ch30.xhtml#ch30fig06">Figure 30-6</a> illustrates how the Internet has been built since the first few years of its commercialization.</p>
        </div>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/30fig06.jpg" aria-describedby="Al30fig06" alt="Illustration depicts the old internet connection pattern." width="614" height="275"><aside class="hidden" id="Al30fig06">
        <p>Illustration shows four clouds A, B, C, and D. Cloud A reads edge (eyeball) provider. Cloud B reads transit (tier 1) provider. Cloud C reads transit (tier 1) provider. Cloud D reads content provider. A is connected to B. B is connected to C via IXP. C is connected to D.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch30fig06"></a><strong>Figure 30-6</strong> <em>The shape of the old Internet</em></p>
        </div>
        <p class="indent">This shape clearly puts the large-scale transit providers in a central role. The QoS and security protections offered by the transit providers regulate how quickly any user can send or receive traffic. If you want to start a new content or edge provider network or service, you can connect to the transit providers and reach pretty much everyone who connects to the Internet. What has been happening in the five years or so before this writing is a shift in the way content and edge providers are connected. The new connection pattern is illustrated in <a href="ch30.xhtml#ch30fig07">Figure 30-7</a>.</p>
        <div class="fig-heading">
        <div class="image"><img src="https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9780134762814/files/graphics/30fig07.jpg" aria-describedby="Al30fig07" alt="Illustration depicts the new internet connection pattern." width="677" height="562"><aside class="hidden" id="Al30fig07">
        <p>Illustration shows seven clouds. The cloud on the top reads content provider which is connected to three other clouds labeled edge (eyeball) provider, IXP, transit (tier 1) provider, and transit (tier 1) provider. IXP connects to two other cloud labeled edge (eyeball) provider and edge (eyeball) provider. Both the transit provider are connected via IXP. One of the transit provider connects to another cloud labeled edge (eyeball) provider.</p>
        </aside>
        </div>
        <p class="fig-caption"><a id="ch30fig07"></a><strong>Figure 30-7</strong> <em>The new shape of Internet connectivity</em></p>
        </div>
        <p class="indent">The content providers have discovered a simple fact: the speed at which their content loads drives user engagement, and user engagement drives revenue. To make their pages load faster, the content providers need to be “closer” to their users. Being closer essentially means cutting out transit providers wherever possible and connecting directly to the edge providers. This means the global Internet is slowly moving away from being a mesh of peer networks to a more hub-and-spoke pattern, with large content providers in the hub, and edge providers acting as the spokes.</p>
        <p class="indentb"><a id="page_779"></a>There is little sense of what this means in the long term. For instance, it could mean</p>
        <p class="bullt">• The Internet will eventually fragment, with the content you can reach being determined by the edge provider you connect to (because not every edge provider will connect to every content provider).</p>
        <p class="bullb">• The transit providers could shrink, but not ultimately die off, allowing full connectivity, but with two classes of service; large content providers will be quickly reachable, while smaller and newer ones will be forced to take the slow path.</p>
        <p class="indentt">The second already appears to be happening. The ultimate effect of this “slow path/fast path” arrangement is that it becomes ever more difficult to start a new content service on the global Internet, which drives ever more power into a smaller group of players over time. Whether this trend will continue, or the ultimate end is healthy <a id="page_780"></a>for the Internet as a whole or the network engineering and larger information technology ecosystems reliant on the Internet, is hard to say at this point.</p>
        <p class="indent">But this is certainly one of those trends worth factoring into any view of what the future of network engineering might look like.</p>
        <div class="heading">
        <h3 class="h3" id="ch30lev12">Final Thoughts on the Future of Network Engineering</h3>
        <p class="noindent">It often seems, in the present moment, like the world is changing too fast, there is no way to keep up, and the future of network engineering is bleak. There are some parts of the network engineering world for which this is likely true; old technologies do, ultimately, die, and others come to the front to take their place (or maybe the entire problem that the technology was designed to solve no longer exists for some reason). Through all of this, however, there will always be a need for well-trained, thoughtful engineers who understand the basic problems, and the scope of solutions available for those problems. For engineers who understand the technology at a more basic level, and hence can ask the right questions at the right time to make a difference in the way a business runs, there will always be a bright future in network engineering.</p>
        </div>
        <p class="indent">If you have read this far, studied the examples, and spent time thinking through the technologies as they have been presented here, you are at least starting on the road toward developing the skills needed to be one of those engineers who will always be in demand.</p>
        <div class="heading">
        <h3 class="h3" id="ch30lev13">Further Reading</h3>
        <p class="ref">Bjorklund, Martin. <em>The YANG 1.1 Data Modeling Language</em>. Request for Comments 7950. RFC Editor, 2016. <a href="https://rfc-editor.org/rfc/rfc7950.txt">https://rfc-editor.org/rfc/rfc7950.txt</a>.</p>
        </div>
        <p class="ref">Callon, Ross. <em>The Twelve Networking Truths</em>. Request for Comments 1925. RFC Editor, 1996. doi:10.17487/RFC1925.</p>
        <p class="ref">“Ethereum Homestead Documentation.” Accessed August 30, 2017. <a href="http://www.ethdocs.org/en/latest/">http://www.ethdocs.org/en/latest/</a>.</p>
        <p class="ref">Gates, Mark. <em>Blockchain: Ultimate Guide to Understanding Blockchain, Bitcoin, Cryptocurrencies, Smart Contracts and the Future of Money</em>. CreateSpace Independent Publishing Platform, 2017.</p>
        <p class="ref">Huston, Geoff. “The Death of Transit?” <em>APNIC Blog</em>, October 28, 2016. <a href="https://blog.apnic.net/2016/10/28/the-death-of-transit/">https://blog.apnic.net/2016/10/28/the-death-of-transit/</a>.</p>
        <p class="ref"><a id="page_781"></a>“HyperConverged.org.” Accessed August 30, 2017. <a href="http://www.hyperconverged.org/">http://www.hyperconverged.org/</a>.</p>
        <p class="ref">Matsumoto, Craig. “Why Machine Learning Is Hard to Apply to Networking.” Blog. <em>SDxCentral</em>, January 2, 2017. <a href="https://www.sdxcentral.com/articles/news/machine-learning-hard-apply-networking/2017/01/">https://www.sdxcentral.com/articles/news/machine-learning-hard-apply-networking/2017/01/</a>.</p>
        <p class="ref">Theobald, Oliver. <em>Machine Learning for Absolute Beginners: A Plain English Introduction</em>. Independently published.</p>
        <p class="ref">“What Is Ether.” Accessed August 30, 2017. <a href="https://www.ethereum.org/ether">https://www.ethereum.org/ether</a>.</p>
        <p class="ref">White, Russ. “Death of Transit: A Need to Prevent Fragmentation.” Accessed August 30, 2017. <a href="http://www.circleid.com/posts/20161107_death_of_transit_need_to_prevent_fragmentation/">http://www.circleid.com/posts/20161107_death_of_transit_need_to_prevent_fragmentation/</a>.</p>
        <p class="ref">Zhang, Lixia, Deborah Estrin, Jeffrey Burke, Van Jacobson, James D. Thornton, Diana K. Smetters, Beichuan Zhang, et al. “Named Data Networking (NDN) Project,” October 31, 2010. <a href="http://named-data.net/techreport/TR001ndn-proj.pdf">http://named-data.net/techreport/TR001ndn-proj.pdf</a>.</p>
        <div class="heading">
        <h3 class="h3" id="ch30lev14">Review Questions</h3>
        <p class="indenthangingN">1. What kinds of network resources might be pooled like compute resources in a hyperconverged solution?</p>
        </div>
        <p class="indenthangingN">2. What is the difference between OpenConfig YANG models and the YANG models standardized by the IETF?</p>
        <p class="indenthangingN">3. Review some of the challenges to implementing and deploying intent-based networking.</p>
        <p class="indenthangingN">4. Where might machine learning be useful in network engineering?</p>
        <p class="indenthangingN">5. What argument does the text use to explain why machine learning may never be used to configure networks?</p>
        <p class="indenthangingN">6. What is the advantage of Named Data Networking over packet-based networks?</p>
        <p class="indenthangingN">7. Research Ethereum. How might blockchains with embedded actions require routing?</p>
        <p class="indenthangingN">8. Some engineers argue it is better to have a common modeling language, rather than a common set of models, for automation. What do you think their line of argument might be?<a id="page_782"></a></p>
        <p class="footnotet"><a id="ch30fn-1"></a><a href="ch30.xhtml#ch30fn1">1</a>. Callon, <em>The Twelve Networking Truths</em>, 1.</p>
        <p class="footnote"><a id="ch30fn-2"></a><a href="ch30.xhtml#ch30fn2">2</a>. Matsumoto, “Why Machine Learning Is Hard to Apply to Networking.”</p>
        </div></div><link rel="stylesheet" href="/files/public/epub-reader/override_v1.css" crossorigin="anonymous"><link rel="stylesheet" href="/api/v2/epubs/urn:orm:book:9780134762814/files/9780134762852.css" crossorigin="anonymous"></div></div></section>
</div>

https://learning.oreilly.com